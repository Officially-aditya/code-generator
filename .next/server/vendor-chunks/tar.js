"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/tar";
exports.ids = ["vendor-chunks/tar"];
exports.modules = {

/***/ "(rsc)/./node_modules/tar/dist/esm/create.js":
/*!*********************************************!*\
  !*** ./node_modules/tar/dist/esm/create.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   create: () => (/* binding */ create)\n/* harmony export */ });\n/* harmony import */ var _isaacs_fs_minipass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @isaacs/fs-minipass */ \"(rsc)/./node_modules/@isaacs/fs-minipass/dist/esm/index.js\");\n/* harmony import */ var node_path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:path */ \"node:path\");\n/* harmony import */ var _list_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./list.js */ \"(rsc)/./node_modules/tar/dist/esm/list.js\");\n/* harmony import */ var _make_command_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./make-command.js */ \"(rsc)/./node_modules/tar/dist/esm/make-command.js\");\n/* harmony import */ var _pack_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./pack.js */ \"(rsc)/./node_modules/tar/dist/esm/pack.js\");\n\n\n\n\n\nconst createFileSync = (opt, files) => {\n    const p = new _pack_js__WEBPACK_IMPORTED_MODULE_4__.PackSync(opt);\n    const stream = new _isaacs_fs_minipass__WEBPACK_IMPORTED_MODULE_0__.WriteStreamSync(opt.file, {\n        mode: opt.mode || 0o666,\n    });\n    p.pipe(stream);\n    addFilesSync(p, files);\n};\nconst createFile = (opt, files) => {\n    const p = new _pack_js__WEBPACK_IMPORTED_MODULE_4__.Pack(opt);\n    const stream = new _isaacs_fs_minipass__WEBPACK_IMPORTED_MODULE_0__.WriteStream(opt.file, {\n        mode: opt.mode || 0o666,\n    });\n    p.pipe(stream);\n    const promise = new Promise((res, rej) => {\n        stream.on('error', rej);\n        stream.on('close', res);\n        p.on('error', rej);\n    });\n    addFilesAsync(p, files);\n    return promise;\n};\nconst addFilesSync = (p, files) => {\n    files.forEach(file => {\n        if (file.charAt(0) === '@') {\n            (0,_list_js__WEBPACK_IMPORTED_MODULE_2__.list)({\n                file: node_path__WEBPACK_IMPORTED_MODULE_1__.resolve(p.cwd, file.slice(1)),\n                sync: true,\n                noResume: true,\n                onReadEntry: entry => p.add(entry),\n            });\n        }\n        else {\n            p.add(file);\n        }\n    });\n    p.end();\n};\nconst addFilesAsync = async (p, files) => {\n    for (let i = 0; i < files.length; i++) {\n        const file = String(files[i]);\n        if (file.charAt(0) === '@') {\n            await (0,_list_js__WEBPACK_IMPORTED_MODULE_2__.list)({\n                file: node_path__WEBPACK_IMPORTED_MODULE_1__.resolve(String(p.cwd), file.slice(1)),\n                noResume: true,\n                onReadEntry: entry => {\n                    p.add(entry);\n                },\n            });\n        }\n        else {\n            p.add(file);\n        }\n    }\n    p.end();\n};\nconst createSync = (opt, files) => {\n    const p = new _pack_js__WEBPACK_IMPORTED_MODULE_4__.PackSync(opt);\n    addFilesSync(p, files);\n    return p;\n};\nconst createAsync = (opt, files) => {\n    const p = new _pack_js__WEBPACK_IMPORTED_MODULE_4__.Pack(opt);\n    addFilesAsync(p, files);\n    return p;\n};\nconst create = (0,_make_command_js__WEBPACK_IMPORTED_MODULE_3__.makeCommand)(createFileSync, createFile, createSync, createAsync, (_opt, files) => {\n    if (!files?.length) {\n        throw new TypeError('no paths specified to add to archive');\n    }\n});\n//# sourceMappingURL=create.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvZXNtL2NyZWF0ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBbUU7QUFDdEM7QUFDSTtBQUNlO0FBQ0w7QUFDM0M7QUFDQSxrQkFBa0IsOENBQVE7QUFDMUIsdUJBQXVCLGdFQUFlO0FBQ3RDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDBDQUFJO0FBQ3RCLHVCQUF1Qiw0REFBVztBQUNsQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksOENBQUk7QUFDaEIsc0JBQXNCLDhDQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQSxrQkFBa0IsOENBQUk7QUFDdEIsc0JBQXNCLDhDQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw4Q0FBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwwQ0FBSTtBQUN0QjtBQUNBO0FBQ0E7QUFDTyxlQUFlLDZEQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpdmUtdmliZS1haS1uZXh0Ly4vbm9kZV9tb2R1bGVzL3Rhci9kaXN0L2VzbS9jcmVhdGUuanM/ZmRhZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBXcml0ZVN0cmVhbSwgV3JpdGVTdHJlYW1TeW5jIH0gZnJvbSAnQGlzYWFjcy9mcy1taW5pcGFzcyc7XG5pbXBvcnQgcGF0aCBmcm9tICdub2RlOnBhdGgnO1xuaW1wb3J0IHsgbGlzdCB9IGZyb20gJy4vbGlzdC5qcyc7XG5pbXBvcnQgeyBtYWtlQ29tbWFuZCB9IGZyb20gJy4vbWFrZS1jb21tYW5kLmpzJztcbmltcG9ydCB7IFBhY2ssIFBhY2tTeW5jIH0gZnJvbSAnLi9wYWNrLmpzJztcbmNvbnN0IGNyZWF0ZUZpbGVTeW5jID0gKG9wdCwgZmlsZXMpID0+IHtcbiAgICBjb25zdCBwID0gbmV3IFBhY2tTeW5jKG9wdCk7XG4gICAgY29uc3Qgc3RyZWFtID0gbmV3IFdyaXRlU3RyZWFtU3luYyhvcHQuZmlsZSwge1xuICAgICAgICBtb2RlOiBvcHQubW9kZSB8fCAwbzY2NixcbiAgICB9KTtcbiAgICBwLnBpcGUoc3RyZWFtKTtcbiAgICBhZGRGaWxlc1N5bmMocCwgZmlsZXMpO1xufTtcbmNvbnN0IGNyZWF0ZUZpbGUgPSAob3B0LCBmaWxlcykgPT4ge1xuICAgIGNvbnN0IHAgPSBuZXcgUGFjayhvcHQpO1xuICAgIGNvbnN0IHN0cmVhbSA9IG5ldyBXcml0ZVN0cmVhbShvcHQuZmlsZSwge1xuICAgICAgICBtb2RlOiBvcHQubW9kZSB8fCAwbzY2NixcbiAgICB9KTtcbiAgICBwLnBpcGUoc3RyZWFtKTtcbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgICAgIHN0cmVhbS5vbignZXJyb3InLCByZWopO1xuICAgICAgICBzdHJlYW0ub24oJ2Nsb3NlJywgcmVzKTtcbiAgICAgICAgcC5vbignZXJyb3InLCByZWopO1xuICAgIH0pO1xuICAgIGFkZEZpbGVzQXN5bmMocCwgZmlsZXMpO1xuICAgIHJldHVybiBwcm9taXNlO1xufTtcbmNvbnN0IGFkZEZpbGVzU3luYyA9IChwLCBmaWxlcykgPT4ge1xuICAgIGZpbGVzLmZvckVhY2goZmlsZSA9PiB7XG4gICAgICAgIGlmIChmaWxlLmNoYXJBdCgwKSA9PT0gJ0AnKSB7XG4gICAgICAgICAgICBsaXN0KHtcbiAgICAgICAgICAgICAgICBmaWxlOiBwYXRoLnJlc29sdmUocC5jd2QsIGZpbGUuc2xpY2UoMSkpLFxuICAgICAgICAgICAgICAgIHN5bmM6IHRydWUsXG4gICAgICAgICAgICAgICAgbm9SZXN1bWU6IHRydWUsXG4gICAgICAgICAgICAgICAgb25SZWFkRW50cnk6IGVudHJ5ID0+IHAuYWRkKGVudHJ5KSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcC5hZGQoZmlsZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBwLmVuZCgpO1xufTtcbmNvbnN0IGFkZEZpbGVzQXN5bmMgPSBhc3luYyAocCwgZmlsZXMpID0+IHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGZpbGUgPSBTdHJpbmcoZmlsZXNbaV0pO1xuICAgICAgICBpZiAoZmlsZS5jaGFyQXQoMCkgPT09ICdAJykge1xuICAgICAgICAgICAgYXdhaXQgbGlzdCh7XG4gICAgICAgICAgICAgICAgZmlsZTogcGF0aC5yZXNvbHZlKFN0cmluZyhwLmN3ZCksIGZpbGUuc2xpY2UoMSkpLFxuICAgICAgICAgICAgICAgIG5vUmVzdW1lOiB0cnVlLFxuICAgICAgICAgICAgICAgIG9uUmVhZEVudHJ5OiBlbnRyeSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHAuYWRkKGVudHJ5KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwLmFkZChmaWxlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwLmVuZCgpO1xufTtcbmNvbnN0IGNyZWF0ZVN5bmMgPSAob3B0LCBmaWxlcykgPT4ge1xuICAgIGNvbnN0IHAgPSBuZXcgUGFja1N5bmMob3B0KTtcbiAgICBhZGRGaWxlc1N5bmMocCwgZmlsZXMpO1xuICAgIHJldHVybiBwO1xufTtcbmNvbnN0IGNyZWF0ZUFzeW5jID0gKG9wdCwgZmlsZXMpID0+IHtcbiAgICBjb25zdCBwID0gbmV3IFBhY2sob3B0KTtcbiAgICBhZGRGaWxlc0FzeW5jKHAsIGZpbGVzKTtcbiAgICByZXR1cm4gcDtcbn07XG5leHBvcnQgY29uc3QgY3JlYXRlID0gbWFrZUNvbW1hbmQoY3JlYXRlRmlsZVN5bmMsIGNyZWF0ZUZpbGUsIGNyZWF0ZVN5bmMsIGNyZWF0ZUFzeW5jLCAoX29wdCwgZmlsZXMpID0+IHtcbiAgICBpZiAoIWZpbGVzPy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbm8gcGF0aHMgc3BlY2lmaWVkIHRvIGFkZCB0byBhcmNoaXZlJyk7XG4gICAgfVxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcmVhdGUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/tar/dist/esm/create.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/tar/dist/esm/cwd-error.js":
/*!************************************************!*\
  !*** ./node_modules/tar/dist/esm/cwd-error.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CwdError: () => (/* binding */ CwdError)\n/* harmony export */ });\nclass CwdError extends Error {\n    path;\n    code;\n    syscall = 'chdir';\n    constructor(path, code) {\n        super(`${code}: Cannot cd into '${path}'`);\n        this.path = path;\n        this.code = code;\n    }\n    get name() {\n        return 'CwdError';\n    }\n}\n//# sourceMappingURL=cwd-error.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvZXNtL2N3ZC1lcnJvci5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixLQUFLLG9CQUFvQixLQUFLO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aXZlLXZpYmUtYWktbmV4dC8uL25vZGVfbW9kdWxlcy90YXIvZGlzdC9lc20vY3dkLWVycm9yLmpzP2NkYmIiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNsYXNzIEN3ZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIHBhdGg7XG4gICAgY29kZTtcbiAgICBzeXNjYWxsID0gJ2NoZGlyJztcbiAgICBjb25zdHJ1Y3RvcihwYXRoLCBjb2RlKSB7XG4gICAgICAgIHN1cGVyKGAke2NvZGV9OiBDYW5ub3QgY2QgaW50byAnJHtwYXRofSdgKTtcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiAnQ3dkRXJyb3InO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWN3ZC1lcnJvci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/tar/dist/esm/cwd-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/tar/dist/esm/extract.js":
/*!**********************************************!*\
  !*** ./node_modules/tar/dist/esm/extract.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   extract: () => (/* binding */ extract)\n/* harmony export */ });\n/* harmony import */ var _isaacs_fs_minipass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @isaacs/fs-minipass */ \"(rsc)/./node_modules/@isaacs/fs-minipass/dist/esm/index.js\");\n/* harmony import */ var node_fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:fs */ \"node:fs\");\n/* harmony import */ var _list_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./list.js */ \"(rsc)/./node_modules/tar/dist/esm/list.js\");\n/* harmony import */ var _make_command_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./make-command.js */ \"(rsc)/./node_modules/tar/dist/esm/make-command.js\");\n/* harmony import */ var _unpack_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./unpack.js */ \"(rsc)/./node_modules/tar/dist/esm/unpack.js\");\n// tar -x\n\n\n\n\n\nconst extractFileSync = (opt) => {\n    const u = new _unpack_js__WEBPACK_IMPORTED_MODULE_4__.UnpackSync(opt);\n    const file = opt.file;\n    const stat = node_fs__WEBPACK_IMPORTED_MODULE_1__.statSync(file);\n    // This trades a zero-byte read() syscall for a stat\n    // However, it will usually result in less memory allocation\n    const readSize = opt.maxReadSize || 16 * 1024 * 1024;\n    const stream = new _isaacs_fs_minipass__WEBPACK_IMPORTED_MODULE_0__.ReadStreamSync(file, {\n        readSize: readSize,\n        size: stat.size,\n    });\n    stream.pipe(u);\n};\nconst extractFile = (opt, _) => {\n    const u = new _unpack_js__WEBPACK_IMPORTED_MODULE_4__.Unpack(opt);\n    const readSize = opt.maxReadSize || 16 * 1024 * 1024;\n    const file = opt.file;\n    const p = new Promise((resolve, reject) => {\n        u.on('error', reject);\n        u.on('close', resolve);\n        // This trades a zero-byte read() syscall for a stat\n        // However, it will usually result in less memory allocation\n        node_fs__WEBPACK_IMPORTED_MODULE_1__.stat(file, (er, stat) => {\n            if (er) {\n                reject(er);\n            }\n            else {\n                const stream = new _isaacs_fs_minipass__WEBPACK_IMPORTED_MODULE_0__.ReadStream(file, {\n                    readSize: readSize,\n                    size: stat.size,\n                });\n                stream.on('error', reject);\n                stream.pipe(u);\n            }\n        });\n    });\n    return p;\n};\nconst extract = (0,_make_command_js__WEBPACK_IMPORTED_MODULE_3__.makeCommand)(extractFileSync, extractFile, opt => new _unpack_js__WEBPACK_IMPORTED_MODULE_4__.UnpackSync(opt), opt => new _unpack_js__WEBPACK_IMPORTED_MODULE_4__.Unpack(opt), (opt, files) => {\n    if (files?.length)\n        (0,_list_js__WEBPACK_IMPORTED_MODULE_2__.filesFilter)(opt, files);\n});\n//# sourceMappingURL=extract.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvZXNtL2V4dHJhY3QuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDMkM7QUFDbEI7QUFDZTtBQUNRO0FBQ0M7QUFDakQ7QUFDQSxrQkFBa0Isa0RBQVU7QUFDNUI7QUFDQSxpQkFBaUIsNkNBQVc7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLCtEQUFrQjtBQUN6QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw4Q0FBTTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEseUNBQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywyREFBYztBQUNqRDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNPLGdCQUFnQiw2REFBVywwQ0FBMEMsa0RBQVUsa0JBQWtCLDhDQUFNO0FBQzlHO0FBQ0EsUUFBUSxxREFBVztBQUNuQixDQUFDO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aXZlLXZpYmUtYWktbmV4dC8uL25vZGVfbW9kdWxlcy90YXIvZGlzdC9lc20vZXh0cmFjdC5qcz9mOTEyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHRhciAteFxuaW1wb3J0ICogYXMgZnNtIGZyb20gJ0Bpc2FhY3MvZnMtbWluaXBhc3MnO1xuaW1wb3J0IGZzIGZyb20gJ25vZGU6ZnMnO1xuaW1wb3J0IHsgZmlsZXNGaWx0ZXIgfSBmcm9tICcuL2xpc3QuanMnO1xuaW1wb3J0IHsgbWFrZUNvbW1hbmQgfSBmcm9tICcuL21ha2UtY29tbWFuZC5qcyc7XG5pbXBvcnQgeyBVbnBhY2ssIFVucGFja1N5bmMgfSBmcm9tICcuL3VucGFjay5qcyc7XG5jb25zdCBleHRyYWN0RmlsZVN5bmMgPSAob3B0KSA9PiB7XG4gICAgY29uc3QgdSA9IG5ldyBVbnBhY2tTeW5jKG9wdCk7XG4gICAgY29uc3QgZmlsZSA9IG9wdC5maWxlO1xuICAgIGNvbnN0IHN0YXQgPSBmcy5zdGF0U3luYyhmaWxlKTtcbiAgICAvLyBUaGlzIHRyYWRlcyBhIHplcm8tYnl0ZSByZWFkKCkgc3lzY2FsbCBmb3IgYSBzdGF0XG4gICAgLy8gSG93ZXZlciwgaXQgd2lsbCB1c3VhbGx5IHJlc3VsdCBpbiBsZXNzIG1lbW9yeSBhbGxvY2F0aW9uXG4gICAgY29uc3QgcmVhZFNpemUgPSBvcHQubWF4UmVhZFNpemUgfHwgMTYgKiAxMDI0ICogMTAyNDtcbiAgICBjb25zdCBzdHJlYW0gPSBuZXcgZnNtLlJlYWRTdHJlYW1TeW5jKGZpbGUsIHtcbiAgICAgICAgcmVhZFNpemU6IHJlYWRTaXplLFxuICAgICAgICBzaXplOiBzdGF0LnNpemUsXG4gICAgfSk7XG4gICAgc3RyZWFtLnBpcGUodSk7XG59O1xuY29uc3QgZXh0cmFjdEZpbGUgPSAob3B0LCBfKSA9PiB7XG4gICAgY29uc3QgdSA9IG5ldyBVbnBhY2sob3B0KTtcbiAgICBjb25zdCByZWFkU2l6ZSA9IG9wdC5tYXhSZWFkU2l6ZSB8fCAxNiAqIDEwMjQgKiAxMDI0O1xuICAgIGNvbnN0IGZpbGUgPSBvcHQuZmlsZTtcbiAgICBjb25zdCBwID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB1Lm9uKCdlcnJvcicsIHJlamVjdCk7XG4gICAgICAgIHUub24oJ2Nsb3NlJywgcmVzb2x2ZSk7XG4gICAgICAgIC8vIFRoaXMgdHJhZGVzIGEgemVyby1ieXRlIHJlYWQoKSBzeXNjYWxsIGZvciBhIHN0YXRcbiAgICAgICAgLy8gSG93ZXZlciwgaXQgd2lsbCB1c3VhbGx5IHJlc3VsdCBpbiBsZXNzIG1lbW9yeSBhbGxvY2F0aW9uXG4gICAgICAgIGZzLnN0YXQoZmlsZSwgKGVyLCBzdGF0KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXIpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RyZWFtID0gbmV3IGZzbS5SZWFkU3RyZWFtKGZpbGUsIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhZFNpemU6IHJlYWRTaXplLFxuICAgICAgICAgICAgICAgICAgICBzaXplOiBzdGF0LnNpemUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc3RyZWFtLm9uKCdlcnJvcicsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgc3RyZWFtLnBpcGUodSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBwO1xufTtcbmV4cG9ydCBjb25zdCBleHRyYWN0ID0gbWFrZUNvbW1hbmQoZXh0cmFjdEZpbGVTeW5jLCBleHRyYWN0RmlsZSwgb3B0ID0+IG5ldyBVbnBhY2tTeW5jKG9wdCksIG9wdCA9PiBuZXcgVW5wYWNrKG9wdCksIChvcHQsIGZpbGVzKSA9PiB7XG4gICAgaWYgKGZpbGVzPy5sZW5ndGgpXG4gICAgICAgIGZpbGVzRmlsdGVyKG9wdCwgZmlsZXMpO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1leHRyYWN0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/tar/dist/esm/extract.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/tar/dist/esm/get-write-flag.js":
/*!*****************************************************!*\
  !*** ./node_modules/tar/dist/esm/get-write-flag.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getWriteFlag: () => (/* binding */ getWriteFlag)\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"fs\");\n// Get the appropriate flag to use for creating files\n// We use fmap on Windows platforms for files less than\n// 512kb.  This is a fairly low limit, but avoids making\n// things slower in some cases.  Since most of what this\n// library is used for is extracting tarballs of many\n// relatively small files in npm packages and the like,\n// it can be a big boost on Windows platforms.\n\nconst platform = process.env.__FAKE_PLATFORM__ || process.platform;\nconst isWindows = platform === 'win32';\n/* c8 ignore start */\nconst { O_CREAT, O_TRUNC, O_WRONLY } = fs__WEBPACK_IMPORTED_MODULE_0__.constants;\nconst UV_FS_O_FILEMAP = Number(process.env.__FAKE_FS_O_FILENAME__) ||\n    fs__WEBPACK_IMPORTED_MODULE_0__.constants.UV_FS_O_FILEMAP ||\n    0;\n/* c8 ignore stop */\nconst fMapEnabled = isWindows && !!UV_FS_O_FILEMAP;\nconst fMapLimit = 512 * 1024;\nconst fMapFlag = UV_FS_O_FILEMAP | O_TRUNC | O_CREAT | O_WRONLY;\nconst getWriteFlag = !fMapEnabled ?\n    () => 'w'\n    : (size) => (size < fMapLimit ? fMapFlag : 'w');\n//# sourceMappingURL=get-write-flag.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvZXNtL2dldC13cml0ZS1mbGFnLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsUUFBUSw2QkFBNkIsRUFBRSx5Q0FBWTtBQUNuRDtBQUNBLElBQUkseUNBQVk7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdml2ZS12aWJlLWFpLW5leHQvLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvZXNtL2dldC13cml0ZS1mbGFnLmpzPzlmZjgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gR2V0IHRoZSBhcHByb3ByaWF0ZSBmbGFnIHRvIHVzZSBmb3IgY3JlYXRpbmcgZmlsZXNcbi8vIFdlIHVzZSBmbWFwIG9uIFdpbmRvd3MgcGxhdGZvcm1zIGZvciBmaWxlcyBsZXNzIHRoYW5cbi8vIDUxMmtiLiAgVGhpcyBpcyBhIGZhaXJseSBsb3cgbGltaXQsIGJ1dCBhdm9pZHMgbWFraW5nXG4vLyB0aGluZ3Mgc2xvd2VyIGluIHNvbWUgY2FzZXMuICBTaW5jZSBtb3N0IG9mIHdoYXQgdGhpc1xuLy8gbGlicmFyeSBpcyB1c2VkIGZvciBpcyBleHRyYWN0aW5nIHRhcmJhbGxzIG9mIG1hbnlcbi8vIHJlbGF0aXZlbHkgc21hbGwgZmlsZXMgaW4gbnBtIHBhY2thZ2VzIGFuZCB0aGUgbGlrZSxcbi8vIGl0IGNhbiBiZSBhIGJpZyBib29zdCBvbiBXaW5kb3dzIHBsYXRmb3Jtcy5cbmltcG9ydCBmcyBmcm9tICdmcyc7XG5jb25zdCBwbGF0Zm9ybSA9IHByb2Nlc3MuZW52Ll9fRkFLRV9QTEFURk9STV9fIHx8IHByb2Nlc3MucGxhdGZvcm07XG5jb25zdCBpc1dpbmRvd3MgPSBwbGF0Zm9ybSA9PT0gJ3dpbjMyJztcbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xuY29uc3QgeyBPX0NSRUFULCBPX1RSVU5DLCBPX1dST05MWSB9ID0gZnMuY29uc3RhbnRzO1xuY29uc3QgVVZfRlNfT19GSUxFTUFQID0gTnVtYmVyKHByb2Nlc3MuZW52Ll9fRkFLRV9GU19PX0ZJTEVOQU1FX18pIHx8XG4gICAgZnMuY29uc3RhbnRzLlVWX0ZTX09fRklMRU1BUCB8fFxuICAgIDA7XG4vKiBjOCBpZ25vcmUgc3RvcCAqL1xuY29uc3QgZk1hcEVuYWJsZWQgPSBpc1dpbmRvd3MgJiYgISFVVl9GU19PX0ZJTEVNQVA7XG5jb25zdCBmTWFwTGltaXQgPSA1MTIgKiAxMDI0O1xuY29uc3QgZk1hcEZsYWcgPSBVVl9GU19PX0ZJTEVNQVAgfCBPX1RSVU5DIHwgT19DUkVBVCB8IE9fV1JPTkxZO1xuZXhwb3J0IGNvbnN0IGdldFdyaXRlRmxhZyA9ICFmTWFwRW5hYmxlZCA/XG4gICAgKCkgPT4gJ3cnXG4gICAgOiAoc2l6ZSkgPT4gKHNpemUgPCBmTWFwTGltaXQgPyBmTWFwRmxhZyA6ICd3Jyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXQtd3JpdGUtZmxhZy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/tar/dist/esm/get-write-flag.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/tar/dist/esm/header.js":
/*!*********************************************!*\
  !*** ./node_modules/tar/dist/esm/header.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Header: () => (/* binding */ Header)\n/* harmony export */ });\n/* harmony import */ var node_path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:path */ \"node:path\");\n/* harmony import */ var _large_numbers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./large-numbers.js */ \"(rsc)/./node_modules/tar/dist/esm/large-numbers.js\");\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types.js */ \"(rsc)/./node_modules/tar/dist/esm/types.js\");\n// parse a 512-byte header block to a data object, or vice-versa\n// encode returns `true` if a pax extended header is needed, because\n// the data could not be faithfully encoded in a simple header.\n// (Also, check header.needPax to see if it needs a pax header.)\n\n\n\nclass Header {\n    cksumValid = false;\n    needPax = false;\n    nullBlock = false;\n    block;\n    path;\n    mode;\n    uid;\n    gid;\n    size;\n    cksum;\n    #type = 'Unsupported';\n    linkpath;\n    uname;\n    gname;\n    devmaj = 0;\n    devmin = 0;\n    atime;\n    ctime;\n    mtime;\n    charset;\n    comment;\n    constructor(data, off = 0, ex, gex) {\n        if (Buffer.isBuffer(data)) {\n            this.decode(data, off || 0, ex, gex);\n        }\n        else if (data) {\n            this.#slurp(data);\n        }\n    }\n    decode(buf, off, ex, gex) {\n        if (!off) {\n            off = 0;\n        }\n        if (!buf || !(buf.length >= off + 512)) {\n            throw new Error('need 512 bytes for header');\n        }\n        this.path = decString(buf, off, 100);\n        this.mode = decNumber(buf, off + 100, 8);\n        this.uid = decNumber(buf, off + 108, 8);\n        this.gid = decNumber(buf, off + 116, 8);\n        this.size = decNumber(buf, off + 124, 12);\n        this.mtime = decDate(buf, off + 136, 12);\n        this.cksum = decNumber(buf, off + 148, 12);\n        // if we have extended or global extended headers, apply them now\n        // See https://github.com/npm/node-tar/pull/187\n        // Apply global before local, so it overrides\n        if (gex)\n            this.#slurp(gex, true);\n        if (ex)\n            this.#slurp(ex);\n        // old tar versions marked dirs as a file with a trailing /\n        const t = decString(buf, off + 156, 1);\n        if (_types_js__WEBPACK_IMPORTED_MODULE_2__.isCode(t)) {\n            this.#type = t || '0';\n        }\n        if (this.#type === '0' && this.path.slice(-1) === '/') {\n            this.#type = '5';\n        }\n        // tar implementations sometimes incorrectly put the stat(dir).size\n        // as the size in the tarball, even though Directory entries are\n        // not able to have any body at all.  In the very rare chance that\n        // it actually DOES have a body, we weren't going to do anything with\n        // it anyway, and it'll just be a warning about an invalid header.\n        if (this.#type === '5') {\n            this.size = 0;\n        }\n        this.linkpath = decString(buf, off + 157, 100);\n        if (buf.subarray(off + 257, off + 265).toString() ===\n            'ustar\\u000000') {\n            this.uname = decString(buf, off + 265, 32);\n            this.gname = decString(buf, off + 297, 32);\n            /* c8 ignore start */\n            this.devmaj = decNumber(buf, off + 329, 8) ?? 0;\n            this.devmin = decNumber(buf, off + 337, 8) ?? 0;\n            /* c8 ignore stop */\n            if (buf[off + 475] !== 0) {\n                // definitely a prefix, definitely >130 chars.\n                const prefix = decString(buf, off + 345, 155);\n                this.path = prefix + '/' + this.path;\n            }\n            else {\n                const prefix = decString(buf, off + 345, 130);\n                if (prefix) {\n                    this.path = prefix + '/' + this.path;\n                }\n                this.atime = decDate(buf, off + 476, 12);\n                this.ctime = decDate(buf, off + 488, 12);\n            }\n        }\n        let sum = 8 * 0x20;\n        for (let i = off; i < off + 148; i++) {\n            sum += buf[i];\n        }\n        for (let i = off + 156; i < off + 512; i++) {\n            sum += buf[i];\n        }\n        this.cksumValid = sum === this.cksum;\n        if (this.cksum === undefined && sum === 8 * 0x20) {\n            this.nullBlock = true;\n        }\n    }\n    #slurp(ex, gex = false) {\n        Object.assign(this, Object.fromEntries(Object.entries(ex).filter(([k, v]) => {\n            // we slurp in everything except for the path attribute in\n            // a global extended header, because that's weird. Also, any\n            // null/undefined values are ignored.\n            return !(v === null ||\n                v === undefined ||\n                (k === 'path' && gex) ||\n                (k === 'linkpath' && gex) ||\n                k === 'global');\n        })));\n    }\n    encode(buf, off = 0) {\n        if (!buf) {\n            buf = this.block = Buffer.alloc(512);\n        }\n        if (this.#type === 'Unsupported') {\n            this.#type = '0';\n        }\n        if (!(buf.length >= off + 512)) {\n            throw new Error('need 512 bytes for header');\n        }\n        const prefixSize = this.ctime || this.atime ? 130 : 155;\n        const split = splitPrefix(this.path || '', prefixSize);\n        const path = split[0];\n        const prefix = split[1];\n        this.needPax = !!split[2];\n        this.needPax = encString(buf, off, 100, path) || this.needPax;\n        this.needPax =\n            encNumber(buf, off + 100, 8, this.mode) || this.needPax;\n        this.needPax =\n            encNumber(buf, off + 108, 8, this.uid) || this.needPax;\n        this.needPax =\n            encNumber(buf, off + 116, 8, this.gid) || this.needPax;\n        this.needPax =\n            encNumber(buf, off + 124, 12, this.size) || this.needPax;\n        this.needPax =\n            encDate(buf, off + 136, 12, this.mtime) || this.needPax;\n        buf[off + 156] = this.#type.charCodeAt(0);\n        this.needPax =\n            encString(buf, off + 157, 100, this.linkpath) || this.needPax;\n        buf.write('ustar\\u000000', off + 257, 8);\n        this.needPax =\n            encString(buf, off + 265, 32, this.uname) || this.needPax;\n        this.needPax =\n            encString(buf, off + 297, 32, this.gname) || this.needPax;\n        this.needPax =\n            encNumber(buf, off + 329, 8, this.devmaj) || this.needPax;\n        this.needPax =\n            encNumber(buf, off + 337, 8, this.devmin) || this.needPax;\n        this.needPax =\n            encString(buf, off + 345, prefixSize, prefix) || this.needPax;\n        if (buf[off + 475] !== 0) {\n            this.needPax =\n                encString(buf, off + 345, 155, prefix) || this.needPax;\n        }\n        else {\n            this.needPax =\n                encString(buf, off + 345, 130, prefix) || this.needPax;\n            this.needPax =\n                encDate(buf, off + 476, 12, this.atime) || this.needPax;\n            this.needPax =\n                encDate(buf, off + 488, 12, this.ctime) || this.needPax;\n        }\n        let sum = 8 * 0x20;\n        for (let i = off; i < off + 148; i++) {\n            sum += buf[i];\n        }\n        for (let i = off + 156; i < off + 512; i++) {\n            sum += buf[i];\n        }\n        this.cksum = sum;\n        encNumber(buf, off + 148, 8, this.cksum);\n        this.cksumValid = true;\n        return this.needPax;\n    }\n    get type() {\n        return (this.#type === 'Unsupported' ?\n            this.#type\n            : _types_js__WEBPACK_IMPORTED_MODULE_2__.name.get(this.#type));\n    }\n    get typeKey() {\n        return this.#type;\n    }\n    set type(type) {\n        const c = String(_types_js__WEBPACK_IMPORTED_MODULE_2__.code.get(type));\n        if (_types_js__WEBPACK_IMPORTED_MODULE_2__.isCode(c) || c === 'Unsupported') {\n            this.#type = c;\n        }\n        else if (_types_js__WEBPACK_IMPORTED_MODULE_2__.isCode(type)) {\n            this.#type = type;\n        }\n        else {\n            throw new TypeError('invalid entry type: ' + type);\n        }\n    }\n}\nconst splitPrefix = (p, prefixSize) => {\n    const pathSize = 100;\n    let pp = p;\n    let prefix = '';\n    let ret = undefined;\n    const root = node_path__WEBPACK_IMPORTED_MODULE_0__.posix.parse(p).root || '.';\n    if (Buffer.byteLength(pp) < pathSize) {\n        ret = [pp, prefix, false];\n    }\n    else {\n        // first set prefix to the dir, and path to the base\n        prefix = node_path__WEBPACK_IMPORTED_MODULE_0__.posix.dirname(pp);\n        pp = node_path__WEBPACK_IMPORTED_MODULE_0__.posix.basename(pp);\n        do {\n            if (Buffer.byteLength(pp) <= pathSize &&\n                Buffer.byteLength(prefix) <= prefixSize) {\n                // both fit!\n                ret = [pp, prefix, false];\n            }\n            else if (Buffer.byteLength(pp) > pathSize &&\n                Buffer.byteLength(prefix) <= prefixSize) {\n                // prefix fits in prefix, but path doesn't fit in path\n                ret = [pp.slice(0, pathSize - 1), prefix, true];\n            }\n            else {\n                // make path take a bit from prefix\n                pp = node_path__WEBPACK_IMPORTED_MODULE_0__.posix.join(node_path__WEBPACK_IMPORTED_MODULE_0__.posix.basename(prefix), pp);\n                prefix = node_path__WEBPACK_IMPORTED_MODULE_0__.posix.dirname(prefix);\n            }\n        } while (prefix !== root && ret === undefined);\n        // at this point, found no resolution, just truncate\n        if (!ret) {\n            ret = [p.slice(0, pathSize - 1), '', true];\n        }\n    }\n    return ret;\n};\nconst decString = (buf, off, size) => buf\n    .subarray(off, off + size)\n    .toString('utf8')\n    .replace(/\\0.*/, '');\nconst decDate = (buf, off, size) => numToDate(decNumber(buf, off, size));\nconst numToDate = (num) => num === undefined ? undefined : new Date(num * 1000);\nconst decNumber = (buf, off, size) => Number(buf[off]) & 0x80 ?\n    _large_numbers_js__WEBPACK_IMPORTED_MODULE_1__.parse(buf.subarray(off, off + size))\n    : decSmallNumber(buf, off, size);\nconst nanUndef = (value) => (isNaN(value) ? undefined : value);\nconst decSmallNumber = (buf, off, size) => nanUndef(parseInt(buf\n    .subarray(off, off + size)\n    .toString('utf8')\n    .replace(/\\0.*$/, '')\n    .trim(), 8));\n// the maximum encodable as a null-terminated octal, by field size\nconst MAXNUM = {\n    12: 0o77777777777,\n    8: 0o7777777,\n};\nconst encNumber = (buf, off, size, num) => num === undefined ? false\n    : num > MAXNUM[size] || num < 0 ?\n        (_large_numbers_js__WEBPACK_IMPORTED_MODULE_1__.encode(num, buf.subarray(off, off + size)), true)\n        : (encSmallNumber(buf, off, size, num), false);\nconst encSmallNumber = (buf, off, size, num) => buf.write(octalString(num, size), off, size, 'ascii');\nconst octalString = (num, size) => padOctal(Math.floor(num).toString(8), size);\nconst padOctal = (str, size) => (str.length === size - 1 ?\n    str\n    : new Array(size - str.length - 1).join('0') + str + ' ') + '\\0';\nconst encDate = (buf, off, size, date) => date === undefined ? false : (encNumber(buf, off, size, date.getTime() / 1000));\n// enough to fill the longest string we've got\nconst NULLS = new Array(156).join('\\0');\n// pad with nulls, return true if it's longer or non-ascii\nconst encString = (buf, off, size, str) => str === undefined ? false : ((buf.write(str + NULLS, off, size, 'utf8'),\n    str.length !== Buffer.byteLength(str) || str.length > size));\n//# sourceMappingURL=header.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvZXNtL2hlYWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDZ0Q7QUFDSjtBQUNSO0FBQzdCO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZDQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGVBQWU7QUFDekM7QUFDQTtBQUNBLGdDQUFnQyxlQUFlO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGVBQWU7QUFDekM7QUFDQTtBQUNBLGdDQUFnQyxlQUFlO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywyQ0FBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDJDQUFVO0FBQ25DLFlBQVksNkNBQVk7QUFDeEI7QUFDQTtBQUNBLGlCQUFpQiw2Q0FBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsNENBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw0Q0FBVTtBQUMzQixhQUFhLDRDQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDRDQUFVLE1BQU0sNENBQVU7QUFDL0MseUJBQXlCLDRDQUFVO0FBQ25DO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLG9EQUFXO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMscURBQVk7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aXZlLXZpYmUtYWktbmV4dC8uL25vZGVfbW9kdWxlcy90YXIvZGlzdC9lc20vaGVhZGVyLmpzPzg2ZTMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gcGFyc2UgYSA1MTItYnl0ZSBoZWFkZXIgYmxvY2sgdG8gYSBkYXRhIG9iamVjdCwgb3IgdmljZS12ZXJzYVxuLy8gZW5jb2RlIHJldHVybnMgYHRydWVgIGlmIGEgcGF4IGV4dGVuZGVkIGhlYWRlciBpcyBuZWVkZWQsIGJlY2F1c2Vcbi8vIHRoZSBkYXRhIGNvdWxkIG5vdCBiZSBmYWl0aGZ1bGx5IGVuY29kZWQgaW4gYSBzaW1wbGUgaGVhZGVyLlxuLy8gKEFsc28sIGNoZWNrIGhlYWRlci5uZWVkUGF4IHRvIHNlZSBpZiBpdCBuZWVkcyBhIHBheCBoZWFkZXIuKVxuaW1wb3J0IHsgcG9zaXggYXMgcGF0aE1vZHVsZSB9IGZyb20gJ25vZGU6cGF0aCc7XG5pbXBvcnQgKiBhcyBsYXJnZSBmcm9tICcuL2xhcmdlLW51bWJlcnMuanMnO1xuaW1wb3J0ICogYXMgdHlwZXMgZnJvbSAnLi90eXBlcy5qcyc7XG5leHBvcnQgY2xhc3MgSGVhZGVyIHtcbiAgICBja3N1bVZhbGlkID0gZmFsc2U7XG4gICAgbmVlZFBheCA9IGZhbHNlO1xuICAgIG51bGxCbG9jayA9IGZhbHNlO1xuICAgIGJsb2NrO1xuICAgIHBhdGg7XG4gICAgbW9kZTtcbiAgICB1aWQ7XG4gICAgZ2lkO1xuICAgIHNpemU7XG4gICAgY2tzdW07XG4gICAgI3R5cGUgPSAnVW5zdXBwb3J0ZWQnO1xuICAgIGxpbmtwYXRoO1xuICAgIHVuYW1lO1xuICAgIGduYW1lO1xuICAgIGRldm1haiA9IDA7XG4gICAgZGV2bWluID0gMDtcbiAgICBhdGltZTtcbiAgICBjdGltZTtcbiAgICBtdGltZTtcbiAgICBjaGFyc2V0O1xuICAgIGNvbW1lbnQ7XG4gICAgY29uc3RydWN0b3IoZGF0YSwgb2ZmID0gMCwgZXgsIGdleCkge1xuICAgICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgICAgICAgICB0aGlzLmRlY29kZShkYXRhLCBvZmYgfHwgMCwgZXgsIGdleCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YSkge1xuICAgICAgICAgICAgdGhpcy4jc2x1cnAoZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVjb2RlKGJ1Ziwgb2ZmLCBleCwgZ2V4KSB7XG4gICAgICAgIGlmICghb2ZmKSB7XG4gICAgICAgICAgICBvZmYgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYnVmIHx8ICEoYnVmLmxlbmd0aCA+PSBvZmYgKyA1MTIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25lZWQgNTEyIGJ5dGVzIGZvciBoZWFkZXInKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhdGggPSBkZWNTdHJpbmcoYnVmLCBvZmYsIDEwMCk7XG4gICAgICAgIHRoaXMubW9kZSA9IGRlY051bWJlcihidWYsIG9mZiArIDEwMCwgOCk7XG4gICAgICAgIHRoaXMudWlkID0gZGVjTnVtYmVyKGJ1Ziwgb2ZmICsgMTA4LCA4KTtcbiAgICAgICAgdGhpcy5naWQgPSBkZWNOdW1iZXIoYnVmLCBvZmYgKyAxMTYsIDgpO1xuICAgICAgICB0aGlzLnNpemUgPSBkZWNOdW1iZXIoYnVmLCBvZmYgKyAxMjQsIDEyKTtcbiAgICAgICAgdGhpcy5tdGltZSA9IGRlY0RhdGUoYnVmLCBvZmYgKyAxMzYsIDEyKTtcbiAgICAgICAgdGhpcy5ja3N1bSA9IGRlY051bWJlcihidWYsIG9mZiArIDE0OCwgMTIpO1xuICAgICAgICAvLyBpZiB3ZSBoYXZlIGV4dGVuZGVkIG9yIGdsb2JhbCBleHRlbmRlZCBoZWFkZXJzLCBhcHBseSB0aGVtIG5vd1xuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL25wbS9ub2RlLXRhci9wdWxsLzE4N1xuICAgICAgICAvLyBBcHBseSBnbG9iYWwgYmVmb3JlIGxvY2FsLCBzbyBpdCBvdmVycmlkZXNcbiAgICAgICAgaWYgKGdleClcbiAgICAgICAgICAgIHRoaXMuI3NsdXJwKGdleCwgdHJ1ZSk7XG4gICAgICAgIGlmIChleClcbiAgICAgICAgICAgIHRoaXMuI3NsdXJwKGV4KTtcbiAgICAgICAgLy8gb2xkIHRhciB2ZXJzaW9ucyBtYXJrZWQgZGlycyBhcyBhIGZpbGUgd2l0aCBhIHRyYWlsaW5nIC9cbiAgICAgICAgY29uc3QgdCA9IGRlY1N0cmluZyhidWYsIG9mZiArIDE1NiwgMSk7XG4gICAgICAgIGlmICh0eXBlcy5pc0NvZGUodCkpIHtcbiAgICAgICAgICAgIHRoaXMuI3R5cGUgPSB0IHx8ICcwJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy4jdHlwZSA9PT0gJzAnICYmIHRoaXMucGF0aC5zbGljZSgtMSkgPT09ICcvJykge1xuICAgICAgICAgICAgdGhpcy4jdHlwZSA9ICc1JztcbiAgICAgICAgfVxuICAgICAgICAvLyB0YXIgaW1wbGVtZW50YXRpb25zIHNvbWV0aW1lcyBpbmNvcnJlY3RseSBwdXQgdGhlIHN0YXQoZGlyKS5zaXplXG4gICAgICAgIC8vIGFzIHRoZSBzaXplIGluIHRoZSB0YXJiYWxsLCBldmVuIHRob3VnaCBEaXJlY3RvcnkgZW50cmllcyBhcmVcbiAgICAgICAgLy8gbm90IGFibGUgdG8gaGF2ZSBhbnkgYm9keSBhdCBhbGwuICBJbiB0aGUgdmVyeSByYXJlIGNoYW5jZSB0aGF0XG4gICAgICAgIC8vIGl0IGFjdHVhbGx5IERPRVMgaGF2ZSBhIGJvZHksIHdlIHdlcmVuJ3QgZ29pbmcgdG8gZG8gYW55dGhpbmcgd2l0aFxuICAgICAgICAvLyBpdCBhbnl3YXksIGFuZCBpdCdsbCBqdXN0IGJlIGEgd2FybmluZyBhYm91dCBhbiBpbnZhbGlkIGhlYWRlci5cbiAgICAgICAgaWYgKHRoaXMuI3R5cGUgPT09ICc1Jykge1xuICAgICAgICAgICAgdGhpcy5zaXplID0gMDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxpbmtwYXRoID0gZGVjU3RyaW5nKGJ1Ziwgb2ZmICsgMTU3LCAxMDApO1xuICAgICAgICBpZiAoYnVmLnN1YmFycmF5KG9mZiArIDI1Nywgb2ZmICsgMjY1KS50b1N0cmluZygpID09PVxuICAgICAgICAgICAgJ3VzdGFyXFx1MDAwMDAwJykge1xuICAgICAgICAgICAgdGhpcy51bmFtZSA9IGRlY1N0cmluZyhidWYsIG9mZiArIDI2NSwgMzIpO1xuICAgICAgICAgICAgdGhpcy5nbmFtZSA9IGRlY1N0cmluZyhidWYsIG9mZiArIDI5NywgMzIpO1xuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICB0aGlzLmRldm1haiA9IGRlY051bWJlcihidWYsIG9mZiArIDMyOSwgOCkgPz8gMDtcbiAgICAgICAgICAgIHRoaXMuZGV2bWluID0gZGVjTnVtYmVyKGJ1Ziwgb2ZmICsgMzM3LCA4KSA/PyAwO1xuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgICAgIGlmIChidWZbb2ZmICsgNDc1XSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIGRlZmluaXRlbHkgYSBwcmVmaXgsIGRlZmluaXRlbHkgPjEzMCBjaGFycy5cbiAgICAgICAgICAgICAgICBjb25zdCBwcmVmaXggPSBkZWNTdHJpbmcoYnVmLCBvZmYgKyAzNDUsIDE1NSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXRoID0gcHJlZml4ICsgJy8nICsgdGhpcy5wYXRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJlZml4ID0gZGVjU3RyaW5nKGJ1Ziwgb2ZmICsgMzQ1LCAxMzApO1xuICAgICAgICAgICAgICAgIGlmIChwcmVmaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXRoID0gcHJlZml4ICsgJy8nICsgdGhpcy5wYXRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmF0aW1lID0gZGVjRGF0ZShidWYsIG9mZiArIDQ3NiwgMTIpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3RpbWUgPSBkZWNEYXRlKGJ1Ziwgb2ZmICsgNDg4LCAxMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN1bSA9IDggKiAweDIwO1xuICAgICAgICBmb3IgKGxldCBpID0gb2ZmOyBpIDwgb2ZmICsgMTQ4OyBpKyspIHtcbiAgICAgICAgICAgIHN1bSArPSBidWZbaV07XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IG9mZiArIDE1NjsgaSA8IG9mZiArIDUxMjsgaSsrKSB7XG4gICAgICAgICAgICBzdW0gKz0gYnVmW2ldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2tzdW1WYWxpZCA9IHN1bSA9PT0gdGhpcy5ja3N1bTtcbiAgICAgICAgaWYgKHRoaXMuY2tzdW0gPT09IHVuZGVmaW5lZCAmJiBzdW0gPT09IDggKiAweDIwKSB7XG4gICAgICAgICAgICB0aGlzLm51bGxCbG9jayA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgI3NsdXJwKGV4LCBnZXggPSBmYWxzZSkge1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhleCkuZmlsdGVyKChbaywgdl0pID0+IHtcbiAgICAgICAgICAgIC8vIHdlIHNsdXJwIGluIGV2ZXJ5dGhpbmcgZXhjZXB0IGZvciB0aGUgcGF0aCBhdHRyaWJ1dGUgaW5cbiAgICAgICAgICAgIC8vIGEgZ2xvYmFsIGV4dGVuZGVkIGhlYWRlciwgYmVjYXVzZSB0aGF0J3Mgd2VpcmQuIEFsc28sIGFueVxuICAgICAgICAgICAgLy8gbnVsbC91bmRlZmluZWQgdmFsdWVzIGFyZSBpZ25vcmVkLlxuICAgICAgICAgICAgcmV0dXJuICEodiA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgIHYgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgIChrID09PSAncGF0aCcgJiYgZ2V4KSB8fFxuICAgICAgICAgICAgICAgIChrID09PSAnbGlua3BhdGgnICYmIGdleCkgfHxcbiAgICAgICAgICAgICAgICBrID09PSAnZ2xvYmFsJyk7XG4gICAgICAgIH0pKSk7XG4gICAgfVxuICAgIGVuY29kZShidWYsIG9mZiA9IDApIHtcbiAgICAgICAgaWYgKCFidWYpIHtcbiAgICAgICAgICAgIGJ1ZiA9IHRoaXMuYmxvY2sgPSBCdWZmZXIuYWxsb2MoNTEyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy4jdHlwZSA9PT0gJ1Vuc3VwcG9ydGVkJykge1xuICAgICAgICAgICAgdGhpcy4jdHlwZSA9ICcwJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShidWYubGVuZ3RoID49IG9mZiArIDUxMikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbmVlZCA1MTIgYnl0ZXMgZm9yIGhlYWRlcicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZWZpeFNpemUgPSB0aGlzLmN0aW1lIHx8IHRoaXMuYXRpbWUgPyAxMzAgOiAxNTU7XG4gICAgICAgIGNvbnN0IHNwbGl0ID0gc3BsaXRQcmVmaXgodGhpcy5wYXRoIHx8ICcnLCBwcmVmaXhTaXplKTtcbiAgICAgICAgY29uc3QgcGF0aCA9IHNwbGl0WzBdO1xuICAgICAgICBjb25zdCBwcmVmaXggPSBzcGxpdFsxXTtcbiAgICAgICAgdGhpcy5uZWVkUGF4ID0gISFzcGxpdFsyXTtcbiAgICAgICAgdGhpcy5uZWVkUGF4ID0gZW5jU3RyaW5nKGJ1Ziwgb2ZmLCAxMDAsIHBhdGgpIHx8IHRoaXMubmVlZFBheDtcbiAgICAgICAgdGhpcy5uZWVkUGF4ID1cbiAgICAgICAgICAgIGVuY051bWJlcihidWYsIG9mZiArIDEwMCwgOCwgdGhpcy5tb2RlKSB8fCB0aGlzLm5lZWRQYXg7XG4gICAgICAgIHRoaXMubmVlZFBheCA9XG4gICAgICAgICAgICBlbmNOdW1iZXIoYnVmLCBvZmYgKyAxMDgsIDgsIHRoaXMudWlkKSB8fCB0aGlzLm5lZWRQYXg7XG4gICAgICAgIHRoaXMubmVlZFBheCA9XG4gICAgICAgICAgICBlbmNOdW1iZXIoYnVmLCBvZmYgKyAxMTYsIDgsIHRoaXMuZ2lkKSB8fCB0aGlzLm5lZWRQYXg7XG4gICAgICAgIHRoaXMubmVlZFBheCA9XG4gICAgICAgICAgICBlbmNOdW1iZXIoYnVmLCBvZmYgKyAxMjQsIDEyLCB0aGlzLnNpemUpIHx8IHRoaXMubmVlZFBheDtcbiAgICAgICAgdGhpcy5uZWVkUGF4ID1cbiAgICAgICAgICAgIGVuY0RhdGUoYnVmLCBvZmYgKyAxMzYsIDEyLCB0aGlzLm10aW1lKSB8fCB0aGlzLm5lZWRQYXg7XG4gICAgICAgIGJ1ZltvZmYgKyAxNTZdID0gdGhpcy4jdHlwZS5jaGFyQ29kZUF0KDApO1xuICAgICAgICB0aGlzLm5lZWRQYXggPVxuICAgICAgICAgICAgZW5jU3RyaW5nKGJ1Ziwgb2ZmICsgMTU3LCAxMDAsIHRoaXMubGlua3BhdGgpIHx8IHRoaXMubmVlZFBheDtcbiAgICAgICAgYnVmLndyaXRlKCd1c3RhclxcdTAwMDAwMCcsIG9mZiArIDI1NywgOCk7XG4gICAgICAgIHRoaXMubmVlZFBheCA9XG4gICAgICAgICAgICBlbmNTdHJpbmcoYnVmLCBvZmYgKyAyNjUsIDMyLCB0aGlzLnVuYW1lKSB8fCB0aGlzLm5lZWRQYXg7XG4gICAgICAgIHRoaXMubmVlZFBheCA9XG4gICAgICAgICAgICBlbmNTdHJpbmcoYnVmLCBvZmYgKyAyOTcsIDMyLCB0aGlzLmduYW1lKSB8fCB0aGlzLm5lZWRQYXg7XG4gICAgICAgIHRoaXMubmVlZFBheCA9XG4gICAgICAgICAgICBlbmNOdW1iZXIoYnVmLCBvZmYgKyAzMjksIDgsIHRoaXMuZGV2bWFqKSB8fCB0aGlzLm5lZWRQYXg7XG4gICAgICAgIHRoaXMubmVlZFBheCA9XG4gICAgICAgICAgICBlbmNOdW1iZXIoYnVmLCBvZmYgKyAzMzcsIDgsIHRoaXMuZGV2bWluKSB8fCB0aGlzLm5lZWRQYXg7XG4gICAgICAgIHRoaXMubmVlZFBheCA9XG4gICAgICAgICAgICBlbmNTdHJpbmcoYnVmLCBvZmYgKyAzNDUsIHByZWZpeFNpemUsIHByZWZpeCkgfHwgdGhpcy5uZWVkUGF4O1xuICAgICAgICBpZiAoYnVmW29mZiArIDQ3NV0gIT09IDApIHtcbiAgICAgICAgICAgIHRoaXMubmVlZFBheCA9XG4gICAgICAgICAgICAgICAgZW5jU3RyaW5nKGJ1Ziwgb2ZmICsgMzQ1LCAxNTUsIHByZWZpeCkgfHwgdGhpcy5uZWVkUGF4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5uZWVkUGF4ID1cbiAgICAgICAgICAgICAgICBlbmNTdHJpbmcoYnVmLCBvZmYgKyAzNDUsIDEzMCwgcHJlZml4KSB8fCB0aGlzLm5lZWRQYXg7XG4gICAgICAgICAgICB0aGlzLm5lZWRQYXggPVxuICAgICAgICAgICAgICAgIGVuY0RhdGUoYnVmLCBvZmYgKyA0NzYsIDEyLCB0aGlzLmF0aW1lKSB8fCB0aGlzLm5lZWRQYXg7XG4gICAgICAgICAgICB0aGlzLm5lZWRQYXggPVxuICAgICAgICAgICAgICAgIGVuY0RhdGUoYnVmLCBvZmYgKyA0ODgsIDEyLCB0aGlzLmN0aW1lKSB8fCB0aGlzLm5lZWRQYXg7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN1bSA9IDggKiAweDIwO1xuICAgICAgICBmb3IgKGxldCBpID0gb2ZmOyBpIDwgb2ZmICsgMTQ4OyBpKyspIHtcbiAgICAgICAgICAgIHN1bSArPSBidWZbaV07XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IG9mZiArIDE1NjsgaSA8IG9mZiArIDUxMjsgaSsrKSB7XG4gICAgICAgICAgICBzdW0gKz0gYnVmW2ldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2tzdW0gPSBzdW07XG4gICAgICAgIGVuY051bWJlcihidWYsIG9mZiArIDE0OCwgOCwgdGhpcy5ja3N1bSk7XG4gICAgICAgIHRoaXMuY2tzdW1WYWxpZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzLm5lZWRQYXg7XG4gICAgfVxuICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuI3R5cGUgPT09ICdVbnN1cHBvcnRlZCcgP1xuICAgICAgICAgICAgdGhpcy4jdHlwZVxuICAgICAgICAgICAgOiB0eXBlcy5uYW1lLmdldCh0aGlzLiN0eXBlKSk7XG4gICAgfVxuICAgIGdldCB0eXBlS2V5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jdHlwZTtcbiAgICB9XG4gICAgc2V0IHR5cGUodHlwZSkge1xuICAgICAgICBjb25zdCBjID0gU3RyaW5nKHR5cGVzLmNvZGUuZ2V0KHR5cGUpKTtcbiAgICAgICAgaWYgKHR5cGVzLmlzQ29kZShjKSB8fCBjID09PSAnVW5zdXBwb3J0ZWQnKSB7XG4gICAgICAgICAgICB0aGlzLiN0eXBlID0gYztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlcy5pc0NvZGUodHlwZSkpIHtcbiAgICAgICAgICAgIHRoaXMuI3R5cGUgPSB0eXBlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBlbnRyeSB0eXBlOiAnICsgdHlwZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5jb25zdCBzcGxpdFByZWZpeCA9IChwLCBwcmVmaXhTaXplKSA9PiB7XG4gICAgY29uc3QgcGF0aFNpemUgPSAxMDA7XG4gICAgbGV0IHBwID0gcDtcbiAgICBsZXQgcHJlZml4ID0gJyc7XG4gICAgbGV0IHJldCA9IHVuZGVmaW5lZDtcbiAgICBjb25zdCByb290ID0gcGF0aE1vZHVsZS5wYXJzZShwKS5yb290IHx8ICcuJztcbiAgICBpZiAoQnVmZmVyLmJ5dGVMZW5ndGgocHApIDwgcGF0aFNpemUpIHtcbiAgICAgICAgcmV0ID0gW3BwLCBwcmVmaXgsIGZhbHNlXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIGZpcnN0IHNldCBwcmVmaXggdG8gdGhlIGRpciwgYW5kIHBhdGggdG8gdGhlIGJhc2VcbiAgICAgICAgcHJlZml4ID0gcGF0aE1vZHVsZS5kaXJuYW1lKHBwKTtcbiAgICAgICAgcHAgPSBwYXRoTW9kdWxlLmJhc2VuYW1lKHBwKTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKEJ1ZmZlci5ieXRlTGVuZ3RoKHBwKSA8PSBwYXRoU2l6ZSAmJlxuICAgICAgICAgICAgICAgIEJ1ZmZlci5ieXRlTGVuZ3RoKHByZWZpeCkgPD0gcHJlZml4U2l6ZSkge1xuICAgICAgICAgICAgICAgIC8vIGJvdGggZml0IVxuICAgICAgICAgICAgICAgIHJldCA9IFtwcCwgcHJlZml4LCBmYWxzZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChCdWZmZXIuYnl0ZUxlbmd0aChwcCkgPiBwYXRoU2l6ZSAmJlxuICAgICAgICAgICAgICAgIEJ1ZmZlci5ieXRlTGVuZ3RoKHByZWZpeCkgPD0gcHJlZml4U2l6ZSkge1xuICAgICAgICAgICAgICAgIC8vIHByZWZpeCBmaXRzIGluIHByZWZpeCwgYnV0IHBhdGggZG9lc24ndCBmaXQgaW4gcGF0aFxuICAgICAgICAgICAgICAgIHJldCA9IFtwcC5zbGljZSgwLCBwYXRoU2l6ZSAtIDEpLCBwcmVmaXgsIHRydWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbWFrZSBwYXRoIHRha2UgYSBiaXQgZnJvbSBwcmVmaXhcbiAgICAgICAgICAgICAgICBwcCA9IHBhdGhNb2R1bGUuam9pbihwYXRoTW9kdWxlLmJhc2VuYW1lKHByZWZpeCksIHBwKTtcbiAgICAgICAgICAgICAgICBwcmVmaXggPSBwYXRoTW9kdWxlLmRpcm5hbWUocHJlZml4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAocHJlZml4ICE9PSByb290ICYmIHJldCA9PT0gdW5kZWZpbmVkKTtcbiAgICAgICAgLy8gYXQgdGhpcyBwb2ludCwgZm91bmQgbm8gcmVzb2x1dGlvbiwganVzdCB0cnVuY2F0ZVxuICAgICAgICBpZiAoIXJldCkge1xuICAgICAgICAgICAgcmV0ID0gW3Auc2xpY2UoMCwgcGF0aFNpemUgLSAxKSwgJycsIHRydWVdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59O1xuY29uc3QgZGVjU3RyaW5nID0gKGJ1Ziwgb2ZmLCBzaXplKSA9PiBidWZcbiAgICAuc3ViYXJyYXkob2ZmLCBvZmYgKyBzaXplKVxuICAgIC50b1N0cmluZygndXRmOCcpXG4gICAgLnJlcGxhY2UoL1xcMC4qLywgJycpO1xuY29uc3QgZGVjRGF0ZSA9IChidWYsIG9mZiwgc2l6ZSkgPT4gbnVtVG9EYXRlKGRlY051bWJlcihidWYsIG9mZiwgc2l6ZSkpO1xuY29uc3QgbnVtVG9EYXRlID0gKG51bSkgPT4gbnVtID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBuZXcgRGF0ZShudW0gKiAxMDAwKTtcbmNvbnN0IGRlY051bWJlciA9IChidWYsIG9mZiwgc2l6ZSkgPT4gTnVtYmVyKGJ1ZltvZmZdKSAmIDB4ODAgP1xuICAgIGxhcmdlLnBhcnNlKGJ1Zi5zdWJhcnJheShvZmYsIG9mZiArIHNpemUpKVxuICAgIDogZGVjU21hbGxOdW1iZXIoYnVmLCBvZmYsIHNpemUpO1xuY29uc3QgbmFuVW5kZWYgPSAodmFsdWUpID0+IChpc05hTih2YWx1ZSkgPyB1bmRlZmluZWQgOiB2YWx1ZSk7XG5jb25zdCBkZWNTbWFsbE51bWJlciA9IChidWYsIG9mZiwgc2l6ZSkgPT4gbmFuVW5kZWYocGFyc2VJbnQoYnVmXG4gICAgLnN1YmFycmF5KG9mZiwgb2ZmICsgc2l6ZSlcbiAgICAudG9TdHJpbmcoJ3V0ZjgnKVxuICAgIC5yZXBsYWNlKC9cXDAuKiQvLCAnJylcbiAgICAudHJpbSgpLCA4KSk7XG4vLyB0aGUgbWF4aW11bSBlbmNvZGFibGUgYXMgYSBudWxsLXRlcm1pbmF0ZWQgb2N0YWwsIGJ5IGZpZWxkIHNpemVcbmNvbnN0IE1BWE5VTSA9IHtcbiAgICAxMjogMG83Nzc3Nzc3Nzc3NyxcbiAgICA4OiAwbzc3Nzc3NzcsXG59O1xuY29uc3QgZW5jTnVtYmVyID0gKGJ1Ziwgb2ZmLCBzaXplLCBudW0pID0+IG51bSA9PT0gdW5kZWZpbmVkID8gZmFsc2VcbiAgICA6IG51bSA+IE1BWE5VTVtzaXplXSB8fCBudW0gPCAwID9cbiAgICAgICAgKGxhcmdlLmVuY29kZShudW0sIGJ1Zi5zdWJhcnJheShvZmYsIG9mZiArIHNpemUpKSwgdHJ1ZSlcbiAgICAgICAgOiAoZW5jU21hbGxOdW1iZXIoYnVmLCBvZmYsIHNpemUsIG51bSksIGZhbHNlKTtcbmNvbnN0IGVuY1NtYWxsTnVtYmVyID0gKGJ1Ziwgb2ZmLCBzaXplLCBudW0pID0+IGJ1Zi53cml0ZShvY3RhbFN0cmluZyhudW0sIHNpemUpLCBvZmYsIHNpemUsICdhc2NpaScpO1xuY29uc3Qgb2N0YWxTdHJpbmcgPSAobnVtLCBzaXplKSA9PiBwYWRPY3RhbChNYXRoLmZsb29yKG51bSkudG9TdHJpbmcoOCksIHNpemUpO1xuY29uc3QgcGFkT2N0YWwgPSAoc3RyLCBzaXplKSA9PiAoc3RyLmxlbmd0aCA9PT0gc2l6ZSAtIDEgP1xuICAgIHN0clxuICAgIDogbmV3IEFycmF5KHNpemUgLSBzdHIubGVuZ3RoIC0gMSkuam9pbignMCcpICsgc3RyICsgJyAnKSArICdcXDAnO1xuY29uc3QgZW5jRGF0ZSA9IChidWYsIG9mZiwgc2l6ZSwgZGF0ZSkgPT4gZGF0ZSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiAoZW5jTnVtYmVyKGJ1Ziwgb2ZmLCBzaXplLCBkYXRlLmdldFRpbWUoKSAvIDEwMDApKTtcbi8vIGVub3VnaCB0byBmaWxsIHRoZSBsb25nZXN0IHN0cmluZyB3ZSd2ZSBnb3RcbmNvbnN0IE5VTExTID0gbmV3IEFycmF5KDE1Nikuam9pbignXFwwJyk7XG4vLyBwYWQgd2l0aCBudWxscywgcmV0dXJuIHRydWUgaWYgaXQncyBsb25nZXIgb3Igbm9uLWFzY2lpXG5jb25zdCBlbmNTdHJpbmcgPSAoYnVmLCBvZmYsIHNpemUsIHN0cikgPT4gc3RyID09PSB1bmRlZmluZWQgPyBmYWxzZSA6ICgoYnVmLndyaXRlKHN0ciArIE5VTExTLCBvZmYsIHNpemUsICd1dGY4JyksXG4gICAgc3RyLmxlbmd0aCAhPT0gQnVmZmVyLmJ5dGVMZW5ndGgoc3RyKSB8fCBzdHIubGVuZ3RoID4gc2l6ZSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGVhZGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/tar/dist/esm/header.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/tar/dist/esm/index.js":
/*!********************************************!*\
  !*** ./node_modules/tar/dist/esm/index.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Header: () => (/* reexport safe */ _header_js__WEBPACK_IMPORTED_MODULE_2__.Header),\n/* harmony export */   Pack: () => (/* reexport safe */ _pack_js__WEBPACK_IMPORTED_MODULE_4__.Pack),\n/* harmony export */   PackJob: () => (/* reexport safe */ _pack_js__WEBPACK_IMPORTED_MODULE_4__.PackJob),\n/* harmony export */   PackSync: () => (/* reexport safe */ _pack_js__WEBPACK_IMPORTED_MODULE_4__.PackSync),\n/* harmony export */   Parser: () => (/* reexport safe */ _parse_js__WEBPACK_IMPORTED_MODULE_5__.Parser),\n/* harmony export */   Pax: () => (/* reexport safe */ _pax_js__WEBPACK_IMPORTED_MODULE_6__.Pax),\n/* harmony export */   ReadEntry: () => (/* reexport safe */ _read_entry_js__WEBPACK_IMPORTED_MODULE_7__.ReadEntry),\n/* harmony export */   Unpack: () => (/* reexport safe */ _unpack_js__WEBPACK_IMPORTED_MODULE_10__.Unpack),\n/* harmony export */   UnpackSync: () => (/* reexport safe */ _unpack_js__WEBPACK_IMPORTED_MODULE_10__.UnpackSync),\n/* harmony export */   WriteEntry: () => (/* reexport safe */ _write_entry_js__WEBPACK_IMPORTED_MODULE_12__.WriteEntry),\n/* harmony export */   WriteEntrySync: () => (/* reexport safe */ _write_entry_js__WEBPACK_IMPORTED_MODULE_12__.WriteEntrySync),\n/* harmony export */   WriteEntryTar: () => (/* reexport safe */ _write_entry_js__WEBPACK_IMPORTED_MODULE_12__.WriteEntryTar),\n/* harmony export */   c: () => (/* reexport safe */ _create_js__WEBPACK_IMPORTED_MODULE_0__.create),\n/* harmony export */   create: () => (/* reexport safe */ _create_js__WEBPACK_IMPORTED_MODULE_0__.create),\n/* harmony export */   extract: () => (/* reexport safe */ _extract_js__WEBPACK_IMPORTED_MODULE_1__.extract),\n/* harmony export */   filesFilter: () => (/* reexport safe */ _list_js__WEBPACK_IMPORTED_MODULE_3__.filesFilter),\n/* harmony export */   list: () => (/* reexport safe */ _list_js__WEBPACK_IMPORTED_MODULE_3__.list),\n/* harmony export */   r: () => (/* reexport safe */ _replace_js__WEBPACK_IMPORTED_MODULE_8__.replace),\n/* harmony export */   replace: () => (/* reexport safe */ _replace_js__WEBPACK_IMPORTED_MODULE_8__.replace),\n/* harmony export */   t: () => (/* reexport safe */ _list_js__WEBPACK_IMPORTED_MODULE_3__.list),\n/* harmony export */   types: () => (/* reexport module object */ _types_js__WEBPACK_IMPORTED_MODULE_9__),\n/* harmony export */   u: () => (/* reexport safe */ _update_js__WEBPACK_IMPORTED_MODULE_11__.update),\n/* harmony export */   update: () => (/* reexport safe */ _update_js__WEBPACK_IMPORTED_MODULE_11__.update),\n/* harmony export */   x: () => (/* reexport safe */ _extract_js__WEBPACK_IMPORTED_MODULE_1__.extract)\n/* harmony export */ });\n/* harmony import */ var _create_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./create.js */ \"(rsc)/./node_modules/tar/dist/esm/create.js\");\n/* harmony import */ var _extract_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./extract.js */ \"(rsc)/./node_modules/tar/dist/esm/extract.js\");\n/* harmony import */ var _header_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./header.js */ \"(rsc)/./node_modules/tar/dist/esm/header.js\");\n/* harmony import */ var _list_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./list.js */ \"(rsc)/./node_modules/tar/dist/esm/list.js\");\n/* harmony import */ var _pack_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./pack.js */ \"(rsc)/./node_modules/tar/dist/esm/pack.js\");\n/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./parse.js */ \"(rsc)/./node_modules/tar/dist/esm/parse.js\");\n/* harmony import */ var _pax_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./pax.js */ \"(rsc)/./node_modules/tar/dist/esm/pax.js\");\n/* harmony import */ var _read_entry_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./read-entry.js */ \"(rsc)/./node_modules/tar/dist/esm/read-entry.js\");\n/* harmony import */ var _replace_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./replace.js */ \"(rsc)/./node_modules/tar/dist/esm/replace.js\");\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./types.js */ \"(rsc)/./node_modules/tar/dist/esm/types.js\");\n/* harmony import */ var _unpack_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./unpack.js */ \"(rsc)/./node_modules/tar/dist/esm/unpack.js\");\n/* harmony import */ var _update_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./update.js */ \"(rsc)/./node_modules/tar/dist/esm/update.js\");\n/* harmony import */ var _write_entry_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./write-entry.js */ \"(rsc)/./node_modules/tar/dist/esm/write-entry.js\");\n\n\n\n\n\n\n\n// classes\n\n\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBNEI7QUFDYztBQUNiO0FBQ2U7QUFDaEI7QUFDRjtBQUNZO0FBQ3RDO0FBQzBCO0FBQ0M7QUFDRjtBQUNPO0FBQ0g7QUFDZTtBQUNSO0FBQ1I7QUFDQTtBQUNjO0FBQ1Q7QUFDakMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aXZlLXZpYmUtYWktbmV4dC8uL25vZGVfbW9kdWxlcy90YXIvZGlzdC9lc20vaW5kZXguanM/OGRmMiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBmcm9tICcuL2NyZWF0ZS5qcyc7XG5leHBvcnQgeyBjcmVhdGUgYXMgYyB9IGZyb20gJy4vY3JlYXRlLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vZXh0cmFjdC5qcyc7XG5leHBvcnQgeyBleHRyYWN0IGFzIHggfSBmcm9tICcuL2V4dHJhY3QuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9oZWFkZXIuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9saXN0LmpzJztcbmV4cG9ydCB7IGxpc3QgYXMgdCB9IGZyb20gJy4vbGlzdC5qcyc7XG4vLyBjbGFzc2VzXG5leHBvcnQgKiBmcm9tICcuL3BhY2suanMnO1xuZXhwb3J0ICogZnJvbSAnLi9wYXJzZS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3BheC5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3JlYWQtZW50cnkuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9yZXBsYWNlLmpzJztcbmV4cG9ydCB7IHJlcGxhY2UgYXMgciB9IGZyb20gJy4vcmVwbGFjZS5qcyc7XG5leHBvcnQgKiBhcyB0eXBlcyBmcm9tICcuL3R5cGVzLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vdW5wYWNrLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vdXBkYXRlLmpzJztcbmV4cG9ydCB7IHVwZGF0ZSBhcyB1IH0gZnJvbSAnLi91cGRhdGUuanMnO1xuZXhwb3J0ICogZnJvbSAnLi93cml0ZS1lbnRyeS5qcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/tar/dist/esm/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/tar/dist/esm/large-numbers.js":
/*!****************************************************!*\
  !*** ./node_modules/tar/dist/esm/large-numbers.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encode: () => (/* binding */ encode),\n/* harmony export */   parse: () => (/* binding */ parse)\n/* harmony export */ });\n// Tar can encode large and negative numbers using a leading byte of\n// 0xff for negative, and 0x80 for positive.\nconst encode = (num, buf) => {\n    if (!Number.isSafeInteger(num)) {\n        // The number is so large that javascript cannot represent it with integer\n        // precision.\n        throw Error('cannot encode number outside of javascript safe integer range');\n    }\n    else if (num < 0) {\n        encodeNegative(num, buf);\n    }\n    else {\n        encodePositive(num, buf);\n    }\n    return buf;\n};\nconst encodePositive = (num, buf) => {\n    buf[0] = 0x80;\n    for (var i = buf.length; i > 1; i--) {\n        buf[i - 1] = num & 0xff;\n        num = Math.floor(num / 0x100);\n    }\n};\nconst encodeNegative = (num, buf) => {\n    buf[0] = 0xff;\n    var flipped = false;\n    num = num * -1;\n    for (var i = buf.length; i > 1; i--) {\n        var byte = num & 0xff;\n        num = Math.floor(num / 0x100);\n        if (flipped) {\n            buf[i - 1] = onesComp(byte);\n        }\n        else if (byte === 0) {\n            buf[i - 1] = 0;\n        }\n        else {\n            flipped = true;\n            buf[i - 1] = twosComp(byte);\n        }\n    }\n};\nconst parse = (buf) => {\n    const pre = buf[0];\n    const value = pre === 0x80 ? pos(buf.subarray(1, buf.length))\n        : pre === 0xff ? twos(buf)\n            : null;\n    if (value === null) {\n        throw Error('invalid base256 encoding');\n    }\n    if (!Number.isSafeInteger(value)) {\n        // The number is so large that javascript cannot represent it with integer\n        // precision.\n        throw Error('parsed number outside of javascript safe integer range');\n    }\n    return value;\n};\nconst twos = (buf) => {\n    var len = buf.length;\n    var sum = 0;\n    var flipped = false;\n    for (var i = len - 1; i > -1; i--) {\n        var byte = Number(buf[i]);\n        var f;\n        if (flipped) {\n            f = onesComp(byte);\n        }\n        else if (byte === 0) {\n            f = byte;\n        }\n        else {\n            flipped = true;\n            f = twosComp(byte);\n        }\n        if (f !== 0) {\n            sum -= f * Math.pow(256, len - i - 1);\n        }\n    }\n    return sum;\n};\nconst pos = (buf) => {\n    var len = buf.length;\n    var sum = 0;\n    for (var i = len - 1; i > -1; i--) {\n        var byte = Number(buf[i]);\n        if (byte !== 0) {\n            sum += byte * Math.pow(256, len - i - 1);\n        }\n    }\n    return sum;\n};\nconst onesComp = (byte) => (0xff ^ byte) & 0xff;\nconst twosComp = (byte) => ((0xff ^ byte) + 1) & 0xff;\n//# sourceMappingURL=large-numbers.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvZXNtL2xhcmdlLW51bWJlcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsT0FBTztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLE9BQU87QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFFBQVE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFFBQVE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aXZlLXZpYmUtYWktbmV4dC8uL25vZGVfbW9kdWxlcy90YXIvZGlzdC9lc20vbGFyZ2UtbnVtYmVycy5qcz9mZDhmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRhciBjYW4gZW5jb2RlIGxhcmdlIGFuZCBuZWdhdGl2ZSBudW1iZXJzIHVzaW5nIGEgbGVhZGluZyBieXRlIG9mXG4vLyAweGZmIGZvciBuZWdhdGl2ZSwgYW5kIDB4ODAgZm9yIHBvc2l0aXZlLlxuZXhwb3J0IGNvbnN0IGVuY29kZSA9IChudW0sIGJ1ZikgPT4ge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobnVtKSkge1xuICAgICAgICAvLyBUaGUgbnVtYmVyIGlzIHNvIGxhcmdlIHRoYXQgamF2YXNjcmlwdCBjYW5ub3QgcmVwcmVzZW50IGl0IHdpdGggaW50ZWdlclxuICAgICAgICAvLyBwcmVjaXNpb24uXG4gICAgICAgIHRocm93IEVycm9yKCdjYW5ub3QgZW5jb2RlIG51bWJlciBvdXRzaWRlIG9mIGphdmFzY3JpcHQgc2FmZSBpbnRlZ2VyIHJhbmdlJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG51bSA8IDApIHtcbiAgICAgICAgZW5jb2RlTmVnYXRpdmUobnVtLCBidWYpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZW5jb2RlUG9zaXRpdmUobnVtLCBidWYpO1xuICAgIH1cbiAgICByZXR1cm4gYnVmO1xufTtcbmNvbnN0IGVuY29kZVBvc2l0aXZlID0gKG51bSwgYnVmKSA9PiB7XG4gICAgYnVmWzBdID0gMHg4MDtcbiAgICBmb3IgKHZhciBpID0gYnVmLmxlbmd0aDsgaSA+IDE7IGktLSkge1xuICAgICAgICBidWZbaSAtIDFdID0gbnVtICYgMHhmZjtcbiAgICAgICAgbnVtID0gTWF0aC5mbG9vcihudW0gLyAweDEwMCk7XG4gICAgfVxufTtcbmNvbnN0IGVuY29kZU5lZ2F0aXZlID0gKG51bSwgYnVmKSA9PiB7XG4gICAgYnVmWzBdID0gMHhmZjtcbiAgICB2YXIgZmxpcHBlZCA9IGZhbHNlO1xuICAgIG51bSA9IG51bSAqIC0xO1xuICAgIGZvciAodmFyIGkgPSBidWYubGVuZ3RoOyBpID4gMTsgaS0tKSB7XG4gICAgICAgIHZhciBieXRlID0gbnVtICYgMHhmZjtcbiAgICAgICAgbnVtID0gTWF0aC5mbG9vcihudW0gLyAweDEwMCk7XG4gICAgICAgIGlmIChmbGlwcGVkKSB7XG4gICAgICAgICAgICBidWZbaSAtIDFdID0gb25lc0NvbXAoYnl0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYnl0ZSA9PT0gMCkge1xuICAgICAgICAgICAgYnVmW2kgLSAxXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmbGlwcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGJ1ZltpIC0gMV0gPSB0d29zQ29tcChieXRlKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5leHBvcnQgY29uc3QgcGFyc2UgPSAoYnVmKSA9PiB7XG4gICAgY29uc3QgcHJlID0gYnVmWzBdO1xuICAgIGNvbnN0IHZhbHVlID0gcHJlID09PSAweDgwID8gcG9zKGJ1Zi5zdWJhcnJheSgxLCBidWYubGVuZ3RoKSlcbiAgICAgICAgOiBwcmUgPT09IDB4ZmYgPyB0d29zKGJ1ZilcbiAgICAgICAgICAgIDogbnVsbDtcbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ2ludmFsaWQgYmFzZTI1NiBlbmNvZGluZycpO1xuICAgIH1cbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbHVlKSkge1xuICAgICAgICAvLyBUaGUgbnVtYmVyIGlzIHNvIGxhcmdlIHRoYXQgamF2YXNjcmlwdCBjYW5ub3QgcmVwcmVzZW50IGl0IHdpdGggaW50ZWdlclxuICAgICAgICAvLyBwcmVjaXNpb24uXG4gICAgICAgIHRocm93IEVycm9yKCdwYXJzZWQgbnVtYmVyIG91dHNpZGUgb2YgamF2YXNjcmlwdCBzYWZlIGludGVnZXIgcmFuZ2UnKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcbmNvbnN0IHR3b3MgPSAoYnVmKSA9PiB7XG4gICAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGg7XG4gICAgdmFyIHN1bSA9IDA7XG4gICAgdmFyIGZsaXBwZWQgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gbGVuIC0gMTsgaSA+IC0xOyBpLS0pIHtcbiAgICAgICAgdmFyIGJ5dGUgPSBOdW1iZXIoYnVmW2ldKTtcbiAgICAgICAgdmFyIGY7XG4gICAgICAgIGlmIChmbGlwcGVkKSB7XG4gICAgICAgICAgICBmID0gb25lc0NvbXAoYnl0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYnl0ZSA9PT0gMCkge1xuICAgICAgICAgICAgZiA9IGJ5dGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmbGlwcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGYgPSB0d29zQ29tcChieXRlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZiAhPT0gMCkge1xuICAgICAgICAgICAgc3VtIC09IGYgKiBNYXRoLnBvdygyNTYsIGxlbiAtIGkgLSAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3VtO1xufTtcbmNvbnN0IHBvcyA9IChidWYpID0+IHtcbiAgICB2YXIgbGVuID0gYnVmLmxlbmd0aDtcbiAgICB2YXIgc3VtID0gMDtcbiAgICBmb3IgKHZhciBpID0gbGVuIC0gMTsgaSA+IC0xOyBpLS0pIHtcbiAgICAgICAgdmFyIGJ5dGUgPSBOdW1iZXIoYnVmW2ldKTtcbiAgICAgICAgaWYgKGJ5dGUgIT09IDApIHtcbiAgICAgICAgICAgIHN1bSArPSBieXRlICogTWF0aC5wb3coMjU2LCBsZW4gLSBpIC0gMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN1bTtcbn07XG5jb25zdCBvbmVzQ29tcCA9IChieXRlKSA9PiAoMHhmZiBeIGJ5dGUpICYgMHhmZjtcbmNvbnN0IHR3b3NDb21wID0gKGJ5dGUpID0+ICgoMHhmZiBeIGJ5dGUpICsgMSkgJiAweGZmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGFyZ2UtbnVtYmVycy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/tar/dist/esm/large-numbers.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/tar/dist/esm/list.js":
/*!*******************************************!*\
  !*** ./node_modules/tar/dist/esm/list.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   filesFilter: () => (/* binding */ filesFilter),\n/* harmony export */   list: () => (/* binding */ list)\n/* harmony export */ });\n/* harmony import */ var _isaacs_fs_minipass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @isaacs/fs-minipass */ \"(rsc)/./node_modules/@isaacs/fs-minipass/dist/esm/index.js\");\n/* harmony import */ var node_fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:fs */ \"node:fs\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var _make_command_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./make-command.js */ \"(rsc)/./node_modules/tar/dist/esm/make-command.js\");\n/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./parse.js */ \"(rsc)/./node_modules/tar/dist/esm/parse.js\");\n/* harmony import */ var _strip_trailing_slashes_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./strip-trailing-slashes.js */ \"(rsc)/./node_modules/tar/dist/esm/strip-trailing-slashes.js\");\n// tar -t\n\n\n\n\n\n\nconst onReadEntryFunction = (opt) => {\n    const onReadEntry = opt.onReadEntry;\n    opt.onReadEntry =\n        onReadEntry ?\n            e => {\n                onReadEntry(e);\n                e.resume();\n            }\n            : e => e.resume();\n};\n// construct a filter that limits the file entries listed\n// include child entries if a dir is included\nconst filesFilter = (opt, files) => {\n    const map = new Map(files.map(f => [(0,_strip_trailing_slashes_js__WEBPACK_IMPORTED_MODULE_5__.stripTrailingSlashes)(f), true]));\n    const filter = opt.filter;\n    const mapHas = (file, r = '') => {\n        const root = r || (0,path__WEBPACK_IMPORTED_MODULE_2__.parse)(file).root || '.';\n        let ret;\n        if (file === root)\n            ret = false;\n        else {\n            const m = map.get(file);\n            if (m !== undefined) {\n                ret = m;\n            }\n            else {\n                ret = mapHas((0,path__WEBPACK_IMPORTED_MODULE_2__.dirname)(file), root);\n            }\n        }\n        map.set(file, ret);\n        return ret;\n    };\n    opt.filter =\n        filter ?\n            (file, entry) => filter(file, entry) && mapHas((0,_strip_trailing_slashes_js__WEBPACK_IMPORTED_MODULE_5__.stripTrailingSlashes)(file))\n            : file => mapHas((0,_strip_trailing_slashes_js__WEBPACK_IMPORTED_MODULE_5__.stripTrailingSlashes)(file));\n};\nconst listFileSync = (opt) => {\n    const p = new _parse_js__WEBPACK_IMPORTED_MODULE_4__.Parser(opt);\n    const file = opt.file;\n    let fd;\n    try {\n        const stat = node_fs__WEBPACK_IMPORTED_MODULE_1__.statSync(file);\n        const readSize = opt.maxReadSize || 16 * 1024 * 1024;\n        if (stat.size < readSize) {\n            p.end(node_fs__WEBPACK_IMPORTED_MODULE_1__.readFileSync(file));\n        }\n        else {\n            let pos = 0;\n            const buf = Buffer.allocUnsafe(readSize);\n            fd = node_fs__WEBPACK_IMPORTED_MODULE_1__.openSync(file, 'r');\n            while (pos < stat.size) {\n                const bytesRead = node_fs__WEBPACK_IMPORTED_MODULE_1__.readSync(fd, buf, 0, readSize, pos);\n                pos += bytesRead;\n                p.write(buf.subarray(0, bytesRead));\n            }\n            p.end();\n        }\n    }\n    finally {\n        if (typeof fd === 'number') {\n            try {\n                node_fs__WEBPACK_IMPORTED_MODULE_1__.closeSync(fd);\n                /* c8 ignore next */\n            }\n            catch (er) { }\n        }\n    }\n};\nconst listFile = (opt, _files) => {\n    const parse = new _parse_js__WEBPACK_IMPORTED_MODULE_4__.Parser(opt);\n    const readSize = opt.maxReadSize || 16 * 1024 * 1024;\n    const file = opt.file;\n    const p = new Promise((resolve, reject) => {\n        parse.on('error', reject);\n        parse.on('end', resolve);\n        node_fs__WEBPACK_IMPORTED_MODULE_1__.stat(file, (er, stat) => {\n            if (er) {\n                reject(er);\n            }\n            else {\n                const stream = new _isaacs_fs_minipass__WEBPACK_IMPORTED_MODULE_0__.ReadStream(file, {\n                    readSize: readSize,\n                    size: stat.size,\n                });\n                stream.on('error', reject);\n                stream.pipe(parse);\n            }\n        });\n    });\n    return p;\n};\nconst list = (0,_make_command_js__WEBPACK_IMPORTED_MODULE_3__.makeCommand)(listFileSync, listFile, opt => new _parse_js__WEBPACK_IMPORTED_MODULE_4__.Parser(opt), opt => new _parse_js__WEBPACK_IMPORTED_MODULE_4__.Parser(opt), (opt, files) => {\n    if (files?.length)\n        filesFilter(opt, files);\n    if (!opt.noResume)\n        onReadEntryFunction(opt);\n});\n//# sourceMappingURL=list.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvZXNtL2xpc3QuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUMyQztBQUNsQjtBQUNhO0FBQ1U7QUFDWjtBQUMrQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLHdDQUF3QyxnRkFBb0I7QUFDNUQ7QUFDQTtBQUNBLDBCQUEwQiwyQ0FBSztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNkNBQU87QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsZ0ZBQW9CO0FBQy9FLDZCQUE2QixnRkFBb0I7QUFDakQ7QUFDQTtBQUNBLGtCQUFrQiw2Q0FBTTtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNkNBQVc7QUFDaEM7QUFDQTtBQUNBLGtCQUFrQixpREFBZTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw2Q0FBVztBQUM1QjtBQUNBLGtDQUFrQyw2Q0FBVztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsOENBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNkNBQU07QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEseUNBQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywyREFBYztBQUNqRDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNPLGFBQWEsNkRBQVcsb0NBQW9DLDZDQUFNLGtCQUFrQiw2Q0FBTTtBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpdmUtdmliZS1haS1uZXh0Ly4vbm9kZV9tb2R1bGVzL3Rhci9kaXN0L2VzbS9saXN0LmpzP2Y2YWIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gdGFyIC10XG5pbXBvcnQgKiBhcyBmc20gZnJvbSAnQGlzYWFjcy9mcy1taW5pcGFzcyc7XG5pbXBvcnQgZnMgZnJvbSAnbm9kZTpmcyc7XG5pbXBvcnQgeyBkaXJuYW1lLCBwYXJzZSB9IGZyb20gJ3BhdGgnO1xuaW1wb3J0IHsgbWFrZUNvbW1hbmQgfSBmcm9tICcuL21ha2UtY29tbWFuZC5qcyc7XG5pbXBvcnQgeyBQYXJzZXIgfSBmcm9tICcuL3BhcnNlLmpzJztcbmltcG9ydCB7IHN0cmlwVHJhaWxpbmdTbGFzaGVzIH0gZnJvbSAnLi9zdHJpcC10cmFpbGluZy1zbGFzaGVzLmpzJztcbmNvbnN0IG9uUmVhZEVudHJ5RnVuY3Rpb24gPSAob3B0KSA9PiB7XG4gICAgY29uc3Qgb25SZWFkRW50cnkgPSBvcHQub25SZWFkRW50cnk7XG4gICAgb3B0Lm9uUmVhZEVudHJ5ID1cbiAgICAgICAgb25SZWFkRW50cnkgP1xuICAgICAgICAgICAgZSA9PiB7XG4gICAgICAgICAgICAgICAgb25SZWFkRW50cnkoZSk7XG4gICAgICAgICAgICAgICAgZS5yZXN1bWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogZSA9PiBlLnJlc3VtZSgpO1xufTtcbi8vIGNvbnN0cnVjdCBhIGZpbHRlciB0aGF0IGxpbWl0cyB0aGUgZmlsZSBlbnRyaWVzIGxpc3RlZFxuLy8gaW5jbHVkZSBjaGlsZCBlbnRyaWVzIGlmIGEgZGlyIGlzIGluY2x1ZGVkXG5leHBvcnQgY29uc3QgZmlsZXNGaWx0ZXIgPSAob3B0LCBmaWxlcykgPT4ge1xuICAgIGNvbnN0IG1hcCA9IG5ldyBNYXAoZmlsZXMubWFwKGYgPT4gW3N0cmlwVHJhaWxpbmdTbGFzaGVzKGYpLCB0cnVlXSkpO1xuICAgIGNvbnN0IGZpbHRlciA9IG9wdC5maWx0ZXI7XG4gICAgY29uc3QgbWFwSGFzID0gKGZpbGUsIHIgPSAnJykgPT4ge1xuICAgICAgICBjb25zdCByb290ID0gciB8fCBwYXJzZShmaWxlKS5yb290IHx8ICcuJztcbiAgICAgICAgbGV0IHJldDtcbiAgICAgICAgaWYgKGZpbGUgPT09IHJvb3QpXG4gICAgICAgICAgICByZXQgPSBmYWxzZTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBtID0gbWFwLmdldChmaWxlKTtcbiAgICAgICAgICAgIGlmIChtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXQgPSBtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gbWFwSGFzKGRpcm5hbWUoZmlsZSksIHJvb3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1hcC5zZXQoZmlsZSwgcmV0KTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIG9wdC5maWx0ZXIgPVxuICAgICAgICBmaWx0ZXIgP1xuICAgICAgICAgICAgKGZpbGUsIGVudHJ5KSA9PiBmaWx0ZXIoZmlsZSwgZW50cnkpICYmIG1hcEhhcyhzdHJpcFRyYWlsaW5nU2xhc2hlcyhmaWxlKSlcbiAgICAgICAgICAgIDogZmlsZSA9PiBtYXBIYXMoc3RyaXBUcmFpbGluZ1NsYXNoZXMoZmlsZSkpO1xufTtcbmNvbnN0IGxpc3RGaWxlU3luYyA9IChvcHQpID0+IHtcbiAgICBjb25zdCBwID0gbmV3IFBhcnNlcihvcHQpO1xuICAgIGNvbnN0IGZpbGUgPSBvcHQuZmlsZTtcbiAgICBsZXQgZmQ7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc3RhdCA9IGZzLnN0YXRTeW5jKGZpbGUpO1xuICAgICAgICBjb25zdCByZWFkU2l6ZSA9IG9wdC5tYXhSZWFkU2l6ZSB8fCAxNiAqIDEwMjQgKiAxMDI0O1xuICAgICAgICBpZiAoc3RhdC5zaXplIDwgcmVhZFNpemUpIHtcbiAgICAgICAgICAgIHAuZW5kKGZzLnJlYWRGaWxlU3luYyhmaWxlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgcG9zID0gMDtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShyZWFkU2l6ZSk7XG4gICAgICAgICAgICBmZCA9IGZzLm9wZW5TeW5jKGZpbGUsICdyJyk7XG4gICAgICAgICAgICB3aGlsZSAocG9zIDwgc3RhdC5zaXplKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnl0ZXNSZWFkID0gZnMucmVhZFN5bmMoZmQsIGJ1ZiwgMCwgcmVhZFNpemUsIHBvcyk7XG4gICAgICAgICAgICAgICAgcG9zICs9IGJ5dGVzUmVhZDtcbiAgICAgICAgICAgICAgICBwLndyaXRlKGJ1Zi5zdWJhcnJheSgwLCBieXRlc1JlYWQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHAuZW5kKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIGlmICh0eXBlb2YgZmQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZzLmNsb3NlU3luYyhmZCk7XG4gICAgICAgICAgICAgICAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcikgeyB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgbGlzdEZpbGUgPSAob3B0LCBfZmlsZXMpID0+IHtcbiAgICBjb25zdCBwYXJzZSA9IG5ldyBQYXJzZXIob3B0KTtcbiAgICBjb25zdCByZWFkU2l6ZSA9IG9wdC5tYXhSZWFkU2l6ZSB8fCAxNiAqIDEwMjQgKiAxMDI0O1xuICAgIGNvbnN0IGZpbGUgPSBvcHQuZmlsZTtcbiAgICBjb25zdCBwID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBwYXJzZS5vbignZXJyb3InLCByZWplY3QpO1xuICAgICAgICBwYXJzZS5vbignZW5kJywgcmVzb2x2ZSk7XG4gICAgICAgIGZzLnN0YXQoZmlsZSwgKGVyLCBzdGF0KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXIpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RyZWFtID0gbmV3IGZzbS5SZWFkU3RyZWFtKGZpbGUsIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhZFNpemU6IHJlYWRTaXplLFxuICAgICAgICAgICAgICAgICAgICBzaXplOiBzdGF0LnNpemUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc3RyZWFtLm9uKCdlcnJvcicsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgc3RyZWFtLnBpcGUocGFyc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcDtcbn07XG5leHBvcnQgY29uc3QgbGlzdCA9IG1ha2VDb21tYW5kKGxpc3RGaWxlU3luYywgbGlzdEZpbGUsIG9wdCA9PiBuZXcgUGFyc2VyKG9wdCksIG9wdCA9PiBuZXcgUGFyc2VyKG9wdCksIChvcHQsIGZpbGVzKSA9PiB7XG4gICAgaWYgKGZpbGVzPy5sZW5ndGgpXG4gICAgICAgIGZpbGVzRmlsdGVyKG9wdCwgZmlsZXMpO1xuICAgIGlmICghb3B0Lm5vUmVzdW1lKVxuICAgICAgICBvblJlYWRFbnRyeUZ1bmN0aW9uKG9wdCk7XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpc3QuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/tar/dist/esm/list.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/tar/dist/esm/make-command.js":
/*!***************************************************!*\
  !*** ./node_modules/tar/dist/esm/make-command.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   makeCommand: () => (/* binding */ makeCommand)\n/* harmony export */ });\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./options.js */ \"(rsc)/./node_modules/tar/dist/esm/options.js\");\n\nconst makeCommand = (syncFile, asyncFile, syncNoFile, asyncNoFile, validate) => {\n    return Object.assign((opt_ = [], entries, cb) => {\n        if (Array.isArray(opt_)) {\n            entries = opt_;\n            opt_ = {};\n        }\n        if (typeof entries === 'function') {\n            cb = entries;\n            entries = undefined;\n        }\n        if (!entries) {\n            entries = [];\n        }\n        else {\n            entries = Array.from(entries);\n        }\n        const opt = (0,_options_js__WEBPACK_IMPORTED_MODULE_0__.dealias)(opt_);\n        validate?.(opt, entries);\n        if ((0,_options_js__WEBPACK_IMPORTED_MODULE_0__.isSyncFile)(opt)) {\n            if (typeof cb === 'function') {\n                throw new TypeError('callback not supported for sync tar functions');\n            }\n            return syncFile(opt, entries);\n        }\n        else if ((0,_options_js__WEBPACK_IMPORTED_MODULE_0__.isAsyncFile)(opt)) {\n            const p = asyncFile(opt, entries);\n            // weirdness to make TS happy\n            const c = cb ? cb : undefined;\n            return c ? p.then(() => c(), c) : p;\n        }\n        else if ((0,_options_js__WEBPACK_IMPORTED_MODULE_0__.isSyncNoFile)(opt)) {\n            if (typeof cb === 'function') {\n                throw new TypeError('callback not supported for sync tar functions');\n            }\n            return syncNoFile(opt, entries);\n        }\n        else if ((0,_options_js__WEBPACK_IMPORTED_MODULE_0__.isAsyncNoFile)(opt)) {\n            if (typeof cb === 'function') {\n                throw new TypeError('callback only supported with file option');\n            }\n            return asyncNoFile(opt, entries);\n            /* c8 ignore start */\n        }\n        else {\n            throw new Error('impossible options??');\n        }\n        /* c8 ignore stop */\n    }, {\n        syncFile,\n        asyncFile,\n        syncNoFile,\n        asyncNoFile,\n        validate,\n    });\n};\n//# sourceMappingURL=make-command.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvZXNtL21ha2UtY29tbWFuZC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUE4RjtBQUN2RjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvREFBTztBQUMzQjtBQUNBLFlBQVksdURBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix3REFBVztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHlEQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMERBQWE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdml2ZS12aWJlLWFpLW5leHQvLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvZXNtL21ha2UtY29tbWFuZC5qcz9lMjNhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGRlYWxpYXMsIGlzQXN5bmNGaWxlLCBpc0FzeW5jTm9GaWxlLCBpc1N5bmNGaWxlLCBpc1N5bmNOb0ZpbGUsIH0gZnJvbSAnLi9vcHRpb25zLmpzJztcbmV4cG9ydCBjb25zdCBtYWtlQ29tbWFuZCA9IChzeW5jRmlsZSwgYXN5bmNGaWxlLCBzeW5jTm9GaWxlLCBhc3luY05vRmlsZSwgdmFsaWRhdGUpID0+IHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbigob3B0XyA9IFtdLCBlbnRyaWVzLCBjYikgPT4ge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRfKSkge1xuICAgICAgICAgICAgZW50cmllcyA9IG9wdF87XG4gICAgICAgICAgICBvcHRfID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBlbnRyaWVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYiA9IGVudHJpZXM7XG4gICAgICAgICAgICBlbnRyaWVzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZW50cmllcykge1xuICAgICAgICAgICAgZW50cmllcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZW50cmllcyA9IEFycmF5LmZyb20oZW50cmllcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0ID0gZGVhbGlhcyhvcHRfKTtcbiAgICAgICAgdmFsaWRhdGU/LihvcHQsIGVudHJpZXMpO1xuICAgICAgICBpZiAoaXNTeW5jRmlsZShvcHQpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2FsbGJhY2sgbm90IHN1cHBvcnRlZCBmb3Igc3luYyB0YXIgZnVuY3Rpb25zJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3luY0ZpbGUob3B0LCBlbnRyaWVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0FzeW5jRmlsZShvcHQpKSB7XG4gICAgICAgICAgICBjb25zdCBwID0gYXN5bmNGaWxlKG9wdCwgZW50cmllcyk7XG4gICAgICAgICAgICAvLyB3ZWlyZG5lc3MgdG8gbWFrZSBUUyBoYXBweVxuICAgICAgICAgICAgY29uc3QgYyA9IGNiID8gY2IgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICByZXR1cm4gYyA/IHAudGhlbigoKSA9PiBjKCksIGMpIDogcDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1N5bmNOb0ZpbGUob3B0KSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NhbGxiYWNrIG5vdCBzdXBwb3J0ZWQgZm9yIHN5bmMgdGFyIGZ1bmN0aW9ucycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN5bmNOb0ZpbGUob3B0LCBlbnRyaWVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0FzeW5jTm9GaWxlKG9wdCkpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjYWxsYmFjayBvbmx5IHN1cHBvcnRlZCB3aXRoIGZpbGUgb3B0aW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXN5bmNOb0ZpbGUob3B0LCBlbnRyaWVzKTtcbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbXBvc3NpYmxlIG9wdGlvbnM/PycpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgfSwge1xuICAgICAgICBzeW5jRmlsZSxcbiAgICAgICAgYXN5bmNGaWxlLFxuICAgICAgICBzeW5jTm9GaWxlLFxuICAgICAgICBhc3luY05vRmlsZSxcbiAgICAgICAgdmFsaWRhdGUsXG4gICAgfSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFrZS1jb21tYW5kLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/tar/dist/esm/make-command.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/tar/dist/esm/mkdir.js":
/*!********************************************!*\
  !*** ./node_modules/tar/dist/esm/mkdir.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   mkdir: () => (/* binding */ mkdir),\n/* harmony export */   mkdirSync: () => (/* binding */ mkdirSync)\n/* harmony export */ });\n/* harmony import */ var chownr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! chownr */ \"(rsc)/./node_modules/chownr/dist/esm/index.js\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var mkdirp__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! mkdirp */ \"(rsc)/./node_modules/mkdirp/dist/mjs/index.js\");\n/* harmony import */ var node_path__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! node:path */ \"node:path\");\n/* harmony import */ var _cwd_error_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./cwd-error.js */ \"(rsc)/./node_modules/tar/dist/esm/cwd-error.js\");\n/* harmony import */ var _normalize_windows_path_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./normalize-windows-path.js */ \"(rsc)/./node_modules/tar/dist/esm/normalize-windows-path.js\");\n/* harmony import */ var _symlink_error_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./symlink-error.js */ \"(rsc)/./node_modules/tar/dist/esm/symlink-error.js\");\n\n\n\n\n\n\n\nconst cGet = (cache, key) => cache.get((0,_normalize_windows_path_js__WEBPACK_IMPORTED_MODULE_5__.normalizeWindowsPath)(key));\nconst cSet = (cache, key, val) => cache.set((0,_normalize_windows_path_js__WEBPACK_IMPORTED_MODULE_5__.normalizeWindowsPath)(key), val);\nconst checkCwd = (dir, cb) => {\n    fs__WEBPACK_IMPORTED_MODULE_1__.stat(dir, (er, st) => {\n        if (er || !st.isDirectory()) {\n            er = new _cwd_error_js__WEBPACK_IMPORTED_MODULE_4__.CwdError(dir, er?.code || 'ENOTDIR');\n        }\n        cb(er);\n    });\n};\n/**\n * Wrapper around mkdirp for tar's needs.\n *\n * The main purpose is to avoid creating directories if we know that\n * they already exist (and track which ones exist for this purpose),\n * and prevent entries from being extracted into symlinked folders,\n * if `preservePaths` is not set.\n */\nconst mkdir = (dir, opt, cb) => {\n    dir = (0,_normalize_windows_path_js__WEBPACK_IMPORTED_MODULE_5__.normalizeWindowsPath)(dir);\n    // if there's any overlap between mask and mode,\n    // then we'll need an explicit chmod\n    /* c8 ignore next */\n    const umask = opt.umask ?? 0o22;\n    const mode = opt.mode | 0o0700;\n    const needChmod = (mode & umask) !== 0;\n    const uid = opt.uid;\n    const gid = opt.gid;\n    const doChown = typeof uid === 'number' &&\n        typeof gid === 'number' &&\n        (uid !== opt.processUid || gid !== opt.processGid);\n    const preserve = opt.preserve;\n    const unlink = opt.unlink;\n    const cache = opt.cache;\n    const cwd = (0,_normalize_windows_path_js__WEBPACK_IMPORTED_MODULE_5__.normalizeWindowsPath)(opt.cwd);\n    const done = (er, created) => {\n        if (er) {\n            cb(er);\n        }\n        else {\n            cSet(cache, dir, true);\n            if (created && doChown) {\n                (0,chownr__WEBPACK_IMPORTED_MODULE_0__.chownr)(created, uid, gid, er => done(er));\n            }\n            else if (needChmod) {\n                fs__WEBPACK_IMPORTED_MODULE_1__.chmod(dir, mode, cb);\n            }\n            else {\n                cb();\n            }\n        }\n    };\n    if (cache && cGet(cache, dir) === true) {\n        return done();\n    }\n    if (dir === cwd) {\n        return checkCwd(dir, done);\n    }\n    if (preserve) {\n        return (0,mkdirp__WEBPACK_IMPORTED_MODULE_2__.mkdirp)(dir, { mode }).then(made => done(null, made ?? undefined), // oh, ts\n        done);\n    }\n    const sub = (0,_normalize_windows_path_js__WEBPACK_IMPORTED_MODULE_5__.normalizeWindowsPath)(node_path__WEBPACK_IMPORTED_MODULE_3__.relative(cwd, dir));\n    const parts = sub.split('/');\n    mkdir_(cwd, parts, mode, cache, unlink, cwd, undefined, done);\n};\nconst mkdir_ = (base, parts, mode, cache, unlink, cwd, created, cb) => {\n    if (!parts.length) {\n        return cb(null, created);\n    }\n    const p = parts.shift();\n    const part = (0,_normalize_windows_path_js__WEBPACK_IMPORTED_MODULE_5__.normalizeWindowsPath)(node_path__WEBPACK_IMPORTED_MODULE_3__.resolve(base + '/' + p));\n    if (cGet(cache, part)) {\n        return mkdir_(part, parts, mode, cache, unlink, cwd, created, cb);\n    }\n    fs__WEBPACK_IMPORTED_MODULE_1__.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb));\n};\nconst onmkdir = (part, parts, mode, cache, unlink, cwd, created, cb) => (er) => {\n    if (er) {\n        fs__WEBPACK_IMPORTED_MODULE_1__.lstat(part, (statEr, st) => {\n            if (statEr) {\n                statEr.path =\n                    statEr.path && (0,_normalize_windows_path_js__WEBPACK_IMPORTED_MODULE_5__.normalizeWindowsPath)(statEr.path);\n                cb(statEr);\n            }\n            else if (st.isDirectory()) {\n                mkdir_(part, parts, mode, cache, unlink, cwd, created, cb);\n            }\n            else if (unlink) {\n                fs__WEBPACK_IMPORTED_MODULE_1__.unlink(part, er => {\n                    if (er) {\n                        return cb(er);\n                    }\n                    fs__WEBPACK_IMPORTED_MODULE_1__.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb));\n                });\n            }\n            else if (st.isSymbolicLink()) {\n                return cb(new _symlink_error_js__WEBPACK_IMPORTED_MODULE_6__.SymlinkError(part, part + '/' + parts.join('/')));\n            }\n            else {\n                cb(er);\n            }\n        });\n    }\n    else {\n        created = created || part;\n        mkdir_(part, parts, mode, cache, unlink, cwd, created, cb);\n    }\n};\nconst checkCwdSync = (dir) => {\n    let ok = false;\n    let code = undefined;\n    try {\n        ok = fs__WEBPACK_IMPORTED_MODULE_1__.statSync(dir).isDirectory();\n    }\n    catch (er) {\n        code = er?.code;\n    }\n    finally {\n        if (!ok) {\n            throw new _cwd_error_js__WEBPACK_IMPORTED_MODULE_4__.CwdError(dir, code ?? 'ENOTDIR');\n        }\n    }\n};\nconst mkdirSync = (dir, opt) => {\n    dir = (0,_normalize_windows_path_js__WEBPACK_IMPORTED_MODULE_5__.normalizeWindowsPath)(dir);\n    // if there's any overlap between mask and mode,\n    // then we'll need an explicit chmod\n    /* c8 ignore next */\n    const umask = opt.umask ?? 0o22;\n    const mode = opt.mode | 0o700;\n    const needChmod = (mode & umask) !== 0;\n    const uid = opt.uid;\n    const gid = opt.gid;\n    const doChown = typeof uid === 'number' &&\n        typeof gid === 'number' &&\n        (uid !== opt.processUid || gid !== opt.processGid);\n    const preserve = opt.preserve;\n    const unlink = opt.unlink;\n    const cache = opt.cache;\n    const cwd = (0,_normalize_windows_path_js__WEBPACK_IMPORTED_MODULE_5__.normalizeWindowsPath)(opt.cwd);\n    const done = (created) => {\n        cSet(cache, dir, true);\n        if (created && doChown) {\n            (0,chownr__WEBPACK_IMPORTED_MODULE_0__.chownrSync)(created, uid, gid);\n        }\n        if (needChmod) {\n            fs__WEBPACK_IMPORTED_MODULE_1__.chmodSync(dir, mode);\n        }\n    };\n    if (cache && cGet(cache, dir) === true) {\n        return done();\n    }\n    if (dir === cwd) {\n        checkCwdSync(cwd);\n        return done();\n    }\n    if (preserve) {\n        return done((0,mkdirp__WEBPACK_IMPORTED_MODULE_2__.mkdirpSync)(dir, mode) ?? undefined);\n    }\n    const sub = (0,_normalize_windows_path_js__WEBPACK_IMPORTED_MODULE_5__.normalizeWindowsPath)(node_path__WEBPACK_IMPORTED_MODULE_3__.relative(cwd, dir));\n    const parts = sub.split('/');\n    let created = undefined;\n    for (let p = parts.shift(), part = cwd; p && (part += '/' + p); p = parts.shift()) {\n        part = (0,_normalize_windows_path_js__WEBPACK_IMPORTED_MODULE_5__.normalizeWindowsPath)(node_path__WEBPACK_IMPORTED_MODULE_3__.resolve(part));\n        if (cGet(cache, part)) {\n            continue;\n        }\n        try {\n            fs__WEBPACK_IMPORTED_MODULE_1__.mkdirSync(part, mode);\n            created = created || part;\n            cSet(cache, part, true);\n        }\n        catch (er) {\n            const st = fs__WEBPACK_IMPORTED_MODULE_1__.lstatSync(part);\n            if (st.isDirectory()) {\n                cSet(cache, part, true);\n                continue;\n            }\n            else if (unlink) {\n                fs__WEBPACK_IMPORTED_MODULE_1__.unlinkSync(part);\n                fs__WEBPACK_IMPORTED_MODULE_1__.mkdirSync(part, mode);\n                created = created || part;\n                cSet(cache, part, true);\n                continue;\n            }\n            else if (st.isSymbolicLink()) {\n                return new _symlink_error_js__WEBPACK_IMPORTED_MODULE_6__.SymlinkError(part, part + '/' + parts.join('/'));\n            }\n        }\n    }\n    return done(created);\n};\n//# sourceMappingURL=mkdir.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvZXNtL21rZGlyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUE0QztBQUN4QjtBQUN3QjtBQUNmO0FBQ2E7QUFDeUI7QUFDakI7QUFDbEQsdUNBQXVDLGdGQUFvQjtBQUMzRCw0Q0FBNEMsZ0ZBQW9CO0FBQ2hFO0FBQ0EsSUFBSSxvQ0FBTztBQUNYO0FBQ0EscUJBQXFCLG1EQUFRO0FBQzdCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxVQUFVLGdGQUFvQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdGQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw4Q0FBTTtBQUN0QjtBQUNBO0FBQ0EsZ0JBQWdCLHFDQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw4Q0FBTSxRQUFRLE1BQU07QUFDbkM7QUFDQTtBQUNBLGdCQUFnQixnRkFBb0IsQ0FBQywrQ0FBYTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGdGQUFvQixDQUFDLDhDQUFZO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLElBQUkscUNBQVE7QUFDWjtBQUNBO0FBQ0E7QUFDQSxRQUFRLHFDQUFRO0FBQ2hCO0FBQ0E7QUFDQSxtQ0FBbUMsZ0ZBQW9CO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzQ0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUNBQVE7QUFDNUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSw4QkFBOEIsMkRBQVk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHdDQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtREFBUTtBQUM5QjtBQUNBO0FBQ0E7QUFDTztBQUNQLFVBQVUsZ0ZBQW9CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0ZBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0RBQVU7QUFDdEI7QUFDQTtBQUNBLFlBQVkseUNBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0RBQVU7QUFDOUI7QUFDQSxnQkFBZ0IsZ0ZBQW9CLENBQUMsK0NBQWE7QUFDbEQ7QUFDQTtBQUNBLDRDQUE0Qyx3QkFBd0I7QUFDcEUsZUFBZSxnRkFBb0IsQ0FBQyw4Q0FBWTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseUNBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIseUNBQVk7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwwQ0FBYTtBQUM3QixnQkFBZ0IseUNBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwyREFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aXZlLXZpYmUtYWktbmV4dC8uL25vZGVfbW9kdWxlcy90YXIvZGlzdC9lc20vbWtkaXIuanM/ZGNlMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjaG93bnIsIGNob3duclN5bmMgfSBmcm9tICdjaG93bnInO1xuaW1wb3J0IGZzIGZyb20gJ2ZzJztcbmltcG9ydCB7IG1rZGlycCwgbWtkaXJwU3luYyB9IGZyb20gJ21rZGlycCc7XG5pbXBvcnQgcGF0aCBmcm9tICdub2RlOnBhdGgnO1xuaW1wb3J0IHsgQ3dkRXJyb3IgfSBmcm9tICcuL2N3ZC1lcnJvci5qcyc7XG5pbXBvcnQgeyBub3JtYWxpemVXaW5kb3dzUGF0aCB9IGZyb20gJy4vbm9ybWFsaXplLXdpbmRvd3MtcGF0aC5qcyc7XG5pbXBvcnQgeyBTeW1saW5rRXJyb3IgfSBmcm9tICcuL3N5bWxpbmstZXJyb3IuanMnO1xuY29uc3QgY0dldCA9IChjYWNoZSwga2V5KSA9PiBjYWNoZS5nZXQobm9ybWFsaXplV2luZG93c1BhdGgoa2V5KSk7XG5jb25zdCBjU2V0ID0gKGNhY2hlLCBrZXksIHZhbCkgPT4gY2FjaGUuc2V0KG5vcm1hbGl6ZVdpbmRvd3NQYXRoKGtleSksIHZhbCk7XG5jb25zdCBjaGVja0N3ZCA9IChkaXIsIGNiKSA9PiB7XG4gICAgZnMuc3RhdChkaXIsIChlciwgc3QpID0+IHtcbiAgICAgICAgaWYgKGVyIHx8ICFzdC5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgICAgICBlciA9IG5ldyBDd2RFcnJvcihkaXIsIGVyPy5jb2RlIHx8ICdFTk9URElSJyk7XG4gICAgICAgIH1cbiAgICAgICAgY2IoZXIpO1xuICAgIH0pO1xufTtcbi8qKlxuICogV3JhcHBlciBhcm91bmQgbWtkaXJwIGZvciB0YXIncyBuZWVkcy5cbiAqXG4gKiBUaGUgbWFpbiBwdXJwb3NlIGlzIHRvIGF2b2lkIGNyZWF0aW5nIGRpcmVjdG9yaWVzIGlmIHdlIGtub3cgdGhhdFxuICogdGhleSBhbHJlYWR5IGV4aXN0IChhbmQgdHJhY2sgd2hpY2ggb25lcyBleGlzdCBmb3IgdGhpcyBwdXJwb3NlKSxcbiAqIGFuZCBwcmV2ZW50IGVudHJpZXMgZnJvbSBiZWluZyBleHRyYWN0ZWQgaW50byBzeW1saW5rZWQgZm9sZGVycyxcbiAqIGlmIGBwcmVzZXJ2ZVBhdGhzYCBpcyBub3Qgc2V0LlxuICovXG5leHBvcnQgY29uc3QgbWtkaXIgPSAoZGlyLCBvcHQsIGNiKSA9PiB7XG4gICAgZGlyID0gbm9ybWFsaXplV2luZG93c1BhdGgoZGlyKTtcbiAgICAvLyBpZiB0aGVyZSdzIGFueSBvdmVybGFwIGJldHdlZW4gbWFzayBhbmQgbW9kZSxcbiAgICAvLyB0aGVuIHdlJ2xsIG5lZWQgYW4gZXhwbGljaXQgY2htb2RcbiAgICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICAgIGNvbnN0IHVtYXNrID0gb3B0LnVtYXNrID8/IDBvMjI7XG4gICAgY29uc3QgbW9kZSA9IG9wdC5tb2RlIHwgMG8wNzAwO1xuICAgIGNvbnN0IG5lZWRDaG1vZCA9IChtb2RlICYgdW1hc2spICE9PSAwO1xuICAgIGNvbnN0IHVpZCA9IG9wdC51aWQ7XG4gICAgY29uc3QgZ2lkID0gb3B0LmdpZDtcbiAgICBjb25zdCBkb0Nob3duID0gdHlwZW9mIHVpZCA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgdHlwZW9mIGdpZCA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgKHVpZCAhPT0gb3B0LnByb2Nlc3NVaWQgfHwgZ2lkICE9PSBvcHQucHJvY2Vzc0dpZCk7XG4gICAgY29uc3QgcHJlc2VydmUgPSBvcHQucHJlc2VydmU7XG4gICAgY29uc3QgdW5saW5rID0gb3B0LnVubGluaztcbiAgICBjb25zdCBjYWNoZSA9IG9wdC5jYWNoZTtcbiAgICBjb25zdCBjd2QgPSBub3JtYWxpemVXaW5kb3dzUGF0aChvcHQuY3dkKTtcbiAgICBjb25zdCBkb25lID0gKGVyLCBjcmVhdGVkKSA9PiB7XG4gICAgICAgIGlmIChlcikge1xuICAgICAgICAgICAgY2IoZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY1NldChjYWNoZSwgZGlyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChjcmVhdGVkICYmIGRvQ2hvd24pIHtcbiAgICAgICAgICAgICAgICBjaG93bnIoY3JlYXRlZCwgdWlkLCBnaWQsIGVyID0+IGRvbmUoZXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5lZWRDaG1vZCkge1xuICAgICAgICAgICAgICAgIGZzLmNobW9kKGRpciwgbW9kZSwgY2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgaWYgKGNhY2hlICYmIGNHZXQoY2FjaGUsIGRpcikgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIGRvbmUoKTtcbiAgICB9XG4gICAgaWYgKGRpciA9PT0gY3dkKSB7XG4gICAgICAgIHJldHVybiBjaGVja0N3ZChkaXIsIGRvbmUpO1xuICAgIH1cbiAgICBpZiAocHJlc2VydmUpIHtcbiAgICAgICAgcmV0dXJuIG1rZGlycChkaXIsIHsgbW9kZSB9KS50aGVuKG1hZGUgPT4gZG9uZShudWxsLCBtYWRlID8/IHVuZGVmaW5lZCksIC8vIG9oLCB0c1xuICAgICAgICBkb25lKTtcbiAgICB9XG4gICAgY29uc3Qgc3ViID0gbm9ybWFsaXplV2luZG93c1BhdGgocGF0aC5yZWxhdGl2ZShjd2QsIGRpcikpO1xuICAgIGNvbnN0IHBhcnRzID0gc3ViLnNwbGl0KCcvJyk7XG4gICAgbWtkaXJfKGN3ZCwgcGFydHMsIG1vZGUsIGNhY2hlLCB1bmxpbmssIGN3ZCwgdW5kZWZpbmVkLCBkb25lKTtcbn07XG5jb25zdCBta2Rpcl8gPSAoYmFzZSwgcGFydHMsIG1vZGUsIGNhY2hlLCB1bmxpbmssIGN3ZCwgY3JlYXRlZCwgY2IpID0+IHtcbiAgICBpZiAoIXBhcnRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gY2IobnVsbCwgY3JlYXRlZCk7XG4gICAgfVxuICAgIGNvbnN0IHAgPSBwYXJ0cy5zaGlmdCgpO1xuICAgIGNvbnN0IHBhcnQgPSBub3JtYWxpemVXaW5kb3dzUGF0aChwYXRoLnJlc29sdmUoYmFzZSArICcvJyArIHApKTtcbiAgICBpZiAoY0dldChjYWNoZSwgcGFydCkpIHtcbiAgICAgICAgcmV0dXJuIG1rZGlyXyhwYXJ0LCBwYXJ0cywgbW9kZSwgY2FjaGUsIHVubGluaywgY3dkLCBjcmVhdGVkLCBjYik7XG4gICAgfVxuICAgIGZzLm1rZGlyKHBhcnQsIG1vZGUsIG9ubWtkaXIocGFydCwgcGFydHMsIG1vZGUsIGNhY2hlLCB1bmxpbmssIGN3ZCwgY3JlYXRlZCwgY2IpKTtcbn07XG5jb25zdCBvbm1rZGlyID0gKHBhcnQsIHBhcnRzLCBtb2RlLCBjYWNoZSwgdW5saW5rLCBjd2QsIGNyZWF0ZWQsIGNiKSA9PiAoZXIpID0+IHtcbiAgICBpZiAoZXIpIHtcbiAgICAgICAgZnMubHN0YXQocGFydCwgKHN0YXRFciwgc3QpID0+IHtcbiAgICAgICAgICAgIGlmIChzdGF0RXIpIHtcbiAgICAgICAgICAgICAgICBzdGF0RXIucGF0aCA9XG4gICAgICAgICAgICAgICAgICAgIHN0YXRFci5wYXRoICYmIG5vcm1hbGl6ZVdpbmRvd3NQYXRoKHN0YXRFci5wYXRoKTtcbiAgICAgICAgICAgICAgICBjYihzdGF0RXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3QuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICAgICAgICAgIG1rZGlyXyhwYXJ0LCBwYXJ0cywgbW9kZSwgY2FjaGUsIHVubGluaywgY3dkLCBjcmVhdGVkLCBjYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh1bmxpbmspIHtcbiAgICAgICAgICAgICAgICBmcy51bmxpbmsocGFydCwgZXIgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYihlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZnMubWtkaXIocGFydCwgbW9kZSwgb25ta2RpcihwYXJ0LCBwYXJ0cywgbW9kZSwgY2FjaGUsIHVubGluaywgY3dkLCBjcmVhdGVkLCBjYikpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3QuaXNTeW1ib2xpY0xpbmsoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYihuZXcgU3ltbGlua0Vycm9yKHBhcnQsIHBhcnQgKyAnLycgKyBwYXJ0cy5qb2luKCcvJykpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNiKGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjcmVhdGVkID0gY3JlYXRlZCB8fCBwYXJ0O1xuICAgICAgICBta2Rpcl8ocGFydCwgcGFydHMsIG1vZGUsIGNhY2hlLCB1bmxpbmssIGN3ZCwgY3JlYXRlZCwgY2IpO1xuICAgIH1cbn07XG5jb25zdCBjaGVja0N3ZFN5bmMgPSAoZGlyKSA9PiB7XG4gICAgbGV0IG9rID0gZmFsc2U7XG4gICAgbGV0IGNvZGUgPSB1bmRlZmluZWQ7XG4gICAgdHJ5IHtcbiAgICAgICAgb2sgPSBmcy5zdGF0U3luYyhkaXIpLmlzRGlyZWN0b3J5KCk7XG4gICAgfVxuICAgIGNhdGNoIChlcikge1xuICAgICAgICBjb2RlID0gZXI/LmNvZGU7XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICBpZiAoIW9rKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQ3dkRXJyb3IoZGlyLCBjb2RlID8/ICdFTk9URElSJyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IG1rZGlyU3luYyA9IChkaXIsIG9wdCkgPT4ge1xuICAgIGRpciA9IG5vcm1hbGl6ZVdpbmRvd3NQYXRoKGRpcik7XG4gICAgLy8gaWYgdGhlcmUncyBhbnkgb3ZlcmxhcCBiZXR3ZWVuIG1hc2sgYW5kIG1vZGUsXG4gICAgLy8gdGhlbiB3ZSdsbCBuZWVkIGFuIGV4cGxpY2l0IGNobW9kXG4gICAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgICBjb25zdCB1bWFzayA9IG9wdC51bWFzayA/PyAwbzIyO1xuICAgIGNvbnN0IG1vZGUgPSBvcHQubW9kZSB8IDBvNzAwO1xuICAgIGNvbnN0IG5lZWRDaG1vZCA9IChtb2RlICYgdW1hc2spICE9PSAwO1xuICAgIGNvbnN0IHVpZCA9IG9wdC51aWQ7XG4gICAgY29uc3QgZ2lkID0gb3B0LmdpZDtcbiAgICBjb25zdCBkb0Nob3duID0gdHlwZW9mIHVpZCA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgdHlwZW9mIGdpZCA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgKHVpZCAhPT0gb3B0LnByb2Nlc3NVaWQgfHwgZ2lkICE9PSBvcHQucHJvY2Vzc0dpZCk7XG4gICAgY29uc3QgcHJlc2VydmUgPSBvcHQucHJlc2VydmU7XG4gICAgY29uc3QgdW5saW5rID0gb3B0LnVubGluaztcbiAgICBjb25zdCBjYWNoZSA9IG9wdC5jYWNoZTtcbiAgICBjb25zdCBjd2QgPSBub3JtYWxpemVXaW5kb3dzUGF0aChvcHQuY3dkKTtcbiAgICBjb25zdCBkb25lID0gKGNyZWF0ZWQpID0+IHtcbiAgICAgICAgY1NldChjYWNoZSwgZGlyLCB0cnVlKTtcbiAgICAgICAgaWYgKGNyZWF0ZWQgJiYgZG9DaG93bikge1xuICAgICAgICAgICAgY2hvd25yU3luYyhjcmVhdGVkLCB1aWQsIGdpZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5lZWRDaG1vZCkge1xuICAgICAgICAgICAgZnMuY2htb2RTeW5jKGRpciwgbW9kZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGlmIChjYWNoZSAmJiBjR2V0KGNhY2hlLCBkaXIpID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBkb25lKCk7XG4gICAgfVxuICAgIGlmIChkaXIgPT09IGN3ZCkge1xuICAgICAgICBjaGVja0N3ZFN5bmMoY3dkKTtcbiAgICAgICAgcmV0dXJuIGRvbmUoKTtcbiAgICB9XG4gICAgaWYgKHByZXNlcnZlKSB7XG4gICAgICAgIHJldHVybiBkb25lKG1rZGlycFN5bmMoZGlyLCBtb2RlKSA/PyB1bmRlZmluZWQpO1xuICAgIH1cbiAgICBjb25zdCBzdWIgPSBub3JtYWxpemVXaW5kb3dzUGF0aChwYXRoLnJlbGF0aXZlKGN3ZCwgZGlyKSk7XG4gICAgY29uc3QgcGFydHMgPSBzdWIuc3BsaXQoJy8nKTtcbiAgICBsZXQgY3JlYXRlZCA9IHVuZGVmaW5lZDtcbiAgICBmb3IgKGxldCBwID0gcGFydHMuc2hpZnQoKSwgcGFydCA9IGN3ZDsgcCAmJiAocGFydCArPSAnLycgKyBwKTsgcCA9IHBhcnRzLnNoaWZ0KCkpIHtcbiAgICAgICAgcGFydCA9IG5vcm1hbGl6ZVdpbmRvd3NQYXRoKHBhdGgucmVzb2x2ZShwYXJ0KSk7XG4gICAgICAgIGlmIChjR2V0KGNhY2hlLCBwYXJ0KSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZzLm1rZGlyU3luYyhwYXJ0LCBtb2RlKTtcbiAgICAgICAgICAgIGNyZWF0ZWQgPSBjcmVhdGVkIHx8IHBhcnQ7XG4gICAgICAgICAgICBjU2V0KGNhY2hlLCBwYXJ0LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0ID0gZnMubHN0YXRTeW5jKHBhcnQpO1xuICAgICAgICAgICAgaWYgKHN0LmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgICAgICAgICBjU2V0KGNhY2hlLCBwYXJ0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHVubGluaykge1xuICAgICAgICAgICAgICAgIGZzLnVubGlua1N5bmMocGFydCk7XG4gICAgICAgICAgICAgICAgZnMubWtkaXJTeW5jKHBhcnQsIG1vZGUpO1xuICAgICAgICAgICAgICAgIGNyZWF0ZWQgPSBjcmVhdGVkIHx8IHBhcnQ7XG4gICAgICAgICAgICAgICAgY1NldChjYWNoZSwgcGFydCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdC5pc1N5bWJvbGljTGluaygpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTeW1saW5rRXJyb3IocGFydCwgcGFydCArICcvJyArIHBhcnRzLmpvaW4oJy8nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRvbmUoY3JlYXRlZCk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWtkaXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/tar/dist/esm/mkdir.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/tar/dist/esm/mode-fix.js":
/*!***********************************************!*\
  !*** ./node_modules/tar/dist/esm/mode-fix.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   modeFix: () => (/* binding */ modeFix)\n/* harmony export */ });\nconst modeFix = (mode, isDir, portable) => {\n    mode &= 0o7777;\n    // in portable mode, use the minimum reasonable umask\n    // if this system creates files with 0o664 by default\n    // (as some linux distros do), then we'll write the\n    // archive with 0o644 instead.  Also, don't ever create\n    // a file that is not readable/writable by the owner.\n    if (portable) {\n        mode = (mode | 0o600) & ~0o22;\n    }\n    // if dirs are readable, then they should be listable\n    if (isDir) {\n        if (mode & 0o400) {\n            mode |= 0o100;\n        }\n        if (mode & 0o40) {\n            mode |= 0o10;\n        }\n        if (mode & 0o4) {\n            mode |= 0o1;\n        }\n    }\n    return mode;\n};\n//# sourceMappingURL=mode-fix.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvZXNtL21vZGUtZml4LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpdmUtdmliZS1haS1uZXh0Ly4vbm9kZV9tb2R1bGVzL3Rhci9kaXN0L2VzbS9tb2RlLWZpeC5qcz9lZjFkIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBtb2RlRml4ID0gKG1vZGUsIGlzRGlyLCBwb3J0YWJsZSkgPT4ge1xuICAgIG1vZGUgJj0gMG83Nzc3O1xuICAgIC8vIGluIHBvcnRhYmxlIG1vZGUsIHVzZSB0aGUgbWluaW11bSByZWFzb25hYmxlIHVtYXNrXG4gICAgLy8gaWYgdGhpcyBzeXN0ZW0gY3JlYXRlcyBmaWxlcyB3aXRoIDBvNjY0IGJ5IGRlZmF1bHRcbiAgICAvLyAoYXMgc29tZSBsaW51eCBkaXN0cm9zIGRvKSwgdGhlbiB3ZSdsbCB3cml0ZSB0aGVcbiAgICAvLyBhcmNoaXZlIHdpdGggMG82NDQgaW5zdGVhZC4gIEFsc28sIGRvbid0IGV2ZXIgY3JlYXRlXG4gICAgLy8gYSBmaWxlIHRoYXQgaXMgbm90IHJlYWRhYmxlL3dyaXRhYmxlIGJ5IHRoZSBvd25lci5cbiAgICBpZiAocG9ydGFibGUpIHtcbiAgICAgICAgbW9kZSA9IChtb2RlIHwgMG82MDApICYgfjBvMjI7XG4gICAgfVxuICAgIC8vIGlmIGRpcnMgYXJlIHJlYWRhYmxlLCB0aGVuIHRoZXkgc2hvdWxkIGJlIGxpc3RhYmxlXG4gICAgaWYgKGlzRGlyKSB7XG4gICAgICAgIGlmIChtb2RlICYgMG80MDApIHtcbiAgICAgICAgICAgIG1vZGUgfD0gMG8xMDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vZGUgJiAwbzQwKSB7XG4gICAgICAgICAgICBtb2RlIHw9IDBvMTA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vZGUgJiAwbzQpIHtcbiAgICAgICAgICAgIG1vZGUgfD0gMG8xO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtb2RlO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZGUtZml4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/tar/dist/esm/mode-fix.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/tar/dist/esm/normalize-unicode.js":
/*!********************************************************!*\
  !*** ./node_modules/tar/dist/esm/normalize-unicode.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   normalizeUnicode: () => (/* binding */ normalizeUnicode)\n/* harmony export */ });\n// warning: extremely hot code path.\n// This has been meticulously optimized for use\n// within npm install on large package trees.\n// Do not edit without careful benchmarking.\nconst normalizeCache = Object.create(null);\nconst { hasOwnProperty } = Object.prototype;\nconst normalizeUnicode = (s) => {\n    if (!hasOwnProperty.call(normalizeCache, s)) {\n        normalizeCache[s] = s.normalize('NFD');\n    }\n    return normalizeCache[s];\n};\n//# sourceMappingURL=normalize-unicode.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvZXNtL25vcm1hbGl6ZS11bmljb2RlLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpQkFBaUI7QUFDbEI7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aXZlLXZpYmUtYWktbmV4dC8uL25vZGVfbW9kdWxlcy90YXIvZGlzdC9lc20vbm9ybWFsaXplLXVuaWNvZGUuanM/ZjFhNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB3YXJuaW5nOiBleHRyZW1lbHkgaG90IGNvZGUgcGF0aC5cbi8vIFRoaXMgaGFzIGJlZW4gbWV0aWN1bG91c2x5IG9wdGltaXplZCBmb3IgdXNlXG4vLyB3aXRoaW4gbnBtIGluc3RhbGwgb24gbGFyZ2UgcGFja2FnZSB0cmVlcy5cbi8vIERvIG5vdCBlZGl0IHdpdGhvdXQgY2FyZWZ1bCBiZW5jaG1hcmtpbmcuXG5jb25zdCBub3JtYWxpemVDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5jb25zdCB7IGhhc093blByb3BlcnR5IH0gPSBPYmplY3QucHJvdG90eXBlO1xuZXhwb3J0IGNvbnN0IG5vcm1hbGl6ZVVuaWNvZGUgPSAocykgPT4ge1xuICAgIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChub3JtYWxpemVDYWNoZSwgcykpIHtcbiAgICAgICAgbm9ybWFsaXplQ2FjaGVbc10gPSBzLm5vcm1hbGl6ZSgnTkZEJyk7XG4gICAgfVxuICAgIHJldHVybiBub3JtYWxpemVDYWNoZVtzXTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub3JtYWxpemUtdW5pY29kZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/tar/dist/esm/normalize-unicode.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/tar/dist/esm/normalize-windows-path.js":
/*!*************************************************************!*\
  !*** ./node_modules/tar/dist/esm/normalize-windows-path.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   normalizeWindowsPath: () => (/* binding */ normalizeWindowsPath)\n/* harmony export */ });\n// on windows, either \\ or / are valid directory separators.\n// on unix, \\ is a valid character in filenames.\n// so, on windows, and only on windows, we replace all \\ chars with /,\n// so that we can use / as our one and only directory separator char.\nconst platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;\nconst normalizeWindowsPath = platform !== 'win32' ?\n    (p) => p\n    : (p) => p && p.replace(/\\\\/g, '/');\n//# sourceMappingURL=normalize-windows-path.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvZXNtL25vcm1hbGl6ZS13aW5kb3dzLXBhdGguanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpdmUtdmliZS1haS1uZXh0Ly4vbm9kZV9tb2R1bGVzL3Rhci9kaXN0L2VzbS9ub3JtYWxpemUtd2luZG93cy1wYXRoLmpzPzA3OWMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gb24gd2luZG93cywgZWl0aGVyIFxcIG9yIC8gYXJlIHZhbGlkIGRpcmVjdG9yeSBzZXBhcmF0b3JzLlxuLy8gb24gdW5peCwgXFwgaXMgYSB2YWxpZCBjaGFyYWN0ZXIgaW4gZmlsZW5hbWVzLlxuLy8gc28sIG9uIHdpbmRvd3MsIGFuZCBvbmx5IG9uIHdpbmRvd3MsIHdlIHJlcGxhY2UgYWxsIFxcIGNoYXJzIHdpdGggLyxcbi8vIHNvIHRoYXQgd2UgY2FuIHVzZSAvIGFzIG91ciBvbmUgYW5kIG9ubHkgZGlyZWN0b3J5IHNlcGFyYXRvciBjaGFyLlxuY29uc3QgcGxhdGZvcm0gPSBwcm9jZXNzLmVudi5URVNUSU5HX1RBUl9GQUtFX1BMQVRGT1JNIHx8IHByb2Nlc3MucGxhdGZvcm07XG5leHBvcnQgY29uc3Qgbm9ybWFsaXplV2luZG93c1BhdGggPSBwbGF0Zm9ybSAhPT0gJ3dpbjMyJyA/XG4gICAgKHApID0+IHBcbiAgICA6IChwKSA9PiBwICYmIHAucmVwbGFjZSgvXFxcXC9nLCAnLycpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bm9ybWFsaXplLXdpbmRvd3MtcGF0aC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/tar/dist/esm/normalize-windows-path.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/tar/dist/esm/options.js":
/*!**********************************************!*\
  !*** ./node_modules/tar/dist/esm/options.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dealias: () => (/* binding */ dealias),\n/* harmony export */   isAsync: () => (/* binding */ isAsync),\n/* harmony export */   isAsyncFile: () => (/* binding */ isAsyncFile),\n/* harmony export */   isAsyncNoFile: () => (/* binding */ isAsyncNoFile),\n/* harmony export */   isFile: () => (/* binding */ isFile),\n/* harmony export */   isNoFile: () => (/* binding */ isNoFile),\n/* harmony export */   isSync: () => (/* binding */ isSync),\n/* harmony export */   isSyncFile: () => (/* binding */ isSyncFile),\n/* harmony export */   isSyncNoFile: () => (/* binding */ isSyncNoFile)\n/* harmony export */ });\n// turn tar(1) style args like `C` into the more verbose things like `cwd`\nconst argmap = new Map([\n    ['C', 'cwd'],\n    ['f', 'file'],\n    ['z', 'gzip'],\n    ['P', 'preservePaths'],\n    ['U', 'unlink'],\n    ['strip-components', 'strip'],\n    ['stripComponents', 'strip'],\n    ['keep-newer', 'newer'],\n    ['keepNewer', 'newer'],\n    ['keep-newer-files', 'newer'],\n    ['keepNewerFiles', 'newer'],\n    ['k', 'keep'],\n    ['keep-existing', 'keep'],\n    ['keepExisting', 'keep'],\n    ['m', 'noMtime'],\n    ['no-mtime', 'noMtime'],\n    ['p', 'preserveOwner'],\n    ['L', 'follow'],\n    ['h', 'follow'],\n    ['onentry', 'onReadEntry'],\n]);\nconst isSyncFile = (o) => !!o.sync && !!o.file;\nconst isAsyncFile = (o) => !o.sync && !!o.file;\nconst isSyncNoFile = (o) => !!o.sync && !o.file;\nconst isAsyncNoFile = (o) => !o.sync && !o.file;\nconst isSync = (o) => !!o.sync;\nconst isAsync = (o) => !o.sync;\nconst isFile = (o) => !!o.file;\nconst isNoFile = (o) => !o.file;\nconst dealiasKey = (k) => {\n    const d = argmap.get(k);\n    if (d)\n        return d;\n    return k;\n};\nconst dealias = (opt = {}) => {\n    if (!opt)\n        return {};\n    const result = {};\n    for (const [key, v] of Object.entries(opt)) {\n        // TS doesn't know that aliases are going to always be the same type\n        const k = dealiasKey(key);\n        result[k] = v;\n    }\n    // affordance for deprecated noChmod -> chmod\n    if (result.chmod === undefined && result.noChmod === false) {\n        result.chmod = true;\n    }\n    delete result.noChmod;\n    return result;\n};\n//# sourceMappingURL=options.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvZXNtL29wdGlvbnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyx5QkFBeUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aXZlLXZpYmUtYWktbmV4dC8uL25vZGVfbW9kdWxlcy90YXIvZGlzdC9lc20vb3B0aW9ucy5qcz8wMjU5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHR1cm4gdGFyKDEpIHN0eWxlIGFyZ3MgbGlrZSBgQ2AgaW50byB0aGUgbW9yZSB2ZXJib3NlIHRoaW5ncyBsaWtlIGBjd2RgXG5jb25zdCBhcmdtYXAgPSBuZXcgTWFwKFtcbiAgICBbJ0MnLCAnY3dkJ10sXG4gICAgWydmJywgJ2ZpbGUnXSxcbiAgICBbJ3onLCAnZ3ppcCddLFxuICAgIFsnUCcsICdwcmVzZXJ2ZVBhdGhzJ10sXG4gICAgWydVJywgJ3VubGluayddLFxuICAgIFsnc3RyaXAtY29tcG9uZW50cycsICdzdHJpcCddLFxuICAgIFsnc3RyaXBDb21wb25lbnRzJywgJ3N0cmlwJ10sXG4gICAgWydrZWVwLW5ld2VyJywgJ25ld2VyJ10sXG4gICAgWydrZWVwTmV3ZXInLCAnbmV3ZXInXSxcbiAgICBbJ2tlZXAtbmV3ZXItZmlsZXMnLCAnbmV3ZXInXSxcbiAgICBbJ2tlZXBOZXdlckZpbGVzJywgJ25ld2VyJ10sXG4gICAgWydrJywgJ2tlZXAnXSxcbiAgICBbJ2tlZXAtZXhpc3RpbmcnLCAna2VlcCddLFxuICAgIFsna2VlcEV4aXN0aW5nJywgJ2tlZXAnXSxcbiAgICBbJ20nLCAnbm9NdGltZSddLFxuICAgIFsnbm8tbXRpbWUnLCAnbm9NdGltZSddLFxuICAgIFsncCcsICdwcmVzZXJ2ZU93bmVyJ10sXG4gICAgWydMJywgJ2ZvbGxvdyddLFxuICAgIFsnaCcsICdmb2xsb3cnXSxcbiAgICBbJ29uZW50cnknLCAnb25SZWFkRW50cnknXSxcbl0pO1xuZXhwb3J0IGNvbnN0IGlzU3luY0ZpbGUgPSAobykgPT4gISFvLnN5bmMgJiYgISFvLmZpbGU7XG5leHBvcnQgY29uc3QgaXNBc3luY0ZpbGUgPSAobykgPT4gIW8uc3luYyAmJiAhIW8uZmlsZTtcbmV4cG9ydCBjb25zdCBpc1N5bmNOb0ZpbGUgPSAobykgPT4gISFvLnN5bmMgJiYgIW8uZmlsZTtcbmV4cG9ydCBjb25zdCBpc0FzeW5jTm9GaWxlID0gKG8pID0+ICFvLnN5bmMgJiYgIW8uZmlsZTtcbmV4cG9ydCBjb25zdCBpc1N5bmMgPSAobykgPT4gISFvLnN5bmM7XG5leHBvcnQgY29uc3QgaXNBc3luYyA9IChvKSA9PiAhby5zeW5jO1xuZXhwb3J0IGNvbnN0IGlzRmlsZSA9IChvKSA9PiAhIW8uZmlsZTtcbmV4cG9ydCBjb25zdCBpc05vRmlsZSA9IChvKSA9PiAhby5maWxlO1xuY29uc3QgZGVhbGlhc0tleSA9IChrKSA9PiB7XG4gICAgY29uc3QgZCA9IGFyZ21hcC5nZXQoayk7XG4gICAgaWYgKGQpXG4gICAgICAgIHJldHVybiBkO1xuICAgIHJldHVybiBrO1xufTtcbmV4cG9ydCBjb25zdCBkZWFsaWFzID0gKG9wdCA9IHt9KSA9PiB7XG4gICAgaWYgKCFvcHQpXG4gICAgICAgIHJldHVybiB7fTtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZdIG9mIE9iamVjdC5lbnRyaWVzKG9wdCkpIHtcbiAgICAgICAgLy8gVFMgZG9lc24ndCBrbm93IHRoYXQgYWxpYXNlcyBhcmUgZ29pbmcgdG8gYWx3YXlzIGJlIHRoZSBzYW1lIHR5cGVcbiAgICAgICAgY29uc3QgayA9IGRlYWxpYXNLZXkoa2V5KTtcbiAgICAgICAgcmVzdWx0W2tdID0gdjtcbiAgICB9XG4gICAgLy8gYWZmb3JkYW5jZSBmb3IgZGVwcmVjYXRlZCBub0NobW9kIC0+IGNobW9kXG4gICAgaWYgKHJlc3VsdC5jaG1vZCA9PT0gdW5kZWZpbmVkICYmIHJlc3VsdC5ub0NobW9kID09PSBmYWxzZSkge1xuICAgICAgICByZXN1bHQuY2htb2QgPSB0cnVlO1xuICAgIH1cbiAgICBkZWxldGUgcmVzdWx0Lm5vQ2htb2Q7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vcHRpb25zLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/tar/dist/esm/options.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/tar/dist/esm/pack.js":
/*!*******************************************!*\
  !*** ./node_modules/tar/dist/esm/pack.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Pack: () => (/* binding */ Pack),\n/* harmony export */   PackJob: () => (/* binding */ PackJob),\n/* harmony export */   PackSync: () => (/* binding */ PackSync)\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var _write_entry_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./write-entry.js */ \"(rsc)/./node_modules/tar/dist/esm/write-entry.js\");\n/* harmony import */ var minipass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! minipass */ \"(rsc)/./node_modules/minipass/dist/esm/index.js\");\n/* harmony import */ var minizlib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! minizlib */ \"(rsc)/./node_modules/minizlib/dist/esm/index.js\");\n/* harmony import */ var yallist__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! yallist */ \"(rsc)/./node_modules/yallist/dist/esm/index.js\");\n/* harmony import */ var _read_entry_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./read-entry.js */ \"(rsc)/./node_modules/tar/dist/esm/read-entry.js\");\n/* harmony import */ var _warn_method_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./warn-method.js */ \"(rsc)/./node_modules/tar/dist/esm/warn-method.js\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var _normalize_windows_path_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./normalize-windows-path.js */ \"(rsc)/./node_modules/tar/dist/esm/normalize-windows-path.js\");\n// A readable tar stream creator\n// Technically, this is a transform stream that you write paths into,\n// and tar format comes out of.\n// The `add()` method is like `write()` but returns this,\n// and end() return `this` as well, so you can\n// do `new Pack(opt).add('files').add('dir').end().pipe(output)\n// You could also do something like:\n// streamOfPaths().pipe(new Pack()).pipe(new fs.WriteStream('out.tar'))\n\n\nclass PackJob {\n    path;\n    absolute;\n    entry;\n    stat;\n    readdir;\n    pending = false;\n    ignore = false;\n    piped = false;\n    constructor(path, absolute) {\n        this.path = path || './';\n        this.absolute = absolute;\n    }\n}\n\n\n\n\n\nconst EOF = Buffer.alloc(1024);\nconst ONSTAT = Symbol('onStat');\nconst ENDED = Symbol('ended');\nconst QUEUE = Symbol('queue');\nconst CURRENT = Symbol('current');\nconst PROCESS = Symbol('process');\nconst PROCESSING = Symbol('processing');\nconst PROCESSJOB = Symbol('processJob');\nconst JOBS = Symbol('jobs');\nconst JOBDONE = Symbol('jobDone');\nconst ADDFSENTRY = Symbol('addFSEntry');\nconst ADDTARENTRY = Symbol('addTarEntry');\nconst STAT = Symbol('stat');\nconst READDIR = Symbol('readdir');\nconst ONREADDIR = Symbol('onreaddir');\nconst PIPE = Symbol('pipe');\nconst ENTRY = Symbol('entry');\nconst ENTRYOPT = Symbol('entryOpt');\nconst WRITEENTRYCLASS = Symbol('writeEntryClass');\nconst WRITE = Symbol('write');\nconst ONDRAIN = Symbol('ondrain');\n\n\nclass Pack extends minipass__WEBPACK_IMPORTED_MODULE_2__.Minipass {\n    opt;\n    cwd;\n    maxReadSize;\n    preservePaths;\n    strict;\n    noPax;\n    prefix;\n    linkCache;\n    statCache;\n    file;\n    portable;\n    zip;\n    readdirCache;\n    noDirRecurse;\n    follow;\n    noMtime;\n    mtime;\n    filter;\n    jobs;\n    [WRITEENTRYCLASS];\n    onWriteEntry;\n    [QUEUE];\n    [JOBS] = 0;\n    [PROCESSING] = false;\n    [ENDED] = false;\n    constructor(opt = {}) {\n        //@ts-ignore\n        super();\n        this.opt = opt;\n        this.file = opt.file || '';\n        this.cwd = opt.cwd || process.cwd();\n        this.maxReadSize = opt.maxReadSize;\n        this.preservePaths = !!opt.preservePaths;\n        this.strict = !!opt.strict;\n        this.noPax = !!opt.noPax;\n        this.prefix = (0,_normalize_windows_path_js__WEBPACK_IMPORTED_MODULE_8__.normalizeWindowsPath)(opt.prefix || '');\n        this.linkCache = opt.linkCache || new Map();\n        this.statCache = opt.statCache || new Map();\n        this.readdirCache = opt.readdirCache || new Map();\n        this.onWriteEntry = opt.onWriteEntry;\n        this[WRITEENTRYCLASS] = _write_entry_js__WEBPACK_IMPORTED_MODULE_1__.WriteEntry;\n        if (typeof opt.onwarn === 'function') {\n            this.on('warn', opt.onwarn);\n        }\n        this.portable = !!opt.portable;\n        if (opt.gzip || opt.brotli) {\n            if (opt.gzip && opt.brotli) {\n                throw new TypeError('gzip and brotli are mutually exclusive');\n            }\n            if (opt.gzip) {\n                if (typeof opt.gzip !== 'object') {\n                    opt.gzip = {};\n                }\n                if (this.portable) {\n                    opt.gzip.portable = true;\n                }\n                this.zip = new minizlib__WEBPACK_IMPORTED_MODULE_3__.Gzip(opt.gzip);\n            }\n            if (opt.brotli) {\n                if (typeof opt.brotli !== 'object') {\n                    opt.brotli = {};\n                }\n                this.zip = new minizlib__WEBPACK_IMPORTED_MODULE_3__.BrotliCompress(opt.brotli);\n            }\n            /* c8 ignore next */\n            if (!this.zip)\n                throw new Error('impossible');\n            const zip = this.zip;\n            zip.on('data', chunk => super.write(chunk));\n            zip.on('end', () => super.end());\n            zip.on('drain', () => this[ONDRAIN]());\n            this.on('resume', () => zip.resume());\n        }\n        else {\n            this.on('drain', this[ONDRAIN]);\n        }\n        this.noDirRecurse = !!opt.noDirRecurse;\n        this.follow = !!opt.follow;\n        this.noMtime = !!opt.noMtime;\n        if (opt.mtime)\n            this.mtime = opt.mtime;\n        this.filter =\n            typeof opt.filter === 'function' ? opt.filter : () => true;\n        this[QUEUE] = new yallist__WEBPACK_IMPORTED_MODULE_4__.Yallist();\n        this[JOBS] = 0;\n        this.jobs = Number(opt.jobs) || 4;\n        this[PROCESSING] = false;\n        this[ENDED] = false;\n    }\n    [WRITE](chunk) {\n        return super.write(chunk);\n    }\n    add(path) {\n        this.write(path);\n        return this;\n    }\n    end(path, encoding, cb) {\n        /* c8 ignore start */\n        if (typeof path === 'function') {\n            cb = path;\n            path = undefined;\n        }\n        if (typeof encoding === 'function') {\n            cb = encoding;\n            encoding = undefined;\n        }\n        /* c8 ignore stop */\n        if (path) {\n            this.add(path);\n        }\n        this[ENDED] = true;\n        this[PROCESS]();\n        /* c8 ignore next */\n        if (cb)\n            cb();\n        return this;\n    }\n    write(path) {\n        if (this[ENDED]) {\n            throw new Error('write after end');\n        }\n        if (path instanceof _read_entry_js__WEBPACK_IMPORTED_MODULE_5__.ReadEntry) {\n            this[ADDTARENTRY](path);\n        }\n        else {\n            this[ADDFSENTRY](path);\n        }\n        return this.flowing;\n    }\n    [ADDTARENTRY](p) {\n        const absolute = (0,_normalize_windows_path_js__WEBPACK_IMPORTED_MODULE_8__.normalizeWindowsPath)(path__WEBPACK_IMPORTED_MODULE_7__.resolve(this.cwd, p.path));\n        // in this case, we don't have to wait for the stat\n        if (!this.filter(p.path, p)) {\n            p.resume();\n        }\n        else {\n            const job = new PackJob(p.path, absolute);\n            job.entry = new _write_entry_js__WEBPACK_IMPORTED_MODULE_1__.WriteEntryTar(p, this[ENTRYOPT](job));\n            job.entry.on('end', () => this[JOBDONE](job));\n            this[JOBS] += 1;\n            this[QUEUE].push(job);\n        }\n        this[PROCESS]();\n    }\n    [ADDFSENTRY](p) {\n        const absolute = (0,_normalize_windows_path_js__WEBPACK_IMPORTED_MODULE_8__.normalizeWindowsPath)(path__WEBPACK_IMPORTED_MODULE_7__.resolve(this.cwd, p));\n        this[QUEUE].push(new PackJob(p, absolute));\n        this[PROCESS]();\n    }\n    [STAT](job) {\n        job.pending = true;\n        this[JOBS] += 1;\n        const stat = this.follow ? 'stat' : 'lstat';\n        fs__WEBPACK_IMPORTED_MODULE_0__[stat](job.absolute, (er, stat) => {\n            job.pending = false;\n            this[JOBS] -= 1;\n            if (er) {\n                this.emit('error', er);\n            }\n            else {\n                this[ONSTAT](job, stat);\n            }\n        });\n    }\n    [ONSTAT](job, stat) {\n        this.statCache.set(job.absolute, stat);\n        job.stat = stat;\n        // now we have the stat, we can filter it.\n        if (!this.filter(job.path, stat)) {\n            job.ignore = true;\n        }\n        this[PROCESS]();\n    }\n    [READDIR](job) {\n        job.pending = true;\n        this[JOBS] += 1;\n        fs__WEBPACK_IMPORTED_MODULE_0__.readdir(job.absolute, (er, entries) => {\n            job.pending = false;\n            this[JOBS] -= 1;\n            if (er) {\n                return this.emit('error', er);\n            }\n            this[ONREADDIR](job, entries);\n        });\n    }\n    [ONREADDIR](job, entries) {\n        this.readdirCache.set(job.absolute, entries);\n        job.readdir = entries;\n        this[PROCESS]();\n    }\n    [PROCESS]() {\n        if (this[PROCESSING]) {\n            return;\n        }\n        this[PROCESSING] = true;\n        for (let w = this[QUEUE].head; !!w && this[JOBS] < this.jobs; w = w.next) {\n            this[PROCESSJOB](w.value);\n            if (w.value.ignore) {\n                const p = w.next;\n                this[QUEUE].removeNode(w);\n                w.next = p;\n            }\n        }\n        this[PROCESSING] = false;\n        if (this[ENDED] && !this[QUEUE].length && this[JOBS] === 0) {\n            if (this.zip) {\n                this.zip.end(EOF);\n            }\n            else {\n                super.write(EOF);\n                super.end();\n            }\n        }\n    }\n    get [CURRENT]() {\n        return this[QUEUE] && this[QUEUE].head && this[QUEUE].head.value;\n    }\n    [JOBDONE](_job) {\n        this[QUEUE].shift();\n        this[JOBS] -= 1;\n        this[PROCESS]();\n    }\n    [PROCESSJOB](job) {\n        if (job.pending) {\n            return;\n        }\n        if (job.entry) {\n            if (job === this[CURRENT] && !job.piped) {\n                this[PIPE](job);\n            }\n            return;\n        }\n        if (!job.stat) {\n            const sc = this.statCache.get(job.absolute);\n            if (sc) {\n                this[ONSTAT](job, sc);\n            }\n            else {\n                this[STAT](job);\n            }\n        }\n        if (!job.stat) {\n            return;\n        }\n        // filtered out!\n        if (job.ignore) {\n            return;\n        }\n        if (!this.noDirRecurse &&\n            job.stat.isDirectory() &&\n            !job.readdir) {\n            const rc = this.readdirCache.get(job.absolute);\n            if (rc) {\n                this[ONREADDIR](job, rc);\n            }\n            else {\n                this[READDIR](job);\n            }\n            if (!job.readdir) {\n                return;\n            }\n        }\n        // we know it doesn't have an entry, because that got checked above\n        job.entry = this[ENTRY](job);\n        if (!job.entry) {\n            job.ignore = true;\n            return;\n        }\n        if (job === this[CURRENT] && !job.piped) {\n            this[PIPE](job);\n        }\n    }\n    [ENTRYOPT](job) {\n        return {\n            onwarn: (code, msg, data) => this.warn(code, msg, data),\n            noPax: this.noPax,\n            cwd: this.cwd,\n            absolute: job.absolute,\n            preservePaths: this.preservePaths,\n            maxReadSize: this.maxReadSize,\n            strict: this.strict,\n            portable: this.portable,\n            linkCache: this.linkCache,\n            statCache: this.statCache,\n            noMtime: this.noMtime,\n            mtime: this.mtime,\n            prefix: this.prefix,\n            onWriteEntry: this.onWriteEntry,\n        };\n    }\n    [ENTRY](job) {\n        this[JOBS] += 1;\n        try {\n            const e = new this[WRITEENTRYCLASS](job.path, this[ENTRYOPT](job));\n            return e\n                .on('end', () => this[JOBDONE](job))\n                .on('error', er => this.emit('error', er));\n        }\n        catch (er) {\n            this.emit('error', er);\n        }\n    }\n    [ONDRAIN]() {\n        if (this[CURRENT] && this[CURRENT].entry) {\n            this[CURRENT].entry.resume();\n        }\n    }\n    // like .pipe() but using super, because our write() is special\n    [PIPE](job) {\n        job.piped = true;\n        if (job.readdir) {\n            job.readdir.forEach(entry => {\n                const p = job.path;\n                const base = p === './' ? '' : p.replace(/\\/*$/, '/');\n                this[ADDFSENTRY](base + entry);\n            });\n        }\n        const source = job.entry;\n        const zip = this.zip;\n        /* c8 ignore start */\n        if (!source)\n            throw new Error('cannot pipe without source');\n        /* c8 ignore stop */\n        if (zip) {\n            source.on('data', chunk => {\n                if (!zip.write(chunk)) {\n                    source.pause();\n                }\n            });\n        }\n        else {\n            source.on('data', chunk => {\n                if (!super.write(chunk)) {\n                    source.pause();\n                }\n            });\n        }\n    }\n    pause() {\n        if (this.zip) {\n            this.zip.pause();\n        }\n        return super.pause();\n    }\n    warn(code, message, data = {}) {\n        (0,_warn_method_js__WEBPACK_IMPORTED_MODULE_6__.warnMethod)(this, code, message, data);\n    }\n}\nclass PackSync extends Pack {\n    sync = true;\n    constructor(opt) {\n        super(opt);\n        this[WRITEENTRYCLASS] = _write_entry_js__WEBPACK_IMPORTED_MODULE_1__.WriteEntrySync;\n    }\n    // pause/resume are no-ops in sync streams.\n    pause() { }\n    resume() { }\n    [STAT](job) {\n        const stat = this.follow ? 'statSync' : 'lstatSync';\n        this[ONSTAT](job, fs__WEBPACK_IMPORTED_MODULE_0__[stat](job.absolute));\n    }\n    [READDIR](job) {\n        this[ONREADDIR](job, fs__WEBPACK_IMPORTED_MODULE_0__.readdirSync(job.absolute));\n    }\n    // gotta get it all in this tick\n    [PIPE](job) {\n        const source = job.entry;\n        const zip = this.zip;\n        if (job.readdir) {\n            job.readdir.forEach(entry => {\n                const p = job.path;\n                const base = p === './' ? '' : p.replace(/\\/*$/, '/');\n                this[ADDFSENTRY](base + entry);\n            });\n        }\n        /* c8 ignore start */\n        if (!source)\n            throw new Error('Cannot pipe without source');\n        /* c8 ignore stop */\n        if (zip) {\n            source.on('data', chunk => {\n                zip.write(chunk);\n            });\n        }\n        else {\n            source.on('data', chunk => {\n                super[WRITE](chunk);\n            });\n        }\n    }\n}\n//# sourceMappingURL=pack.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvZXNtL3BhY2suanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNvQjtBQUMwRDtBQUN2RTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ29DO0FBQ0g7QUFDQztBQUNVO0FBQ0c7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3dCO0FBQzJDO0FBQzVELG1CQUFtQiw4Q0FBUTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0ZBQW9CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHVEQUFVO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwwQ0FBUztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG9EQUFtQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDRDQUFPO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFEQUFTO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0ZBQW9CLENBQUMseUNBQVk7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDBEQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdGQUFvQixDQUFDLHlDQUFZO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwrQkFBRTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVDQUFVO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLCtCQUErQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyxRQUFRLDJEQUFVO0FBQ2xCO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQywyREFBYztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsK0JBQUU7QUFDNUI7QUFDQTtBQUNBLDZCQUE2QiwyQ0FBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdml2ZS12aWJlLWFpLW5leHQvLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvZXNtL3BhY2suanM/MzE5YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBBIHJlYWRhYmxlIHRhciBzdHJlYW0gY3JlYXRvclxuLy8gVGVjaG5pY2FsbHksIHRoaXMgaXMgYSB0cmFuc2Zvcm0gc3RyZWFtIHRoYXQgeW91IHdyaXRlIHBhdGhzIGludG8sXG4vLyBhbmQgdGFyIGZvcm1hdCBjb21lcyBvdXQgb2YuXG4vLyBUaGUgYGFkZCgpYCBtZXRob2QgaXMgbGlrZSBgd3JpdGUoKWAgYnV0IHJldHVybnMgdGhpcyxcbi8vIGFuZCBlbmQoKSByZXR1cm4gYHRoaXNgIGFzIHdlbGwsIHNvIHlvdSBjYW5cbi8vIGRvIGBuZXcgUGFjayhvcHQpLmFkZCgnZmlsZXMnKS5hZGQoJ2RpcicpLmVuZCgpLnBpcGUob3V0cHV0KVxuLy8gWW91IGNvdWxkIGFsc28gZG8gc29tZXRoaW5nIGxpa2U6XG4vLyBzdHJlYW1PZlBhdGhzKCkucGlwZShuZXcgUGFjaygpKS5waXBlKG5ldyBmcy5Xcml0ZVN0cmVhbSgnb3V0LnRhcicpKVxuaW1wb3J0IGZzIGZyb20gJ2ZzJztcbmltcG9ydCB7IFdyaXRlRW50cnksIFdyaXRlRW50cnlTeW5jLCBXcml0ZUVudHJ5VGFyLCB9IGZyb20gJy4vd3JpdGUtZW50cnkuanMnO1xuZXhwb3J0IGNsYXNzIFBhY2tKb2Ige1xuICAgIHBhdGg7XG4gICAgYWJzb2x1dGU7XG4gICAgZW50cnk7XG4gICAgc3RhdDtcbiAgICByZWFkZGlyO1xuICAgIHBlbmRpbmcgPSBmYWxzZTtcbiAgICBpZ25vcmUgPSBmYWxzZTtcbiAgICBwaXBlZCA9IGZhbHNlO1xuICAgIGNvbnN0cnVjdG9yKHBhdGgsIGFic29sdXRlKSB7XG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGggfHwgJy4vJztcbiAgICAgICAgdGhpcy5hYnNvbHV0ZSA9IGFic29sdXRlO1xuICAgIH1cbn1cbmltcG9ydCB7IE1pbmlwYXNzIH0gZnJvbSAnbWluaXBhc3MnO1xuaW1wb3J0ICogYXMgemxpYiBmcm9tICdtaW5pemxpYic7XG5pbXBvcnQgeyBZYWxsaXN0IH0gZnJvbSAneWFsbGlzdCc7XG5pbXBvcnQgeyBSZWFkRW50cnkgfSBmcm9tICcuL3JlYWQtZW50cnkuanMnO1xuaW1wb3J0IHsgd2Fybk1ldGhvZCwgfSBmcm9tICcuL3dhcm4tbWV0aG9kLmpzJztcbmNvbnN0IEVPRiA9IEJ1ZmZlci5hbGxvYygxMDI0KTtcbmNvbnN0IE9OU1RBVCA9IFN5bWJvbCgnb25TdGF0Jyk7XG5jb25zdCBFTkRFRCA9IFN5bWJvbCgnZW5kZWQnKTtcbmNvbnN0IFFVRVVFID0gU3ltYm9sKCdxdWV1ZScpO1xuY29uc3QgQ1VSUkVOVCA9IFN5bWJvbCgnY3VycmVudCcpO1xuY29uc3QgUFJPQ0VTUyA9IFN5bWJvbCgncHJvY2VzcycpO1xuY29uc3QgUFJPQ0VTU0lORyA9IFN5bWJvbCgncHJvY2Vzc2luZycpO1xuY29uc3QgUFJPQ0VTU0pPQiA9IFN5bWJvbCgncHJvY2Vzc0pvYicpO1xuY29uc3QgSk9CUyA9IFN5bWJvbCgnam9icycpO1xuY29uc3QgSk9CRE9ORSA9IFN5bWJvbCgnam9iRG9uZScpO1xuY29uc3QgQURERlNFTlRSWSA9IFN5bWJvbCgnYWRkRlNFbnRyeScpO1xuY29uc3QgQUREVEFSRU5UUlkgPSBTeW1ib2woJ2FkZFRhckVudHJ5Jyk7XG5jb25zdCBTVEFUID0gU3ltYm9sKCdzdGF0Jyk7XG5jb25zdCBSRUFERElSID0gU3ltYm9sKCdyZWFkZGlyJyk7XG5jb25zdCBPTlJFQURESVIgPSBTeW1ib2woJ29ucmVhZGRpcicpO1xuY29uc3QgUElQRSA9IFN5bWJvbCgncGlwZScpO1xuY29uc3QgRU5UUlkgPSBTeW1ib2woJ2VudHJ5Jyk7XG5jb25zdCBFTlRSWU9QVCA9IFN5bWJvbCgnZW50cnlPcHQnKTtcbmNvbnN0IFdSSVRFRU5UUllDTEFTUyA9IFN5bWJvbCgnd3JpdGVFbnRyeUNsYXNzJyk7XG5jb25zdCBXUklURSA9IFN5bWJvbCgnd3JpdGUnKTtcbmNvbnN0IE9ORFJBSU4gPSBTeW1ib2woJ29uZHJhaW4nKTtcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHsgbm9ybWFsaXplV2luZG93c1BhdGggfSBmcm9tICcuL25vcm1hbGl6ZS13aW5kb3dzLXBhdGguanMnO1xuZXhwb3J0IGNsYXNzIFBhY2sgZXh0ZW5kcyBNaW5pcGFzcyB7XG4gICAgb3B0O1xuICAgIGN3ZDtcbiAgICBtYXhSZWFkU2l6ZTtcbiAgICBwcmVzZXJ2ZVBhdGhzO1xuICAgIHN0cmljdDtcbiAgICBub1BheDtcbiAgICBwcmVmaXg7XG4gICAgbGlua0NhY2hlO1xuICAgIHN0YXRDYWNoZTtcbiAgICBmaWxlO1xuICAgIHBvcnRhYmxlO1xuICAgIHppcDtcbiAgICByZWFkZGlyQ2FjaGU7XG4gICAgbm9EaXJSZWN1cnNlO1xuICAgIGZvbGxvdztcbiAgICBub010aW1lO1xuICAgIG10aW1lO1xuICAgIGZpbHRlcjtcbiAgICBqb2JzO1xuICAgIFtXUklURUVOVFJZQ0xBU1NdO1xuICAgIG9uV3JpdGVFbnRyeTtcbiAgICBbUVVFVUVdO1xuICAgIFtKT0JTXSA9IDA7XG4gICAgW1BST0NFU1NJTkddID0gZmFsc2U7XG4gICAgW0VOREVEXSA9IGZhbHNlO1xuICAgIGNvbnN0cnVjdG9yKG9wdCA9IHt9KSB7XG4gICAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm9wdCA9IG9wdDtcbiAgICAgICAgdGhpcy5maWxlID0gb3B0LmZpbGUgfHwgJyc7XG4gICAgICAgIHRoaXMuY3dkID0gb3B0LmN3ZCB8fCBwcm9jZXNzLmN3ZCgpO1xuICAgICAgICB0aGlzLm1heFJlYWRTaXplID0gb3B0Lm1heFJlYWRTaXplO1xuICAgICAgICB0aGlzLnByZXNlcnZlUGF0aHMgPSAhIW9wdC5wcmVzZXJ2ZVBhdGhzO1xuICAgICAgICB0aGlzLnN0cmljdCA9ICEhb3B0LnN0cmljdDtcbiAgICAgICAgdGhpcy5ub1BheCA9ICEhb3B0Lm5vUGF4O1xuICAgICAgICB0aGlzLnByZWZpeCA9IG5vcm1hbGl6ZVdpbmRvd3NQYXRoKG9wdC5wcmVmaXggfHwgJycpO1xuICAgICAgICB0aGlzLmxpbmtDYWNoZSA9IG9wdC5saW5rQ2FjaGUgfHwgbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnN0YXRDYWNoZSA9IG9wdC5zdGF0Q2FjaGUgfHwgbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnJlYWRkaXJDYWNoZSA9IG9wdC5yZWFkZGlyQ2FjaGUgfHwgbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLm9uV3JpdGVFbnRyeSA9IG9wdC5vbldyaXRlRW50cnk7XG4gICAgICAgIHRoaXNbV1JJVEVFTlRSWUNMQVNTXSA9IFdyaXRlRW50cnk7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0Lm9ud2FybiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5vbignd2FybicsIG9wdC5vbndhcm4pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucG9ydGFibGUgPSAhIW9wdC5wb3J0YWJsZTtcbiAgICAgICAgaWYgKG9wdC5nemlwIHx8IG9wdC5icm90bGkpIHtcbiAgICAgICAgICAgIGlmIChvcHQuZ3ppcCAmJiBvcHQuYnJvdGxpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZ3ppcCBhbmQgYnJvdGxpIGFyZSBtdXR1YWxseSBleGNsdXNpdmUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHQuZ3ppcCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0Lmd6aXAgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdC5nemlwID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBvcnRhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdC5nemlwLnBvcnRhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy56aXAgPSBuZXcgemxpYi5HemlwKG9wdC5nemlwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHQuYnJvdGxpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHQuYnJvdGxpICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICBvcHQuYnJvdGxpID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuemlwID0gbmV3IHpsaWIuQnJvdGxpQ29tcHJlc3Mob3B0LmJyb3RsaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgaWYgKCF0aGlzLnppcClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ltcG9zc2libGUnKTtcbiAgICAgICAgICAgIGNvbnN0IHppcCA9IHRoaXMuemlwO1xuICAgICAgICAgICAgemlwLm9uKCdkYXRhJywgY2h1bmsgPT4gc3VwZXIud3JpdGUoY2h1bmspKTtcbiAgICAgICAgICAgIHppcC5vbignZW5kJywgKCkgPT4gc3VwZXIuZW5kKCkpO1xuICAgICAgICAgICAgemlwLm9uKCdkcmFpbicsICgpID0+IHRoaXNbT05EUkFJTl0oKSk7XG4gICAgICAgICAgICB0aGlzLm9uKCdyZXN1bWUnLCAoKSA9PiB6aXAucmVzdW1lKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vbignZHJhaW4nLCB0aGlzW09ORFJBSU5dKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5vRGlyUmVjdXJzZSA9ICEhb3B0Lm5vRGlyUmVjdXJzZTtcbiAgICAgICAgdGhpcy5mb2xsb3cgPSAhIW9wdC5mb2xsb3c7XG4gICAgICAgIHRoaXMubm9NdGltZSA9ICEhb3B0Lm5vTXRpbWU7XG4gICAgICAgIGlmIChvcHQubXRpbWUpXG4gICAgICAgICAgICB0aGlzLm10aW1lID0gb3B0Lm10aW1lO1xuICAgICAgICB0aGlzLmZpbHRlciA9XG4gICAgICAgICAgICB0eXBlb2Ygb3B0LmZpbHRlciA9PT0gJ2Z1bmN0aW9uJyA/IG9wdC5maWx0ZXIgOiAoKSA9PiB0cnVlO1xuICAgICAgICB0aGlzW1FVRVVFXSA9IG5ldyBZYWxsaXN0KCk7XG4gICAgICAgIHRoaXNbSk9CU10gPSAwO1xuICAgICAgICB0aGlzLmpvYnMgPSBOdW1iZXIob3B0LmpvYnMpIHx8IDQ7XG4gICAgICAgIHRoaXNbUFJPQ0VTU0lOR10gPSBmYWxzZTtcbiAgICAgICAgdGhpc1tFTkRFRF0gPSBmYWxzZTtcbiAgICB9XG4gICAgW1dSSVRFXShjaHVuaykge1xuICAgICAgICByZXR1cm4gc3VwZXIud3JpdGUoY2h1bmspO1xuICAgIH1cbiAgICBhZGQocGF0aCkge1xuICAgICAgICB0aGlzLndyaXRlKHBhdGgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZW5kKHBhdGgsIGVuY29kaW5nLCBjYikge1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgaWYgKHR5cGVvZiBwYXRoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYiA9IHBhdGg7XG4gICAgICAgICAgICBwYXRoID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgICAgICAgICBlbmNvZGluZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgICAgdGhpcy5hZGQocGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1tFTkRFRF0gPSB0cnVlO1xuICAgICAgICB0aGlzW1BST0NFU1NdKCk7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGlmIChjYilcbiAgICAgICAgICAgIGNiKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB3cml0ZShwYXRoKSB7XG4gICAgICAgIGlmICh0aGlzW0VOREVEXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd3cml0ZSBhZnRlciBlbmQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0aCBpbnN0YW5jZW9mIFJlYWRFbnRyeSkge1xuICAgICAgICAgICAgdGhpc1tBRERUQVJFTlRSWV0ocGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzW0FEREZTRU5UUlldKHBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmZsb3dpbmc7XG4gICAgfVxuICAgIFtBRERUQVJFTlRSWV0ocCkge1xuICAgICAgICBjb25zdCBhYnNvbHV0ZSA9IG5vcm1hbGl6ZVdpbmRvd3NQYXRoKHBhdGgucmVzb2x2ZSh0aGlzLmN3ZCwgcC5wYXRoKSk7XG4gICAgICAgIC8vIGluIHRoaXMgY2FzZSwgd2UgZG9uJ3QgaGF2ZSB0byB3YWl0IGZvciB0aGUgc3RhdFxuICAgICAgICBpZiAoIXRoaXMuZmlsdGVyKHAucGF0aCwgcCkpIHtcbiAgICAgICAgICAgIHAucmVzdW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBqb2IgPSBuZXcgUGFja0pvYihwLnBhdGgsIGFic29sdXRlKTtcbiAgICAgICAgICAgIGpvYi5lbnRyeSA9IG5ldyBXcml0ZUVudHJ5VGFyKHAsIHRoaXNbRU5UUllPUFRdKGpvYikpO1xuICAgICAgICAgICAgam9iLmVudHJ5Lm9uKCdlbmQnLCAoKSA9PiB0aGlzW0pPQkRPTkVdKGpvYikpO1xuICAgICAgICAgICAgdGhpc1tKT0JTXSArPSAxO1xuICAgICAgICAgICAgdGhpc1tRVUVVRV0ucHVzaChqb2IpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXNbUFJPQ0VTU10oKTtcbiAgICB9XG4gICAgW0FEREZTRU5UUlldKHApIHtcbiAgICAgICAgY29uc3QgYWJzb2x1dGUgPSBub3JtYWxpemVXaW5kb3dzUGF0aChwYXRoLnJlc29sdmUodGhpcy5jd2QsIHApKTtcbiAgICAgICAgdGhpc1tRVUVVRV0ucHVzaChuZXcgUGFja0pvYihwLCBhYnNvbHV0ZSkpO1xuICAgICAgICB0aGlzW1BST0NFU1NdKCk7XG4gICAgfVxuICAgIFtTVEFUXShqb2IpIHtcbiAgICAgICAgam9iLnBlbmRpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzW0pPQlNdICs9IDE7XG4gICAgICAgIGNvbnN0IHN0YXQgPSB0aGlzLmZvbGxvdyA/ICdzdGF0JyA6ICdsc3RhdCc7XG4gICAgICAgIGZzW3N0YXRdKGpvYi5hYnNvbHV0ZSwgKGVyLCBzdGF0KSA9PiB7XG4gICAgICAgICAgICBqb2IucGVuZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpc1tKT0JTXSAtPSAxO1xuICAgICAgICAgICAgaWYgKGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXNbT05TVEFUXShqb2IsIHN0YXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgW09OU1RBVF0oam9iLCBzdGF0KSB7XG4gICAgICAgIHRoaXMuc3RhdENhY2hlLnNldChqb2IuYWJzb2x1dGUsIHN0YXQpO1xuICAgICAgICBqb2Iuc3RhdCA9IHN0YXQ7XG4gICAgICAgIC8vIG5vdyB3ZSBoYXZlIHRoZSBzdGF0LCB3ZSBjYW4gZmlsdGVyIGl0LlxuICAgICAgICBpZiAoIXRoaXMuZmlsdGVyKGpvYi5wYXRoLCBzdGF0KSkge1xuICAgICAgICAgICAgam9iLmlnbm9yZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1tQUk9DRVNTXSgpO1xuICAgIH1cbiAgICBbUkVBRERJUl0oam9iKSB7XG4gICAgICAgIGpvYi5wZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpc1tKT0JTXSArPSAxO1xuICAgICAgICBmcy5yZWFkZGlyKGpvYi5hYnNvbHV0ZSwgKGVyLCBlbnRyaWVzKSA9PiB7XG4gICAgICAgICAgICBqb2IucGVuZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpc1tKT0JTXSAtPSAxO1xuICAgICAgICAgICAgaWYgKGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnZXJyb3InLCBlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzW09OUkVBRERJUl0oam9iLCBlbnRyaWVzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIFtPTlJFQURESVJdKGpvYiwgZW50cmllcykge1xuICAgICAgICB0aGlzLnJlYWRkaXJDYWNoZS5zZXQoam9iLmFic29sdXRlLCBlbnRyaWVzKTtcbiAgICAgICAgam9iLnJlYWRkaXIgPSBlbnRyaWVzO1xuICAgICAgICB0aGlzW1BST0NFU1NdKCk7XG4gICAgfVxuICAgIFtQUk9DRVNTXSgpIHtcbiAgICAgICAgaWYgKHRoaXNbUFJPQ0VTU0lOR10pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzW1BST0NFU1NJTkddID0gdHJ1ZTtcbiAgICAgICAgZm9yIChsZXQgdyA9IHRoaXNbUVVFVUVdLmhlYWQ7ICEhdyAmJiB0aGlzW0pPQlNdIDwgdGhpcy5qb2JzOyB3ID0gdy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzW1BST0NFU1NKT0JdKHcudmFsdWUpO1xuICAgICAgICAgICAgaWYgKHcudmFsdWUuaWdub3JlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcCA9IHcubmV4dDtcbiAgICAgICAgICAgICAgICB0aGlzW1FVRVVFXS5yZW1vdmVOb2RlKHcpO1xuICAgICAgICAgICAgICAgIHcubmV4dCA9IHA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1tQUk9DRVNTSU5HXSA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpc1tFTkRFRF0gJiYgIXRoaXNbUVVFVUVdLmxlbmd0aCAmJiB0aGlzW0pPQlNdID09PSAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy56aXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnppcC5lbmQoRU9GKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN1cGVyLndyaXRlKEVPRik7XG4gICAgICAgICAgICAgICAgc3VwZXIuZW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IFtDVVJSRU5UXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbUVVFVUVdICYmIHRoaXNbUVVFVUVdLmhlYWQgJiYgdGhpc1tRVUVVRV0uaGVhZC52YWx1ZTtcbiAgICB9XG4gICAgW0pPQkRPTkVdKF9qb2IpIHtcbiAgICAgICAgdGhpc1tRVUVVRV0uc2hpZnQoKTtcbiAgICAgICAgdGhpc1tKT0JTXSAtPSAxO1xuICAgICAgICB0aGlzW1BST0NFU1NdKCk7XG4gICAgfVxuICAgIFtQUk9DRVNTSk9CXShqb2IpIHtcbiAgICAgICAgaWYgKGpvYi5wZW5kaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGpvYi5lbnRyeSkge1xuICAgICAgICAgICAgaWYgKGpvYiA9PT0gdGhpc1tDVVJSRU5UXSAmJiAham9iLnBpcGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tQSVBFXShqb2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICgham9iLnN0YXQpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjID0gdGhpcy5zdGF0Q2FjaGUuZ2V0KGpvYi5hYnNvbHV0ZSk7XG4gICAgICAgICAgICBpZiAoc2MpIHtcbiAgICAgICAgICAgICAgICB0aGlzW09OU1RBVF0oam9iLCBzYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzW1NUQVRdKGpvYik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFqb2Iuc3RhdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZpbHRlcmVkIG91dCFcbiAgICAgICAgaWYgKGpvYi5pZ25vcmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMubm9EaXJSZWN1cnNlICYmXG4gICAgICAgICAgICBqb2Iuc3RhdC5pc0RpcmVjdG9yeSgpICYmXG4gICAgICAgICAgICAham9iLnJlYWRkaXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHJjID0gdGhpcy5yZWFkZGlyQ2FjaGUuZ2V0KGpvYi5hYnNvbHV0ZSk7XG4gICAgICAgICAgICBpZiAocmMpIHtcbiAgICAgICAgICAgICAgICB0aGlzW09OUkVBRERJUl0oam9iLCByYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzW1JFQURESVJdKGpvYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWpvYi5yZWFkZGlyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHdlIGtub3cgaXQgZG9lc24ndCBoYXZlIGFuIGVudHJ5LCBiZWNhdXNlIHRoYXQgZ290IGNoZWNrZWQgYWJvdmVcbiAgICAgICAgam9iLmVudHJ5ID0gdGhpc1tFTlRSWV0oam9iKTtcbiAgICAgICAgaWYgKCFqb2IuZW50cnkpIHtcbiAgICAgICAgICAgIGpvYi5pZ25vcmUgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChqb2IgPT09IHRoaXNbQ1VSUkVOVF0gJiYgIWpvYi5waXBlZCkge1xuICAgICAgICAgICAgdGhpc1tQSVBFXShqb2IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFtFTlRSWU9QVF0oam9iKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvbndhcm46IChjb2RlLCBtc2csIGRhdGEpID0+IHRoaXMud2Fybihjb2RlLCBtc2csIGRhdGEpLFxuICAgICAgICAgICAgbm9QYXg6IHRoaXMubm9QYXgsXG4gICAgICAgICAgICBjd2Q6IHRoaXMuY3dkLFxuICAgICAgICAgICAgYWJzb2x1dGU6IGpvYi5hYnNvbHV0ZSxcbiAgICAgICAgICAgIHByZXNlcnZlUGF0aHM6IHRoaXMucHJlc2VydmVQYXRocyxcbiAgICAgICAgICAgIG1heFJlYWRTaXplOiB0aGlzLm1heFJlYWRTaXplLFxuICAgICAgICAgICAgc3RyaWN0OiB0aGlzLnN0cmljdCxcbiAgICAgICAgICAgIHBvcnRhYmxlOiB0aGlzLnBvcnRhYmxlLFxuICAgICAgICAgICAgbGlua0NhY2hlOiB0aGlzLmxpbmtDYWNoZSxcbiAgICAgICAgICAgIHN0YXRDYWNoZTogdGhpcy5zdGF0Q2FjaGUsXG4gICAgICAgICAgICBub010aW1lOiB0aGlzLm5vTXRpbWUsXG4gICAgICAgICAgICBtdGltZTogdGhpcy5tdGltZSxcbiAgICAgICAgICAgIHByZWZpeDogdGhpcy5wcmVmaXgsXG4gICAgICAgICAgICBvbldyaXRlRW50cnk6IHRoaXMub25Xcml0ZUVudHJ5LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBbRU5UUlldKGpvYikge1xuICAgICAgICB0aGlzW0pPQlNdICs9IDE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBlID0gbmV3IHRoaXNbV1JJVEVFTlRSWUNMQVNTXShqb2IucGF0aCwgdGhpc1tFTlRSWU9QVF0oam9iKSk7XG4gICAgICAgICAgICByZXR1cm4gZVxuICAgICAgICAgICAgICAgIC5vbignZW5kJywgKCkgPT4gdGhpc1tKT0JET05FXShqb2IpKVxuICAgICAgICAgICAgICAgIC5vbignZXJyb3InLCBlciA9PiB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgW09ORFJBSU5dKCkge1xuICAgICAgICBpZiAodGhpc1tDVVJSRU5UXSAmJiB0aGlzW0NVUlJFTlRdLmVudHJ5KSB7XG4gICAgICAgICAgICB0aGlzW0NVUlJFTlRdLmVudHJ5LnJlc3VtZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGxpa2UgLnBpcGUoKSBidXQgdXNpbmcgc3VwZXIsIGJlY2F1c2Ugb3VyIHdyaXRlKCkgaXMgc3BlY2lhbFxuICAgIFtQSVBFXShqb2IpIHtcbiAgICAgICAgam9iLnBpcGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKGpvYi5yZWFkZGlyKSB7XG4gICAgICAgICAgICBqb2IucmVhZGRpci5mb3JFYWNoKGVudHJ5ID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwID0gam9iLnBhdGg7XG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZSA9IHAgPT09ICcuLycgPyAnJyA6IHAucmVwbGFjZSgvXFwvKiQvLCAnLycpO1xuICAgICAgICAgICAgICAgIHRoaXNbQURERlNFTlRSWV0oYmFzZSArIGVudHJ5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IGpvYi5lbnRyeTtcbiAgICAgICAgY29uc3QgemlwID0gdGhpcy56aXA7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICBpZiAoIXNvdXJjZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHBpcGUgd2l0aG91dCBzb3VyY2UnKTtcbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgaWYgKHppcCkge1xuICAgICAgICAgICAgc291cmNlLm9uKCdkYXRhJywgY2h1bmsgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghemlwLndyaXRlKGNodW5rKSkge1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2UucGF1c2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNvdXJjZS5vbignZGF0YScsIGNodW5rID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXN1cGVyLndyaXRlKGNodW5rKSkge1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2UucGF1c2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXVzZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuemlwKSB7XG4gICAgICAgICAgICB0aGlzLnppcC5wYXVzZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5wYXVzZSgpO1xuICAgIH1cbiAgICB3YXJuKGNvZGUsIG1lc3NhZ2UsIGRhdGEgPSB7fSkge1xuICAgICAgICB3YXJuTWV0aG9kKHRoaXMsIGNvZGUsIG1lc3NhZ2UsIGRhdGEpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBQYWNrU3luYyBleHRlbmRzIFBhY2sge1xuICAgIHN5bmMgPSB0cnVlO1xuICAgIGNvbnN0cnVjdG9yKG9wdCkge1xuICAgICAgICBzdXBlcihvcHQpO1xuICAgICAgICB0aGlzW1dSSVRFRU5UUllDTEFTU10gPSBXcml0ZUVudHJ5U3luYztcbiAgICB9XG4gICAgLy8gcGF1c2UvcmVzdW1lIGFyZSBuby1vcHMgaW4gc3luYyBzdHJlYW1zLlxuICAgIHBhdXNlKCkgeyB9XG4gICAgcmVzdW1lKCkgeyB9XG4gICAgW1NUQVRdKGpvYikge1xuICAgICAgICBjb25zdCBzdGF0ID0gdGhpcy5mb2xsb3cgPyAnc3RhdFN5bmMnIDogJ2xzdGF0U3luYyc7XG4gICAgICAgIHRoaXNbT05TVEFUXShqb2IsIGZzW3N0YXRdKGpvYi5hYnNvbHV0ZSkpO1xuICAgIH1cbiAgICBbUkVBRERJUl0oam9iKSB7XG4gICAgICAgIHRoaXNbT05SRUFERElSXShqb2IsIGZzLnJlYWRkaXJTeW5jKGpvYi5hYnNvbHV0ZSkpO1xuICAgIH1cbiAgICAvLyBnb3R0YSBnZXQgaXQgYWxsIGluIHRoaXMgdGlja1xuICAgIFtQSVBFXShqb2IpIHtcbiAgICAgICAgY29uc3Qgc291cmNlID0gam9iLmVudHJ5O1xuICAgICAgICBjb25zdCB6aXAgPSB0aGlzLnppcDtcbiAgICAgICAgaWYgKGpvYi5yZWFkZGlyKSB7XG4gICAgICAgICAgICBqb2IucmVhZGRpci5mb3JFYWNoKGVudHJ5ID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwID0gam9iLnBhdGg7XG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZSA9IHAgPT09ICcuLycgPyAnJyA6IHAucmVwbGFjZSgvXFwvKiQvLCAnLycpO1xuICAgICAgICAgICAgICAgIHRoaXNbQURERlNFTlRSWV0oYmFzZSArIGVudHJ5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICBpZiAoIXNvdXJjZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHBpcGUgd2l0aG91dCBzb3VyY2UnKTtcbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgaWYgKHppcCkge1xuICAgICAgICAgICAgc291cmNlLm9uKCdkYXRhJywgY2h1bmsgPT4ge1xuICAgICAgICAgICAgICAgIHppcC53cml0ZShjaHVuayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNvdXJjZS5vbignZGF0YScsIGNodW5rID0+IHtcbiAgICAgICAgICAgICAgICBzdXBlcltXUklURV0oY2h1bmspO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYWNrLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/tar/dist/esm/pack.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/tar/dist/esm/parse.js":
/*!********************************************!*\
  !*** ./node_modules/tar/dist/esm/parse.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Parser: () => (/* binding */ Parser)\n/* harmony export */ });\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var minizlib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! minizlib */ \"(rsc)/./node_modules/minizlib/dist/esm/index.js\");\n/* harmony import */ var yallist__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! yallist */ \"(rsc)/./node_modules/yallist/dist/esm/index.js\");\n/* harmony import */ var _header_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./header.js */ \"(rsc)/./node_modules/tar/dist/esm/header.js\");\n/* harmony import */ var _pax_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./pax.js */ \"(rsc)/./node_modules/tar/dist/esm/pax.js\");\n/* harmony import */ var _read_entry_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./read-entry.js */ \"(rsc)/./node_modules/tar/dist/esm/read-entry.js\");\n/* harmony import */ var _warn_method_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./warn-method.js */ \"(rsc)/./node_modules/tar/dist/esm/warn-method.js\");\n// this[BUFFER] is the remainder of a chunk if we're waiting for\n// the full 512 bytes of a header to come in.  We will Buffer.concat()\n// it to the next write(), which is a mem copy, but a small one.\n//\n// this[QUEUE] is a Yallist of entries that haven't been emitted\n// yet this can only get filled up if the user keeps write()ing after\n// a write() returns false, or does a write() with more than one entry\n//\n// We don't buffer chunks, we always parse them and either create an\n// entry, or push it into the active entry.  The ReadEntry class knows\n// to throw data away if .ignore=true\n//\n// Shift entry off the buffer when it emits 'end', and emit 'entry' for\n// the next one in the list.\n//\n// At any time, we're pushing body chunks into the entry at WRITEENTRY,\n// and waiting for 'end' on the entry at READENTRY\n//\n// ignored entries get .resume() called on them straight away\n\n\n\n\n\n\n\nconst maxMetaEntrySize = 1024 * 1024;\nconst gzipHeader = Buffer.from([0x1f, 0x8b]);\nconst STATE = Symbol('state');\nconst WRITEENTRY = Symbol('writeEntry');\nconst READENTRY = Symbol('readEntry');\nconst NEXTENTRY = Symbol('nextEntry');\nconst PROCESSENTRY = Symbol('processEntry');\nconst EX = Symbol('extendedHeader');\nconst GEX = Symbol('globalExtendedHeader');\nconst META = Symbol('meta');\nconst EMITMETA = Symbol('emitMeta');\nconst BUFFER = Symbol('buffer');\nconst QUEUE = Symbol('queue');\nconst ENDED = Symbol('ended');\nconst EMITTEDEND = Symbol('emittedEnd');\nconst EMIT = Symbol('emit');\nconst UNZIP = Symbol('unzip');\nconst CONSUMECHUNK = Symbol('consumeChunk');\nconst CONSUMECHUNKSUB = Symbol('consumeChunkSub');\nconst CONSUMEBODY = Symbol('consumeBody');\nconst CONSUMEMETA = Symbol('consumeMeta');\nconst CONSUMEHEADER = Symbol('consumeHeader');\nconst CONSUMING = Symbol('consuming');\nconst BUFFERCONCAT = Symbol('bufferConcat');\nconst MAYBEEND = Symbol('maybeEnd');\nconst WRITING = Symbol('writing');\nconst ABORTED = Symbol('aborted');\nconst DONE = Symbol('onDone');\nconst SAW_VALID_ENTRY = Symbol('sawValidEntry');\nconst SAW_NULL_BLOCK = Symbol('sawNullBlock');\nconst SAW_EOF = Symbol('sawEOF');\nconst CLOSESTREAM = Symbol('closeStream');\nconst noop = () => true;\nclass Parser extends events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n    file;\n    strict;\n    maxMetaEntrySize;\n    filter;\n    brotli;\n    writable = true;\n    readable = false;\n    [QUEUE] = new yallist__WEBPACK_IMPORTED_MODULE_2__.Yallist();\n    [BUFFER];\n    [READENTRY];\n    [WRITEENTRY];\n    [STATE] = 'begin';\n    [META] = '';\n    [EX];\n    [GEX];\n    [ENDED] = false;\n    [UNZIP];\n    [ABORTED] = false;\n    [SAW_VALID_ENTRY];\n    [SAW_NULL_BLOCK] = false;\n    [SAW_EOF] = false;\n    [WRITING] = false;\n    [CONSUMING] = false;\n    [EMITTEDEND] = false;\n    constructor(opt = {}) {\n        super();\n        this.file = opt.file || '';\n        // these BADARCHIVE errors can't be detected early. listen on DONE.\n        this.on(DONE, () => {\n            if (this[STATE] === 'begin' ||\n                this[SAW_VALID_ENTRY] === false) {\n                // either less than 1 block of data, or all entries were invalid.\n                // Either way, probably not even a tarball.\n                this.warn('TAR_BAD_ARCHIVE', 'Unrecognized archive format');\n            }\n        });\n        if (opt.ondone) {\n            this.on(DONE, opt.ondone);\n        }\n        else {\n            this.on(DONE, () => {\n                this.emit('prefinish');\n                this.emit('finish');\n                this.emit('end');\n            });\n        }\n        this.strict = !!opt.strict;\n        this.maxMetaEntrySize = opt.maxMetaEntrySize || maxMetaEntrySize;\n        this.filter = typeof opt.filter === 'function' ? opt.filter : noop;\n        // Unlike gzip, brotli doesn't have any magic bytes to identify it\n        // Users need to explicitly tell us they're extracting a brotli file\n        // Or we infer from the file extension\n        const isTBR = opt.file &&\n            (opt.file.endsWith('.tar.br') || opt.file.endsWith('.tbr'));\n        // if it's a tbr file it MIGHT be brotli, but we don't know until\n        // we look at it and verify it's not a valid tar file.\n        this.brotli =\n            !opt.gzip && opt.brotli !== undefined ? opt.brotli\n                : isTBR ? undefined\n                    : false;\n        // have to set this so that streams are ok piping into it\n        this.on('end', () => this[CLOSESTREAM]());\n        if (typeof opt.onwarn === 'function') {\n            this.on('warn', opt.onwarn);\n        }\n        if (typeof opt.onReadEntry === 'function') {\n            this.on('entry', opt.onReadEntry);\n        }\n    }\n    warn(code, message, data = {}) {\n        (0,_warn_method_js__WEBPACK_IMPORTED_MODULE_6__.warnMethod)(this, code, message, data);\n    }\n    [CONSUMEHEADER](chunk, position) {\n        if (this[SAW_VALID_ENTRY] === undefined) {\n            this[SAW_VALID_ENTRY] = false;\n        }\n        let header;\n        try {\n            header = new _header_js__WEBPACK_IMPORTED_MODULE_3__.Header(chunk, position, this[EX], this[GEX]);\n        }\n        catch (er) {\n            return this.warn('TAR_ENTRY_INVALID', er);\n        }\n        if (header.nullBlock) {\n            if (this[SAW_NULL_BLOCK]) {\n                this[SAW_EOF] = true;\n                // ending an archive with no entries.  pointless, but legal.\n                if (this[STATE] === 'begin') {\n                    this[STATE] = 'header';\n                }\n                this[EMIT]('eof');\n            }\n            else {\n                this[SAW_NULL_BLOCK] = true;\n                this[EMIT]('nullBlock');\n            }\n        }\n        else {\n            this[SAW_NULL_BLOCK] = false;\n            if (!header.cksumValid) {\n                this.warn('TAR_ENTRY_INVALID', 'checksum failure', { header });\n            }\n            else if (!header.path) {\n                this.warn('TAR_ENTRY_INVALID', 'path is required', { header });\n            }\n            else {\n                const type = header.type;\n                if (/^(Symbolic)?Link$/.test(type) && !header.linkpath) {\n                    this.warn('TAR_ENTRY_INVALID', 'linkpath required', {\n                        header,\n                    });\n                }\n                else if (!/^(Symbolic)?Link$/.test(type) &&\n                    !/^(Global)?ExtendedHeader$/.test(type) &&\n                    header.linkpath) {\n                    this.warn('TAR_ENTRY_INVALID', 'linkpath forbidden', {\n                        header,\n                    });\n                }\n                else {\n                    const entry = (this[WRITEENTRY] = new _read_entry_js__WEBPACK_IMPORTED_MODULE_5__.ReadEntry(header, this[EX], this[GEX]));\n                    // we do this for meta & ignored entries as well, because they\n                    // are still valid tar, or else we wouldn't know to ignore them\n                    if (!this[SAW_VALID_ENTRY]) {\n                        if (entry.remain) {\n                            // this might be the one!\n                            const onend = () => {\n                                if (!entry.invalid) {\n                                    this[SAW_VALID_ENTRY] = true;\n                                }\n                            };\n                            entry.on('end', onend);\n                        }\n                        else {\n                            this[SAW_VALID_ENTRY] = true;\n                        }\n                    }\n                    if (entry.meta) {\n                        if (entry.size > this.maxMetaEntrySize) {\n                            entry.ignore = true;\n                            this[EMIT]('ignoredEntry', entry);\n                            this[STATE] = 'ignore';\n                            entry.resume();\n                        }\n                        else if (entry.size > 0) {\n                            this[META] = '';\n                            entry.on('data', c => (this[META] += c));\n                            this[STATE] = 'meta';\n                        }\n                    }\n                    else {\n                        this[EX] = undefined;\n                        entry.ignore =\n                            entry.ignore || !this.filter(entry.path, entry);\n                        if (entry.ignore) {\n                            // probably valid, just not something we care about\n                            this[EMIT]('ignoredEntry', entry);\n                            this[STATE] = entry.remain ? 'ignore' : 'header';\n                            entry.resume();\n                        }\n                        else {\n                            if (entry.remain) {\n                                this[STATE] = 'body';\n                            }\n                            else {\n                                this[STATE] = 'header';\n                                entry.end();\n                            }\n                            if (!this[READENTRY]) {\n                                this[QUEUE].push(entry);\n                                this[NEXTENTRY]();\n                            }\n                            else {\n                                this[QUEUE].push(entry);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    [CLOSESTREAM]() {\n        queueMicrotask(() => this.emit('close'));\n    }\n    [PROCESSENTRY](entry) {\n        let go = true;\n        if (!entry) {\n            this[READENTRY] = undefined;\n            go = false;\n        }\n        else if (Array.isArray(entry)) {\n            const [ev, ...args] = entry;\n            this.emit(ev, ...args);\n        }\n        else {\n            this[READENTRY] = entry;\n            this.emit('entry', entry);\n            if (!entry.emittedEnd) {\n                entry.on('end', () => this[NEXTENTRY]());\n                go = false;\n            }\n        }\n        return go;\n    }\n    [NEXTENTRY]() {\n        do { } while (this[PROCESSENTRY](this[QUEUE].shift()));\n        if (!this[QUEUE].length) {\n            // At this point, there's nothing in the queue, but we may have an\n            // entry which is being consumed (readEntry).\n            // If we don't, then we definitely can handle more data.\n            // If we do, and either it's flowing, or it has never had any data\n            // written to it, then it needs more.\n            // The only other possibility is that it has returned false from a\n            // write() call, so we wait for the next drain to continue.\n            const re = this[READENTRY];\n            const drainNow = !re || re.flowing || re.size === re.remain;\n            if (drainNow) {\n                if (!this[WRITING]) {\n                    this.emit('drain');\n                }\n            }\n            else {\n                re.once('drain', () => this.emit('drain'));\n            }\n        }\n    }\n    [CONSUMEBODY](chunk, position) {\n        // write up to but no  more than writeEntry.blockRemain\n        const entry = this[WRITEENTRY];\n        /* c8 ignore start */\n        if (!entry) {\n            throw new Error('attempt to consume body without entry??');\n        }\n        const br = entry.blockRemain ?? 0;\n        /* c8 ignore stop */\n        const c = br >= chunk.length && position === 0 ?\n            chunk\n            : chunk.subarray(position, position + br);\n        entry.write(c);\n        if (!entry.blockRemain) {\n            this[STATE] = 'header';\n            this[WRITEENTRY] = undefined;\n            entry.end();\n        }\n        return c.length;\n    }\n    [CONSUMEMETA](chunk, position) {\n        const entry = this[WRITEENTRY];\n        const ret = this[CONSUMEBODY](chunk, position);\n        // if we finished, then the entry is reset\n        if (!this[WRITEENTRY] && entry) {\n            this[EMITMETA](entry);\n        }\n        return ret;\n    }\n    [EMIT](ev, data, extra) {\n        if (!this[QUEUE].length && !this[READENTRY]) {\n            this.emit(ev, data, extra);\n        }\n        else {\n            this[QUEUE].push([ev, data, extra]);\n        }\n    }\n    [EMITMETA](entry) {\n        this[EMIT]('meta', this[META]);\n        switch (entry.type) {\n            case 'ExtendedHeader':\n            case 'OldExtendedHeader':\n                this[EX] = _pax_js__WEBPACK_IMPORTED_MODULE_4__.Pax.parse(this[META], this[EX], false);\n                break;\n            case 'GlobalExtendedHeader':\n                this[GEX] = _pax_js__WEBPACK_IMPORTED_MODULE_4__.Pax.parse(this[META], this[GEX], true);\n                break;\n            case 'NextFileHasLongPath':\n            case 'OldGnuLongPath': {\n                const ex = this[EX] ?? Object.create(null);\n                this[EX] = ex;\n                ex.path = this[META].replace(/\\0.*/, '');\n                break;\n            }\n            case 'NextFileHasLongLinkpath': {\n                const ex = this[EX] || Object.create(null);\n                this[EX] = ex;\n                ex.linkpath = this[META].replace(/\\0.*/, '');\n                break;\n            }\n            /* c8 ignore start */\n            default:\n                throw new Error('unknown meta: ' + entry.type);\n            /* c8 ignore stop */\n        }\n    }\n    abort(error) {\n        this[ABORTED] = true;\n        this.emit('abort', error);\n        // always throws, even in non-strict mode\n        this.warn('TAR_ABORT', error, { recoverable: false });\n    }\n    write(chunk, encoding, cb) {\n        if (typeof encoding === 'function') {\n            cb = encoding;\n            encoding = undefined;\n        }\n        if (typeof chunk === 'string') {\n            chunk = Buffer.from(chunk, \n            /* c8 ignore next */\n            typeof encoding === 'string' ? encoding : 'utf8');\n        }\n        if (this[ABORTED]) {\n            /* c8 ignore next */\n            cb?.();\n            return false;\n        }\n        // first write, might be gzipped\n        const needSniff = this[UNZIP] === undefined ||\n            (this.brotli === undefined && this[UNZIP] === false);\n        if (needSniff && chunk) {\n            if (this[BUFFER]) {\n                chunk = Buffer.concat([this[BUFFER], chunk]);\n                this[BUFFER] = undefined;\n            }\n            if (chunk.length < gzipHeader.length) {\n                this[BUFFER] = chunk;\n                /* c8 ignore next */\n                cb?.();\n                return true;\n            }\n            // look for gzip header\n            for (let i = 0; this[UNZIP] === undefined && i < gzipHeader.length; i++) {\n                if (chunk[i] !== gzipHeader[i]) {\n                    this[UNZIP] = false;\n                }\n            }\n            const maybeBrotli = this.brotli === undefined;\n            if (this[UNZIP] === false && maybeBrotli) {\n                // read the first header to see if it's a valid tar file. If so,\n                // we can safely assume that it's not actually brotli, despite the\n                // .tbr or .tar.br file extension.\n                // if we ended before getting a full chunk, yes, def brotli\n                if (chunk.length < 512) {\n                    if (this[ENDED]) {\n                        this.brotli = true;\n                    }\n                    else {\n                        this[BUFFER] = chunk;\n                        /* c8 ignore next */\n                        cb?.();\n                        return true;\n                    }\n                }\n                else {\n                    // if it's tar, it's pretty reliably not brotli, chances of\n                    // that happening are astronomical.\n                    try {\n                        new _header_js__WEBPACK_IMPORTED_MODULE_3__.Header(chunk.subarray(0, 512));\n                        this.brotli = false;\n                    }\n                    catch (_) {\n                        this.brotli = true;\n                    }\n                }\n            }\n            if (this[UNZIP] === undefined ||\n                (this[UNZIP] === false && this.brotli)) {\n                const ended = this[ENDED];\n                this[ENDED] = false;\n                this[UNZIP] =\n                    this[UNZIP] === undefined ?\n                        new minizlib__WEBPACK_IMPORTED_MODULE_1__.Unzip({})\n                        : new minizlib__WEBPACK_IMPORTED_MODULE_1__.BrotliDecompress({});\n                this[UNZIP].on('data', chunk => this[CONSUMECHUNK](chunk));\n                this[UNZIP].on('error', er => this.abort(er));\n                this[UNZIP].on('end', () => {\n                    this[ENDED] = true;\n                    this[CONSUMECHUNK]();\n                });\n                this[WRITING] = true;\n                const ret = !!this[UNZIP][ended ? 'end' : 'write'](chunk);\n                this[WRITING] = false;\n                cb?.();\n                return ret;\n            }\n        }\n        this[WRITING] = true;\n        if (this[UNZIP]) {\n            this[UNZIP].write(chunk);\n        }\n        else {\n            this[CONSUMECHUNK](chunk);\n        }\n        this[WRITING] = false;\n        // return false if there's a queue, or if the current entry isn't flowing\n        const ret = this[QUEUE].length ? false\n            : this[READENTRY] ? this[READENTRY].flowing\n                : true;\n        // if we have no queue, then that means a clogged READENTRY\n        if (!ret && !this[QUEUE].length) {\n            this[READENTRY]?.once('drain', () => this.emit('drain'));\n        }\n        /* c8 ignore next */\n        cb?.();\n        return ret;\n    }\n    [BUFFERCONCAT](c) {\n        if (c && !this[ABORTED]) {\n            this[BUFFER] =\n                this[BUFFER] ? Buffer.concat([this[BUFFER], c]) : c;\n        }\n    }\n    [MAYBEEND]() {\n        if (this[ENDED] &&\n            !this[EMITTEDEND] &&\n            !this[ABORTED] &&\n            !this[CONSUMING]) {\n            this[EMITTEDEND] = true;\n            const entry = this[WRITEENTRY];\n            if (entry && entry.blockRemain) {\n                // truncated, likely a damaged file\n                const have = this[BUFFER] ? this[BUFFER].length : 0;\n                this.warn('TAR_BAD_ARCHIVE', `Truncated input (needed ${entry.blockRemain} more bytes, only ${have} available)`, { entry });\n                if (this[BUFFER]) {\n                    entry.write(this[BUFFER]);\n                }\n                entry.end();\n            }\n            this[EMIT](DONE);\n        }\n    }\n    [CONSUMECHUNK](chunk) {\n        if (this[CONSUMING] && chunk) {\n            this[BUFFERCONCAT](chunk);\n        }\n        else if (!chunk && !this[BUFFER]) {\n            this[MAYBEEND]();\n        }\n        else if (chunk) {\n            this[CONSUMING] = true;\n            if (this[BUFFER]) {\n                this[BUFFERCONCAT](chunk);\n                const c = this[BUFFER];\n                this[BUFFER] = undefined;\n                this[CONSUMECHUNKSUB](c);\n            }\n            else {\n                this[CONSUMECHUNKSUB](chunk);\n            }\n            while (this[BUFFER] &&\n                this[BUFFER]?.length >= 512 &&\n                !this[ABORTED] &&\n                !this[SAW_EOF]) {\n                const c = this[BUFFER];\n                this[BUFFER] = undefined;\n                this[CONSUMECHUNKSUB](c);\n            }\n            this[CONSUMING] = false;\n        }\n        if (!this[BUFFER] || this[ENDED]) {\n            this[MAYBEEND]();\n        }\n    }\n    [CONSUMECHUNKSUB](chunk) {\n        // we know that we are in CONSUMING mode, so anything written goes into\n        // the buffer.  Advance the position and put any remainder in the buffer.\n        let position = 0;\n        const length = chunk.length;\n        while (position + 512 <= length &&\n            !this[ABORTED] &&\n            !this[SAW_EOF]) {\n            switch (this[STATE]) {\n                case 'begin':\n                case 'header':\n                    this[CONSUMEHEADER](chunk, position);\n                    position += 512;\n                    break;\n                case 'ignore':\n                case 'body':\n                    position += this[CONSUMEBODY](chunk, position);\n                    break;\n                case 'meta':\n                    position += this[CONSUMEMETA](chunk, position);\n                    break;\n                /* c8 ignore start */\n                default:\n                    throw new Error('invalid state: ' + this[STATE]);\n                /* c8 ignore stop */\n            }\n        }\n        if (position < length) {\n            if (this[BUFFER]) {\n                this[BUFFER] = Buffer.concat([\n                    chunk.subarray(position),\n                    this[BUFFER],\n                ]);\n            }\n            else {\n                this[BUFFER] = chunk.subarray(position);\n            }\n        }\n    }\n    end(chunk, encoding, cb) {\n        if (typeof chunk === 'function') {\n            cb = chunk;\n            encoding = undefined;\n            chunk = undefined;\n        }\n        if (typeof encoding === 'function') {\n            cb = encoding;\n            encoding = undefined;\n        }\n        if (typeof chunk === 'string') {\n            chunk = Buffer.from(chunk, encoding);\n        }\n        if (cb)\n            this.once('finish', cb);\n        if (!this[ABORTED]) {\n            if (this[UNZIP]) {\n                /* c8 ignore start */\n                if (chunk)\n                    this[UNZIP].write(chunk);\n                /* c8 ignore stop */\n                this[UNZIP].end();\n            }\n            else {\n                this[ENDED] = true;\n                if (this.brotli === undefined)\n                    chunk = chunk || Buffer.alloc(0);\n                if (chunk)\n                    this.write(chunk);\n                this[MAYBEEND]();\n            }\n        }\n        return this;\n    }\n}\n//# sourceMappingURL=parse.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvZXNtL3BhcnNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDNEM7QUFDTztBQUNqQjtBQUNHO0FBQ047QUFDYTtBQUNHO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHFCQUFxQixnREFBRTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw0Q0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyxRQUFRLDJEQUFVO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDhDQUFNO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxRQUFRO0FBQzdFO0FBQ0E7QUFDQSxxRUFBcUUsUUFBUTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSwwREFBMEQscURBQVM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsd0NBQUc7QUFDOUI7QUFDQTtBQUNBLDRCQUE0Qix3Q0FBRztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msb0JBQW9CO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG9EQUFvRDtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw4Q0FBTTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwyQ0FBSyxHQUFHO0FBQ3BDLDhCQUE4QixzREFBZ0IsR0FBRztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLG1CQUFtQixtQkFBbUIsTUFBTSxlQUFlLE9BQU87QUFDMUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aXZlLXZpYmUtYWktbmV4dC8uL25vZGVfbW9kdWxlcy90YXIvZGlzdC9lc20vcGFyc2UuanM/NGRlYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB0aGlzW0JVRkZFUl0gaXMgdGhlIHJlbWFpbmRlciBvZiBhIGNodW5rIGlmIHdlJ3JlIHdhaXRpbmcgZm9yXG4vLyB0aGUgZnVsbCA1MTIgYnl0ZXMgb2YgYSBoZWFkZXIgdG8gY29tZSBpbi4gIFdlIHdpbGwgQnVmZmVyLmNvbmNhdCgpXG4vLyBpdCB0byB0aGUgbmV4dCB3cml0ZSgpLCB3aGljaCBpcyBhIG1lbSBjb3B5LCBidXQgYSBzbWFsbCBvbmUuXG4vL1xuLy8gdGhpc1tRVUVVRV0gaXMgYSBZYWxsaXN0IG9mIGVudHJpZXMgdGhhdCBoYXZlbid0IGJlZW4gZW1pdHRlZFxuLy8geWV0IHRoaXMgY2FuIG9ubHkgZ2V0IGZpbGxlZCB1cCBpZiB0aGUgdXNlciBrZWVwcyB3cml0ZSgpaW5nIGFmdGVyXG4vLyBhIHdyaXRlKCkgcmV0dXJucyBmYWxzZSwgb3IgZG9lcyBhIHdyaXRlKCkgd2l0aCBtb3JlIHRoYW4gb25lIGVudHJ5XG4vL1xuLy8gV2UgZG9uJ3QgYnVmZmVyIGNodW5rcywgd2UgYWx3YXlzIHBhcnNlIHRoZW0gYW5kIGVpdGhlciBjcmVhdGUgYW5cbi8vIGVudHJ5LCBvciBwdXNoIGl0IGludG8gdGhlIGFjdGl2ZSBlbnRyeS4gIFRoZSBSZWFkRW50cnkgY2xhc3Mga25vd3Ncbi8vIHRvIHRocm93IGRhdGEgYXdheSBpZiAuaWdub3JlPXRydWVcbi8vXG4vLyBTaGlmdCBlbnRyeSBvZmYgdGhlIGJ1ZmZlciB3aGVuIGl0IGVtaXRzICdlbmQnLCBhbmQgZW1pdCAnZW50cnknIGZvclxuLy8gdGhlIG5leHQgb25lIGluIHRoZSBsaXN0LlxuLy9cbi8vIEF0IGFueSB0aW1lLCB3ZSdyZSBwdXNoaW5nIGJvZHkgY2h1bmtzIGludG8gdGhlIGVudHJ5IGF0IFdSSVRFRU5UUlksXG4vLyBhbmQgd2FpdGluZyBmb3IgJ2VuZCcgb24gdGhlIGVudHJ5IGF0IFJFQURFTlRSWVxuLy9cbi8vIGlnbm9yZWQgZW50cmllcyBnZXQgLnJlc3VtZSgpIGNhbGxlZCBvbiB0aGVtIHN0cmFpZ2h0IGF3YXlcbmltcG9ydCB7IEV2ZW50RW1pdHRlciBhcyBFRSB9IGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQgeyBCcm90bGlEZWNvbXByZXNzLCBVbnppcCB9IGZyb20gJ21pbml6bGliJztcbmltcG9ydCB7IFlhbGxpc3QgfSBmcm9tICd5YWxsaXN0JztcbmltcG9ydCB7IEhlYWRlciB9IGZyb20gJy4vaGVhZGVyLmpzJztcbmltcG9ydCB7IFBheCB9IGZyb20gJy4vcGF4LmpzJztcbmltcG9ydCB7IFJlYWRFbnRyeSB9IGZyb20gJy4vcmVhZC1lbnRyeS5qcyc7XG5pbXBvcnQgeyB3YXJuTWV0aG9kLCB9IGZyb20gJy4vd2Fybi1tZXRob2QuanMnO1xuY29uc3QgbWF4TWV0YUVudHJ5U2l6ZSA9IDEwMjQgKiAxMDI0O1xuY29uc3QgZ3ppcEhlYWRlciA9IEJ1ZmZlci5mcm9tKFsweDFmLCAweDhiXSk7XG5jb25zdCBTVEFURSA9IFN5bWJvbCgnc3RhdGUnKTtcbmNvbnN0IFdSSVRFRU5UUlkgPSBTeW1ib2woJ3dyaXRlRW50cnknKTtcbmNvbnN0IFJFQURFTlRSWSA9IFN5bWJvbCgncmVhZEVudHJ5Jyk7XG5jb25zdCBORVhURU5UUlkgPSBTeW1ib2woJ25leHRFbnRyeScpO1xuY29uc3QgUFJPQ0VTU0VOVFJZID0gU3ltYm9sKCdwcm9jZXNzRW50cnknKTtcbmNvbnN0IEVYID0gU3ltYm9sKCdleHRlbmRlZEhlYWRlcicpO1xuY29uc3QgR0VYID0gU3ltYm9sKCdnbG9iYWxFeHRlbmRlZEhlYWRlcicpO1xuY29uc3QgTUVUQSA9IFN5bWJvbCgnbWV0YScpO1xuY29uc3QgRU1JVE1FVEEgPSBTeW1ib2woJ2VtaXRNZXRhJyk7XG5jb25zdCBCVUZGRVIgPSBTeW1ib2woJ2J1ZmZlcicpO1xuY29uc3QgUVVFVUUgPSBTeW1ib2woJ3F1ZXVlJyk7XG5jb25zdCBFTkRFRCA9IFN5bWJvbCgnZW5kZWQnKTtcbmNvbnN0IEVNSVRURURFTkQgPSBTeW1ib2woJ2VtaXR0ZWRFbmQnKTtcbmNvbnN0IEVNSVQgPSBTeW1ib2woJ2VtaXQnKTtcbmNvbnN0IFVOWklQID0gU3ltYm9sKCd1bnppcCcpO1xuY29uc3QgQ09OU1VNRUNIVU5LID0gU3ltYm9sKCdjb25zdW1lQ2h1bmsnKTtcbmNvbnN0IENPTlNVTUVDSFVOS1NVQiA9IFN5bWJvbCgnY29uc3VtZUNodW5rU3ViJyk7XG5jb25zdCBDT05TVU1FQk9EWSA9IFN5bWJvbCgnY29uc3VtZUJvZHknKTtcbmNvbnN0IENPTlNVTUVNRVRBID0gU3ltYm9sKCdjb25zdW1lTWV0YScpO1xuY29uc3QgQ09OU1VNRUhFQURFUiA9IFN5bWJvbCgnY29uc3VtZUhlYWRlcicpO1xuY29uc3QgQ09OU1VNSU5HID0gU3ltYm9sKCdjb25zdW1pbmcnKTtcbmNvbnN0IEJVRkZFUkNPTkNBVCA9IFN5bWJvbCgnYnVmZmVyQ29uY2F0Jyk7XG5jb25zdCBNQVlCRUVORCA9IFN5bWJvbCgnbWF5YmVFbmQnKTtcbmNvbnN0IFdSSVRJTkcgPSBTeW1ib2woJ3dyaXRpbmcnKTtcbmNvbnN0IEFCT1JURUQgPSBTeW1ib2woJ2Fib3J0ZWQnKTtcbmNvbnN0IERPTkUgPSBTeW1ib2woJ29uRG9uZScpO1xuY29uc3QgU0FXX1ZBTElEX0VOVFJZID0gU3ltYm9sKCdzYXdWYWxpZEVudHJ5Jyk7XG5jb25zdCBTQVdfTlVMTF9CTE9DSyA9IFN5bWJvbCgnc2F3TnVsbEJsb2NrJyk7XG5jb25zdCBTQVdfRU9GID0gU3ltYm9sKCdzYXdFT0YnKTtcbmNvbnN0IENMT1NFU1RSRUFNID0gU3ltYm9sKCdjbG9zZVN0cmVhbScpO1xuY29uc3Qgbm9vcCA9ICgpID0+IHRydWU7XG5leHBvcnQgY2xhc3MgUGFyc2VyIGV4dGVuZHMgRUUge1xuICAgIGZpbGU7XG4gICAgc3RyaWN0O1xuICAgIG1heE1ldGFFbnRyeVNpemU7XG4gICAgZmlsdGVyO1xuICAgIGJyb3RsaTtcbiAgICB3cml0YWJsZSA9IHRydWU7XG4gICAgcmVhZGFibGUgPSBmYWxzZTtcbiAgICBbUVVFVUVdID0gbmV3IFlhbGxpc3QoKTtcbiAgICBbQlVGRkVSXTtcbiAgICBbUkVBREVOVFJZXTtcbiAgICBbV1JJVEVFTlRSWV07XG4gICAgW1NUQVRFXSA9ICdiZWdpbic7XG4gICAgW01FVEFdID0gJyc7XG4gICAgW0VYXTtcbiAgICBbR0VYXTtcbiAgICBbRU5ERURdID0gZmFsc2U7XG4gICAgW1VOWklQXTtcbiAgICBbQUJPUlRFRF0gPSBmYWxzZTtcbiAgICBbU0FXX1ZBTElEX0VOVFJZXTtcbiAgICBbU0FXX05VTExfQkxPQ0tdID0gZmFsc2U7XG4gICAgW1NBV19FT0ZdID0gZmFsc2U7XG4gICAgW1dSSVRJTkddID0gZmFsc2U7XG4gICAgW0NPTlNVTUlOR10gPSBmYWxzZTtcbiAgICBbRU1JVFRFREVORF0gPSBmYWxzZTtcbiAgICBjb25zdHJ1Y3RvcihvcHQgPSB7fSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZpbGUgPSBvcHQuZmlsZSB8fCAnJztcbiAgICAgICAgLy8gdGhlc2UgQkFEQVJDSElWRSBlcnJvcnMgY2FuJ3QgYmUgZGV0ZWN0ZWQgZWFybHkuIGxpc3RlbiBvbiBET05FLlxuICAgICAgICB0aGlzLm9uKERPTkUsICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzW1NUQVRFXSA9PT0gJ2JlZ2luJyB8fFxuICAgICAgICAgICAgICAgIHRoaXNbU0FXX1ZBTElEX0VOVFJZXSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAvLyBlaXRoZXIgbGVzcyB0aGFuIDEgYmxvY2sgb2YgZGF0YSwgb3IgYWxsIGVudHJpZXMgd2VyZSBpbnZhbGlkLlxuICAgICAgICAgICAgICAgIC8vIEVpdGhlciB3YXksIHByb2JhYmx5IG5vdCBldmVuIGEgdGFyYmFsbC5cbiAgICAgICAgICAgICAgICB0aGlzLndhcm4oJ1RBUl9CQURfQVJDSElWRScsICdVbnJlY29nbml6ZWQgYXJjaGl2ZSBmb3JtYXQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChvcHQub25kb25lKSB7XG4gICAgICAgICAgICB0aGlzLm9uKERPTkUsIG9wdC5vbmRvbmUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vbihET05FLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2ZpbmlzaCcpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZW5kJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0cmljdCA9ICEhb3B0LnN0cmljdDtcbiAgICAgICAgdGhpcy5tYXhNZXRhRW50cnlTaXplID0gb3B0Lm1heE1ldGFFbnRyeVNpemUgfHwgbWF4TWV0YUVudHJ5U2l6ZTtcbiAgICAgICAgdGhpcy5maWx0ZXIgPSB0eXBlb2Ygb3B0LmZpbHRlciA9PT0gJ2Z1bmN0aW9uJyA/IG9wdC5maWx0ZXIgOiBub29wO1xuICAgICAgICAvLyBVbmxpa2UgZ3ppcCwgYnJvdGxpIGRvZXNuJ3QgaGF2ZSBhbnkgbWFnaWMgYnl0ZXMgdG8gaWRlbnRpZnkgaXRcbiAgICAgICAgLy8gVXNlcnMgbmVlZCB0byBleHBsaWNpdGx5IHRlbGwgdXMgdGhleSdyZSBleHRyYWN0aW5nIGEgYnJvdGxpIGZpbGVcbiAgICAgICAgLy8gT3Igd2UgaW5mZXIgZnJvbSB0aGUgZmlsZSBleHRlbnNpb25cbiAgICAgICAgY29uc3QgaXNUQlIgPSBvcHQuZmlsZSAmJlxuICAgICAgICAgICAgKG9wdC5maWxlLmVuZHNXaXRoKCcudGFyLmJyJykgfHwgb3B0LmZpbGUuZW5kc1dpdGgoJy50YnInKSk7XG4gICAgICAgIC8vIGlmIGl0J3MgYSB0YnIgZmlsZSBpdCBNSUdIVCBiZSBicm90bGksIGJ1dCB3ZSBkb24ndCBrbm93IHVudGlsXG4gICAgICAgIC8vIHdlIGxvb2sgYXQgaXQgYW5kIHZlcmlmeSBpdCdzIG5vdCBhIHZhbGlkIHRhciBmaWxlLlxuICAgICAgICB0aGlzLmJyb3RsaSA9XG4gICAgICAgICAgICAhb3B0Lmd6aXAgJiYgb3B0LmJyb3RsaSAhPT0gdW5kZWZpbmVkID8gb3B0LmJyb3RsaVxuICAgICAgICAgICAgICAgIDogaXNUQlIgPyB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgOiBmYWxzZTtcbiAgICAgICAgLy8gaGF2ZSB0byBzZXQgdGhpcyBzbyB0aGF0IHN0cmVhbXMgYXJlIG9rIHBpcGluZyBpbnRvIGl0XG4gICAgICAgIHRoaXMub24oJ2VuZCcsICgpID0+IHRoaXNbQ0xPU0VTVFJFQU1dKCkpO1xuICAgICAgICBpZiAodHlwZW9mIG9wdC5vbndhcm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMub24oJ3dhcm4nLCBvcHQub253YXJuKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9wdC5vblJlYWRFbnRyeSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5vbignZW50cnknLCBvcHQub25SZWFkRW50cnkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdhcm4oY29kZSwgbWVzc2FnZSwgZGF0YSA9IHt9KSB7XG4gICAgICAgIHdhcm5NZXRob2QodGhpcywgY29kZSwgbWVzc2FnZSwgZGF0YSk7XG4gICAgfVxuICAgIFtDT05TVU1FSEVBREVSXShjaHVuaywgcG9zaXRpb24pIHtcbiAgICAgICAgaWYgKHRoaXNbU0FXX1ZBTElEX0VOVFJZXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzW1NBV19WQUxJRF9FTlRSWV0gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaGVhZGVyO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaGVhZGVyID0gbmV3IEhlYWRlcihjaHVuaywgcG9zaXRpb24sIHRoaXNbRVhdLCB0aGlzW0dFWF0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2FybignVEFSX0VOVFJZX0lOVkFMSUQnLCBlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlYWRlci5udWxsQmxvY2spIHtcbiAgICAgICAgICAgIGlmICh0aGlzW1NBV19OVUxMX0JMT0NLXSkge1xuICAgICAgICAgICAgICAgIHRoaXNbU0FXX0VPRl0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIGVuZGluZyBhbiBhcmNoaXZlIHdpdGggbm8gZW50cmllcy4gIHBvaW50bGVzcywgYnV0IGxlZ2FsLlxuICAgICAgICAgICAgICAgIGlmICh0aGlzW1NUQVRFXSA9PT0gJ2JlZ2luJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW1NUQVRFXSA9ICdoZWFkZXInO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzW0VNSVRdKCdlb2YnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXNbU0FXX05VTExfQkxPQ0tdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzW0VNSVRdKCdudWxsQmxvY2snKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXNbU0FXX05VTExfQkxPQ0tdID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoIWhlYWRlci5ja3N1bVZhbGlkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53YXJuKCdUQVJfRU5UUllfSU5WQUxJRCcsICdjaGVja3N1bSBmYWlsdXJlJywgeyBoZWFkZXIgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghaGVhZGVyLnBhdGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndhcm4oJ1RBUl9FTlRSWV9JTlZBTElEJywgJ3BhdGggaXMgcmVxdWlyZWQnLCB7IGhlYWRlciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBoZWFkZXIudHlwZTtcbiAgICAgICAgICAgICAgICBpZiAoL14oU3ltYm9saWMpP0xpbmskLy50ZXN0KHR5cGUpICYmICFoZWFkZXIubGlua3BhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53YXJuKCdUQVJfRU5UUllfSU5WQUxJRCcsICdsaW5rcGF0aCByZXF1aXJlZCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcixcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCEvXihTeW1ib2xpYyk/TGluayQvLnRlc3QodHlwZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgIS9eKEdsb2JhbCk/RXh0ZW5kZWRIZWFkZXIkLy50ZXN0KHR5cGUpICYmXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlci5saW5rcGF0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLndhcm4oJ1RBUl9FTlRSWV9JTlZBTElEJywgJ2xpbmtwYXRoIGZvcmJpZGRlbicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcixcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbnRyeSA9ICh0aGlzW1dSSVRFRU5UUlldID0gbmV3IFJlYWRFbnRyeShoZWFkZXIsIHRoaXNbRVhdLCB0aGlzW0dFWF0pKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgZG8gdGhpcyBmb3IgbWV0YSAmIGlnbm9yZWQgZW50cmllcyBhcyB3ZWxsLCBiZWNhdXNlIHRoZXlcbiAgICAgICAgICAgICAgICAgICAgLy8gYXJlIHN0aWxsIHZhbGlkIHRhciwgb3IgZWxzZSB3ZSB3b3VsZG4ndCBrbm93IHRvIGlnbm9yZSB0aGVtXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpc1tTQVdfVkFMSURfRU5UUlldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW50cnkucmVtYWluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBtaWdodCBiZSB0aGUgb25lIVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9uZW5kID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWVudHJ5LmludmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbU0FXX1ZBTElEX0VOVFJZXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5Lm9uKCdlbmQnLCBvbmVuZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW1NBV19WQUxJRF9FTlRSWV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbnRyeS5tZXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW50cnkuc2l6ZSA+IHRoaXMubWF4TWV0YUVudHJ5U2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5Lmlnbm9yZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tFTUlUXSgnaWdub3JlZEVudHJ5JywgZW50cnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbU1RBVEVdID0gJ2lnbm9yZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cnkucmVzdW1lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChlbnRyeS5zaXplID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbTUVUQV0gPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyeS5vbignZGF0YScsIGMgPT4gKHRoaXNbTUVUQV0gKz0gYykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbU1RBVEVdID0gJ21ldGEnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tFWF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRyeS5pZ25vcmUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5Lmlnbm9yZSB8fCAhdGhpcy5maWx0ZXIoZW50cnkucGF0aCwgZW50cnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJ5Lmlnbm9yZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByb2JhYmx5IHZhbGlkLCBqdXN0IG5vdCBzb21ldGhpbmcgd2UgY2FyZSBhYm91dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbRU1JVF0oJ2lnbm9yZWRFbnRyeScsIGVudHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW1NUQVRFXSA9IGVudHJ5LnJlbWFpbiA/ICdpZ25vcmUnIDogJ2hlYWRlcic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cnkucmVzdW1lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW50cnkucmVtYWluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbU1RBVEVdID0gJ2JvZHknO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tTVEFURV0gPSAnaGVhZGVyJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cnkuZW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpc1tSRUFERU5UUlldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbUVVFVUVdLnB1c2goZW50cnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW05FWFRFTlRSWV0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbUVVFVUVdLnB1c2goZW50cnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBbQ0xPU0VTVFJFQU1dKCkge1xuICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB0aGlzLmVtaXQoJ2Nsb3NlJykpO1xuICAgIH1cbiAgICBbUFJPQ0VTU0VOVFJZXShlbnRyeSkge1xuICAgICAgICBsZXQgZ28gPSB0cnVlO1xuICAgICAgICBpZiAoIWVudHJ5KSB7XG4gICAgICAgICAgICB0aGlzW1JFQURFTlRSWV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBnbyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZW50cnkpKSB7XG4gICAgICAgICAgICBjb25zdCBbZXYsIC4uLmFyZ3NdID0gZW50cnk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoZXYsIC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpc1tSRUFERU5UUlldID0gZW50cnk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2VudHJ5JywgZW50cnkpO1xuICAgICAgICAgICAgaWYgKCFlbnRyeS5lbWl0dGVkRW5kKSB7XG4gICAgICAgICAgICAgICAgZW50cnkub24oJ2VuZCcsICgpID0+IHRoaXNbTkVYVEVOVFJZXSgpKTtcbiAgICAgICAgICAgICAgICBnbyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnbztcbiAgICB9XG4gICAgW05FWFRFTlRSWV0oKSB7XG4gICAgICAgIGRvIHsgfSB3aGlsZSAodGhpc1tQUk9DRVNTRU5UUlldKHRoaXNbUVVFVUVdLnNoaWZ0KCkpKTtcbiAgICAgICAgaWYgKCF0aGlzW1FVRVVFXS5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQsIHRoZXJlJ3Mgbm90aGluZyBpbiB0aGUgcXVldWUsIGJ1dCB3ZSBtYXkgaGF2ZSBhblxuICAgICAgICAgICAgLy8gZW50cnkgd2hpY2ggaXMgYmVpbmcgY29uc3VtZWQgKHJlYWRFbnRyeSkuXG4gICAgICAgICAgICAvLyBJZiB3ZSBkb24ndCwgdGhlbiB3ZSBkZWZpbml0ZWx5IGNhbiBoYW5kbGUgbW9yZSBkYXRhLlxuICAgICAgICAgICAgLy8gSWYgd2UgZG8sIGFuZCBlaXRoZXIgaXQncyBmbG93aW5nLCBvciBpdCBoYXMgbmV2ZXIgaGFkIGFueSBkYXRhXG4gICAgICAgICAgICAvLyB3cml0dGVuIHRvIGl0LCB0aGVuIGl0IG5lZWRzIG1vcmUuXG4gICAgICAgICAgICAvLyBUaGUgb25seSBvdGhlciBwb3NzaWJpbGl0eSBpcyB0aGF0IGl0IGhhcyByZXR1cm5lZCBmYWxzZSBmcm9tIGFcbiAgICAgICAgICAgIC8vIHdyaXRlKCkgY2FsbCwgc28gd2Ugd2FpdCBmb3IgdGhlIG5leHQgZHJhaW4gdG8gY29udGludWUuXG4gICAgICAgICAgICBjb25zdCByZSA9IHRoaXNbUkVBREVOVFJZXTtcbiAgICAgICAgICAgIGNvbnN0IGRyYWluTm93ID0gIXJlIHx8IHJlLmZsb3dpbmcgfHwgcmUuc2l6ZSA9PT0gcmUucmVtYWluO1xuICAgICAgICAgICAgaWYgKGRyYWluTm93KSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzW1dSSVRJTkddKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZHJhaW4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZS5vbmNlKCdkcmFpbicsICgpID0+IHRoaXMuZW1pdCgnZHJhaW4nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgW0NPTlNVTUVCT0RZXShjaHVuaywgcG9zaXRpb24pIHtcbiAgICAgICAgLy8gd3JpdGUgdXAgdG8gYnV0IG5vICBtb3JlIHRoYW4gd3JpdGVFbnRyeS5ibG9ja1JlbWFpblxuICAgICAgICBjb25zdCBlbnRyeSA9IHRoaXNbV1JJVEVFTlRSWV07XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICBpZiAoIWVudHJ5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2F0dGVtcHQgdG8gY29uc3VtZSBib2R5IHdpdGhvdXQgZW50cnk/PycpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJyID0gZW50cnkuYmxvY2tSZW1haW4gPz8gMDtcbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgY29uc3QgYyA9IGJyID49IGNodW5rLmxlbmd0aCAmJiBwb3NpdGlvbiA9PT0gMCA/XG4gICAgICAgICAgICBjaHVua1xuICAgICAgICAgICAgOiBjaHVuay5zdWJhcnJheShwb3NpdGlvbiwgcG9zaXRpb24gKyBicik7XG4gICAgICAgIGVudHJ5LndyaXRlKGMpO1xuICAgICAgICBpZiAoIWVudHJ5LmJsb2NrUmVtYWluKSB7XG4gICAgICAgICAgICB0aGlzW1NUQVRFXSA9ICdoZWFkZXInO1xuICAgICAgICAgICAgdGhpc1tXUklURUVOVFJZXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGVudHJ5LmVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjLmxlbmd0aDtcbiAgICB9XG4gICAgW0NPTlNVTUVNRVRBXShjaHVuaywgcG9zaXRpb24pIHtcbiAgICAgICAgY29uc3QgZW50cnkgPSB0aGlzW1dSSVRFRU5UUlldO1xuICAgICAgICBjb25zdCByZXQgPSB0aGlzW0NPTlNVTUVCT0RZXShjaHVuaywgcG9zaXRpb24pO1xuICAgICAgICAvLyBpZiB3ZSBmaW5pc2hlZCwgdGhlbiB0aGUgZW50cnkgaXMgcmVzZXRcbiAgICAgICAgaWYgKCF0aGlzW1dSSVRFRU5UUlldICYmIGVudHJ5KSB7XG4gICAgICAgICAgICB0aGlzW0VNSVRNRVRBXShlbnRyeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgW0VNSVRdKGV2LCBkYXRhLCBleHRyYSkge1xuICAgICAgICBpZiAoIXRoaXNbUVVFVUVdLmxlbmd0aCAmJiAhdGhpc1tSRUFERU5UUlldKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoZXYsIGRhdGEsIGV4dHJhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXNbUVVFVUVdLnB1c2goW2V2LCBkYXRhLCBleHRyYV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIFtFTUlUTUVUQV0oZW50cnkpIHtcbiAgICAgICAgdGhpc1tFTUlUXSgnbWV0YScsIHRoaXNbTUVUQV0pO1xuICAgICAgICBzd2l0Y2ggKGVudHJ5LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ0V4dGVuZGVkSGVhZGVyJzpcbiAgICAgICAgICAgIGNhc2UgJ09sZEV4dGVuZGVkSGVhZGVyJzpcbiAgICAgICAgICAgICAgICB0aGlzW0VYXSA9IFBheC5wYXJzZSh0aGlzW01FVEFdLCB0aGlzW0VYXSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnR2xvYmFsRXh0ZW5kZWRIZWFkZXInOlxuICAgICAgICAgICAgICAgIHRoaXNbR0VYXSA9IFBheC5wYXJzZSh0aGlzW01FVEFdLCB0aGlzW0dFWF0sIHRydWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnTmV4dEZpbGVIYXNMb25nUGF0aCc6XG4gICAgICAgICAgICBjYXNlICdPbGRHbnVMb25nUGF0aCc6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBleCA9IHRoaXNbRVhdID8/IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICAgICAgdGhpc1tFWF0gPSBleDtcbiAgICAgICAgICAgICAgICBleC5wYXRoID0gdGhpc1tNRVRBXS5yZXBsYWNlKC9cXDAuKi8sICcnKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ05leHRGaWxlSGFzTG9uZ0xpbmtwYXRoJzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4ID0gdGhpc1tFWF0gfHwgT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgICAgICB0aGlzW0VYXSA9IGV4O1xuICAgICAgICAgICAgICAgIGV4LmxpbmtwYXRoID0gdGhpc1tNRVRBXS5yZXBsYWNlKC9cXDAuKi8sICcnKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gbWV0YTogJyArIGVudHJ5LnR5cGUpO1xuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgfVxuICAgIH1cbiAgICBhYm9ydChlcnJvcikge1xuICAgICAgICB0aGlzW0FCT1JURURdID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lbWl0KCdhYm9ydCcsIGVycm9yKTtcbiAgICAgICAgLy8gYWx3YXlzIHRocm93cywgZXZlbiBpbiBub24tc3RyaWN0IG1vZGVcbiAgICAgICAgdGhpcy53YXJuKCdUQVJfQUJPUlQnLCBlcnJvciwgeyByZWNvdmVyYWJsZTogZmFsc2UgfSk7XG4gICAgfVxuICAgIHdyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2IgPSBlbmNvZGluZztcbiAgICAgICAgICAgIGVuY29kaW5nID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBcbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnID8gZW5jb2RpbmcgOiAndXRmOCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzW0FCT1JURURdKSB7XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgY2I/LigpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZpcnN0IHdyaXRlLCBtaWdodCBiZSBnemlwcGVkXG4gICAgICAgIGNvbnN0IG5lZWRTbmlmZiA9IHRoaXNbVU5aSVBdID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICh0aGlzLmJyb3RsaSA9PT0gdW5kZWZpbmVkICYmIHRoaXNbVU5aSVBdID09PSBmYWxzZSk7XG4gICAgICAgIGlmIChuZWVkU25pZmYgJiYgY2h1bmspIHtcbiAgICAgICAgICAgIGlmICh0aGlzW0JVRkZFUl0pIHtcbiAgICAgICAgICAgICAgICBjaHVuayA9IEJ1ZmZlci5jb25jYXQoW3RoaXNbQlVGRkVSXSwgY2h1bmtdKTtcbiAgICAgICAgICAgICAgICB0aGlzW0JVRkZFUl0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2h1bmsubGVuZ3RoIDwgZ3ppcEhlYWRlci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzW0JVRkZFUl0gPSBjaHVuaztcbiAgICAgICAgICAgICAgICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgICAgIGNiPy4oKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGxvb2sgZm9yIGd6aXAgaGVhZGVyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgdGhpc1tVTlpJUF0gPT09IHVuZGVmaW5lZCAmJiBpIDwgZ3ppcEhlYWRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChjaHVua1tpXSAhPT0gZ3ppcEhlYWRlcltpXSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW1VOWklQXSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1heWJlQnJvdGxpID0gdGhpcy5icm90bGkgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICh0aGlzW1VOWklQXSA9PT0gZmFsc2UgJiYgbWF5YmVCcm90bGkpIHtcbiAgICAgICAgICAgICAgICAvLyByZWFkIHRoZSBmaXJzdCBoZWFkZXIgdG8gc2VlIGlmIGl0J3MgYSB2YWxpZCB0YXIgZmlsZS4gSWYgc28sXG4gICAgICAgICAgICAgICAgLy8gd2UgY2FuIHNhZmVseSBhc3N1bWUgdGhhdCBpdCdzIG5vdCBhY3R1YWxseSBicm90bGksIGRlc3BpdGUgdGhlXG4gICAgICAgICAgICAgICAgLy8gLnRiciBvciAudGFyLmJyIGZpbGUgZXh0ZW5zaW9uLlxuICAgICAgICAgICAgICAgIC8vIGlmIHdlIGVuZGVkIGJlZm9yZSBnZXR0aW5nIGEgZnVsbCBjaHVuaywgeWVzLCBkZWYgYnJvdGxpXG4gICAgICAgICAgICAgICAgaWYgKGNodW5rLmxlbmd0aCA8IDUxMikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpc1tFTkRFRF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYnJvdGxpID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbQlVGRkVSXSA9IGNodW5rO1xuICAgICAgICAgICAgICAgICAgICAgICAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGNiPy4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBpdCdzIHRhciwgaXQncyBwcmV0dHkgcmVsaWFibHkgbm90IGJyb3RsaSwgY2hhbmNlcyBvZlxuICAgICAgICAgICAgICAgICAgICAvLyB0aGF0IGhhcHBlbmluZyBhcmUgYXN0cm9ub21pY2FsLlxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IEhlYWRlcihjaHVuay5zdWJhcnJheSgwLCA1MTIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYnJvdGxpID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYnJvdGxpID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzW1VOWklQXSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgKHRoaXNbVU5aSVBdID09PSBmYWxzZSAmJiB0aGlzLmJyb3RsaSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbmRlZCA9IHRoaXNbRU5ERURdO1xuICAgICAgICAgICAgICAgIHRoaXNbRU5ERURdID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpc1tVTlpJUF0gPVxuICAgICAgICAgICAgICAgICAgICB0aGlzW1VOWklQXSA9PT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBVbnppcCh7fSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogbmV3IEJyb3RsaURlY29tcHJlc3Moe30pO1xuICAgICAgICAgICAgICAgIHRoaXNbVU5aSVBdLm9uKCdkYXRhJywgY2h1bmsgPT4gdGhpc1tDT05TVU1FQ0hVTktdKGNodW5rKSk7XG4gICAgICAgICAgICAgICAgdGhpc1tVTlpJUF0ub24oJ2Vycm9yJywgZXIgPT4gdGhpcy5hYm9ydChlcikpO1xuICAgICAgICAgICAgICAgIHRoaXNbVU5aSVBdLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbRU5ERURdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tDT05TVU1FQ0hVTktdKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpc1tXUklUSU5HXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc3QgcmV0ID0gISF0aGlzW1VOWklQXVtlbmRlZCA/ICdlbmQnIDogJ3dyaXRlJ10oY2h1bmspO1xuICAgICAgICAgICAgICAgIHRoaXNbV1JJVElOR10gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjYj8uKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzW1dSSVRJTkddID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXNbVU5aSVBdKSB7XG4gICAgICAgICAgICB0aGlzW1VOWklQXS53cml0ZShjaHVuayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzW0NPTlNVTUVDSFVOS10oY2h1bmspO1xuICAgICAgICB9XG4gICAgICAgIHRoaXNbV1JJVElOR10gPSBmYWxzZTtcbiAgICAgICAgLy8gcmV0dXJuIGZhbHNlIGlmIHRoZXJlJ3MgYSBxdWV1ZSwgb3IgaWYgdGhlIGN1cnJlbnQgZW50cnkgaXNuJ3QgZmxvd2luZ1xuICAgICAgICBjb25zdCByZXQgPSB0aGlzW1FVRVVFXS5sZW5ndGggPyBmYWxzZVxuICAgICAgICAgICAgOiB0aGlzW1JFQURFTlRSWV0gPyB0aGlzW1JFQURFTlRSWV0uZmxvd2luZ1xuICAgICAgICAgICAgICAgIDogdHJ1ZTtcbiAgICAgICAgLy8gaWYgd2UgaGF2ZSBubyBxdWV1ZSwgdGhlbiB0aGF0IG1lYW5zIGEgY2xvZ2dlZCBSRUFERU5UUllcbiAgICAgICAgaWYgKCFyZXQgJiYgIXRoaXNbUVVFVUVdLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpc1tSRUFERU5UUlldPy5vbmNlKCdkcmFpbicsICgpID0+IHRoaXMuZW1pdCgnZHJhaW4nKSk7XG4gICAgICAgIH1cbiAgICAgICAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgICAgICAgY2I/LigpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBbQlVGRkVSQ09OQ0FUXShjKSB7XG4gICAgICAgIGlmIChjICYmICF0aGlzW0FCT1JURURdKSB7XG4gICAgICAgICAgICB0aGlzW0JVRkZFUl0gPVxuICAgICAgICAgICAgICAgIHRoaXNbQlVGRkVSXSA/IEJ1ZmZlci5jb25jYXQoW3RoaXNbQlVGRkVSXSwgY10pIDogYztcbiAgICAgICAgfVxuICAgIH1cbiAgICBbTUFZQkVFTkRdKCkge1xuICAgICAgICBpZiAodGhpc1tFTkRFRF0gJiZcbiAgICAgICAgICAgICF0aGlzW0VNSVRURURFTkRdICYmXG4gICAgICAgICAgICAhdGhpc1tBQk9SVEVEXSAmJlxuICAgICAgICAgICAgIXRoaXNbQ09OU1VNSU5HXSkge1xuICAgICAgICAgICAgdGhpc1tFTUlUVEVERU5EXSA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCBlbnRyeSA9IHRoaXNbV1JJVEVFTlRSWV07XG4gICAgICAgICAgICBpZiAoZW50cnkgJiYgZW50cnkuYmxvY2tSZW1haW4pIHtcbiAgICAgICAgICAgICAgICAvLyB0cnVuY2F0ZWQsIGxpa2VseSBhIGRhbWFnZWQgZmlsZVxuICAgICAgICAgICAgICAgIGNvbnN0IGhhdmUgPSB0aGlzW0JVRkZFUl0gPyB0aGlzW0JVRkZFUl0ubGVuZ3RoIDogMDtcbiAgICAgICAgICAgICAgICB0aGlzLndhcm4oJ1RBUl9CQURfQVJDSElWRScsIGBUcnVuY2F0ZWQgaW5wdXQgKG5lZWRlZCAke2VudHJ5LmJsb2NrUmVtYWlufSBtb3JlIGJ5dGVzLCBvbmx5ICR7aGF2ZX0gYXZhaWxhYmxlKWAsIHsgZW50cnkgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXNbQlVGRkVSXSkge1xuICAgICAgICAgICAgICAgICAgICBlbnRyeS53cml0ZSh0aGlzW0JVRkZFUl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbnRyeS5lbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXNbRU1JVF0oRE9ORSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgW0NPTlNVTUVDSFVOS10oY2h1bmspIHtcbiAgICAgICAgaWYgKHRoaXNbQ09OU1VNSU5HXSAmJiBjaHVuaykge1xuICAgICAgICAgICAgdGhpc1tCVUZGRVJDT05DQVRdKGNodW5rKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghY2h1bmsgJiYgIXRoaXNbQlVGRkVSXSkge1xuICAgICAgICAgICAgdGhpc1tNQVlCRUVORF0oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaHVuaykge1xuICAgICAgICAgICAgdGhpc1tDT05TVU1JTkddID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzW0JVRkZFUl0pIHtcbiAgICAgICAgICAgICAgICB0aGlzW0JVRkZFUkNPTkNBVF0oY2h1bmspO1xuICAgICAgICAgICAgICAgIGNvbnN0IGMgPSB0aGlzW0JVRkZFUl07XG4gICAgICAgICAgICAgICAgdGhpc1tCVUZGRVJdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRoaXNbQ09OU1VNRUNIVU5LU1VCXShjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXNbQ09OU1VNRUNIVU5LU1VCXShjaHVuayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAodGhpc1tCVUZGRVJdICYmXG4gICAgICAgICAgICAgICAgdGhpc1tCVUZGRVJdPy5sZW5ndGggPj0gNTEyICYmXG4gICAgICAgICAgICAgICAgIXRoaXNbQUJPUlRFRF0gJiZcbiAgICAgICAgICAgICAgICAhdGhpc1tTQVdfRU9GXSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGMgPSB0aGlzW0JVRkZFUl07XG4gICAgICAgICAgICAgICAgdGhpc1tCVUZGRVJdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRoaXNbQ09OU1VNRUNIVU5LU1VCXShjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXNbQ09OU1VNSU5HXSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpc1tCVUZGRVJdIHx8IHRoaXNbRU5ERURdKSB7XG4gICAgICAgICAgICB0aGlzW01BWUJFRU5EXSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFtDT05TVU1FQ0hVTktTVUJdKGNodW5rKSB7XG4gICAgICAgIC8vIHdlIGtub3cgdGhhdCB3ZSBhcmUgaW4gQ09OU1VNSU5HIG1vZGUsIHNvIGFueXRoaW5nIHdyaXR0ZW4gZ29lcyBpbnRvXG4gICAgICAgIC8vIHRoZSBidWZmZXIuICBBZHZhbmNlIHRoZSBwb3NpdGlvbiBhbmQgcHV0IGFueSByZW1haW5kZXIgaW4gdGhlIGJ1ZmZlci5cbiAgICAgICAgbGV0IHBvc2l0aW9uID0gMDtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gY2h1bmsubGVuZ3RoO1xuICAgICAgICB3aGlsZSAocG9zaXRpb24gKyA1MTIgPD0gbGVuZ3RoICYmXG4gICAgICAgICAgICAhdGhpc1tBQk9SVEVEXSAmJlxuICAgICAgICAgICAgIXRoaXNbU0FXX0VPRl0pIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpc1tTVEFURV0pIHtcbiAgICAgICAgICAgICAgICBjYXNlICdiZWdpbic6XG4gICAgICAgICAgICAgICAgY2FzZSAnaGVhZGVyJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tDT05TVU1FSEVBREVSXShjaHVuaywgcG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiArPSA1MTI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2lnbm9yZSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9keSc6XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uICs9IHRoaXNbQ09OU1VNRUJPRFldKGNodW5rLCBwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ21ldGEnOlxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiArPSB0aGlzW0NPTlNVTUVNRVRBXShjaHVuaywgcG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc3RhdGU6ICcgKyB0aGlzW1NUQVRFXSk7XG4gICAgICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zaXRpb24gPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzW0JVRkZFUl0pIHtcbiAgICAgICAgICAgICAgICB0aGlzW0JVRkZFUl0gPSBCdWZmZXIuY29uY2F0KFtcbiAgICAgICAgICAgICAgICAgICAgY2h1bmsuc3ViYXJyYXkocG9zaXRpb24pLFxuICAgICAgICAgICAgICAgICAgICB0aGlzW0JVRkZFUl0sXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzW0JVRkZFUl0gPSBjaHVuay5zdWJhcnJheShwb3NpdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZW5kKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2IgPSBjaHVuaztcbiAgICAgICAgICAgIGVuY29kaW5nID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY2h1bmsgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2IgPSBlbmNvZGluZztcbiAgICAgICAgICAgIGVuY29kaW5nID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNiKVxuICAgICAgICAgICAgdGhpcy5vbmNlKCdmaW5pc2gnLCBjYik7XG4gICAgICAgIGlmICghdGhpc1tBQk9SVEVEXSkge1xuICAgICAgICAgICAgaWYgKHRoaXNbVU5aSVBdKSB7XG4gICAgICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICAgICAgaWYgKGNodW5rKVxuICAgICAgICAgICAgICAgICAgICB0aGlzW1VOWklQXS53cml0ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgICAgICAgICB0aGlzW1VOWklQXS5lbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXNbRU5ERURdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5icm90bGkgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgY2h1bmsgPSBjaHVuayB8fCBCdWZmZXIuYWxsb2MoMCk7XG4gICAgICAgICAgICAgICAgaWYgKGNodW5rKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLndyaXRlKGNodW5rKTtcbiAgICAgICAgICAgICAgICB0aGlzW01BWUJFRU5EXSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnNlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/tar/dist/esm/parse.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/tar/dist/esm/path-reservations.js":
/*!********************************************************!*\
  !*** ./node_modules/tar/dist/esm/path-reservations.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PathReservations: () => (/* binding */ PathReservations)\n/* harmony export */ });\n/* harmony import */ var node_path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:path */ \"node:path\");\n/* harmony import */ var _normalize_unicode_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./normalize-unicode.js */ \"(rsc)/./node_modules/tar/dist/esm/normalize-unicode.js\");\n/* harmony import */ var _strip_trailing_slashes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./strip-trailing-slashes.js */ \"(rsc)/./node_modules/tar/dist/esm/strip-trailing-slashes.js\");\n// A path exclusive reservation system\n// reserve([list, of, paths], fn)\n// When the fn is first in line for all its paths, it\n// is called with a cb that clears the reservation.\n//\n// Used by async unpack to avoid clobbering paths in use,\n// while still allowing maximal safe parallelization.\n\n\n\nconst platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;\nconst isWindows = platform === 'win32';\n// return a set of parent dirs for a given path\n// '/a/b/c/d' -> ['/', '/a', '/a/b', '/a/b/c', '/a/b/c/d']\nconst getDirs = (path) => {\n    const dirs = path\n        .split('/')\n        .slice(0, -1)\n        .reduce((set, path) => {\n        const s = set[set.length - 1];\n        if (s !== undefined) {\n            path = (0,node_path__WEBPACK_IMPORTED_MODULE_0__.join)(s, path);\n        }\n        set.push(path || '/');\n        return set;\n    }, []);\n    return dirs;\n};\nclass PathReservations {\n    // path => [function or Set]\n    // A Set object means a directory reservation\n    // A fn is a direct reservation on that path\n    #queues = new Map();\n    // fn => {paths:[path,...], dirs:[path, ...]}\n    #reservations = new Map();\n    // functions currently running\n    #running = new Set();\n    reserve(paths, fn) {\n        paths =\n            isWindows ?\n                ['win32 parallelization disabled']\n                : paths.map(p => {\n                    // don't need normPath, because we skip this entirely for windows\n                    return (0,_strip_trailing_slashes_js__WEBPACK_IMPORTED_MODULE_2__.stripTrailingSlashes)((0,node_path__WEBPACK_IMPORTED_MODULE_0__.join)((0,_normalize_unicode_js__WEBPACK_IMPORTED_MODULE_1__.normalizeUnicode)(p))).toLowerCase();\n                });\n        const dirs = new Set(paths.map(path => getDirs(path)).reduce((a, b) => a.concat(b)));\n        this.#reservations.set(fn, { dirs, paths });\n        for (const p of paths) {\n            const q = this.#queues.get(p);\n            if (!q) {\n                this.#queues.set(p, [fn]);\n            }\n            else {\n                q.push(fn);\n            }\n        }\n        for (const dir of dirs) {\n            const q = this.#queues.get(dir);\n            if (!q) {\n                this.#queues.set(dir, [new Set([fn])]);\n            }\n            else {\n                const l = q[q.length - 1];\n                if (l instanceof Set) {\n                    l.add(fn);\n                }\n                else {\n                    q.push(new Set([fn]));\n                }\n            }\n        }\n        return this.#run(fn);\n    }\n    // return the queues for each path the function cares about\n    // fn => {paths, dirs}\n    #getQueues(fn) {\n        const res = this.#reservations.get(fn);\n        /* c8 ignore start */\n        if (!res) {\n            throw new Error('function does not have any path reservations');\n        }\n        /* c8 ignore stop */\n        return {\n            paths: res.paths.map((path) => this.#queues.get(path)),\n            dirs: [...res.dirs].map(path => this.#queues.get(path)),\n        };\n    }\n    // check if fn is first in line for all its paths, and is\n    // included in the first set for all its dir queues\n    check(fn) {\n        const { paths, dirs } = this.#getQueues(fn);\n        return (paths.every(q => q && q[0] === fn) &&\n            dirs.every(q => q && q[0] instanceof Set && q[0].has(fn)));\n    }\n    // run the function if it's first in line and not already running\n    #run(fn) {\n        if (this.#running.has(fn) || !this.check(fn)) {\n            return false;\n        }\n        this.#running.add(fn);\n        fn(() => this.#clear(fn));\n        return true;\n    }\n    #clear(fn) {\n        if (!this.#running.has(fn)) {\n            return false;\n        }\n        const res = this.#reservations.get(fn);\n        /* c8 ignore start */\n        if (!res) {\n            throw new Error('invalid reservation');\n        }\n        /* c8 ignore stop */\n        const { paths, dirs } = res;\n        const next = new Set();\n        for (const path of paths) {\n            const q = this.#queues.get(path);\n            /* c8 ignore start */\n            if (!q || q?.[0] !== fn) {\n                continue;\n            }\n            /* c8 ignore stop */\n            const q0 = q[1];\n            if (!q0) {\n                this.#queues.delete(path);\n                continue;\n            }\n            q.shift();\n            if (typeof q0 === 'function') {\n                next.add(q0);\n            }\n            else {\n                for (const f of q0) {\n                    next.add(f);\n                }\n            }\n        }\n        for (const dir of dirs) {\n            const q = this.#queues.get(dir);\n            const q0 = q?.[0];\n            /* c8 ignore next - type safety only */\n            if (!q || !(q0 instanceof Set))\n                continue;\n            if (q0.size === 1 && q.length === 1) {\n                this.#queues.delete(dir);\n                continue;\n            }\n            else if (q0.size === 1) {\n                q.shift();\n                // next one must be a function,\n                // or else the Set would've been reused\n                const n = q[0];\n                if (typeof n === 'function') {\n                    next.add(n);\n                }\n            }\n            else {\n                q0.delete(fn);\n            }\n        }\n        this.#running.delete(fn);\n        next.forEach(fn => this.#run(fn));\n        return true;\n    }\n}\n//# sourceMappingURL=path-reservations.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvZXNtL3BhdGgtcmVzZXJ2YXRpb25zLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNpQztBQUN5QjtBQUNTO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsK0NBQUk7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixnRkFBb0IsQ0FBQywrQ0FBSSxDQUFDLHVFQUFnQjtBQUNyRSxpQkFBaUI7QUFDakI7QUFDQSxxQ0FBcUMsYUFBYTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpdmUtdmliZS1haS1uZXh0Ly4vbm9kZV9tb2R1bGVzL3Rhci9kaXN0L2VzbS9wYXRoLXJlc2VydmF0aW9ucy5qcz8yMWZiIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEEgcGF0aCBleGNsdXNpdmUgcmVzZXJ2YXRpb24gc3lzdGVtXG4vLyByZXNlcnZlKFtsaXN0LCBvZiwgcGF0aHNdLCBmbilcbi8vIFdoZW4gdGhlIGZuIGlzIGZpcnN0IGluIGxpbmUgZm9yIGFsbCBpdHMgcGF0aHMsIGl0XG4vLyBpcyBjYWxsZWQgd2l0aCBhIGNiIHRoYXQgY2xlYXJzIHRoZSByZXNlcnZhdGlvbi5cbi8vXG4vLyBVc2VkIGJ5IGFzeW5jIHVucGFjayB0byBhdm9pZCBjbG9iYmVyaW5nIHBhdGhzIGluIHVzZSxcbi8vIHdoaWxlIHN0aWxsIGFsbG93aW5nIG1heGltYWwgc2FmZSBwYXJhbGxlbGl6YXRpb24uXG5pbXBvcnQgeyBqb2luIH0gZnJvbSAnbm9kZTpwYXRoJztcbmltcG9ydCB7IG5vcm1hbGl6ZVVuaWNvZGUgfSBmcm9tICcuL25vcm1hbGl6ZS11bmljb2RlLmpzJztcbmltcG9ydCB7IHN0cmlwVHJhaWxpbmdTbGFzaGVzIH0gZnJvbSAnLi9zdHJpcC10cmFpbGluZy1zbGFzaGVzLmpzJztcbmNvbnN0IHBsYXRmb3JtID0gcHJvY2Vzcy5lbnYuVEVTVElOR19UQVJfRkFLRV9QTEFURk9STSB8fCBwcm9jZXNzLnBsYXRmb3JtO1xuY29uc3QgaXNXaW5kb3dzID0gcGxhdGZvcm0gPT09ICd3aW4zMic7XG4vLyByZXR1cm4gYSBzZXQgb2YgcGFyZW50IGRpcnMgZm9yIGEgZ2l2ZW4gcGF0aFxuLy8gJy9hL2IvYy9kJyAtPiBbJy8nLCAnL2EnLCAnL2EvYicsICcvYS9iL2MnLCAnL2EvYi9jL2QnXVxuY29uc3QgZ2V0RGlycyA9IChwYXRoKSA9PiB7XG4gICAgY29uc3QgZGlycyA9IHBhdGhcbiAgICAgICAgLnNwbGl0KCcvJylcbiAgICAgICAgLnNsaWNlKDAsIC0xKVxuICAgICAgICAucmVkdWNlKChzZXQsIHBhdGgpID0+IHtcbiAgICAgICAgY29uc3QgcyA9IHNldFtzZXQubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhdGggPSBqb2luKHMsIHBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIHNldC5wdXNoKHBhdGggfHwgJy8nKTtcbiAgICAgICAgcmV0dXJuIHNldDtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIGRpcnM7XG59O1xuZXhwb3J0IGNsYXNzIFBhdGhSZXNlcnZhdGlvbnMge1xuICAgIC8vIHBhdGggPT4gW2Z1bmN0aW9uIG9yIFNldF1cbiAgICAvLyBBIFNldCBvYmplY3QgbWVhbnMgYSBkaXJlY3RvcnkgcmVzZXJ2YXRpb25cbiAgICAvLyBBIGZuIGlzIGEgZGlyZWN0IHJlc2VydmF0aW9uIG9uIHRoYXQgcGF0aFxuICAgICNxdWV1ZXMgPSBuZXcgTWFwKCk7XG4gICAgLy8gZm4gPT4ge3BhdGhzOltwYXRoLC4uLl0sIGRpcnM6W3BhdGgsIC4uLl19XG4gICAgI3Jlc2VydmF0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICAvLyBmdW5jdGlvbnMgY3VycmVudGx5IHJ1bm5pbmdcbiAgICAjcnVubmluZyA9IG5ldyBTZXQoKTtcbiAgICByZXNlcnZlKHBhdGhzLCBmbikge1xuICAgICAgICBwYXRocyA9XG4gICAgICAgICAgICBpc1dpbmRvd3MgP1xuICAgICAgICAgICAgICAgIFsnd2luMzIgcGFyYWxsZWxpemF0aW9uIGRpc2FibGVkJ11cbiAgICAgICAgICAgICAgICA6IHBhdGhzLm1hcChwID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZG9uJ3QgbmVlZCBub3JtUGF0aCwgYmVjYXVzZSB3ZSBza2lwIHRoaXMgZW50aXJlbHkgZm9yIHdpbmRvd3NcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cmlwVHJhaWxpbmdTbGFzaGVzKGpvaW4obm9ybWFsaXplVW5pY29kZShwKSkpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGRpcnMgPSBuZXcgU2V0KHBhdGhzLm1hcChwYXRoID0+IGdldERpcnMocGF0aCkpLnJlZHVjZSgoYSwgYikgPT4gYS5jb25jYXQoYikpKTtcbiAgICAgICAgdGhpcy4jcmVzZXJ2YXRpb25zLnNldChmbiwgeyBkaXJzLCBwYXRocyB9KTtcbiAgICAgICAgZm9yIChjb25zdCBwIG9mIHBhdGhzKSB7XG4gICAgICAgICAgICBjb25zdCBxID0gdGhpcy4jcXVldWVzLmdldChwKTtcbiAgICAgICAgICAgIGlmICghcSkge1xuICAgICAgICAgICAgICAgIHRoaXMuI3F1ZXVlcy5zZXQocCwgW2ZuXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBxLnB1c2goZm4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgZGlyIG9mIGRpcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHEgPSB0aGlzLiNxdWV1ZXMuZ2V0KGRpcik7XG4gICAgICAgICAgICBpZiAoIXEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNxdWV1ZXMuc2V0KGRpciwgW25ldyBTZXQoW2ZuXSldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGwgPSBxW3EubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKGwgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgbC5hZGQoZm4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcS5wdXNoKG5ldyBTZXQoW2ZuXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy4jcnVuKGZuKTtcbiAgICB9XG4gICAgLy8gcmV0dXJuIHRoZSBxdWV1ZXMgZm9yIGVhY2ggcGF0aCB0aGUgZnVuY3Rpb24gY2FyZXMgYWJvdXRcbiAgICAvLyBmbiA9PiB7cGF0aHMsIGRpcnN9XG4gICAgI2dldFF1ZXVlcyhmbikge1xuICAgICAgICBjb25zdCByZXMgPSB0aGlzLiNyZXNlcnZhdGlvbnMuZ2V0KGZuKTtcbiAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIGlmICghcmVzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Z1bmN0aW9uIGRvZXMgbm90IGhhdmUgYW55IHBhdGggcmVzZXJ2YXRpb25zJyk7XG4gICAgICAgIH1cbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBhdGhzOiByZXMucGF0aHMubWFwKChwYXRoKSA9PiB0aGlzLiNxdWV1ZXMuZ2V0KHBhdGgpKSxcbiAgICAgICAgICAgIGRpcnM6IFsuLi5yZXMuZGlyc10ubWFwKHBhdGggPT4gdGhpcy4jcXVldWVzLmdldChwYXRoKSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIGNoZWNrIGlmIGZuIGlzIGZpcnN0IGluIGxpbmUgZm9yIGFsbCBpdHMgcGF0aHMsIGFuZCBpc1xuICAgIC8vIGluY2x1ZGVkIGluIHRoZSBmaXJzdCBzZXQgZm9yIGFsbCBpdHMgZGlyIHF1ZXVlc1xuICAgIGNoZWNrKGZuKSB7XG4gICAgICAgIGNvbnN0IHsgcGF0aHMsIGRpcnMgfSA9IHRoaXMuI2dldFF1ZXVlcyhmbik7XG4gICAgICAgIHJldHVybiAocGF0aHMuZXZlcnkocSA9PiBxICYmIHFbMF0gPT09IGZuKSAmJlxuICAgICAgICAgICAgZGlycy5ldmVyeShxID0+IHEgJiYgcVswXSBpbnN0YW5jZW9mIFNldCAmJiBxWzBdLmhhcyhmbikpKTtcbiAgICB9XG4gICAgLy8gcnVuIHRoZSBmdW5jdGlvbiBpZiBpdCdzIGZpcnN0IGluIGxpbmUgYW5kIG5vdCBhbHJlYWR5IHJ1bm5pbmdcbiAgICAjcnVuKGZuKSB7XG4gICAgICAgIGlmICh0aGlzLiNydW5uaW5nLmhhcyhmbikgfHwgIXRoaXMuY2hlY2soZm4pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcnVubmluZy5hZGQoZm4pO1xuICAgICAgICBmbigoKSA9PiB0aGlzLiNjbGVhcihmbikpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgI2NsZWFyKGZuKSB7XG4gICAgICAgIGlmICghdGhpcy4jcnVubmluZy5oYXMoZm4pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzID0gdGhpcy4jcmVzZXJ2YXRpb25zLmdldChmbik7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICBpZiAoIXJlcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHJlc2VydmF0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgY29uc3QgeyBwYXRocywgZGlycyB9ID0gcmVzO1xuICAgICAgICBjb25zdCBuZXh0ID0gbmV3IFNldCgpO1xuICAgICAgICBmb3IgKGNvbnN0IHBhdGggb2YgcGF0aHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHEgPSB0aGlzLiNxdWV1ZXMuZ2V0KHBhdGgpO1xuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICBpZiAoIXEgfHwgcT8uWzBdICE9PSBmbikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgICAgIGNvbnN0IHEwID0gcVsxXTtcbiAgICAgICAgICAgIGlmICghcTApIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNxdWV1ZXMuZGVsZXRlKHBhdGgpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcS5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBxMCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIG5leHQuYWRkKHEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZiBvZiBxMCkge1xuICAgICAgICAgICAgICAgICAgICBuZXh0LmFkZChmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBkaXIgb2YgZGlycykge1xuICAgICAgICAgICAgY29uc3QgcSA9IHRoaXMuI3F1ZXVlcy5nZXQoZGlyKTtcbiAgICAgICAgICAgIGNvbnN0IHEwID0gcT8uWzBdO1xuICAgICAgICAgICAgLyogYzggaWdub3JlIG5leHQgLSB0eXBlIHNhZmV0eSBvbmx5ICovXG4gICAgICAgICAgICBpZiAoIXEgfHwgIShxMCBpbnN0YW5jZW9mIFNldCkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAocTAuc2l6ZSA9PT0gMSAmJiBxLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuI3F1ZXVlcy5kZWxldGUoZGlyKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHEwLnNpemUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBxLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgLy8gbmV4dCBvbmUgbXVzdCBiZSBhIGZ1bmN0aW9uLFxuICAgICAgICAgICAgICAgIC8vIG9yIGVsc2UgdGhlIFNldCB3b3VsZCd2ZSBiZWVuIHJldXNlZFxuICAgICAgICAgICAgICAgIGNvbnN0IG4gPSBxWzBdO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBuZXh0LmFkZChuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBxMC5kZWxldGUoZm4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3J1bm5pbmcuZGVsZXRlKGZuKTtcbiAgICAgICAgbmV4dC5mb3JFYWNoKGZuID0+IHRoaXMuI3J1bihmbikpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXRoLXJlc2VydmF0aW9ucy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/tar/dist/esm/path-reservations.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/tar/dist/esm/pax.js":
/*!******************************************!*\
  !*** ./node_modules/tar/dist/esm/pax.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Pax: () => (/* binding */ Pax)\n/* harmony export */ });\n/* harmony import */ var node_path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:path */ \"node:path\");\n/* harmony import */ var _header_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./header.js */ \"(rsc)/./node_modules/tar/dist/esm/header.js\");\n\n\nclass Pax {\n    atime;\n    mtime;\n    ctime;\n    charset;\n    comment;\n    gid;\n    uid;\n    gname;\n    uname;\n    linkpath;\n    dev;\n    ino;\n    nlink;\n    path;\n    size;\n    mode;\n    global;\n    constructor(obj, global = false) {\n        this.atime = obj.atime;\n        this.charset = obj.charset;\n        this.comment = obj.comment;\n        this.ctime = obj.ctime;\n        this.dev = obj.dev;\n        this.gid = obj.gid;\n        this.global = global;\n        this.gname = obj.gname;\n        this.ino = obj.ino;\n        this.linkpath = obj.linkpath;\n        this.mtime = obj.mtime;\n        this.nlink = obj.nlink;\n        this.path = obj.path;\n        this.size = obj.size;\n        this.uid = obj.uid;\n        this.uname = obj.uname;\n    }\n    encode() {\n        const body = this.encodeBody();\n        if (body === '') {\n            return Buffer.allocUnsafe(0);\n        }\n        const bodyLen = Buffer.byteLength(body);\n        // round up to 512 bytes\n        // add 512 for header\n        const bufLen = 512 * Math.ceil(1 + bodyLen / 512);\n        const buf = Buffer.allocUnsafe(bufLen);\n        // 0-fill the header section, it might not hit every field\n        for (let i = 0; i < 512; i++) {\n            buf[i] = 0;\n        }\n        new _header_js__WEBPACK_IMPORTED_MODULE_1__.Header({\n            // XXX split the path\n            // then the path should be PaxHeader + basename, but less than 99,\n            // prepend with the dirname\n            /* c8 ignore start */\n            path: ('PaxHeader/' + (0,node_path__WEBPACK_IMPORTED_MODULE_0__.basename)(this.path ?? '')).slice(0, 99),\n            /* c8 ignore stop */\n            mode: this.mode || 0o644,\n            uid: this.uid,\n            gid: this.gid,\n            size: bodyLen,\n            mtime: this.mtime,\n            type: this.global ? 'GlobalExtendedHeader' : 'ExtendedHeader',\n            linkpath: '',\n            uname: this.uname || '',\n            gname: this.gname || '',\n            devmaj: 0,\n            devmin: 0,\n            atime: this.atime,\n            ctime: this.ctime,\n        }).encode(buf);\n        buf.write(body, 512, bodyLen, 'utf8');\n        // null pad after the body\n        for (let i = bodyLen + 512; i < buf.length; i++) {\n            buf[i] = 0;\n        }\n        return buf;\n    }\n    encodeBody() {\n        return (this.encodeField('path') +\n            this.encodeField('ctime') +\n            this.encodeField('atime') +\n            this.encodeField('dev') +\n            this.encodeField('ino') +\n            this.encodeField('nlink') +\n            this.encodeField('charset') +\n            this.encodeField('comment') +\n            this.encodeField('gid') +\n            this.encodeField('gname') +\n            this.encodeField('linkpath') +\n            this.encodeField('mtime') +\n            this.encodeField('size') +\n            this.encodeField('uid') +\n            this.encodeField('uname'));\n    }\n    encodeField(field) {\n        if (this[field] === undefined) {\n            return '';\n        }\n        const r = this[field];\n        const v = r instanceof Date ? r.getTime() / 1000 : r;\n        const s = ' ' +\n            (field === 'dev' || field === 'ino' || field === 'nlink' ?\n                'SCHILY.'\n                : '') +\n            field +\n            '=' +\n            v +\n            '\\n';\n        const byteLen = Buffer.byteLength(s);\n        // the digits includes the length of the digits in ascii base-10\n        // so if it's 9 characters, then adding 1 for the 9 makes it 10\n        // which makes it 11 chars.\n        let digits = Math.floor(Math.log(byteLen) / Math.log(10)) + 1;\n        if (byteLen + digits >= Math.pow(10, digits)) {\n            digits += 1;\n        }\n        const len = digits + byteLen;\n        return len + s;\n    }\n    static parse(str, ex, g = false) {\n        return new Pax(merge(parseKV(str), ex), g);\n    }\n}\nconst merge = (a, b) => b ? Object.assign({}, b, a) : a;\nconst parseKV = (str) => str\n    .replace(/\\n$/, '')\n    .split('\\n')\n    .reduce(parseKVLine, Object.create(null));\nconst parseKVLine = (set, line) => {\n    const n = parseInt(line, 10);\n    // XXX Values with \\n in them will fail this.\n    // Refactor to not be a naive line-by-line parse.\n    if (n !== Buffer.byteLength(line) + 1) {\n        return set;\n    }\n    line = line.slice((n + ' ').length);\n    const kv = line.split('=');\n    const r = kv.shift();\n    if (!r) {\n        return set;\n    }\n    const k = r.replace(/^SCHILY\\.(dev|ino|nlink)/, '$1');\n    const v = kv.join('=');\n    set[k] =\n        /^([A-Z]+\\.)?([mac]|birth|creation)time$/.test(k) ?\n            new Date(Number(v) * 1000)\n            : /^[0-9]+$/.test(v) ? +v\n                : v;\n    return set;\n};\n//# sourceMappingURL=pax.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvZXNtL3BheC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBcUM7QUFDQTtBQUM5QjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBLFlBQVksOENBQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsbURBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esb0NBQW9DLGdCQUFnQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpdmUtdmliZS1haS1uZXh0Ly4vbm9kZV9tb2R1bGVzL3Rhci9kaXN0L2VzbS9wYXguanM/NjljOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBiYXNlbmFtZSB9IGZyb20gJ25vZGU6cGF0aCc7XG5pbXBvcnQgeyBIZWFkZXIgfSBmcm9tICcuL2hlYWRlci5qcyc7XG5leHBvcnQgY2xhc3MgUGF4IHtcbiAgICBhdGltZTtcbiAgICBtdGltZTtcbiAgICBjdGltZTtcbiAgICBjaGFyc2V0O1xuICAgIGNvbW1lbnQ7XG4gICAgZ2lkO1xuICAgIHVpZDtcbiAgICBnbmFtZTtcbiAgICB1bmFtZTtcbiAgICBsaW5rcGF0aDtcbiAgICBkZXY7XG4gICAgaW5vO1xuICAgIG5saW5rO1xuICAgIHBhdGg7XG4gICAgc2l6ZTtcbiAgICBtb2RlO1xuICAgIGdsb2JhbDtcbiAgICBjb25zdHJ1Y3RvcihvYmosIGdsb2JhbCA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuYXRpbWUgPSBvYmouYXRpbWU7XG4gICAgICAgIHRoaXMuY2hhcnNldCA9IG9iai5jaGFyc2V0O1xuICAgICAgICB0aGlzLmNvbW1lbnQgPSBvYmouY29tbWVudDtcbiAgICAgICAgdGhpcy5jdGltZSA9IG9iai5jdGltZTtcbiAgICAgICAgdGhpcy5kZXYgPSBvYmouZGV2O1xuICAgICAgICB0aGlzLmdpZCA9IG9iai5naWQ7XG4gICAgICAgIHRoaXMuZ2xvYmFsID0gZ2xvYmFsO1xuICAgICAgICB0aGlzLmduYW1lID0gb2JqLmduYW1lO1xuICAgICAgICB0aGlzLmlubyA9IG9iai5pbm87XG4gICAgICAgIHRoaXMubGlua3BhdGggPSBvYmoubGlua3BhdGg7XG4gICAgICAgIHRoaXMubXRpbWUgPSBvYmoubXRpbWU7XG4gICAgICAgIHRoaXMubmxpbmsgPSBvYmoubmxpbms7XG4gICAgICAgIHRoaXMucGF0aCA9IG9iai5wYXRoO1xuICAgICAgICB0aGlzLnNpemUgPSBvYmouc2l6ZTtcbiAgICAgICAgdGhpcy51aWQgPSBvYmoudWlkO1xuICAgICAgICB0aGlzLnVuYW1lID0gb2JqLnVuYW1lO1xuICAgIH1cbiAgICBlbmNvZGUoKSB7XG4gICAgICAgIGNvbnN0IGJvZHkgPSB0aGlzLmVuY29kZUJvZHkoKTtcbiAgICAgICAgaWYgKGJvZHkgPT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm4gQnVmZmVyLmFsbG9jVW5zYWZlKDApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJvZHlMZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aChib2R5KTtcbiAgICAgICAgLy8gcm91bmQgdXAgdG8gNTEyIGJ5dGVzXG4gICAgICAgIC8vIGFkZCA1MTIgZm9yIGhlYWRlclxuICAgICAgICBjb25zdCBidWZMZW4gPSA1MTIgKiBNYXRoLmNlaWwoMSArIGJvZHlMZW4gLyA1MTIpO1xuICAgICAgICBjb25zdCBidWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoYnVmTGVuKTtcbiAgICAgICAgLy8gMC1maWxsIHRoZSBoZWFkZXIgc2VjdGlvbiwgaXQgbWlnaHQgbm90IGhpdCBldmVyeSBmaWVsZFxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDUxMjsgaSsrKSB7XG4gICAgICAgICAgICBidWZbaV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIG5ldyBIZWFkZXIoe1xuICAgICAgICAgICAgLy8gWFhYIHNwbGl0IHRoZSBwYXRoXG4gICAgICAgICAgICAvLyB0aGVuIHRoZSBwYXRoIHNob3VsZCBiZSBQYXhIZWFkZXIgKyBiYXNlbmFtZSwgYnV0IGxlc3MgdGhhbiA5OSxcbiAgICAgICAgICAgIC8vIHByZXBlbmQgd2l0aCB0aGUgZGlybmFtZVxuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICBwYXRoOiAoJ1BheEhlYWRlci8nICsgYmFzZW5hbWUodGhpcy5wYXRoID8/ICcnKSkuc2xpY2UoMCwgOTkpLFxuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgICAgIG1vZGU6IHRoaXMubW9kZSB8fCAwbzY0NCxcbiAgICAgICAgICAgIHVpZDogdGhpcy51aWQsXG4gICAgICAgICAgICBnaWQ6IHRoaXMuZ2lkLFxuICAgICAgICAgICAgc2l6ZTogYm9keUxlbixcbiAgICAgICAgICAgIG10aW1lOiB0aGlzLm10aW1lLFxuICAgICAgICAgICAgdHlwZTogdGhpcy5nbG9iYWwgPyAnR2xvYmFsRXh0ZW5kZWRIZWFkZXInIDogJ0V4dGVuZGVkSGVhZGVyJyxcbiAgICAgICAgICAgIGxpbmtwYXRoOiAnJyxcbiAgICAgICAgICAgIHVuYW1lOiB0aGlzLnVuYW1lIHx8ICcnLFxuICAgICAgICAgICAgZ25hbWU6IHRoaXMuZ25hbWUgfHwgJycsXG4gICAgICAgICAgICBkZXZtYWo6IDAsXG4gICAgICAgICAgICBkZXZtaW46IDAsXG4gICAgICAgICAgICBhdGltZTogdGhpcy5hdGltZSxcbiAgICAgICAgICAgIGN0aW1lOiB0aGlzLmN0aW1lLFxuICAgICAgICB9KS5lbmNvZGUoYnVmKTtcbiAgICAgICAgYnVmLndyaXRlKGJvZHksIDUxMiwgYm9keUxlbiwgJ3V0ZjgnKTtcbiAgICAgICAgLy8gbnVsbCBwYWQgYWZ0ZXIgdGhlIGJvZHlcbiAgICAgICAgZm9yIChsZXQgaSA9IGJvZHlMZW4gKyA1MTI7IGkgPCBidWYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGJ1ZltpXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9XG4gICAgZW5jb2RlQm9keSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmVuY29kZUZpZWxkKCdwYXRoJykgK1xuICAgICAgICAgICAgdGhpcy5lbmNvZGVGaWVsZCgnY3RpbWUnKSArXG4gICAgICAgICAgICB0aGlzLmVuY29kZUZpZWxkKCdhdGltZScpICtcbiAgICAgICAgICAgIHRoaXMuZW5jb2RlRmllbGQoJ2RldicpICtcbiAgICAgICAgICAgIHRoaXMuZW5jb2RlRmllbGQoJ2lubycpICtcbiAgICAgICAgICAgIHRoaXMuZW5jb2RlRmllbGQoJ25saW5rJykgK1xuICAgICAgICAgICAgdGhpcy5lbmNvZGVGaWVsZCgnY2hhcnNldCcpICtcbiAgICAgICAgICAgIHRoaXMuZW5jb2RlRmllbGQoJ2NvbW1lbnQnKSArXG4gICAgICAgICAgICB0aGlzLmVuY29kZUZpZWxkKCdnaWQnKSArXG4gICAgICAgICAgICB0aGlzLmVuY29kZUZpZWxkKCdnbmFtZScpICtcbiAgICAgICAgICAgIHRoaXMuZW5jb2RlRmllbGQoJ2xpbmtwYXRoJykgK1xuICAgICAgICAgICAgdGhpcy5lbmNvZGVGaWVsZCgnbXRpbWUnKSArXG4gICAgICAgICAgICB0aGlzLmVuY29kZUZpZWxkKCdzaXplJykgK1xuICAgICAgICAgICAgdGhpcy5lbmNvZGVGaWVsZCgndWlkJykgK1xuICAgICAgICAgICAgdGhpcy5lbmNvZGVGaWVsZCgndW5hbWUnKSk7XG4gICAgfVxuICAgIGVuY29kZUZpZWxkKGZpZWxkKSB7XG4gICAgICAgIGlmICh0aGlzW2ZpZWxkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgciA9IHRoaXNbZmllbGRdO1xuICAgICAgICBjb25zdCB2ID0gciBpbnN0YW5jZW9mIERhdGUgPyByLmdldFRpbWUoKSAvIDEwMDAgOiByO1xuICAgICAgICBjb25zdCBzID0gJyAnICtcbiAgICAgICAgICAgIChmaWVsZCA9PT0gJ2RldicgfHwgZmllbGQgPT09ICdpbm8nIHx8IGZpZWxkID09PSAnbmxpbmsnID9cbiAgICAgICAgICAgICAgICAnU0NISUxZLidcbiAgICAgICAgICAgICAgICA6ICcnKSArXG4gICAgICAgICAgICBmaWVsZCArXG4gICAgICAgICAgICAnPScgK1xuICAgICAgICAgICAgdiArXG4gICAgICAgICAgICAnXFxuJztcbiAgICAgICAgY29uc3QgYnl0ZUxlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHMpO1xuICAgICAgICAvLyB0aGUgZGlnaXRzIGluY2x1ZGVzIHRoZSBsZW5ndGggb2YgdGhlIGRpZ2l0cyBpbiBhc2NpaSBiYXNlLTEwXG4gICAgICAgIC8vIHNvIGlmIGl0J3MgOSBjaGFyYWN0ZXJzLCB0aGVuIGFkZGluZyAxIGZvciB0aGUgOSBtYWtlcyBpdCAxMFxuICAgICAgICAvLyB3aGljaCBtYWtlcyBpdCAxMSBjaGFycy5cbiAgICAgICAgbGV0IGRpZ2l0cyA9IE1hdGguZmxvb3IoTWF0aC5sb2coYnl0ZUxlbikgLyBNYXRoLmxvZygxMCkpICsgMTtcbiAgICAgICAgaWYgKGJ5dGVMZW4gKyBkaWdpdHMgPj0gTWF0aC5wb3coMTAsIGRpZ2l0cykpIHtcbiAgICAgICAgICAgIGRpZ2l0cyArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlbiA9IGRpZ2l0cyArIGJ5dGVMZW47XG4gICAgICAgIHJldHVybiBsZW4gKyBzO1xuICAgIH1cbiAgICBzdGF0aWMgcGFyc2Uoc3RyLCBleCwgZyA9IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGF4KG1lcmdlKHBhcnNlS1Yoc3RyKSwgZXgpLCBnKTtcbiAgICB9XG59XG5jb25zdCBtZXJnZSA9IChhLCBiKSA9PiBiID8gT2JqZWN0LmFzc2lnbih7fSwgYiwgYSkgOiBhO1xuY29uc3QgcGFyc2VLViA9IChzdHIpID0+IHN0clxuICAgIC5yZXBsYWNlKC9cXG4kLywgJycpXG4gICAgLnNwbGl0KCdcXG4nKVxuICAgIC5yZWR1Y2UocGFyc2VLVkxpbmUsIE9iamVjdC5jcmVhdGUobnVsbCkpO1xuY29uc3QgcGFyc2VLVkxpbmUgPSAoc2V0LCBsaW5lKSA9PiB7XG4gICAgY29uc3QgbiA9IHBhcnNlSW50KGxpbmUsIDEwKTtcbiAgICAvLyBYWFggVmFsdWVzIHdpdGggXFxuIGluIHRoZW0gd2lsbCBmYWlsIHRoaXMuXG4gICAgLy8gUmVmYWN0b3IgdG8gbm90IGJlIGEgbmFpdmUgbGluZS1ieS1saW5lIHBhcnNlLlxuICAgIGlmIChuICE9PSBCdWZmZXIuYnl0ZUxlbmd0aChsaW5lKSArIDEpIHtcbiAgICAgICAgcmV0dXJuIHNldDtcbiAgICB9XG4gICAgbGluZSA9IGxpbmUuc2xpY2UoKG4gKyAnICcpLmxlbmd0aCk7XG4gICAgY29uc3Qga3YgPSBsaW5lLnNwbGl0KCc9Jyk7XG4gICAgY29uc3QgciA9IGt2LnNoaWZ0KCk7XG4gICAgaWYgKCFyKSB7XG4gICAgICAgIHJldHVybiBzZXQ7XG4gICAgfVxuICAgIGNvbnN0IGsgPSByLnJlcGxhY2UoL15TQ0hJTFlcXC4oZGV2fGlub3xubGluaykvLCAnJDEnKTtcbiAgICBjb25zdCB2ID0ga3Yuam9pbignPScpO1xuICAgIHNldFtrXSA9XG4gICAgICAgIC9eKFtBLVpdK1xcLik/KFttYWNdfGJpcnRofGNyZWF0aW9uKXRpbWUkLy50ZXN0KGspID9cbiAgICAgICAgICAgIG5ldyBEYXRlKE51bWJlcih2KSAqIDEwMDApXG4gICAgICAgICAgICA6IC9eWzAtOV0rJC8udGVzdCh2KSA/ICt2XG4gICAgICAgICAgICAgICAgOiB2O1xuICAgIHJldHVybiBzZXQ7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGF4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/tar/dist/esm/pax.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/tar/dist/esm/read-entry.js":
/*!*************************************************!*\
  !*** ./node_modules/tar/dist/esm/read-entry.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ReadEntry: () => (/* binding */ ReadEntry)\n/* harmony export */ });\n/* harmony import */ var minipass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! minipass */ \"(rsc)/./node_modules/minipass/dist/esm/index.js\");\n/* harmony import */ var _normalize_windows_path_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./normalize-windows-path.js */ \"(rsc)/./node_modules/tar/dist/esm/normalize-windows-path.js\");\n\n\nclass ReadEntry extends minipass__WEBPACK_IMPORTED_MODULE_0__.Minipass {\n    extended;\n    globalExtended;\n    header;\n    startBlockSize;\n    blockRemain;\n    remain;\n    type;\n    meta = false;\n    ignore = false;\n    path;\n    mode;\n    uid;\n    gid;\n    uname;\n    gname;\n    size = 0;\n    mtime;\n    atime;\n    ctime;\n    linkpath;\n    dev;\n    ino;\n    nlink;\n    invalid = false;\n    absolute;\n    unsupported = false;\n    constructor(header, ex, gex) {\n        super({});\n        // read entries always start life paused.  this is to avoid the\n        // situation where Minipass's auto-ending empty streams results\n        // in an entry ending before we're ready for it.\n        this.pause();\n        this.extended = ex;\n        this.globalExtended = gex;\n        this.header = header;\n        /* c8 ignore start */\n        this.remain = header.size ?? 0;\n        /* c8 ignore stop */\n        this.startBlockSize = 512 * Math.ceil(this.remain / 512);\n        this.blockRemain = this.startBlockSize;\n        this.type = header.type;\n        switch (this.type) {\n            case 'File':\n            case 'OldFile':\n            case 'Link':\n            case 'SymbolicLink':\n            case 'CharacterDevice':\n            case 'BlockDevice':\n            case 'Directory':\n            case 'FIFO':\n            case 'ContiguousFile':\n            case 'GNUDumpDir':\n                break;\n            case 'NextFileHasLongLinkpath':\n            case 'NextFileHasLongPath':\n            case 'OldGnuLongPath':\n            case 'GlobalExtendedHeader':\n            case 'ExtendedHeader':\n            case 'OldExtendedHeader':\n                this.meta = true;\n                break;\n            // NOTE: gnutar and bsdtar treat unrecognized types as 'File'\n            // it may be worth doing the same, but with a warning.\n            default:\n                this.ignore = true;\n        }\n        /* c8 ignore start */\n        if (!header.path) {\n            throw new Error('no path provided for tar.ReadEntry');\n        }\n        /* c8 ignore stop */\n        this.path = (0,_normalize_windows_path_js__WEBPACK_IMPORTED_MODULE_1__.normalizeWindowsPath)(header.path);\n        this.mode = header.mode;\n        if (this.mode) {\n            this.mode = this.mode & 0o7777;\n        }\n        this.uid = header.uid;\n        this.gid = header.gid;\n        this.uname = header.uname;\n        this.gname = header.gname;\n        this.size = this.remain;\n        this.mtime = header.mtime;\n        this.atime = header.atime;\n        this.ctime = header.ctime;\n        /* c8 ignore start */\n        this.linkpath =\n            header.linkpath ?\n                (0,_normalize_windows_path_js__WEBPACK_IMPORTED_MODULE_1__.normalizeWindowsPath)(header.linkpath)\n                : undefined;\n        /* c8 ignore stop */\n        this.uname = header.uname;\n        this.gname = header.gname;\n        if (ex) {\n            this.#slurp(ex);\n        }\n        if (gex) {\n            this.#slurp(gex, true);\n        }\n    }\n    write(data) {\n        const writeLen = data.length;\n        if (writeLen > this.blockRemain) {\n            throw new Error('writing more to entry than is appropriate');\n        }\n        const r = this.remain;\n        const br = this.blockRemain;\n        this.remain = Math.max(0, r - writeLen);\n        this.blockRemain = Math.max(0, br - writeLen);\n        if (this.ignore) {\n            return true;\n        }\n        if (r >= writeLen) {\n            return super.write(data);\n        }\n        // r < writeLen\n        return super.write(data.subarray(0, r));\n    }\n    #slurp(ex, gex = false) {\n        if (ex.path)\n            ex.path = (0,_normalize_windows_path_js__WEBPACK_IMPORTED_MODULE_1__.normalizeWindowsPath)(ex.path);\n        if (ex.linkpath)\n            ex.linkpath = (0,_normalize_windows_path_js__WEBPACK_IMPORTED_MODULE_1__.normalizeWindowsPath)(ex.linkpath);\n        Object.assign(this, Object.fromEntries(Object.entries(ex).filter(([k, v]) => {\n            // we slurp in everything except for the path attribute in\n            // a global extended header, because that's weird. Also, any\n            // null/undefined values are ignored.\n            return !(v === null ||\n                v === undefined ||\n                (k === 'path' && gex));\n        })));\n    }\n}\n//# sourceMappingURL=read-entry.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvZXNtL3JlYWQtZW50cnkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQW9DO0FBQytCO0FBQzVELHdCQUF3Qiw4Q0FBUTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0ZBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnRkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0ZBQW9CO0FBQzFDO0FBQ0EsMEJBQTBCLGdGQUFvQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aXZlLXZpYmUtYWktbmV4dC8uL25vZGVfbW9kdWxlcy90YXIvZGlzdC9lc20vcmVhZC1lbnRyeS5qcz9jNTAxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE1pbmlwYXNzIH0gZnJvbSAnbWluaXBhc3MnO1xuaW1wb3J0IHsgbm9ybWFsaXplV2luZG93c1BhdGggfSBmcm9tICcuL25vcm1hbGl6ZS13aW5kb3dzLXBhdGguanMnO1xuZXhwb3J0IGNsYXNzIFJlYWRFbnRyeSBleHRlbmRzIE1pbmlwYXNzIHtcbiAgICBleHRlbmRlZDtcbiAgICBnbG9iYWxFeHRlbmRlZDtcbiAgICBoZWFkZXI7XG4gICAgc3RhcnRCbG9ja1NpemU7XG4gICAgYmxvY2tSZW1haW47XG4gICAgcmVtYWluO1xuICAgIHR5cGU7XG4gICAgbWV0YSA9IGZhbHNlO1xuICAgIGlnbm9yZSA9IGZhbHNlO1xuICAgIHBhdGg7XG4gICAgbW9kZTtcbiAgICB1aWQ7XG4gICAgZ2lkO1xuICAgIHVuYW1lO1xuICAgIGduYW1lO1xuICAgIHNpemUgPSAwO1xuICAgIG10aW1lO1xuICAgIGF0aW1lO1xuICAgIGN0aW1lO1xuICAgIGxpbmtwYXRoO1xuICAgIGRldjtcbiAgICBpbm87XG4gICAgbmxpbms7XG4gICAgaW52YWxpZCA9IGZhbHNlO1xuICAgIGFic29sdXRlO1xuICAgIHVuc3VwcG9ydGVkID0gZmFsc2U7XG4gICAgY29uc3RydWN0b3IoaGVhZGVyLCBleCwgZ2V4KSB7XG4gICAgICAgIHN1cGVyKHt9KTtcbiAgICAgICAgLy8gcmVhZCBlbnRyaWVzIGFsd2F5cyBzdGFydCBsaWZlIHBhdXNlZC4gIHRoaXMgaXMgdG8gYXZvaWQgdGhlXG4gICAgICAgIC8vIHNpdHVhdGlvbiB3aGVyZSBNaW5pcGFzcydzIGF1dG8tZW5kaW5nIGVtcHR5IHN0cmVhbXMgcmVzdWx0c1xuICAgICAgICAvLyBpbiBhbiBlbnRyeSBlbmRpbmcgYmVmb3JlIHdlJ3JlIHJlYWR5IGZvciBpdC5cbiAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgICB0aGlzLmV4dGVuZGVkID0gZXg7XG4gICAgICAgIHRoaXMuZ2xvYmFsRXh0ZW5kZWQgPSBnZXg7XG4gICAgICAgIHRoaXMuaGVhZGVyID0gaGVhZGVyO1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgdGhpcy5yZW1haW4gPSBoZWFkZXIuc2l6ZSA/PyAwO1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICB0aGlzLnN0YXJ0QmxvY2tTaXplID0gNTEyICogTWF0aC5jZWlsKHRoaXMucmVtYWluIC8gNTEyKTtcbiAgICAgICAgdGhpcy5ibG9ja1JlbWFpbiA9IHRoaXMuc3RhcnRCbG9ja1NpemU7XG4gICAgICAgIHRoaXMudHlwZSA9IGhlYWRlci50eXBlO1xuICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnRmlsZSc6XG4gICAgICAgICAgICBjYXNlICdPbGRGaWxlJzpcbiAgICAgICAgICAgIGNhc2UgJ0xpbmsnOlxuICAgICAgICAgICAgY2FzZSAnU3ltYm9saWNMaW5rJzpcbiAgICAgICAgICAgIGNhc2UgJ0NoYXJhY3RlckRldmljZSc6XG4gICAgICAgICAgICBjYXNlICdCbG9ja0RldmljZSc6XG4gICAgICAgICAgICBjYXNlICdEaXJlY3RvcnknOlxuICAgICAgICAgICAgY2FzZSAnRklGTyc6XG4gICAgICAgICAgICBjYXNlICdDb250aWd1b3VzRmlsZSc6XG4gICAgICAgICAgICBjYXNlICdHTlVEdW1wRGlyJzpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ05leHRGaWxlSGFzTG9uZ0xpbmtwYXRoJzpcbiAgICAgICAgICAgIGNhc2UgJ05leHRGaWxlSGFzTG9uZ1BhdGgnOlxuICAgICAgICAgICAgY2FzZSAnT2xkR251TG9uZ1BhdGgnOlxuICAgICAgICAgICAgY2FzZSAnR2xvYmFsRXh0ZW5kZWRIZWFkZXInOlxuICAgICAgICAgICAgY2FzZSAnRXh0ZW5kZWRIZWFkZXInOlxuICAgICAgICAgICAgY2FzZSAnT2xkRXh0ZW5kZWRIZWFkZXInOlxuICAgICAgICAgICAgICAgIHRoaXMubWV0YSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBOT1RFOiBnbnV0YXIgYW5kIGJzZHRhciB0cmVhdCB1bnJlY29nbml6ZWQgdHlwZXMgYXMgJ0ZpbGUnXG4gICAgICAgICAgICAvLyBpdCBtYXkgYmUgd29ydGggZG9pbmcgdGhlIHNhbWUsIGJ1dCB3aXRoIGEgd2FybmluZy5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhpcy5pZ25vcmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICBpZiAoIWhlYWRlci5wYXRoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIHBhdGggcHJvdmlkZWQgZm9yIHRhci5SZWFkRW50cnknKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICB0aGlzLnBhdGggPSBub3JtYWxpemVXaW5kb3dzUGF0aChoZWFkZXIucGF0aCk7XG4gICAgICAgIHRoaXMubW9kZSA9IGhlYWRlci5tb2RlO1xuICAgICAgICBpZiAodGhpcy5tb2RlKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGUgPSB0aGlzLm1vZGUgJiAwbzc3Nzc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51aWQgPSBoZWFkZXIudWlkO1xuICAgICAgICB0aGlzLmdpZCA9IGhlYWRlci5naWQ7XG4gICAgICAgIHRoaXMudW5hbWUgPSBoZWFkZXIudW5hbWU7XG4gICAgICAgIHRoaXMuZ25hbWUgPSBoZWFkZXIuZ25hbWU7XG4gICAgICAgIHRoaXMuc2l6ZSA9IHRoaXMucmVtYWluO1xuICAgICAgICB0aGlzLm10aW1lID0gaGVhZGVyLm10aW1lO1xuICAgICAgICB0aGlzLmF0aW1lID0gaGVhZGVyLmF0aW1lO1xuICAgICAgICB0aGlzLmN0aW1lID0gaGVhZGVyLmN0aW1lO1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgdGhpcy5saW5rcGF0aCA9XG4gICAgICAgICAgICBoZWFkZXIubGlua3BhdGggP1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZVdpbmRvd3NQYXRoKGhlYWRlci5saW5rcGF0aClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgdGhpcy51bmFtZSA9IGhlYWRlci51bmFtZTtcbiAgICAgICAgdGhpcy5nbmFtZSA9IGhlYWRlci5nbmFtZTtcbiAgICAgICAgaWYgKGV4KSB7XG4gICAgICAgICAgICB0aGlzLiNzbHVycChleCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdleCkge1xuICAgICAgICAgICAgdGhpcy4jc2x1cnAoZ2V4LCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3cml0ZShkYXRhKSB7XG4gICAgICAgIGNvbnN0IHdyaXRlTGVuID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGlmICh3cml0ZUxlbiA+IHRoaXMuYmxvY2tSZW1haW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignd3JpdGluZyBtb3JlIHRvIGVudHJ5IHRoYW4gaXMgYXBwcm9wcmlhdGUnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByID0gdGhpcy5yZW1haW47XG4gICAgICAgIGNvbnN0IGJyID0gdGhpcy5ibG9ja1JlbWFpbjtcbiAgICAgICAgdGhpcy5yZW1haW4gPSBNYXRoLm1heCgwLCByIC0gd3JpdGVMZW4pO1xuICAgICAgICB0aGlzLmJsb2NrUmVtYWluID0gTWF0aC5tYXgoMCwgYnIgLSB3cml0ZUxlbik7XG4gICAgICAgIGlmICh0aGlzLmlnbm9yZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHIgPj0gd3JpdGVMZW4pIHtcbiAgICAgICAgICAgIHJldHVybiBzdXBlci53cml0ZShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByIDwgd3JpdGVMZW5cbiAgICAgICAgcmV0dXJuIHN1cGVyLndyaXRlKGRhdGEuc3ViYXJyYXkoMCwgcikpO1xuICAgIH1cbiAgICAjc2x1cnAoZXgsIGdleCA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChleC5wYXRoKVxuICAgICAgICAgICAgZXgucGF0aCA9IG5vcm1hbGl6ZVdpbmRvd3NQYXRoKGV4LnBhdGgpO1xuICAgICAgICBpZiAoZXgubGlua3BhdGgpXG4gICAgICAgICAgICBleC5saW5rcGF0aCA9IG5vcm1hbGl6ZVdpbmRvd3NQYXRoKGV4LmxpbmtwYXRoKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMoZXgpLmZpbHRlcigoW2ssIHZdKSA9PiB7XG4gICAgICAgICAgICAvLyB3ZSBzbHVycCBpbiBldmVyeXRoaW5nIGV4Y2VwdCBmb3IgdGhlIHBhdGggYXR0cmlidXRlIGluXG4gICAgICAgICAgICAvLyBhIGdsb2JhbCBleHRlbmRlZCBoZWFkZXIsIGJlY2F1c2UgdGhhdCdzIHdlaXJkLiBBbHNvLCBhbnlcbiAgICAgICAgICAgIC8vIG51bGwvdW5kZWZpbmVkIHZhbHVlcyBhcmUgaWdub3JlZC5cbiAgICAgICAgICAgIHJldHVybiAhKHYgPT09IG51bGwgfHxcbiAgICAgICAgICAgICAgICB2ID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAoayA9PT0gJ3BhdGgnICYmIGdleCkpO1xuICAgICAgICB9KSkpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlYWQtZW50cnkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/tar/dist/esm/read-entry.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/tar/dist/esm/replace.js":
/*!**********************************************!*\
  !*** ./node_modules/tar/dist/esm/replace.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   replace: () => (/* binding */ replace)\n/* harmony export */ });\n/* harmony import */ var _isaacs_fs_minipass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @isaacs/fs-minipass */ \"(rsc)/./node_modules/@isaacs/fs-minipass/dist/esm/index.js\");\n/* harmony import */ var node_fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:fs */ \"node:fs\");\n/* harmony import */ var node_path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! node:path */ \"node:path\");\n/* harmony import */ var _header_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./header.js */ \"(rsc)/./node_modules/tar/dist/esm/header.js\");\n/* harmony import */ var _list_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./list.js */ \"(rsc)/./node_modules/tar/dist/esm/list.js\");\n/* harmony import */ var _make_command_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./make-command.js */ \"(rsc)/./node_modules/tar/dist/esm/make-command.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./options.js */ \"(rsc)/./node_modules/tar/dist/esm/options.js\");\n/* harmony import */ var _pack_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./pack.js */ \"(rsc)/./node_modules/tar/dist/esm/pack.js\");\n// tar -r\n\n\n\n\n\n\n\n\n// starting at the head of the file, read a Header\n// If the checksum is invalid, that's our position to start writing\n// If it is, jump forward by the specified size (round up to 512)\n// and try again.\n// Write the new Pack stream starting there.\nconst replaceSync = (opt, files) => {\n    const p = new _pack_js__WEBPACK_IMPORTED_MODULE_7__.PackSync(opt);\n    let threw = true;\n    let fd;\n    let position;\n    try {\n        try {\n            fd = node_fs__WEBPACK_IMPORTED_MODULE_1__.openSync(opt.file, 'r+');\n        }\n        catch (er) {\n            if (er?.code === 'ENOENT') {\n                fd = node_fs__WEBPACK_IMPORTED_MODULE_1__.openSync(opt.file, 'w+');\n            }\n            else {\n                throw er;\n            }\n        }\n        const st = node_fs__WEBPACK_IMPORTED_MODULE_1__.fstatSync(fd);\n        const headBuf = Buffer.alloc(512);\n        POSITION: for (position = 0; position < st.size; position += 512) {\n            for (let bufPos = 0, bytes = 0; bufPos < 512; bufPos += bytes) {\n                bytes = node_fs__WEBPACK_IMPORTED_MODULE_1__.readSync(fd, headBuf, bufPos, headBuf.length - bufPos, position + bufPos);\n                if (position === 0 &&\n                    headBuf[0] === 0x1f &&\n                    headBuf[1] === 0x8b) {\n                    throw new Error('cannot append to compressed archives');\n                }\n                if (!bytes) {\n                    break POSITION;\n                }\n            }\n            const h = new _header_js__WEBPACK_IMPORTED_MODULE_3__.Header(headBuf);\n            if (!h.cksumValid) {\n                break;\n            }\n            const entryBlockSize = 512 * Math.ceil((h.size || 0) / 512);\n            if (position + entryBlockSize + 512 > st.size) {\n                break;\n            }\n            // the 512 for the header we just parsed will be added as well\n            // also jump ahead all the blocks for the body\n            position += entryBlockSize;\n            if (opt.mtimeCache && h.mtime) {\n                opt.mtimeCache.set(String(h.path), h.mtime);\n            }\n        }\n        threw = false;\n        streamSync(opt, p, position, fd, files);\n    }\n    finally {\n        if (threw) {\n            try {\n                node_fs__WEBPACK_IMPORTED_MODULE_1__.closeSync(fd);\n            }\n            catch (er) { }\n        }\n    }\n};\nconst streamSync = (opt, p, position, fd, files) => {\n    const stream = new _isaacs_fs_minipass__WEBPACK_IMPORTED_MODULE_0__.WriteStreamSync(opt.file, {\n        fd: fd,\n        start: position,\n    });\n    p.pipe(stream);\n    addFilesSync(p, files);\n};\nconst replaceAsync = (opt, files) => {\n    files = Array.from(files);\n    const p = new _pack_js__WEBPACK_IMPORTED_MODULE_7__.Pack(opt);\n    const getPos = (fd, size, cb_) => {\n        const cb = (er, pos) => {\n            if (er) {\n                node_fs__WEBPACK_IMPORTED_MODULE_1__.close(fd, _ => cb_(er));\n            }\n            else {\n                cb_(null, pos);\n            }\n        };\n        let position = 0;\n        if (size === 0) {\n            return cb(null, 0);\n        }\n        let bufPos = 0;\n        const headBuf = Buffer.alloc(512);\n        const onread = (er, bytes) => {\n            if (er || typeof bytes === 'undefined') {\n                return cb(er);\n            }\n            bufPos += bytes;\n            if (bufPos < 512 && bytes) {\n                return node_fs__WEBPACK_IMPORTED_MODULE_1__.read(fd, headBuf, bufPos, headBuf.length - bufPos, position + bufPos, onread);\n            }\n            if (position === 0 &&\n                headBuf[0] === 0x1f &&\n                headBuf[1] === 0x8b) {\n                return cb(new Error('cannot append to compressed archives'));\n            }\n            // truncated header\n            if (bufPos < 512) {\n                return cb(null, position);\n            }\n            const h = new _header_js__WEBPACK_IMPORTED_MODULE_3__.Header(headBuf);\n            if (!h.cksumValid) {\n                return cb(null, position);\n            }\n            /* c8 ignore next */\n            const entryBlockSize = 512 * Math.ceil((h.size ?? 0) / 512);\n            if (position + entryBlockSize + 512 > size) {\n                return cb(null, position);\n            }\n            position += entryBlockSize + 512;\n            if (position >= size) {\n                return cb(null, position);\n            }\n            if (opt.mtimeCache && h.mtime) {\n                opt.mtimeCache.set(String(h.path), h.mtime);\n            }\n            bufPos = 0;\n            node_fs__WEBPACK_IMPORTED_MODULE_1__.read(fd, headBuf, 0, 512, position, onread);\n        };\n        node_fs__WEBPACK_IMPORTED_MODULE_1__.read(fd, headBuf, 0, 512, position, onread);\n    };\n    const promise = new Promise((resolve, reject) => {\n        p.on('error', reject);\n        let flag = 'r+';\n        const onopen = (er, fd) => {\n            if (er && er.code === 'ENOENT' && flag === 'r+') {\n                flag = 'w+';\n                return node_fs__WEBPACK_IMPORTED_MODULE_1__.open(opt.file, flag, onopen);\n            }\n            if (er || !fd) {\n                return reject(er);\n            }\n            node_fs__WEBPACK_IMPORTED_MODULE_1__.fstat(fd, (er, st) => {\n                if (er) {\n                    return node_fs__WEBPACK_IMPORTED_MODULE_1__.close(fd, () => reject(er));\n                }\n                getPos(fd, st.size, (er, position) => {\n                    if (er) {\n                        return reject(er);\n                    }\n                    const stream = new _isaacs_fs_minipass__WEBPACK_IMPORTED_MODULE_0__.WriteStream(opt.file, {\n                        fd: fd,\n                        start: position,\n                    });\n                    p.pipe(stream);\n                    stream.on('error', reject);\n                    stream.on('close', resolve);\n                    addFilesAsync(p, files);\n                });\n            });\n        };\n        node_fs__WEBPACK_IMPORTED_MODULE_1__.open(opt.file, flag, onopen);\n    });\n    return promise;\n};\nconst addFilesSync = (p, files) => {\n    files.forEach(file => {\n        if (file.charAt(0) === '@') {\n            (0,_list_js__WEBPACK_IMPORTED_MODULE_4__.list)({\n                file: node_path__WEBPACK_IMPORTED_MODULE_2__.resolve(p.cwd, file.slice(1)),\n                sync: true,\n                noResume: true,\n                onReadEntry: entry => p.add(entry),\n            });\n        }\n        else {\n            p.add(file);\n        }\n    });\n    p.end();\n};\nconst addFilesAsync = async (p, files) => {\n    for (let i = 0; i < files.length; i++) {\n        const file = String(files[i]);\n        if (file.charAt(0) === '@') {\n            await (0,_list_js__WEBPACK_IMPORTED_MODULE_4__.list)({\n                file: node_path__WEBPACK_IMPORTED_MODULE_2__.resolve(String(p.cwd), file.slice(1)),\n                noResume: true,\n                onReadEntry: entry => p.add(entry),\n            });\n        }\n        else {\n            p.add(file);\n        }\n    }\n    p.end();\n};\nconst replace = (0,_make_command_js__WEBPACK_IMPORTED_MODULE_5__.makeCommand)(replaceSync, replaceAsync, \n/* c8 ignore start */\n() => {\n    throw new TypeError('file is required');\n}, () => {\n    throw new TypeError('file is required');\n}, \n/* c8 ignore stop */\n(opt, entries) => {\n    if (!(0,_options_js__WEBPACK_IMPORTED_MODULE_6__.isFile)(opt)) {\n        throw new TypeError('file is required');\n    }\n    if (opt.gzip ||\n        opt.brotli ||\n        opt.file.endsWith('.br') ||\n        opt.file.endsWith('.tbr')) {\n        throw new TypeError('cannot append to compressed archives');\n    }\n    if (!entries?.length) {\n        throw new TypeError('no paths specified to add/replace');\n    }\n});\n//# sourceMappingURL=replace.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvZXNtL3JlcGxhY2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7QUFDbUU7QUFDMUM7QUFDSTtBQUNRO0FBQ0o7QUFDZTtBQUNUO0FBQ0k7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDhDQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsNkNBQVc7QUFDNUI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDZDQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsOENBQVk7QUFDL0I7QUFDQSxxQ0FBcUMsb0JBQW9CO0FBQ3pELDRDQUE0QyxjQUFjO0FBQzFELHdCQUF3Qiw2Q0FBVztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsOENBQU07QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw4Q0FBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0VBQWU7QUFDdEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDBDQUFJO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwwQ0FBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHlDQUFPO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDhDQUFNO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5Q0FBTztBQUNuQjtBQUNBLFFBQVEseUNBQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix5Q0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMENBQVE7QUFDcEI7QUFDQSwyQkFBMkIsMENBQVE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyw0REFBVztBQUNsRDtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBLFFBQVEseUNBQU87QUFDZixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksOENBQUk7QUFDaEIsc0JBQXNCLDhDQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQSxrQkFBa0IsOENBQUk7QUFDdEIsc0JBQXNCLDhDQUFZO0FBQ2xDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxnQkFBZ0IsNkRBQVc7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxTQUFTLG1EQUFNO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpdmUtdmliZS1haS1uZXh0Ly4vbm9kZV9tb2R1bGVzL3Rhci9kaXN0L2VzbS9yZXBsYWNlLmpzPzczYzMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gdGFyIC1yXG5pbXBvcnQgeyBXcml0ZVN0cmVhbSwgV3JpdGVTdHJlYW1TeW5jIH0gZnJvbSAnQGlzYWFjcy9mcy1taW5pcGFzcyc7XG5pbXBvcnQgZnMgZnJvbSAnbm9kZTpmcyc7XG5pbXBvcnQgcGF0aCBmcm9tICdub2RlOnBhdGgnO1xuaW1wb3J0IHsgSGVhZGVyIH0gZnJvbSAnLi9oZWFkZXIuanMnO1xuaW1wb3J0IHsgbGlzdCB9IGZyb20gJy4vbGlzdC5qcyc7XG5pbXBvcnQgeyBtYWtlQ29tbWFuZCB9IGZyb20gJy4vbWFrZS1jb21tYW5kLmpzJztcbmltcG9ydCB7IGlzRmlsZSwgfSBmcm9tICcuL29wdGlvbnMuanMnO1xuaW1wb3J0IHsgUGFjaywgUGFja1N5bmMgfSBmcm9tICcuL3BhY2suanMnO1xuLy8gc3RhcnRpbmcgYXQgdGhlIGhlYWQgb2YgdGhlIGZpbGUsIHJlYWQgYSBIZWFkZXJcbi8vIElmIHRoZSBjaGVja3N1bSBpcyBpbnZhbGlkLCB0aGF0J3Mgb3VyIHBvc2l0aW9uIHRvIHN0YXJ0IHdyaXRpbmdcbi8vIElmIGl0IGlzLCBqdW1wIGZvcndhcmQgYnkgdGhlIHNwZWNpZmllZCBzaXplIChyb3VuZCB1cCB0byA1MTIpXG4vLyBhbmQgdHJ5IGFnYWluLlxuLy8gV3JpdGUgdGhlIG5ldyBQYWNrIHN0cmVhbSBzdGFydGluZyB0aGVyZS5cbmNvbnN0IHJlcGxhY2VTeW5jID0gKG9wdCwgZmlsZXMpID0+IHtcbiAgICBjb25zdCBwID0gbmV3IFBhY2tTeW5jKG9wdCk7XG4gICAgbGV0IHRocmV3ID0gdHJ1ZTtcbiAgICBsZXQgZmQ7XG4gICAgbGV0IHBvc2l0aW9uO1xuICAgIHRyeSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmZCA9IGZzLm9wZW5TeW5jKG9wdC5maWxlLCAncisnKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXIpIHtcbiAgICAgICAgICAgIGlmIChlcj8uY29kZSA9PT0gJ0VOT0VOVCcpIHtcbiAgICAgICAgICAgICAgICBmZCA9IGZzLm9wZW5TeW5jKG9wdC5maWxlLCAndysnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0ID0gZnMuZnN0YXRTeW5jKGZkKTtcbiAgICAgICAgY29uc3QgaGVhZEJ1ZiA9IEJ1ZmZlci5hbGxvYyg1MTIpO1xuICAgICAgICBQT1NJVElPTjogZm9yIChwb3NpdGlvbiA9IDA7IHBvc2l0aW9uIDwgc3Quc2l6ZTsgcG9zaXRpb24gKz0gNTEyKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBidWZQb3MgPSAwLCBieXRlcyA9IDA7IGJ1ZlBvcyA8IDUxMjsgYnVmUG9zICs9IGJ5dGVzKSB7XG4gICAgICAgICAgICAgICAgYnl0ZXMgPSBmcy5yZWFkU3luYyhmZCwgaGVhZEJ1ZiwgYnVmUG9zLCBoZWFkQnVmLmxlbmd0aCAtIGJ1ZlBvcywgcG9zaXRpb24gKyBidWZQb3MpO1xuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICBoZWFkQnVmWzBdID09PSAweDFmICYmXG4gICAgICAgICAgICAgICAgICAgIGhlYWRCdWZbMV0gPT09IDB4OGIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgYXBwZW5kIHRvIGNvbXByZXNzZWQgYXJjaGl2ZXMnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFieXRlcykge1xuICAgICAgICAgICAgICAgICAgICBicmVhayBQT1NJVElPTjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoID0gbmV3IEhlYWRlcihoZWFkQnVmKTtcbiAgICAgICAgICAgIGlmICghaC5ja3N1bVZhbGlkKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBlbnRyeUJsb2NrU2l6ZSA9IDUxMiAqIE1hdGguY2VpbCgoaC5zaXplIHx8IDApIC8gNTEyKTtcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiArIGVudHJ5QmxvY2tTaXplICsgNTEyID4gc3Quc2l6ZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGhlIDUxMiBmb3IgdGhlIGhlYWRlciB3ZSBqdXN0IHBhcnNlZCB3aWxsIGJlIGFkZGVkIGFzIHdlbGxcbiAgICAgICAgICAgIC8vIGFsc28ganVtcCBhaGVhZCBhbGwgdGhlIGJsb2NrcyBmb3IgdGhlIGJvZHlcbiAgICAgICAgICAgIHBvc2l0aW9uICs9IGVudHJ5QmxvY2tTaXplO1xuICAgICAgICAgICAgaWYgKG9wdC5tdGltZUNhY2hlICYmIGgubXRpbWUpIHtcbiAgICAgICAgICAgICAgICBvcHQubXRpbWVDYWNoZS5zZXQoU3RyaW5nKGgucGF0aCksIGgubXRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocmV3ID0gZmFsc2U7XG4gICAgICAgIHN0cmVhbVN5bmMob3B0LCBwLCBwb3NpdGlvbiwgZmQsIGZpbGVzKTtcbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIGlmICh0aHJldykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmcy5jbG9zZVN5bmMoZmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVyKSB7IH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5jb25zdCBzdHJlYW1TeW5jID0gKG9wdCwgcCwgcG9zaXRpb24sIGZkLCBmaWxlcykgPT4ge1xuICAgIGNvbnN0IHN0cmVhbSA9IG5ldyBXcml0ZVN0cmVhbVN5bmMob3B0LmZpbGUsIHtcbiAgICAgICAgZmQ6IGZkLFxuICAgICAgICBzdGFydDogcG9zaXRpb24sXG4gICAgfSk7XG4gICAgcC5waXBlKHN0cmVhbSk7XG4gICAgYWRkRmlsZXNTeW5jKHAsIGZpbGVzKTtcbn07XG5jb25zdCByZXBsYWNlQXN5bmMgPSAob3B0LCBmaWxlcykgPT4ge1xuICAgIGZpbGVzID0gQXJyYXkuZnJvbShmaWxlcyk7XG4gICAgY29uc3QgcCA9IG5ldyBQYWNrKG9wdCk7XG4gICAgY29uc3QgZ2V0UG9zID0gKGZkLCBzaXplLCBjYl8pID0+IHtcbiAgICAgICAgY29uc3QgY2IgPSAoZXIsIHBvcykgPT4ge1xuICAgICAgICAgICAgaWYgKGVyKSB7XG4gICAgICAgICAgICAgICAgZnMuY2xvc2UoZmQsIF8gPT4gY2JfKGVyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYl8obnVsbCwgcG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHBvc2l0aW9uID0gMDtcbiAgICAgICAgaWYgKHNpemUgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBjYihudWxsLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYnVmUG9zID0gMDtcbiAgICAgICAgY29uc3QgaGVhZEJ1ZiA9IEJ1ZmZlci5hbGxvYyg1MTIpO1xuICAgICAgICBjb25zdCBvbnJlYWQgPSAoZXIsIGJ5dGVzKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXIgfHwgdHlwZW9mIGJ5dGVzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYihlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZQb3MgKz0gYnl0ZXM7XG4gICAgICAgICAgICBpZiAoYnVmUG9zIDwgNTEyICYmIGJ5dGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZzLnJlYWQoZmQsIGhlYWRCdWYsIGJ1ZlBvcywgaGVhZEJ1Zi5sZW5ndGggLSBidWZQb3MsIHBvc2l0aW9uICsgYnVmUG9zLCBvbnJlYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09PSAwICYmXG4gICAgICAgICAgICAgICAgaGVhZEJ1ZlswXSA9PT0gMHgxZiAmJlxuICAgICAgICAgICAgICAgIGhlYWRCdWZbMV0gPT09IDB4OGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2IobmV3IEVycm9yKCdjYW5ub3QgYXBwZW5kIHRvIGNvbXByZXNzZWQgYXJjaGl2ZXMnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0cnVuY2F0ZWQgaGVhZGVyXG4gICAgICAgICAgICBpZiAoYnVmUG9zIDwgNTEyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNiKG51bGwsIHBvc2l0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGggPSBuZXcgSGVhZGVyKGhlYWRCdWYpO1xuICAgICAgICAgICAgaWYgKCFoLmNrc3VtVmFsaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2IobnVsbCwgcG9zaXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgIGNvbnN0IGVudHJ5QmxvY2tTaXplID0gNTEyICogTWF0aC5jZWlsKChoLnNpemUgPz8gMCkgLyA1MTIpO1xuICAgICAgICAgICAgaWYgKHBvc2l0aW9uICsgZW50cnlCbG9ja1NpemUgKyA1MTIgPiBzaXplKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNiKG51bGwsIHBvc2l0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvc2l0aW9uICs9IGVudHJ5QmxvY2tTaXplICsgNTEyO1xuICAgICAgICAgICAgaWYgKHBvc2l0aW9uID49IHNpemUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2IobnVsbCwgcG9zaXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdC5tdGltZUNhY2hlICYmIGgubXRpbWUpIHtcbiAgICAgICAgICAgICAgICBvcHQubXRpbWVDYWNoZS5zZXQoU3RyaW5nKGgucGF0aCksIGgubXRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmUG9zID0gMDtcbiAgICAgICAgICAgIGZzLnJlYWQoZmQsIGhlYWRCdWYsIDAsIDUxMiwgcG9zaXRpb24sIG9ucmVhZCk7XG4gICAgICAgIH07XG4gICAgICAgIGZzLnJlYWQoZmQsIGhlYWRCdWYsIDAsIDUxMiwgcG9zaXRpb24sIG9ucmVhZCk7XG4gICAgfTtcbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBwLm9uKCdlcnJvcicsIHJlamVjdCk7XG4gICAgICAgIGxldCBmbGFnID0gJ3IrJztcbiAgICAgICAgY29uc3Qgb25vcGVuID0gKGVyLCBmZCkgPT4ge1xuICAgICAgICAgICAgaWYgKGVyICYmIGVyLmNvZGUgPT09ICdFTk9FTlQnICYmIGZsYWcgPT09ICdyKycpIHtcbiAgICAgICAgICAgICAgICBmbGFnID0gJ3crJztcbiAgICAgICAgICAgICAgICByZXR1cm4gZnMub3BlbihvcHQuZmlsZSwgZmxhZywgb25vcGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlciB8fCAhZmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZzLmZzdGF0KGZkLCAoZXIsIHN0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmcy5jbG9zZShmZCwgKCkgPT4gcmVqZWN0KGVyKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGdldFBvcyhmZCwgc3Quc2l6ZSwgKGVyLCBwb3NpdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IG5ldyBXcml0ZVN0cmVhbShvcHQuZmlsZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmQ6IGZkLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcC5waXBlKHN0cmVhbSk7XG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbS5vbignZXJyb3InLCByZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW0ub24oJ2Nsb3NlJywgcmVzb2x2ZSk7XG4gICAgICAgICAgICAgICAgICAgIGFkZEZpbGVzQXN5bmMocCwgZmlsZXMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGZzLm9wZW4ob3B0LmZpbGUsIGZsYWcsIG9ub3Blbik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59O1xuY29uc3QgYWRkRmlsZXNTeW5jID0gKHAsIGZpbGVzKSA9PiB7XG4gICAgZmlsZXMuZm9yRWFjaChmaWxlID0+IHtcbiAgICAgICAgaWYgKGZpbGUuY2hhckF0KDApID09PSAnQCcpIHtcbiAgICAgICAgICAgIGxpc3Qoe1xuICAgICAgICAgICAgICAgIGZpbGU6IHBhdGgucmVzb2x2ZShwLmN3ZCwgZmlsZS5zbGljZSgxKSksXG4gICAgICAgICAgICAgICAgc3luYzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBub1Jlc3VtZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBvblJlYWRFbnRyeTogZW50cnkgPT4gcC5hZGQoZW50cnkpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwLmFkZChmaWxlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHAuZW5kKCk7XG59O1xuY29uc3QgYWRkRmlsZXNBc3luYyA9IGFzeW5jIChwLCBmaWxlcykgPT4ge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZmlsZSA9IFN0cmluZyhmaWxlc1tpXSk7XG4gICAgICAgIGlmIChmaWxlLmNoYXJBdCgwKSA9PT0gJ0AnKSB7XG4gICAgICAgICAgICBhd2FpdCBsaXN0KHtcbiAgICAgICAgICAgICAgICBmaWxlOiBwYXRoLnJlc29sdmUoU3RyaW5nKHAuY3dkKSwgZmlsZS5zbGljZSgxKSksXG4gICAgICAgICAgICAgICAgbm9SZXN1bWU6IHRydWUsXG4gICAgICAgICAgICAgICAgb25SZWFkRW50cnk6IGVudHJ5ID0+IHAuYWRkKGVudHJ5KSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcC5hZGQoZmlsZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcC5lbmQoKTtcbn07XG5leHBvcnQgY29uc3QgcmVwbGFjZSA9IG1ha2VDb21tYW5kKHJlcGxhY2VTeW5jLCByZXBsYWNlQXN5bmMsIFxuLyogYzggaWdub3JlIHN0YXJ0ICovXG4oKSA9PiB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZmlsZSBpcyByZXF1aXJlZCcpO1xufSwgKCkgPT4ge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ZpbGUgaXMgcmVxdWlyZWQnKTtcbn0sIFxuLyogYzggaWdub3JlIHN0b3AgKi9cbihvcHQsIGVudHJpZXMpID0+IHtcbiAgICBpZiAoIWlzRmlsZShvcHQpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ZpbGUgaXMgcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgaWYgKG9wdC5nemlwIHx8XG4gICAgICAgIG9wdC5icm90bGkgfHxcbiAgICAgICAgb3B0LmZpbGUuZW5kc1dpdGgoJy5icicpIHx8XG4gICAgICAgIG9wdC5maWxlLmVuZHNXaXRoKCcudGJyJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2Fubm90IGFwcGVuZCB0byBjb21wcmVzc2VkIGFyY2hpdmVzJyk7XG4gICAgfVxuICAgIGlmICghZW50cmllcz8ubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ25vIHBhdGhzIHNwZWNpZmllZCB0byBhZGQvcmVwbGFjZScpO1xuICAgIH1cbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVwbGFjZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/tar/dist/esm/replace.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/tar/dist/esm/strip-absolute-path.js":
/*!**********************************************************!*\
  !*** ./node_modules/tar/dist/esm/strip-absolute-path.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   stripAbsolutePath: () => (/* binding */ stripAbsolutePath)\n/* harmony export */ });\n/* harmony import */ var node_path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:path */ \"node:path\");\n// unix absolute paths are also absolute on win32, so we use this for both\n\nconst { isAbsolute, parse } = node_path__WEBPACK_IMPORTED_MODULE_0__.win32;\n// returns [root, stripped]\n// Note that windows will think that //x/y/z/a has a \"root\" of //x/y, and in\n// those cases, we want to sanitize it to x/y/z/a, not z/a, so we strip /\n// explicitly if it's the first character.\n// drive-specific relative paths on Windows get their root stripped off even\n// though they are not absolute, so `c:../foo` becomes ['c:', '../foo']\nconst stripAbsolutePath = (path) => {\n    let r = '';\n    let parsed = parse(path);\n    while (isAbsolute(path) || parsed.root) {\n        // windows will think that //x/y/z has a \"root\" of //x/y/\n        // but strip the //?/C:/ off of //?/C:/path\n        const root = path.charAt(0) === '/' && path.slice(0, 4) !== '//?/' ?\n            '/'\n            : parsed.root;\n        path = path.slice(root.length);\n        r += root;\n        parsed = parse(path);\n    }\n    return [r, path];\n};\n//# sourceMappingURL=strip-absolute-path.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvZXNtL3N0cmlwLWFic29sdXRlLXBhdGguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNrQztBQUNsQyxRQUFRLG9CQUFvQixFQUFFLDRDQUFLO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdml2ZS12aWJlLWFpLW5leHQvLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvZXNtL3N0cmlwLWFic29sdXRlLXBhdGguanM/YjlhNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB1bml4IGFic29sdXRlIHBhdGhzIGFyZSBhbHNvIGFic29sdXRlIG9uIHdpbjMyLCBzbyB3ZSB1c2UgdGhpcyBmb3IgYm90aFxuaW1wb3J0IHsgd2luMzIgfSBmcm9tICdub2RlOnBhdGgnO1xuY29uc3QgeyBpc0Fic29sdXRlLCBwYXJzZSB9ID0gd2luMzI7XG4vLyByZXR1cm5zIFtyb290LCBzdHJpcHBlZF1cbi8vIE5vdGUgdGhhdCB3aW5kb3dzIHdpbGwgdGhpbmsgdGhhdCAvL3gveS96L2EgaGFzIGEgXCJyb290XCIgb2YgLy94L3ksIGFuZCBpblxuLy8gdGhvc2UgY2FzZXMsIHdlIHdhbnQgdG8gc2FuaXRpemUgaXQgdG8geC95L3ovYSwgbm90IHovYSwgc28gd2Ugc3RyaXAgL1xuLy8gZXhwbGljaXRseSBpZiBpdCdzIHRoZSBmaXJzdCBjaGFyYWN0ZXIuXG4vLyBkcml2ZS1zcGVjaWZpYyByZWxhdGl2ZSBwYXRocyBvbiBXaW5kb3dzIGdldCB0aGVpciByb290IHN0cmlwcGVkIG9mZiBldmVuXG4vLyB0aG91Z2ggdGhleSBhcmUgbm90IGFic29sdXRlLCBzbyBgYzouLi9mb29gIGJlY29tZXMgWydjOicsICcuLi9mb28nXVxuZXhwb3J0IGNvbnN0IHN0cmlwQWJzb2x1dGVQYXRoID0gKHBhdGgpID0+IHtcbiAgICBsZXQgciA9ICcnO1xuICAgIGxldCBwYXJzZWQgPSBwYXJzZShwYXRoKTtcbiAgICB3aGlsZSAoaXNBYnNvbHV0ZShwYXRoKSB8fCBwYXJzZWQucm9vdCkge1xuICAgICAgICAvLyB3aW5kb3dzIHdpbGwgdGhpbmsgdGhhdCAvL3gveS96IGhhcyBhIFwicm9vdFwiIG9mIC8veC95L1xuICAgICAgICAvLyBidXQgc3RyaXAgdGhlIC8vPy9DOi8gb2ZmIG9mIC8vPy9DOi9wYXRoXG4gICAgICAgIGNvbnN0IHJvb3QgPSBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nICYmIHBhdGguc2xpY2UoMCwgNCkgIT09ICcvLz8vJyA/XG4gICAgICAgICAgICAnLydcbiAgICAgICAgICAgIDogcGFyc2VkLnJvb3Q7XG4gICAgICAgIHBhdGggPSBwYXRoLnNsaWNlKHJvb3QubGVuZ3RoKTtcbiAgICAgICAgciArPSByb290O1xuICAgICAgICBwYXJzZWQgPSBwYXJzZShwYXRoKTtcbiAgICB9XG4gICAgcmV0dXJuIFtyLCBwYXRoXTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHJpcC1hYnNvbHV0ZS1wYXRoLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/tar/dist/esm/strip-absolute-path.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/tar/dist/esm/strip-trailing-slashes.js":
/*!*************************************************************!*\
  !*** ./node_modules/tar/dist/esm/strip-trailing-slashes.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   stripTrailingSlashes: () => (/* binding */ stripTrailingSlashes)\n/* harmony export */ });\n// warning: extremely hot code path.\n// This has been meticulously optimized for use\n// within npm install on large package trees.\n// Do not edit without careful benchmarking.\nconst stripTrailingSlashes = (str) => {\n    let i = str.length - 1;\n    let slashesStart = -1;\n    while (i > -1 && str.charAt(i) === '/') {\n        slashesStart = i;\n        i--;\n    }\n    return slashesStart === -1 ? str : str.slice(0, slashesStart);\n};\n//# sourceMappingURL=strip-trailing-slashes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvZXNtL3N0cmlwLXRyYWlsaW5nLXNsYXNoZXMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aXZlLXZpYmUtYWktbmV4dC8uL25vZGVfbW9kdWxlcy90YXIvZGlzdC9lc20vc3RyaXAtdHJhaWxpbmctc2xhc2hlcy5qcz82MGQxIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHdhcm5pbmc6IGV4dHJlbWVseSBob3QgY29kZSBwYXRoLlxuLy8gVGhpcyBoYXMgYmVlbiBtZXRpY3Vsb3VzbHkgb3B0aW1pemVkIGZvciB1c2Vcbi8vIHdpdGhpbiBucG0gaW5zdGFsbCBvbiBsYXJnZSBwYWNrYWdlIHRyZWVzLlxuLy8gRG8gbm90IGVkaXQgd2l0aG91dCBjYXJlZnVsIGJlbmNobWFya2luZy5cbmV4cG9ydCBjb25zdCBzdHJpcFRyYWlsaW5nU2xhc2hlcyA9IChzdHIpID0+IHtcbiAgICBsZXQgaSA9IHN0ci5sZW5ndGggLSAxO1xuICAgIGxldCBzbGFzaGVzU3RhcnQgPSAtMTtcbiAgICB3aGlsZSAoaSA+IC0xICYmIHN0ci5jaGFyQXQoaSkgPT09ICcvJykge1xuICAgICAgICBzbGFzaGVzU3RhcnQgPSBpO1xuICAgICAgICBpLS07XG4gICAgfVxuICAgIHJldHVybiBzbGFzaGVzU3RhcnQgPT09IC0xID8gc3RyIDogc3RyLnNsaWNlKDAsIHNsYXNoZXNTdGFydCk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RyaXAtdHJhaWxpbmctc2xhc2hlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/tar/dist/esm/strip-trailing-slashes.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/tar/dist/esm/symlink-error.js":
/*!****************************************************!*\
  !*** ./node_modules/tar/dist/esm/symlink-error.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SymlinkError: () => (/* binding */ SymlinkError)\n/* harmony export */ });\nclass SymlinkError extends Error {\n    path;\n    symlink;\n    syscall = 'symlink';\n    code = 'TAR_SYMLINK_ERROR';\n    constructor(symlink, path) {\n        super('TAR_SYMLINK_ERROR: Cannot extract through symbolic link');\n        this.symlink = symlink;\n        this.path = path;\n    }\n    get name() {\n        return 'SymlinkError';\n    }\n}\n//# sourceMappingURL=symlink-error.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvZXNtL3N5bWxpbmstZXJyb3IuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpdmUtdmliZS1haS1uZXh0Ly4vbm9kZV9tb2R1bGVzL3Rhci9kaXN0L2VzbS9zeW1saW5rLWVycm9yLmpzP2I2YjgiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNsYXNzIFN5bWxpbmtFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBwYXRoO1xuICAgIHN5bWxpbms7XG4gICAgc3lzY2FsbCA9ICdzeW1saW5rJztcbiAgICBjb2RlID0gJ1RBUl9TWU1MSU5LX0VSUk9SJztcbiAgICBjb25zdHJ1Y3RvcihzeW1saW5rLCBwYXRoKSB7XG4gICAgICAgIHN1cGVyKCdUQVJfU1lNTElOS19FUlJPUjogQ2Fubm90IGV4dHJhY3QgdGhyb3VnaCBzeW1ib2xpYyBsaW5rJyk7XG4gICAgICAgIHRoaXMuc3ltbGluayA9IHN5bWxpbms7XG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgfVxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gJ1N5bWxpbmtFcnJvcic7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3ltbGluay1lcnJvci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/tar/dist/esm/symlink-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/tar/dist/esm/types.js":
/*!********************************************!*\
  !*** ./node_modules/tar/dist/esm/types.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   code: () => (/* binding */ code),\n/* harmony export */   isCode: () => (/* binding */ isCode),\n/* harmony export */   isName: () => (/* binding */ isName),\n/* harmony export */   name: () => (/* binding */ name)\n/* harmony export */ });\nconst isCode = (c) => name.has(c);\nconst isName = (c) => code.has(c);\n// map types from key to human-friendly name\nconst name = new Map([\n    ['0', 'File'],\n    // same as File\n    ['', 'OldFile'],\n    ['1', 'Link'],\n    ['2', 'SymbolicLink'],\n    // Devices and FIFOs aren't fully supported\n    // they are parsed, but skipped when unpacking\n    ['3', 'CharacterDevice'],\n    ['4', 'BlockDevice'],\n    ['5', 'Directory'],\n    ['6', 'FIFO'],\n    // same as File\n    ['7', 'ContiguousFile'],\n    // pax headers\n    ['g', 'GlobalExtendedHeader'],\n    ['x', 'ExtendedHeader'],\n    // vendor-specific stuff\n    // skip\n    ['A', 'SolarisACL'],\n    // like 5, but with data, which should be skipped\n    ['D', 'GNUDumpDir'],\n    // metadata only, skip\n    ['I', 'Inode'],\n    // data = link path of next file\n    ['K', 'NextFileHasLongLinkpath'],\n    // data = path of next file\n    ['L', 'NextFileHasLongPath'],\n    // skip\n    ['M', 'ContinuationFile'],\n    // like L\n    ['N', 'OldGnuLongPath'],\n    // skip\n    ['S', 'SparseFile'],\n    // skip\n    ['V', 'TapeVolumeHeader'],\n    // like x\n    ['X', 'OldExtendedHeader'],\n]);\n// map the other direction\nconst code = new Map(Array.from(name).map(kv => [kv[1], kv[0]]));\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvZXNtL3R5cGVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBTztBQUNBO0FBQ1A7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aXZlLXZpYmUtYWktbmV4dC8uL25vZGVfbW9kdWxlcy90YXIvZGlzdC9lc20vdHlwZXMuanM/ZDM1ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgaXNDb2RlID0gKGMpID0+IG5hbWUuaGFzKGMpO1xuZXhwb3J0IGNvbnN0IGlzTmFtZSA9IChjKSA9PiBjb2RlLmhhcyhjKTtcbi8vIG1hcCB0eXBlcyBmcm9tIGtleSB0byBodW1hbi1mcmllbmRseSBuYW1lXG5leHBvcnQgY29uc3QgbmFtZSA9IG5ldyBNYXAoW1xuICAgIFsnMCcsICdGaWxlJ10sXG4gICAgLy8gc2FtZSBhcyBGaWxlXG4gICAgWycnLCAnT2xkRmlsZSddLFxuICAgIFsnMScsICdMaW5rJ10sXG4gICAgWycyJywgJ1N5bWJvbGljTGluayddLFxuICAgIC8vIERldmljZXMgYW5kIEZJRk9zIGFyZW4ndCBmdWxseSBzdXBwb3J0ZWRcbiAgICAvLyB0aGV5IGFyZSBwYXJzZWQsIGJ1dCBza2lwcGVkIHdoZW4gdW5wYWNraW5nXG4gICAgWyczJywgJ0NoYXJhY3RlckRldmljZSddLFxuICAgIFsnNCcsICdCbG9ja0RldmljZSddLFxuICAgIFsnNScsICdEaXJlY3RvcnknXSxcbiAgICBbJzYnLCAnRklGTyddLFxuICAgIC8vIHNhbWUgYXMgRmlsZVxuICAgIFsnNycsICdDb250aWd1b3VzRmlsZSddLFxuICAgIC8vIHBheCBoZWFkZXJzXG4gICAgWydnJywgJ0dsb2JhbEV4dGVuZGVkSGVhZGVyJ10sXG4gICAgWyd4JywgJ0V4dGVuZGVkSGVhZGVyJ10sXG4gICAgLy8gdmVuZG9yLXNwZWNpZmljIHN0dWZmXG4gICAgLy8gc2tpcFxuICAgIFsnQScsICdTb2xhcmlzQUNMJ10sXG4gICAgLy8gbGlrZSA1LCBidXQgd2l0aCBkYXRhLCB3aGljaCBzaG91bGQgYmUgc2tpcHBlZFxuICAgIFsnRCcsICdHTlVEdW1wRGlyJ10sXG4gICAgLy8gbWV0YWRhdGEgb25seSwgc2tpcFxuICAgIFsnSScsICdJbm9kZSddLFxuICAgIC8vIGRhdGEgPSBsaW5rIHBhdGggb2YgbmV4dCBmaWxlXG4gICAgWydLJywgJ05leHRGaWxlSGFzTG9uZ0xpbmtwYXRoJ10sXG4gICAgLy8gZGF0YSA9IHBhdGggb2YgbmV4dCBmaWxlXG4gICAgWydMJywgJ05leHRGaWxlSGFzTG9uZ1BhdGgnXSxcbiAgICAvLyBza2lwXG4gICAgWydNJywgJ0NvbnRpbnVhdGlvbkZpbGUnXSxcbiAgICAvLyBsaWtlIExcbiAgICBbJ04nLCAnT2xkR251TG9uZ1BhdGgnXSxcbiAgICAvLyBza2lwXG4gICAgWydTJywgJ1NwYXJzZUZpbGUnXSxcbiAgICAvLyBza2lwXG4gICAgWydWJywgJ1RhcGVWb2x1bWVIZWFkZXInXSxcbiAgICAvLyBsaWtlIHhcbiAgICBbJ1gnLCAnT2xkRXh0ZW5kZWRIZWFkZXInXSxcbl0pO1xuLy8gbWFwIHRoZSBvdGhlciBkaXJlY3Rpb25cbmV4cG9ydCBjb25zdCBjb2RlID0gbmV3IE1hcChBcnJheS5mcm9tKG5hbWUpLm1hcChrdiA9PiBba3ZbMV0sIGt2WzBdXSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/tar/dist/esm/types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/tar/dist/esm/unpack.js":
/*!*********************************************!*\
  !*** ./node_modules/tar/dist/esm/unpack.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Unpack: () => (/* binding */ Unpack),\n/* harmony export */   UnpackSync: () => (/* binding */ UnpackSync)\n/* harmony export */ });\n/* harmony import */ var _isaacs_fs_minipass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @isaacs/fs-minipass */ \"(rsc)/./node_modules/@isaacs/fs-minipass/dist/esm/index.js\");\n/* harmony import */ var node_assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:assert */ \"node:assert\");\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n/* harmony import */ var node_fs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! node:fs */ \"node:fs\");\n/* harmony import */ var node_path__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! node:path */ \"node:path\");\n/* harmony import */ var _get_write_flag_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./get-write-flag.js */ \"(rsc)/./node_modules/tar/dist/esm/get-write-flag.js\");\n/* harmony import */ var _mkdir_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./mkdir.js */ \"(rsc)/./node_modules/tar/dist/esm/mkdir.js\");\n/* harmony import */ var _normalize_unicode_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./normalize-unicode.js */ \"(rsc)/./node_modules/tar/dist/esm/normalize-unicode.js\");\n/* harmony import */ var _normalize_windows_path_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./normalize-windows-path.js */ \"(rsc)/./node_modules/tar/dist/esm/normalize-windows-path.js\");\n/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./parse.js */ \"(rsc)/./node_modules/tar/dist/esm/parse.js\");\n/* harmony import */ var _strip_absolute_path_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./strip-absolute-path.js */ \"(rsc)/./node_modules/tar/dist/esm/strip-absolute-path.js\");\n/* harmony import */ var _strip_trailing_slashes_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./strip-trailing-slashes.js */ \"(rsc)/./node_modules/tar/dist/esm/strip-trailing-slashes.js\");\n/* harmony import */ var _winchars_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./winchars.js */ \"(rsc)/./node_modules/tar/dist/esm/winchars.js\");\n/* harmony import */ var _path_reservations_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./path-reservations.js */ \"(rsc)/./node_modules/tar/dist/esm/path-reservations.js\");\n// the PEND/UNPEND stuff tracks whether we're ready to emit end/close yet.\n// but the path reservations are required to avoid race conditions where\n// parallelized unpack ops may mess with one another, due to dependencies\n// (like a Link depending on its target) or destructive operations (like\n// clobbering an fs object to create one of a different type.)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst ONENTRY = Symbol('onEntry');\nconst CHECKFS = Symbol('checkFs');\nconst CHECKFS2 = Symbol('checkFs2');\nconst PRUNECACHE = Symbol('pruneCache');\nconst ISREUSABLE = Symbol('isReusable');\nconst MAKEFS = Symbol('makeFs');\nconst FILE = Symbol('file');\nconst DIRECTORY = Symbol('directory');\nconst LINK = Symbol('link');\nconst SYMLINK = Symbol('symlink');\nconst HARDLINK = Symbol('hardlink');\nconst UNSUPPORTED = Symbol('unsupported');\nconst CHECKPATH = Symbol('checkPath');\nconst MKDIR = Symbol('mkdir');\nconst ONERROR = Symbol('onError');\nconst PENDING = Symbol('pending');\nconst PEND = Symbol('pend');\nconst UNPEND = Symbol('unpend');\nconst ENDED = Symbol('ended');\nconst MAYBECLOSE = Symbol('maybeClose');\nconst SKIP = Symbol('skip');\nconst DOCHOWN = Symbol('doChown');\nconst UID = Symbol('uid');\nconst GID = Symbol('gid');\nconst CHECKED_CWD = Symbol('checkedCwd');\nconst platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;\nconst isWindows = platform === 'win32';\nconst DEFAULT_MAX_DEPTH = 1024;\n// Unlinks on Windows are not atomic.\n//\n// This means that if you have a file entry, followed by another\n// file entry with an identical name, and you cannot re-use the file\n// (because it's a hardlink, or because unlink:true is set, or it's\n// Windows, which does not have useful nlink values), then the unlink\n// will be committed to the disk AFTER the new file has been written\n// over the old one, deleting the new file.\n//\n// To work around this, on Windows systems, we rename the file and then\n// delete the renamed file.  It's a sloppy kludge, but frankly, I do not\n// know of a better way to do this, given windows' non-atomic unlink\n// semantics.\n//\n// See: https://github.com/npm/node-tar/issues/183\n/* c8 ignore start */\nconst unlinkFile = (path, cb) => {\n    if (!isWindows) {\n        return node_fs__WEBPACK_IMPORTED_MODULE_3__.unlink(path, cb);\n    }\n    const name = path + '.DELETE.' + (0,node_crypto__WEBPACK_IMPORTED_MODULE_2__.randomBytes)(16).toString('hex');\n    node_fs__WEBPACK_IMPORTED_MODULE_3__.rename(path, name, er => {\n        if (er) {\n            return cb(er);\n        }\n        node_fs__WEBPACK_IMPORTED_MODULE_3__.unlink(name, cb);\n    });\n};\n/* c8 ignore stop */\n/* c8 ignore start */\nconst unlinkFileSync = (path) => {\n    if (!isWindows) {\n        return node_fs__WEBPACK_IMPORTED_MODULE_3__.unlinkSync(path);\n    }\n    const name = path + '.DELETE.' + (0,node_crypto__WEBPACK_IMPORTED_MODULE_2__.randomBytes)(16).toString('hex');\n    node_fs__WEBPACK_IMPORTED_MODULE_3__.renameSync(path, name);\n    node_fs__WEBPACK_IMPORTED_MODULE_3__.unlinkSync(name);\n};\n/* c8 ignore stop */\n// this.gid, entry.gid, this.processUid\nconst uint32 = (a, b, c) => a !== undefined && a === a >>> 0 ? a\n    : b !== undefined && b === b >>> 0 ? b\n        : c;\n// clear the cache if it's a case-insensitive unicode-squashing match.\n// we can't know if the current file system is case-sensitive or supports\n// unicode fully, so we check for similarity on the maximally compatible\n// representation.  Err on the side of pruning, since all it's doing is\n// preventing lstats, and it's not the end of the world if we get a false\n// positive.\n// Note that on windows, we always drop the entire cache whenever a\n// symbolic link is encountered, because 8.3 filenames are impossible\n// to reason about, and collisions are hazards rather than just failures.\nconst cacheKeyNormalize = (path) => (0,_strip_trailing_slashes_js__WEBPACK_IMPORTED_MODULE_11__.stripTrailingSlashes)((0,_normalize_windows_path_js__WEBPACK_IMPORTED_MODULE_8__.normalizeWindowsPath)((0,_normalize_unicode_js__WEBPACK_IMPORTED_MODULE_7__.normalizeUnicode)(path))).toLowerCase();\n// remove all cache entries matching ${abs}/**\nconst pruneCache = (cache, abs) => {\n    abs = cacheKeyNormalize(abs);\n    for (const path of cache.keys()) {\n        const pnorm = cacheKeyNormalize(path);\n        if (pnorm === abs || pnorm.indexOf(abs + '/') === 0) {\n            cache.delete(path);\n        }\n    }\n};\nconst dropCache = (cache) => {\n    for (const key of cache.keys()) {\n        cache.delete(key);\n    }\n};\nclass Unpack extends _parse_js__WEBPACK_IMPORTED_MODULE_9__.Parser {\n    [ENDED] = false;\n    [CHECKED_CWD] = false;\n    [PENDING] = 0;\n    reservations = new _path_reservations_js__WEBPACK_IMPORTED_MODULE_13__.PathReservations();\n    transform;\n    writable = true;\n    readable = false;\n    dirCache;\n    uid;\n    gid;\n    setOwner;\n    preserveOwner;\n    processGid;\n    processUid;\n    maxDepth;\n    forceChown;\n    win32;\n    newer;\n    keep;\n    noMtime;\n    preservePaths;\n    unlink;\n    cwd;\n    strip;\n    processUmask;\n    umask;\n    dmode;\n    fmode;\n    chmod;\n    constructor(opt = {}) {\n        opt.ondone = () => {\n            this[ENDED] = true;\n            this[MAYBECLOSE]();\n        };\n        super(opt);\n        this.transform = opt.transform;\n        this.dirCache = opt.dirCache || new Map();\n        this.chmod = !!opt.chmod;\n        if (typeof opt.uid === 'number' || typeof opt.gid === 'number') {\n            // need both or neither\n            if (typeof opt.uid !== 'number' ||\n                typeof opt.gid !== 'number') {\n                throw new TypeError('cannot set owner without number uid and gid');\n            }\n            if (opt.preserveOwner) {\n                throw new TypeError('cannot preserve owner in archive and also set owner explicitly');\n            }\n            this.uid = opt.uid;\n            this.gid = opt.gid;\n            this.setOwner = true;\n        }\n        else {\n            this.uid = undefined;\n            this.gid = undefined;\n            this.setOwner = false;\n        }\n        // default true for root\n        if (opt.preserveOwner === undefined &&\n            typeof opt.uid !== 'number') {\n            this.preserveOwner = !!(process.getuid && process.getuid() === 0);\n        }\n        else {\n            this.preserveOwner = !!opt.preserveOwner;\n        }\n        this.processUid =\n            (this.preserveOwner || this.setOwner) && process.getuid ?\n                process.getuid()\n                : undefined;\n        this.processGid =\n            (this.preserveOwner || this.setOwner) && process.getgid ?\n                process.getgid()\n                : undefined;\n        // prevent excessively deep nesting of subfolders\n        // set to `Infinity` to remove this restriction\n        this.maxDepth =\n            typeof opt.maxDepth === 'number' ?\n                opt.maxDepth\n                : DEFAULT_MAX_DEPTH;\n        // mostly just for testing, but useful in some cases.\n        // Forcibly trigger a chown on every entry, no matter what\n        this.forceChown = opt.forceChown === true;\n        // turn ><?| in filenames into 0xf000-higher encoded forms\n        this.win32 = !!opt.win32 || isWindows;\n        // do not unpack over files that are newer than what's in the archive\n        this.newer = !!opt.newer;\n        // do not unpack over ANY files\n        this.keep = !!opt.keep;\n        // do not set mtime/atime of extracted entries\n        this.noMtime = !!opt.noMtime;\n        // allow .., absolute path entries, and unpacking through symlinks\n        // without this, warn and skip .., relativize absolutes, and error\n        // on symlinks in extraction path\n        this.preservePaths = !!opt.preservePaths;\n        // unlink files and links before writing. This breaks existing hard\n        // links, and removes symlink directories rather than erroring\n        this.unlink = !!opt.unlink;\n        this.cwd = (0,_normalize_windows_path_js__WEBPACK_IMPORTED_MODULE_8__.normalizeWindowsPath)(node_path__WEBPACK_IMPORTED_MODULE_4__.resolve(opt.cwd || process.cwd()));\n        this.strip = Number(opt.strip) || 0;\n        // if we're not chmodding, then we don't need the process umask\n        this.processUmask =\n            !this.chmod ? 0\n                : typeof opt.processUmask === 'number' ? opt.processUmask\n                    : process.umask();\n        this.umask =\n            typeof opt.umask === 'number' ? opt.umask : this.processUmask;\n        // default mode for dirs created as parents\n        this.dmode = opt.dmode || 0o0777 & ~this.umask;\n        this.fmode = opt.fmode || 0o0666 & ~this.umask;\n        this.on('entry', entry => this[ONENTRY](entry));\n    }\n    // a bad or damaged archive is a warning for Parser, but an error\n    // when extracting.  Mark those errors as unrecoverable, because\n    // the Unpack contract cannot be met.\n    warn(code, msg, data = {}) {\n        if (code === 'TAR_BAD_ARCHIVE' || code === 'TAR_ABORT') {\n            data.recoverable = false;\n        }\n        return super.warn(code, msg, data);\n    }\n    [MAYBECLOSE]() {\n        if (this[ENDED] && this[PENDING] === 0) {\n            this.emit('prefinish');\n            this.emit('finish');\n            this.emit('end');\n        }\n    }\n    [CHECKPATH](entry) {\n        const p = (0,_normalize_windows_path_js__WEBPACK_IMPORTED_MODULE_8__.normalizeWindowsPath)(entry.path);\n        const parts = p.split('/');\n        if (this.strip) {\n            if (parts.length < this.strip) {\n                return false;\n            }\n            if (entry.type === 'Link') {\n                const linkparts = (0,_normalize_windows_path_js__WEBPACK_IMPORTED_MODULE_8__.normalizeWindowsPath)(String(entry.linkpath)).split('/');\n                if (linkparts.length >= this.strip) {\n                    entry.linkpath = linkparts.slice(this.strip).join('/');\n                }\n                else {\n                    return false;\n                }\n            }\n            parts.splice(0, this.strip);\n            entry.path = parts.join('/');\n        }\n        if (isFinite(this.maxDepth) && parts.length > this.maxDepth) {\n            this.warn('TAR_ENTRY_ERROR', 'path excessively deep', {\n                entry,\n                path: p,\n                depth: parts.length,\n                maxDepth: this.maxDepth,\n            });\n            return false;\n        }\n        if (!this.preservePaths) {\n            if (parts.includes('..') ||\n                /* c8 ignore next */\n                (isWindows && /^[a-z]:\\.\\.$/i.test(parts[0] ?? ''))) {\n                this.warn('TAR_ENTRY_ERROR', `path contains '..'`, {\n                    entry,\n                    path: p,\n                });\n                return false;\n            }\n            // strip off the root\n            const [root, stripped] = (0,_strip_absolute_path_js__WEBPACK_IMPORTED_MODULE_10__.stripAbsolutePath)(p);\n            if (root) {\n                entry.path = String(stripped);\n                this.warn('TAR_ENTRY_INFO', `stripping ${root} from absolute path`, {\n                    entry,\n                    path: p,\n                });\n            }\n        }\n        if (node_path__WEBPACK_IMPORTED_MODULE_4__.isAbsolute(entry.path)) {\n            entry.absolute = (0,_normalize_windows_path_js__WEBPACK_IMPORTED_MODULE_8__.normalizeWindowsPath)(node_path__WEBPACK_IMPORTED_MODULE_4__.resolve(entry.path));\n        }\n        else {\n            entry.absolute = (0,_normalize_windows_path_js__WEBPACK_IMPORTED_MODULE_8__.normalizeWindowsPath)(node_path__WEBPACK_IMPORTED_MODULE_4__.resolve(this.cwd, entry.path));\n        }\n        // if we somehow ended up with a path that escapes the cwd, and we are\n        // not in preservePaths mode, then something is fishy!  This should have\n        // been prevented above, so ignore this for coverage.\n        /* c8 ignore start - defense in depth */\n        if (!this.preservePaths &&\n            typeof entry.absolute === 'string' &&\n            entry.absolute.indexOf(this.cwd + '/') !== 0 &&\n            entry.absolute !== this.cwd) {\n            this.warn('TAR_ENTRY_ERROR', 'path escaped extraction target', {\n                entry,\n                path: (0,_normalize_windows_path_js__WEBPACK_IMPORTED_MODULE_8__.normalizeWindowsPath)(entry.path),\n                resolvedPath: entry.absolute,\n                cwd: this.cwd,\n            });\n            return false;\n        }\n        /* c8 ignore stop */\n        // an archive can set properties on the extraction directory, but it\n        // may not replace the cwd with a different kind of thing entirely.\n        if (entry.absolute === this.cwd &&\n            entry.type !== 'Directory' &&\n            entry.type !== 'GNUDumpDir') {\n            return false;\n        }\n        // only encode : chars that aren't drive letter indicators\n        if (this.win32) {\n            const { root: aRoot } = node_path__WEBPACK_IMPORTED_MODULE_4__.win32.parse(String(entry.absolute));\n            entry.absolute =\n                aRoot + _winchars_js__WEBPACK_IMPORTED_MODULE_12__.encode(String(entry.absolute).slice(aRoot.length));\n            const { root: pRoot } = node_path__WEBPACK_IMPORTED_MODULE_4__.win32.parse(entry.path);\n            entry.path = pRoot + _winchars_js__WEBPACK_IMPORTED_MODULE_12__.encode(entry.path.slice(pRoot.length));\n        }\n        return true;\n    }\n    [ONENTRY](entry) {\n        if (!this[CHECKPATH](entry)) {\n            return entry.resume();\n        }\n        node_assert__WEBPACK_IMPORTED_MODULE_1__.equal(typeof entry.absolute, 'string');\n        switch (entry.type) {\n            case 'Directory':\n            case 'GNUDumpDir':\n                if (entry.mode) {\n                    entry.mode = entry.mode | 0o700;\n                }\n            // eslint-disable-next-line no-fallthrough\n            case 'File':\n            case 'OldFile':\n            case 'ContiguousFile':\n            case 'Link':\n            case 'SymbolicLink':\n                return this[CHECKFS](entry);\n            case 'CharacterDevice':\n            case 'BlockDevice':\n            case 'FIFO':\n            default:\n                return this[UNSUPPORTED](entry);\n        }\n    }\n    [ONERROR](er, entry) {\n        // Cwd has to exist, or else nothing works. That's serious.\n        // Other errors are warnings, which raise the error in strict\n        // mode, but otherwise continue on.\n        if (er.name === 'CwdError') {\n            this.emit('error', er);\n        }\n        else {\n            this.warn('TAR_ENTRY_ERROR', er, { entry });\n            this[UNPEND]();\n            entry.resume();\n        }\n    }\n    [MKDIR](dir, mode, cb) {\n        (0,_mkdir_js__WEBPACK_IMPORTED_MODULE_6__.mkdir)((0,_normalize_windows_path_js__WEBPACK_IMPORTED_MODULE_8__.normalizeWindowsPath)(dir), {\n            uid: this.uid,\n            gid: this.gid,\n            processUid: this.processUid,\n            processGid: this.processGid,\n            umask: this.processUmask,\n            preserve: this.preservePaths,\n            unlink: this.unlink,\n            cache: this.dirCache,\n            cwd: this.cwd,\n            mode: mode,\n        }, cb);\n    }\n    [DOCHOWN](entry) {\n        // in preserve owner mode, chown if the entry doesn't match process\n        // in set owner mode, chown if setting doesn't match process\n        return (this.forceChown ||\n            (this.preserveOwner &&\n                ((typeof entry.uid === 'number' &&\n                    entry.uid !== this.processUid) ||\n                    (typeof entry.gid === 'number' &&\n                        entry.gid !== this.processGid))) ||\n            (typeof this.uid === 'number' &&\n                this.uid !== this.processUid) ||\n            (typeof this.gid === 'number' && this.gid !== this.processGid));\n    }\n    [UID](entry) {\n        return uint32(this.uid, entry.uid, this.processUid);\n    }\n    [GID](entry) {\n        return uint32(this.gid, entry.gid, this.processGid);\n    }\n    [FILE](entry, fullyDone) {\n        const mode = typeof entry.mode === 'number' ?\n            entry.mode & 0o7777\n            : this.fmode;\n        const stream = new _isaacs_fs_minipass__WEBPACK_IMPORTED_MODULE_0__.WriteStream(String(entry.absolute), {\n            // slight lie, but it can be numeric flags\n            flags: (0,_get_write_flag_js__WEBPACK_IMPORTED_MODULE_5__.getWriteFlag)(entry.size),\n            mode: mode,\n            autoClose: false,\n        });\n        stream.on('error', (er) => {\n            if (stream.fd) {\n                node_fs__WEBPACK_IMPORTED_MODULE_3__.close(stream.fd, () => { });\n            }\n            // flush all the data out so that we aren't left hanging\n            // if the error wasn't actually fatal.  otherwise the parse\n            // is blocked, and we never proceed.\n            stream.write = () => true;\n            this[ONERROR](er, entry);\n            fullyDone();\n        });\n        let actions = 1;\n        const done = (er) => {\n            if (er) {\n                /* c8 ignore start - we should always have a fd by now */\n                if (stream.fd) {\n                    node_fs__WEBPACK_IMPORTED_MODULE_3__.close(stream.fd, () => { });\n                }\n                /* c8 ignore stop */\n                this[ONERROR](er, entry);\n                fullyDone();\n                return;\n            }\n            if (--actions === 0) {\n                if (stream.fd !== undefined) {\n                    node_fs__WEBPACK_IMPORTED_MODULE_3__.close(stream.fd, er => {\n                        if (er) {\n                            this[ONERROR](er, entry);\n                        }\n                        else {\n                            this[UNPEND]();\n                        }\n                        fullyDone();\n                    });\n                }\n            }\n        };\n        stream.on('finish', () => {\n            // if futimes fails, try utimes\n            // if utimes fails, fail with the original error\n            // same for fchown/chown\n            const abs = String(entry.absolute);\n            const fd = stream.fd;\n            if (typeof fd === 'number' && entry.mtime && !this.noMtime) {\n                actions++;\n                const atime = entry.atime || new Date();\n                const mtime = entry.mtime;\n                node_fs__WEBPACK_IMPORTED_MODULE_3__.futimes(fd, atime, mtime, er => er ?\n                    node_fs__WEBPACK_IMPORTED_MODULE_3__.utimes(abs, atime, mtime, er2 => done(er2 && er))\n                    : done());\n            }\n            if (typeof fd === 'number' && this[DOCHOWN](entry)) {\n                actions++;\n                const uid = this[UID](entry);\n                const gid = this[GID](entry);\n                if (typeof uid === 'number' && typeof gid === 'number') {\n                    node_fs__WEBPACK_IMPORTED_MODULE_3__.fchown(fd, uid, gid, er => er ?\n                        node_fs__WEBPACK_IMPORTED_MODULE_3__.chown(abs, uid, gid, er2 => done(er2 && er))\n                        : done());\n                }\n            }\n            done();\n        });\n        const tx = this.transform ? this.transform(entry) || entry : entry;\n        if (tx !== entry) {\n            tx.on('error', (er) => {\n                this[ONERROR](er, entry);\n                fullyDone();\n            });\n            entry.pipe(tx);\n        }\n        tx.pipe(stream);\n    }\n    [DIRECTORY](entry, fullyDone) {\n        const mode = typeof entry.mode === 'number' ?\n            entry.mode & 0o7777\n            : this.dmode;\n        this[MKDIR](String(entry.absolute), mode, er => {\n            if (er) {\n                this[ONERROR](er, entry);\n                fullyDone();\n                return;\n            }\n            let actions = 1;\n            const done = () => {\n                if (--actions === 0) {\n                    fullyDone();\n                    this[UNPEND]();\n                    entry.resume();\n                }\n            };\n            if (entry.mtime && !this.noMtime) {\n                actions++;\n                node_fs__WEBPACK_IMPORTED_MODULE_3__.utimes(String(entry.absolute), entry.atime || new Date(), entry.mtime, done);\n            }\n            if (this[DOCHOWN](entry)) {\n                actions++;\n                node_fs__WEBPACK_IMPORTED_MODULE_3__.chown(String(entry.absolute), Number(this[UID](entry)), Number(this[GID](entry)), done);\n            }\n            done();\n        });\n    }\n    [UNSUPPORTED](entry) {\n        entry.unsupported = true;\n        this.warn('TAR_ENTRY_UNSUPPORTED', `unsupported entry type: ${entry.type}`, { entry });\n        entry.resume();\n    }\n    [SYMLINK](entry, done) {\n        this[LINK](entry, String(entry.linkpath), 'symlink', done);\n    }\n    [HARDLINK](entry, done) {\n        const linkpath = (0,_normalize_windows_path_js__WEBPACK_IMPORTED_MODULE_8__.normalizeWindowsPath)(node_path__WEBPACK_IMPORTED_MODULE_4__.resolve(this.cwd, String(entry.linkpath)));\n        this[LINK](entry, linkpath, 'link', done);\n    }\n    [PEND]() {\n        this[PENDING]++;\n    }\n    [UNPEND]() {\n        this[PENDING]--;\n        this[MAYBECLOSE]();\n    }\n    [SKIP](entry) {\n        this[UNPEND]();\n        entry.resume();\n    }\n    // Check if we can reuse an existing filesystem entry safely and\n    // overwrite it, rather than unlinking and recreating\n    // Windows doesn't report a useful nlink, so we just never reuse entries\n    [ISREUSABLE](entry, st) {\n        return (entry.type === 'File' &&\n            !this.unlink &&\n            st.isFile() &&\n            st.nlink <= 1 &&\n            !isWindows);\n    }\n    // check if a thing is there, and if so, try to clobber it\n    [CHECKFS](entry) {\n        this[PEND]();\n        const paths = [entry.path];\n        if (entry.linkpath) {\n            paths.push(entry.linkpath);\n        }\n        this.reservations.reserve(paths, done => this[CHECKFS2](entry, done));\n    }\n    [PRUNECACHE](entry) {\n        // if we are not creating a directory, and the path is in the dirCache,\n        // then that means we are about to delete the directory we created\n        // previously, and it is no longer going to be a directory, and neither\n        // is any of its children.\n        // If a symbolic link is encountered, all bets are off.  There is no\n        // reasonable way to sanitize the cache in such a way we will be able to\n        // avoid having filesystem collisions.  If this happens with a non-symlink\n        // entry, it'll just fail to unpack, but a symlink to a directory, using an\n        // 8.3 shortname or certain unicode attacks, can evade detection and lead\n        // to arbitrary writes to anywhere on the system.\n        if (entry.type === 'SymbolicLink') {\n            dropCache(this.dirCache);\n        }\n        else if (entry.type !== 'Directory') {\n            pruneCache(this.dirCache, String(entry.absolute));\n        }\n    }\n    [CHECKFS2](entry, fullyDone) {\n        this[PRUNECACHE](entry);\n        const done = (er) => {\n            this[PRUNECACHE](entry);\n            fullyDone(er);\n        };\n        const checkCwd = () => {\n            this[MKDIR](this.cwd, this.dmode, er => {\n                if (er) {\n                    this[ONERROR](er, entry);\n                    done();\n                    return;\n                }\n                this[CHECKED_CWD] = true;\n                start();\n            });\n        };\n        const start = () => {\n            if (entry.absolute !== this.cwd) {\n                const parent = (0,_normalize_windows_path_js__WEBPACK_IMPORTED_MODULE_8__.normalizeWindowsPath)(node_path__WEBPACK_IMPORTED_MODULE_4__.dirname(String(entry.absolute)));\n                if (parent !== this.cwd) {\n                    return this[MKDIR](parent, this.dmode, er => {\n                        if (er) {\n                            this[ONERROR](er, entry);\n                            done();\n                            return;\n                        }\n                        afterMakeParent();\n                    });\n                }\n            }\n            afterMakeParent();\n        };\n        const afterMakeParent = () => {\n            node_fs__WEBPACK_IMPORTED_MODULE_3__.lstat(String(entry.absolute), (lstatEr, st) => {\n                if (st &&\n                    (this.keep ||\n                        /* c8 ignore next */\n                        (this.newer && st.mtime > (entry.mtime ?? st.mtime)))) {\n                    this[SKIP](entry);\n                    done();\n                    return;\n                }\n                if (lstatEr || this[ISREUSABLE](entry, st)) {\n                    return this[MAKEFS](null, entry, done);\n                }\n                if (st.isDirectory()) {\n                    if (entry.type === 'Directory') {\n                        const needChmod = this.chmod &&\n                            entry.mode &&\n                            (st.mode & 0o7777) !== entry.mode;\n                        const afterChmod = (er) => this[MAKEFS](er ?? null, entry, done);\n                        if (!needChmod) {\n                            return afterChmod();\n                        }\n                        return node_fs__WEBPACK_IMPORTED_MODULE_3__.chmod(String(entry.absolute), Number(entry.mode), afterChmod);\n                    }\n                    // Not a dir entry, have to remove it.\n                    // NB: the only way to end up with an entry that is the cwd\n                    // itself, in such a way that == does not detect, is a\n                    // tricky windows absolute path with UNC or 8.3 parts (and\n                    // preservePaths:true, or else it will have been stripped).\n                    // In that case, the user has opted out of path protections\n                    // explicitly, so if they blow away the cwd, c'est la vie.\n                    if (entry.absolute !== this.cwd) {\n                        return node_fs__WEBPACK_IMPORTED_MODULE_3__.rmdir(String(entry.absolute), (er) => this[MAKEFS](er ?? null, entry, done));\n                    }\n                }\n                // not a dir, and not reusable\n                // don't remove if the cwd, we want that error\n                if (entry.absolute === this.cwd) {\n                    return this[MAKEFS](null, entry, done);\n                }\n                unlinkFile(String(entry.absolute), er => this[MAKEFS](er ?? null, entry, done));\n            });\n        };\n        if (this[CHECKED_CWD]) {\n            start();\n        }\n        else {\n            checkCwd();\n        }\n    }\n    [MAKEFS](er, entry, done) {\n        if (er) {\n            this[ONERROR](er, entry);\n            done();\n            return;\n        }\n        switch (entry.type) {\n            case 'File':\n            case 'OldFile':\n            case 'ContiguousFile':\n                return this[FILE](entry, done);\n            case 'Link':\n                return this[HARDLINK](entry, done);\n            case 'SymbolicLink':\n                return this[SYMLINK](entry, done);\n            case 'Directory':\n            case 'GNUDumpDir':\n                return this[DIRECTORY](entry, done);\n        }\n    }\n    [LINK](entry, linkpath, link, done) {\n        // XXX: get the type ('symlink' or 'junction') for windows\n        node_fs__WEBPACK_IMPORTED_MODULE_3__[link](linkpath, String(entry.absolute), er => {\n            if (er) {\n                this[ONERROR](er, entry);\n            }\n            else {\n                this[UNPEND]();\n                entry.resume();\n            }\n            done();\n        });\n    }\n}\nconst callSync = (fn) => {\n    try {\n        return [null, fn()];\n    }\n    catch (er) {\n        return [er, null];\n    }\n};\nclass UnpackSync extends Unpack {\n    sync = true;\n    [MAKEFS](er, entry) {\n        return super[MAKEFS](er, entry, () => { });\n    }\n    [CHECKFS](entry) {\n        this[PRUNECACHE](entry);\n        if (!this[CHECKED_CWD]) {\n            const er = this[MKDIR](this.cwd, this.dmode);\n            if (er) {\n                return this[ONERROR](er, entry);\n            }\n            this[CHECKED_CWD] = true;\n        }\n        // don't bother to make the parent if the current entry is the cwd,\n        // we've already checked it.\n        if (entry.absolute !== this.cwd) {\n            const parent = (0,_normalize_windows_path_js__WEBPACK_IMPORTED_MODULE_8__.normalizeWindowsPath)(node_path__WEBPACK_IMPORTED_MODULE_4__.dirname(String(entry.absolute)));\n            if (parent !== this.cwd) {\n                const mkParent = this[MKDIR](parent, this.dmode);\n                if (mkParent) {\n                    return this[ONERROR](mkParent, entry);\n                }\n            }\n        }\n        const [lstatEr, st] = callSync(() => node_fs__WEBPACK_IMPORTED_MODULE_3__.lstatSync(String(entry.absolute)));\n        if (st &&\n            (this.keep ||\n                /* c8 ignore next */\n                (this.newer && st.mtime > (entry.mtime ?? st.mtime)))) {\n            return this[SKIP](entry);\n        }\n        if (lstatEr || this[ISREUSABLE](entry, st)) {\n            return this[MAKEFS](null, entry);\n        }\n        if (st.isDirectory()) {\n            if (entry.type === 'Directory') {\n                const needChmod = this.chmod &&\n                    entry.mode &&\n                    (st.mode & 0o7777) !== entry.mode;\n                const [er] = needChmod ?\n                    callSync(() => {\n                        node_fs__WEBPACK_IMPORTED_MODULE_3__.chmodSync(String(entry.absolute), Number(entry.mode));\n                    })\n                    : [];\n                return this[MAKEFS](er, entry);\n            }\n            // not a dir entry, have to remove it\n            const [er] = callSync(() => node_fs__WEBPACK_IMPORTED_MODULE_3__.rmdirSync(String(entry.absolute)));\n            this[MAKEFS](er, entry);\n        }\n        // not a dir, and not reusable.\n        // don't remove if it's the cwd, since we want that error.\n        const [er] = entry.absolute === this.cwd ?\n            []\n            : callSync(() => unlinkFileSync(String(entry.absolute)));\n        this[MAKEFS](er, entry);\n    }\n    [FILE](entry, done) {\n        const mode = typeof entry.mode === 'number' ?\n            entry.mode & 0o7777\n            : this.fmode;\n        const oner = (er) => {\n            let closeError;\n            try {\n                node_fs__WEBPACK_IMPORTED_MODULE_3__.closeSync(fd);\n            }\n            catch (e) {\n                closeError = e;\n            }\n            if (er || closeError) {\n                this[ONERROR](er || closeError, entry);\n            }\n            done();\n        };\n        let fd;\n        try {\n            fd = node_fs__WEBPACK_IMPORTED_MODULE_3__.openSync(String(entry.absolute), (0,_get_write_flag_js__WEBPACK_IMPORTED_MODULE_5__.getWriteFlag)(entry.size), mode);\n        }\n        catch (er) {\n            return oner(er);\n        }\n        const tx = this.transform ? this.transform(entry) || entry : entry;\n        if (tx !== entry) {\n            tx.on('error', (er) => this[ONERROR](er, entry));\n            entry.pipe(tx);\n        }\n        tx.on('data', (chunk) => {\n            try {\n                node_fs__WEBPACK_IMPORTED_MODULE_3__.writeSync(fd, chunk, 0, chunk.length);\n            }\n            catch (er) {\n                oner(er);\n            }\n        });\n        tx.on('end', () => {\n            let er = null;\n            // try both, falling futimes back to utimes\n            // if either fails, handle the first error\n            if (entry.mtime && !this.noMtime) {\n                const atime = entry.atime || new Date();\n                const mtime = entry.mtime;\n                try {\n                    node_fs__WEBPACK_IMPORTED_MODULE_3__.futimesSync(fd, atime, mtime);\n                }\n                catch (futimeser) {\n                    try {\n                        node_fs__WEBPACK_IMPORTED_MODULE_3__.utimesSync(String(entry.absolute), atime, mtime);\n                    }\n                    catch (utimeser) {\n                        er = futimeser;\n                    }\n                }\n            }\n            if (this[DOCHOWN](entry)) {\n                const uid = this[UID](entry);\n                const gid = this[GID](entry);\n                try {\n                    node_fs__WEBPACK_IMPORTED_MODULE_3__.fchownSync(fd, Number(uid), Number(gid));\n                }\n                catch (fchowner) {\n                    try {\n                        node_fs__WEBPACK_IMPORTED_MODULE_3__.chownSync(String(entry.absolute), Number(uid), Number(gid));\n                    }\n                    catch (chowner) {\n                        er = er || fchowner;\n                    }\n                }\n            }\n            oner(er);\n        });\n    }\n    [DIRECTORY](entry, done) {\n        const mode = typeof entry.mode === 'number' ?\n            entry.mode & 0o7777\n            : this.dmode;\n        const er = this[MKDIR](String(entry.absolute), mode);\n        if (er) {\n            this[ONERROR](er, entry);\n            done();\n            return;\n        }\n        if (entry.mtime && !this.noMtime) {\n            try {\n                node_fs__WEBPACK_IMPORTED_MODULE_3__.utimesSync(String(entry.absolute), entry.atime || new Date(), entry.mtime);\n                /* c8 ignore next */\n            }\n            catch (er) { }\n        }\n        if (this[DOCHOWN](entry)) {\n            try {\n                node_fs__WEBPACK_IMPORTED_MODULE_3__.chownSync(String(entry.absolute), Number(this[UID](entry)), Number(this[GID](entry)));\n            }\n            catch (er) { }\n        }\n        done();\n        entry.resume();\n    }\n    [MKDIR](dir, mode) {\n        try {\n            return (0,_mkdir_js__WEBPACK_IMPORTED_MODULE_6__.mkdirSync)((0,_normalize_windows_path_js__WEBPACK_IMPORTED_MODULE_8__.normalizeWindowsPath)(dir), {\n                uid: this.uid,\n                gid: this.gid,\n                processUid: this.processUid,\n                processGid: this.processGid,\n                umask: this.processUmask,\n                preserve: this.preservePaths,\n                unlink: this.unlink,\n                cache: this.dirCache,\n                cwd: this.cwd,\n                mode: mode,\n            });\n        }\n        catch (er) {\n            return er;\n        }\n    }\n    [LINK](entry, linkpath, link, done) {\n        const ls = `${link}Sync`;\n        try {\n            node_fs__WEBPACK_IMPORTED_MODULE_3__[ls](linkpath, String(entry.absolute));\n            done();\n            entry.resume();\n        }\n        catch (er) {\n            return this[ONERROR](er, entry);\n        }\n    }\n}\n//# sourceMappingURL=unpack.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvZXNtL3VucGFjay5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUMyQztBQUNWO0FBQ1M7QUFDakI7QUFDSTtBQUNzQjtBQUNMO0FBQ1k7QUFDUztBQUMvQjtBQUN5QjtBQUNNO0FBQy9CO0FBQ3NCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwyQ0FBUztBQUN4QjtBQUNBLHFDQUFxQyx3REFBVztBQUNoRCxJQUFJLDJDQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsUUFBUSwyQ0FBUztBQUNqQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsK0NBQWE7QUFDNUI7QUFDQSxxQ0FBcUMsd0RBQVc7QUFDaEQsSUFBSSwrQ0FBYTtBQUNqQixJQUFJLCtDQUFhO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxpRkFBb0IsQ0FBQyxnRkFBb0IsQ0FBQyx1RUFBZ0I7QUFDOUYsdUNBQXVDLElBQUk7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHFCQUFxQiw2Q0FBTTtBQUNsQztBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsb0VBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnRkFBb0IsQ0FBQyw4Q0FBWTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnRkFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGdGQUFvQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDJFQUFpQjtBQUN0RDtBQUNBO0FBQ0EseURBQXlELE1BQU07QUFDL0Q7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsWUFBWSxpREFBZTtBQUMzQiw2QkFBNkIsZ0ZBQW9CLENBQUMsOENBQVk7QUFDOUQ7QUFDQTtBQUNBLDZCQUE2QixnRkFBb0IsQ0FBQyw4Q0FBWTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdGQUFvQjtBQUMxQztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjLEVBQUUsNENBQVU7QUFDOUM7QUFDQSx3QkFBd0IsaURBQVM7QUFDakMsb0JBQW9CLGNBQWMsRUFBRSw0Q0FBVTtBQUM5QyxpQ0FBaUMsaURBQVM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDhDQUFZO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLE9BQU87QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZ0RBQUssQ0FBQyxnRkFBb0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDREQUFlO0FBQzFDO0FBQ0EsbUJBQW1CLGdFQUFZO0FBQy9CO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGdCQUFnQiwwQ0FBUSxxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwQ0FBUSxxQkFBcUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwQ0FBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw0Q0FBVTtBQUMxQixvQkFBb0IsMkNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkNBQVM7QUFDN0Isd0JBQXdCLDBDQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDJDQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwwQ0FBUTtBQUN4QjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxXQUFXLEtBQUssT0FBTztBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0ZBQW9CLENBQUMsOENBQVk7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsZ0ZBQW9CLENBQUMsOENBQVk7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwQ0FBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDBDQUFRO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwwQ0FBUTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0NBQUU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdGQUFvQixDQUFDLDhDQUFZO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLDhDQUFZO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDhDQUFZO0FBQ3BDLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyw4Q0FBWTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw4Q0FBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDZDQUFXLHlCQUF5QixnRUFBWTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDhDQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0RBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLCtDQUFhO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLCtDQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw4Q0FBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQ0FBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsOENBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvREFBUyxDQUFDLGdGQUFvQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsS0FBSztBQUMzQjtBQUNBLFlBQVksb0NBQUU7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aXZlLXZpYmUtYWktbmV4dC8uL25vZGVfbW9kdWxlcy90YXIvZGlzdC9lc20vdW5wYWNrLmpzPzc3YjAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gdGhlIFBFTkQvVU5QRU5EIHN0dWZmIHRyYWNrcyB3aGV0aGVyIHdlJ3JlIHJlYWR5IHRvIGVtaXQgZW5kL2Nsb3NlIHlldC5cbi8vIGJ1dCB0aGUgcGF0aCByZXNlcnZhdGlvbnMgYXJlIHJlcXVpcmVkIHRvIGF2b2lkIHJhY2UgY29uZGl0aW9ucyB3aGVyZVxuLy8gcGFyYWxsZWxpemVkIHVucGFjayBvcHMgbWF5IG1lc3Mgd2l0aCBvbmUgYW5vdGhlciwgZHVlIHRvIGRlcGVuZGVuY2llc1xuLy8gKGxpa2UgYSBMaW5rIGRlcGVuZGluZyBvbiBpdHMgdGFyZ2V0KSBvciBkZXN0cnVjdGl2ZSBvcGVyYXRpb25zIChsaWtlXG4vLyBjbG9iYmVyaW5nIGFuIGZzIG9iamVjdCB0byBjcmVhdGUgb25lIG9mIGEgZGlmZmVyZW50IHR5cGUuKVxuaW1wb3J0ICogYXMgZnNtIGZyb20gJ0Bpc2FhY3MvZnMtbWluaXBhc3MnO1xuaW1wb3J0IGFzc2VydCBmcm9tICdub2RlOmFzc2VydCc7XG5pbXBvcnQgeyByYW5kb21CeXRlcyB9IGZyb20gJ25vZGU6Y3J5cHRvJztcbmltcG9ydCBmcyBmcm9tICdub2RlOmZzJztcbmltcG9ydCBwYXRoIGZyb20gJ25vZGU6cGF0aCc7XG5pbXBvcnQgeyBnZXRXcml0ZUZsYWcgfSBmcm9tICcuL2dldC13cml0ZS1mbGFnLmpzJztcbmltcG9ydCB7IG1rZGlyLCBta2RpclN5bmMgfSBmcm9tICcuL21rZGlyLmpzJztcbmltcG9ydCB7IG5vcm1hbGl6ZVVuaWNvZGUgfSBmcm9tICcuL25vcm1hbGl6ZS11bmljb2RlLmpzJztcbmltcG9ydCB7IG5vcm1hbGl6ZVdpbmRvd3NQYXRoIH0gZnJvbSAnLi9ub3JtYWxpemUtd2luZG93cy1wYXRoLmpzJztcbmltcG9ydCB7IFBhcnNlciB9IGZyb20gJy4vcGFyc2UuanMnO1xuaW1wb3J0IHsgc3RyaXBBYnNvbHV0ZVBhdGggfSBmcm9tICcuL3N0cmlwLWFic29sdXRlLXBhdGguanMnO1xuaW1wb3J0IHsgc3RyaXBUcmFpbGluZ1NsYXNoZXMgfSBmcm9tICcuL3N0cmlwLXRyYWlsaW5nLXNsYXNoZXMuanMnO1xuaW1wb3J0ICogYXMgd2MgZnJvbSAnLi93aW5jaGFycy5qcyc7XG5pbXBvcnQgeyBQYXRoUmVzZXJ2YXRpb25zIH0gZnJvbSAnLi9wYXRoLXJlc2VydmF0aW9ucy5qcyc7XG5jb25zdCBPTkVOVFJZID0gU3ltYm9sKCdvbkVudHJ5Jyk7XG5jb25zdCBDSEVDS0ZTID0gU3ltYm9sKCdjaGVja0ZzJyk7XG5jb25zdCBDSEVDS0ZTMiA9IFN5bWJvbCgnY2hlY2tGczInKTtcbmNvbnN0IFBSVU5FQ0FDSEUgPSBTeW1ib2woJ3BydW5lQ2FjaGUnKTtcbmNvbnN0IElTUkVVU0FCTEUgPSBTeW1ib2woJ2lzUmV1c2FibGUnKTtcbmNvbnN0IE1BS0VGUyA9IFN5bWJvbCgnbWFrZUZzJyk7XG5jb25zdCBGSUxFID0gU3ltYm9sKCdmaWxlJyk7XG5jb25zdCBESVJFQ1RPUlkgPSBTeW1ib2woJ2RpcmVjdG9yeScpO1xuY29uc3QgTElOSyA9IFN5bWJvbCgnbGluaycpO1xuY29uc3QgU1lNTElOSyA9IFN5bWJvbCgnc3ltbGluaycpO1xuY29uc3QgSEFSRExJTksgPSBTeW1ib2woJ2hhcmRsaW5rJyk7XG5jb25zdCBVTlNVUFBPUlRFRCA9IFN5bWJvbCgndW5zdXBwb3J0ZWQnKTtcbmNvbnN0IENIRUNLUEFUSCA9IFN5bWJvbCgnY2hlY2tQYXRoJyk7XG5jb25zdCBNS0RJUiA9IFN5bWJvbCgnbWtkaXInKTtcbmNvbnN0IE9ORVJST1IgPSBTeW1ib2woJ29uRXJyb3InKTtcbmNvbnN0IFBFTkRJTkcgPSBTeW1ib2woJ3BlbmRpbmcnKTtcbmNvbnN0IFBFTkQgPSBTeW1ib2woJ3BlbmQnKTtcbmNvbnN0IFVOUEVORCA9IFN5bWJvbCgndW5wZW5kJyk7XG5jb25zdCBFTkRFRCA9IFN5bWJvbCgnZW5kZWQnKTtcbmNvbnN0IE1BWUJFQ0xPU0UgPSBTeW1ib2woJ21heWJlQ2xvc2UnKTtcbmNvbnN0IFNLSVAgPSBTeW1ib2woJ3NraXAnKTtcbmNvbnN0IERPQ0hPV04gPSBTeW1ib2woJ2RvQ2hvd24nKTtcbmNvbnN0IFVJRCA9IFN5bWJvbCgndWlkJyk7XG5jb25zdCBHSUQgPSBTeW1ib2woJ2dpZCcpO1xuY29uc3QgQ0hFQ0tFRF9DV0QgPSBTeW1ib2woJ2NoZWNrZWRDd2QnKTtcbmNvbnN0IHBsYXRmb3JtID0gcHJvY2Vzcy5lbnYuVEVTVElOR19UQVJfRkFLRV9QTEFURk9STSB8fCBwcm9jZXNzLnBsYXRmb3JtO1xuY29uc3QgaXNXaW5kb3dzID0gcGxhdGZvcm0gPT09ICd3aW4zMic7XG5jb25zdCBERUZBVUxUX01BWF9ERVBUSCA9IDEwMjQ7XG4vLyBVbmxpbmtzIG9uIFdpbmRvd3MgYXJlIG5vdCBhdG9taWMuXG4vL1xuLy8gVGhpcyBtZWFucyB0aGF0IGlmIHlvdSBoYXZlIGEgZmlsZSBlbnRyeSwgZm9sbG93ZWQgYnkgYW5vdGhlclxuLy8gZmlsZSBlbnRyeSB3aXRoIGFuIGlkZW50aWNhbCBuYW1lLCBhbmQgeW91IGNhbm5vdCByZS11c2UgdGhlIGZpbGVcbi8vIChiZWNhdXNlIGl0J3MgYSBoYXJkbGluaywgb3IgYmVjYXVzZSB1bmxpbms6dHJ1ZSBpcyBzZXQsIG9yIGl0J3Ncbi8vIFdpbmRvd3MsIHdoaWNoIGRvZXMgbm90IGhhdmUgdXNlZnVsIG5saW5rIHZhbHVlcyksIHRoZW4gdGhlIHVubGlua1xuLy8gd2lsbCBiZSBjb21taXR0ZWQgdG8gdGhlIGRpc2sgQUZURVIgdGhlIG5ldyBmaWxlIGhhcyBiZWVuIHdyaXR0ZW5cbi8vIG92ZXIgdGhlIG9sZCBvbmUsIGRlbGV0aW5nIHRoZSBuZXcgZmlsZS5cbi8vXG4vLyBUbyB3b3JrIGFyb3VuZCB0aGlzLCBvbiBXaW5kb3dzIHN5c3RlbXMsIHdlIHJlbmFtZSB0aGUgZmlsZSBhbmQgdGhlblxuLy8gZGVsZXRlIHRoZSByZW5hbWVkIGZpbGUuICBJdCdzIGEgc2xvcHB5IGtsdWRnZSwgYnV0IGZyYW5rbHksIEkgZG8gbm90XG4vLyBrbm93IG9mIGEgYmV0dGVyIHdheSB0byBkbyB0aGlzLCBnaXZlbiB3aW5kb3dzJyBub24tYXRvbWljIHVubGlua1xuLy8gc2VtYW50aWNzLlxuLy9cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL25wbS9ub2RlLXRhci9pc3N1ZXMvMTgzXG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cbmNvbnN0IHVubGlua0ZpbGUgPSAocGF0aCwgY2IpID0+IHtcbiAgICBpZiAoIWlzV2luZG93cykge1xuICAgICAgICByZXR1cm4gZnMudW5saW5rKHBhdGgsIGNiKTtcbiAgICB9XG4gICAgY29uc3QgbmFtZSA9IHBhdGggKyAnLkRFTEVURS4nICsgcmFuZG9tQnl0ZXMoMTYpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICBmcy5yZW5hbWUocGF0aCwgbmFtZSwgZXIgPT4ge1xuICAgICAgICBpZiAoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBjYihlcik7XG4gICAgICAgIH1cbiAgICAgICAgZnMudW5saW5rKG5hbWUsIGNiKTtcbiAgICB9KTtcbn07XG4vKiBjOCBpZ25vcmUgc3RvcCAqL1xuLyogYzggaWdub3JlIHN0YXJ0ICovXG5jb25zdCB1bmxpbmtGaWxlU3luYyA9IChwYXRoKSA9PiB7XG4gICAgaWYgKCFpc1dpbmRvd3MpIHtcbiAgICAgICAgcmV0dXJuIGZzLnVubGlua1N5bmMocGF0aCk7XG4gICAgfVxuICAgIGNvbnN0IG5hbWUgPSBwYXRoICsgJy5ERUxFVEUuJyArIHJhbmRvbUJ5dGVzKDE2KS50b1N0cmluZygnaGV4Jyk7XG4gICAgZnMucmVuYW1lU3luYyhwYXRoLCBuYW1lKTtcbiAgICBmcy51bmxpbmtTeW5jKG5hbWUpO1xufTtcbi8qIGM4IGlnbm9yZSBzdG9wICovXG4vLyB0aGlzLmdpZCwgZW50cnkuZ2lkLCB0aGlzLnByb2Nlc3NVaWRcbmNvbnN0IHVpbnQzMiA9IChhLCBiLCBjKSA9PiBhICE9PSB1bmRlZmluZWQgJiYgYSA9PT0gYSA+Pj4gMCA/IGFcbiAgICA6IGIgIT09IHVuZGVmaW5lZCAmJiBiID09PSBiID4+PiAwID8gYlxuICAgICAgICA6IGM7XG4vLyBjbGVhciB0aGUgY2FjaGUgaWYgaXQncyBhIGNhc2UtaW5zZW5zaXRpdmUgdW5pY29kZS1zcXVhc2hpbmcgbWF0Y2guXG4vLyB3ZSBjYW4ndCBrbm93IGlmIHRoZSBjdXJyZW50IGZpbGUgc3lzdGVtIGlzIGNhc2Utc2Vuc2l0aXZlIG9yIHN1cHBvcnRzXG4vLyB1bmljb2RlIGZ1bGx5LCBzbyB3ZSBjaGVjayBmb3Igc2ltaWxhcml0eSBvbiB0aGUgbWF4aW1hbGx5IGNvbXBhdGlibGVcbi8vIHJlcHJlc2VudGF0aW9uLiAgRXJyIG9uIHRoZSBzaWRlIG9mIHBydW5pbmcsIHNpbmNlIGFsbCBpdCdzIGRvaW5nIGlzXG4vLyBwcmV2ZW50aW5nIGxzdGF0cywgYW5kIGl0J3Mgbm90IHRoZSBlbmQgb2YgdGhlIHdvcmxkIGlmIHdlIGdldCBhIGZhbHNlXG4vLyBwb3NpdGl2ZS5cbi8vIE5vdGUgdGhhdCBvbiB3aW5kb3dzLCB3ZSBhbHdheXMgZHJvcCB0aGUgZW50aXJlIGNhY2hlIHdoZW5ldmVyIGFcbi8vIHN5bWJvbGljIGxpbmsgaXMgZW5jb3VudGVyZWQsIGJlY2F1c2UgOC4zIGZpbGVuYW1lcyBhcmUgaW1wb3NzaWJsZVxuLy8gdG8gcmVhc29uIGFib3V0LCBhbmQgY29sbGlzaW9ucyBhcmUgaGF6YXJkcyByYXRoZXIgdGhhbiBqdXN0IGZhaWx1cmVzLlxuY29uc3QgY2FjaGVLZXlOb3JtYWxpemUgPSAocGF0aCkgPT4gc3RyaXBUcmFpbGluZ1NsYXNoZXMobm9ybWFsaXplV2luZG93c1BhdGgobm9ybWFsaXplVW5pY29kZShwYXRoKSkpLnRvTG93ZXJDYXNlKCk7XG4vLyByZW1vdmUgYWxsIGNhY2hlIGVudHJpZXMgbWF0Y2hpbmcgJHthYnN9LyoqXG5jb25zdCBwcnVuZUNhY2hlID0gKGNhY2hlLCBhYnMpID0+IHtcbiAgICBhYnMgPSBjYWNoZUtleU5vcm1hbGl6ZShhYnMpO1xuICAgIGZvciAoY29uc3QgcGF0aCBvZiBjYWNoZS5rZXlzKCkpIHtcbiAgICAgICAgY29uc3QgcG5vcm0gPSBjYWNoZUtleU5vcm1hbGl6ZShwYXRoKTtcbiAgICAgICAgaWYgKHBub3JtID09PSBhYnMgfHwgcG5vcm0uaW5kZXhPZihhYnMgKyAnLycpID09PSAwKSB7XG4gICAgICAgICAgICBjYWNoZS5kZWxldGUocGF0aCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgZHJvcENhY2hlID0gKGNhY2hlKSA9PiB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgY2FjaGUua2V5cygpKSB7XG4gICAgICAgIGNhY2hlLmRlbGV0ZShrZXkpO1xuICAgIH1cbn07XG5leHBvcnQgY2xhc3MgVW5wYWNrIGV4dGVuZHMgUGFyc2VyIHtcbiAgICBbRU5ERURdID0gZmFsc2U7XG4gICAgW0NIRUNLRURfQ1dEXSA9IGZhbHNlO1xuICAgIFtQRU5ESU5HXSA9IDA7XG4gICAgcmVzZXJ2YXRpb25zID0gbmV3IFBhdGhSZXNlcnZhdGlvbnMoKTtcbiAgICB0cmFuc2Zvcm07XG4gICAgd3JpdGFibGUgPSB0cnVlO1xuICAgIHJlYWRhYmxlID0gZmFsc2U7XG4gICAgZGlyQ2FjaGU7XG4gICAgdWlkO1xuICAgIGdpZDtcbiAgICBzZXRPd25lcjtcbiAgICBwcmVzZXJ2ZU93bmVyO1xuICAgIHByb2Nlc3NHaWQ7XG4gICAgcHJvY2Vzc1VpZDtcbiAgICBtYXhEZXB0aDtcbiAgICBmb3JjZUNob3duO1xuICAgIHdpbjMyO1xuICAgIG5ld2VyO1xuICAgIGtlZXA7XG4gICAgbm9NdGltZTtcbiAgICBwcmVzZXJ2ZVBhdGhzO1xuICAgIHVubGluaztcbiAgICBjd2Q7XG4gICAgc3RyaXA7XG4gICAgcHJvY2Vzc1VtYXNrO1xuICAgIHVtYXNrO1xuICAgIGRtb2RlO1xuICAgIGZtb2RlO1xuICAgIGNobW9kO1xuICAgIGNvbnN0cnVjdG9yKG9wdCA9IHt9KSB7XG4gICAgICAgIG9wdC5vbmRvbmUgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzW0VOREVEXSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzW01BWUJFQ0xPU0VdKCk7XG4gICAgICAgIH07XG4gICAgICAgIHN1cGVyKG9wdCk7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gb3B0LnRyYW5zZm9ybTtcbiAgICAgICAgdGhpcy5kaXJDYWNoZSA9IG9wdC5kaXJDYWNoZSB8fCBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuY2htb2QgPSAhIW9wdC5jaG1vZDtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHQudWlkID09PSAnbnVtYmVyJyB8fCB0eXBlb2Ygb3B0LmdpZCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIC8vIG5lZWQgYm90aCBvciBuZWl0aGVyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdC51aWQgIT09ICdudW1iZXInIHx8XG4gICAgICAgICAgICAgICAgdHlwZW9mIG9wdC5naWQgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2Fubm90IHNldCBvd25lciB3aXRob3V0IG51bWJlciB1aWQgYW5kIGdpZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdC5wcmVzZXJ2ZU93bmVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2Fubm90IHByZXNlcnZlIG93bmVyIGluIGFyY2hpdmUgYW5kIGFsc28gc2V0IG93bmVyIGV4cGxpY2l0bHknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudWlkID0gb3B0LnVpZDtcbiAgICAgICAgICAgIHRoaXMuZ2lkID0gb3B0LmdpZDtcbiAgICAgICAgICAgIHRoaXMuc2V0T3duZXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51aWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLmdpZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuc2V0T3duZXIgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkZWZhdWx0IHRydWUgZm9yIHJvb3RcbiAgICAgICAgaWYgKG9wdC5wcmVzZXJ2ZU93bmVyID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHR5cGVvZiBvcHQudWlkICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy5wcmVzZXJ2ZU93bmVyID0gISEocHJvY2Vzcy5nZXR1aWQgJiYgcHJvY2Vzcy5nZXR1aWQoKSA9PT0gMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnByZXNlcnZlT3duZXIgPSAhIW9wdC5wcmVzZXJ2ZU93bmVyO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJvY2Vzc1VpZCA9XG4gICAgICAgICAgICAodGhpcy5wcmVzZXJ2ZU93bmVyIHx8IHRoaXMuc2V0T3duZXIpICYmIHByb2Nlc3MuZ2V0dWlkID9cbiAgICAgICAgICAgICAgICBwcm9jZXNzLmdldHVpZCgpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucHJvY2Vzc0dpZCA9XG4gICAgICAgICAgICAodGhpcy5wcmVzZXJ2ZU93bmVyIHx8IHRoaXMuc2V0T3duZXIpICYmIHByb2Nlc3MuZ2V0Z2lkID9cbiAgICAgICAgICAgICAgICBwcm9jZXNzLmdldGdpZCgpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIC8vIHByZXZlbnQgZXhjZXNzaXZlbHkgZGVlcCBuZXN0aW5nIG9mIHN1YmZvbGRlcnNcbiAgICAgICAgLy8gc2V0IHRvIGBJbmZpbml0eWAgdG8gcmVtb3ZlIHRoaXMgcmVzdHJpY3Rpb25cbiAgICAgICAgdGhpcy5tYXhEZXB0aCA9XG4gICAgICAgICAgICB0eXBlb2Ygb3B0Lm1heERlcHRoID09PSAnbnVtYmVyJyA/XG4gICAgICAgICAgICAgICAgb3B0Lm1heERlcHRoXG4gICAgICAgICAgICAgICAgOiBERUZBVUxUX01BWF9ERVBUSDtcbiAgICAgICAgLy8gbW9zdGx5IGp1c3QgZm9yIHRlc3RpbmcsIGJ1dCB1c2VmdWwgaW4gc29tZSBjYXNlcy5cbiAgICAgICAgLy8gRm9yY2libHkgdHJpZ2dlciBhIGNob3duIG9uIGV2ZXJ5IGVudHJ5LCBubyBtYXR0ZXIgd2hhdFxuICAgICAgICB0aGlzLmZvcmNlQ2hvd24gPSBvcHQuZm9yY2VDaG93biA9PT0gdHJ1ZTtcbiAgICAgICAgLy8gdHVybiA+PD98IGluIGZpbGVuYW1lcyBpbnRvIDB4ZjAwMC1oaWdoZXIgZW5jb2RlZCBmb3Jtc1xuICAgICAgICB0aGlzLndpbjMyID0gISFvcHQud2luMzIgfHwgaXNXaW5kb3dzO1xuICAgICAgICAvLyBkbyBub3QgdW5wYWNrIG92ZXIgZmlsZXMgdGhhdCBhcmUgbmV3ZXIgdGhhbiB3aGF0J3MgaW4gdGhlIGFyY2hpdmVcbiAgICAgICAgdGhpcy5uZXdlciA9ICEhb3B0Lm5ld2VyO1xuICAgICAgICAvLyBkbyBub3QgdW5wYWNrIG92ZXIgQU5ZIGZpbGVzXG4gICAgICAgIHRoaXMua2VlcCA9ICEhb3B0LmtlZXA7XG4gICAgICAgIC8vIGRvIG5vdCBzZXQgbXRpbWUvYXRpbWUgb2YgZXh0cmFjdGVkIGVudHJpZXNcbiAgICAgICAgdGhpcy5ub010aW1lID0gISFvcHQubm9NdGltZTtcbiAgICAgICAgLy8gYWxsb3cgLi4sIGFic29sdXRlIHBhdGggZW50cmllcywgYW5kIHVucGFja2luZyB0aHJvdWdoIHN5bWxpbmtzXG4gICAgICAgIC8vIHdpdGhvdXQgdGhpcywgd2FybiBhbmQgc2tpcCAuLiwgcmVsYXRpdml6ZSBhYnNvbHV0ZXMsIGFuZCBlcnJvclxuICAgICAgICAvLyBvbiBzeW1saW5rcyBpbiBleHRyYWN0aW9uIHBhdGhcbiAgICAgICAgdGhpcy5wcmVzZXJ2ZVBhdGhzID0gISFvcHQucHJlc2VydmVQYXRocztcbiAgICAgICAgLy8gdW5saW5rIGZpbGVzIGFuZCBsaW5rcyBiZWZvcmUgd3JpdGluZy4gVGhpcyBicmVha3MgZXhpc3RpbmcgaGFyZFxuICAgICAgICAvLyBsaW5rcywgYW5kIHJlbW92ZXMgc3ltbGluayBkaXJlY3RvcmllcyByYXRoZXIgdGhhbiBlcnJvcmluZ1xuICAgICAgICB0aGlzLnVubGluayA9ICEhb3B0LnVubGluaztcbiAgICAgICAgdGhpcy5jd2QgPSBub3JtYWxpemVXaW5kb3dzUGF0aChwYXRoLnJlc29sdmUob3B0LmN3ZCB8fCBwcm9jZXNzLmN3ZCgpKSk7XG4gICAgICAgIHRoaXMuc3RyaXAgPSBOdW1iZXIob3B0LnN0cmlwKSB8fCAwO1xuICAgICAgICAvLyBpZiB3ZSdyZSBub3QgY2htb2RkaW5nLCB0aGVuIHdlIGRvbid0IG5lZWQgdGhlIHByb2Nlc3MgdW1hc2tcbiAgICAgICAgdGhpcy5wcm9jZXNzVW1hc2sgPVxuICAgICAgICAgICAgIXRoaXMuY2htb2QgPyAwXG4gICAgICAgICAgICAgICAgOiB0eXBlb2Ygb3B0LnByb2Nlc3NVbWFzayA9PT0gJ251bWJlcicgPyBvcHQucHJvY2Vzc1VtYXNrXG4gICAgICAgICAgICAgICAgICAgIDogcHJvY2Vzcy51bWFzaygpO1xuICAgICAgICB0aGlzLnVtYXNrID1cbiAgICAgICAgICAgIHR5cGVvZiBvcHQudW1hc2sgPT09ICdudW1iZXInID8gb3B0LnVtYXNrIDogdGhpcy5wcm9jZXNzVW1hc2s7XG4gICAgICAgIC8vIGRlZmF1bHQgbW9kZSBmb3IgZGlycyBjcmVhdGVkIGFzIHBhcmVudHNcbiAgICAgICAgdGhpcy5kbW9kZSA9IG9wdC5kbW9kZSB8fCAwbzA3NzcgJiB+dGhpcy51bWFzaztcbiAgICAgICAgdGhpcy5mbW9kZSA9IG9wdC5mbW9kZSB8fCAwbzA2NjYgJiB+dGhpcy51bWFzaztcbiAgICAgICAgdGhpcy5vbignZW50cnknLCBlbnRyeSA9PiB0aGlzW09ORU5UUlldKGVudHJ5KSk7XG4gICAgfVxuICAgIC8vIGEgYmFkIG9yIGRhbWFnZWQgYXJjaGl2ZSBpcyBhIHdhcm5pbmcgZm9yIFBhcnNlciwgYnV0IGFuIGVycm9yXG4gICAgLy8gd2hlbiBleHRyYWN0aW5nLiAgTWFyayB0aG9zZSBlcnJvcnMgYXMgdW5yZWNvdmVyYWJsZSwgYmVjYXVzZVxuICAgIC8vIHRoZSBVbnBhY2sgY29udHJhY3QgY2Fubm90IGJlIG1ldC5cbiAgICB3YXJuKGNvZGUsIG1zZywgZGF0YSA9IHt9KSB7XG4gICAgICAgIGlmIChjb2RlID09PSAnVEFSX0JBRF9BUkNISVZFJyB8fCBjb2RlID09PSAnVEFSX0FCT1JUJykge1xuICAgICAgICAgICAgZGF0YS5yZWNvdmVyYWJsZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci53YXJuKGNvZGUsIG1zZywgZGF0YSk7XG4gICAgfVxuICAgIFtNQVlCRUNMT1NFXSgpIHtcbiAgICAgICAgaWYgKHRoaXNbRU5ERURdICYmIHRoaXNbUEVORElOR10gPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncHJlZmluaXNoJyk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2ZpbmlzaCcpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdlbmQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBbQ0hFQ0tQQVRIXShlbnRyeSkge1xuICAgICAgICBjb25zdCBwID0gbm9ybWFsaXplV2luZG93c1BhdGgoZW50cnkucGF0aCk7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gcC5zcGxpdCgnLycpO1xuICAgICAgICBpZiAodGhpcy5zdHJpcCkge1xuICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA8IHRoaXMuc3RyaXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW50cnkudHlwZSA9PT0gJ0xpbmsnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGlua3BhcnRzID0gbm9ybWFsaXplV2luZG93c1BhdGgoU3RyaW5nKGVudHJ5LmxpbmtwYXRoKSkuc3BsaXQoJy8nKTtcbiAgICAgICAgICAgICAgICBpZiAobGlua3BhcnRzLmxlbmd0aCA+PSB0aGlzLnN0cmlwKSB7XG4gICAgICAgICAgICAgICAgICAgIGVudHJ5LmxpbmtwYXRoID0gbGlua3BhcnRzLnNsaWNlKHRoaXMuc3RyaXApLmpvaW4oJy8nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJ0cy5zcGxpY2UoMCwgdGhpcy5zdHJpcCk7XG4gICAgICAgICAgICBlbnRyeS5wYXRoID0gcGFydHMuam9pbignLycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0Zpbml0ZSh0aGlzLm1heERlcHRoKSAmJiBwYXJ0cy5sZW5ndGggPiB0aGlzLm1heERlcHRoKSB7XG4gICAgICAgICAgICB0aGlzLndhcm4oJ1RBUl9FTlRSWV9FUlJPUicsICdwYXRoIGV4Y2Vzc2l2ZWx5IGRlZXAnLCB7XG4gICAgICAgICAgICAgICAgZW50cnksXG4gICAgICAgICAgICAgICAgcGF0aDogcCxcbiAgICAgICAgICAgICAgICBkZXB0aDogcGFydHMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIG1heERlcHRoOiB0aGlzLm1heERlcHRoLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnByZXNlcnZlUGF0aHMpIHtcbiAgICAgICAgICAgIGlmIChwYXJ0cy5pbmNsdWRlcygnLi4nKSB8fFxuICAgICAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgKGlzV2luZG93cyAmJiAvXlthLXpdOlxcLlxcLiQvaS50ZXN0KHBhcnRzWzBdID8/ICcnKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndhcm4oJ1RBUl9FTlRSWV9FUlJPUicsIGBwYXRoIGNvbnRhaW5zICcuLidgLCB7XG4gICAgICAgICAgICAgICAgICAgIGVudHJ5LFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBwLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHN0cmlwIG9mZiB0aGUgcm9vdFxuICAgICAgICAgICAgY29uc3QgW3Jvb3QsIHN0cmlwcGVkXSA9IHN0cmlwQWJzb2x1dGVQYXRoKHApO1xuICAgICAgICAgICAgaWYgKHJvb3QpIHtcbiAgICAgICAgICAgICAgICBlbnRyeS5wYXRoID0gU3RyaW5nKHN0cmlwcGVkKTtcbiAgICAgICAgICAgICAgICB0aGlzLndhcm4oJ1RBUl9FTlRSWV9JTkZPJywgYHN0cmlwcGluZyAke3Jvb3R9IGZyb20gYWJzb2x1dGUgcGF0aGAsIHtcbiAgICAgICAgICAgICAgICAgICAgZW50cnksXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IHAsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdGguaXNBYnNvbHV0ZShlbnRyeS5wYXRoKSkge1xuICAgICAgICAgICAgZW50cnkuYWJzb2x1dGUgPSBub3JtYWxpemVXaW5kb3dzUGF0aChwYXRoLnJlc29sdmUoZW50cnkucGF0aCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZW50cnkuYWJzb2x1dGUgPSBub3JtYWxpemVXaW5kb3dzUGF0aChwYXRoLnJlc29sdmUodGhpcy5jd2QsIGVudHJ5LnBhdGgpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB3ZSBzb21laG93IGVuZGVkIHVwIHdpdGggYSBwYXRoIHRoYXQgZXNjYXBlcyB0aGUgY3dkLCBhbmQgd2UgYXJlXG4gICAgICAgIC8vIG5vdCBpbiBwcmVzZXJ2ZVBhdGhzIG1vZGUsIHRoZW4gc29tZXRoaW5nIGlzIGZpc2h5ISAgVGhpcyBzaG91bGQgaGF2ZVxuICAgICAgICAvLyBiZWVuIHByZXZlbnRlZCBhYm92ZSwgc28gaWdub3JlIHRoaXMgZm9yIGNvdmVyYWdlLlxuICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgLSBkZWZlbnNlIGluIGRlcHRoICovXG4gICAgICAgIGlmICghdGhpcy5wcmVzZXJ2ZVBhdGhzICYmXG4gICAgICAgICAgICB0eXBlb2YgZW50cnkuYWJzb2x1dGUgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICBlbnRyeS5hYnNvbHV0ZS5pbmRleE9mKHRoaXMuY3dkICsgJy8nKSAhPT0gMCAmJlxuICAgICAgICAgICAgZW50cnkuYWJzb2x1dGUgIT09IHRoaXMuY3dkKSB7XG4gICAgICAgICAgICB0aGlzLndhcm4oJ1RBUl9FTlRSWV9FUlJPUicsICdwYXRoIGVzY2FwZWQgZXh0cmFjdGlvbiB0YXJnZXQnLCB7XG4gICAgICAgICAgICAgICAgZW50cnksXG4gICAgICAgICAgICAgICAgcGF0aDogbm9ybWFsaXplV2luZG93c1BhdGgoZW50cnkucGF0aCksXG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRQYXRoOiBlbnRyeS5hYnNvbHV0ZSxcbiAgICAgICAgICAgICAgICBjd2Q6IHRoaXMuY3dkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgLy8gYW4gYXJjaGl2ZSBjYW4gc2V0IHByb3BlcnRpZXMgb24gdGhlIGV4dHJhY3Rpb24gZGlyZWN0b3J5LCBidXQgaXRcbiAgICAgICAgLy8gbWF5IG5vdCByZXBsYWNlIHRoZSBjd2Qgd2l0aCBhIGRpZmZlcmVudCBraW5kIG9mIHRoaW5nIGVudGlyZWx5LlxuICAgICAgICBpZiAoZW50cnkuYWJzb2x1dGUgPT09IHRoaXMuY3dkICYmXG4gICAgICAgICAgICBlbnRyeS50eXBlICE9PSAnRGlyZWN0b3J5JyAmJlxuICAgICAgICAgICAgZW50cnkudHlwZSAhPT0gJ0dOVUR1bXBEaXInKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb25seSBlbmNvZGUgOiBjaGFycyB0aGF0IGFyZW4ndCBkcml2ZSBsZXR0ZXIgaW5kaWNhdG9yc1xuICAgICAgICBpZiAodGhpcy53aW4zMikge1xuICAgICAgICAgICAgY29uc3QgeyByb290OiBhUm9vdCB9ID0gcGF0aC53aW4zMi5wYXJzZShTdHJpbmcoZW50cnkuYWJzb2x1dGUpKTtcbiAgICAgICAgICAgIGVudHJ5LmFic29sdXRlID1cbiAgICAgICAgICAgICAgICBhUm9vdCArIHdjLmVuY29kZShTdHJpbmcoZW50cnkuYWJzb2x1dGUpLnNsaWNlKGFSb290Lmxlbmd0aCkpO1xuICAgICAgICAgICAgY29uc3QgeyByb290OiBwUm9vdCB9ID0gcGF0aC53aW4zMi5wYXJzZShlbnRyeS5wYXRoKTtcbiAgICAgICAgICAgIGVudHJ5LnBhdGggPSBwUm9vdCArIHdjLmVuY29kZShlbnRyeS5wYXRoLnNsaWNlKHBSb290Lmxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBbT05FTlRSWV0oZW50cnkpIHtcbiAgICAgICAgaWYgKCF0aGlzW0NIRUNLUEFUSF0oZW50cnkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZW50cnkucmVzdW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0LmVxdWFsKHR5cGVvZiBlbnRyeS5hYnNvbHV0ZSwgJ3N0cmluZycpO1xuICAgICAgICBzd2l0Y2ggKGVudHJ5LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ0RpcmVjdG9yeSc6XG4gICAgICAgICAgICBjYXNlICdHTlVEdW1wRGlyJzpcbiAgICAgICAgICAgICAgICBpZiAoZW50cnkubW9kZSkge1xuICAgICAgICAgICAgICAgICAgICBlbnRyeS5tb2RlID0gZW50cnkubW9kZSB8IDBvNzAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgICAgICAgICAgY2FzZSAnRmlsZSc6XG4gICAgICAgICAgICBjYXNlICdPbGRGaWxlJzpcbiAgICAgICAgICAgIGNhc2UgJ0NvbnRpZ3VvdXNGaWxlJzpcbiAgICAgICAgICAgIGNhc2UgJ0xpbmsnOlxuICAgICAgICAgICAgY2FzZSAnU3ltYm9saWNMaW5rJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tDSEVDS0ZTXShlbnRyeSk7XG4gICAgICAgICAgICBjYXNlICdDaGFyYWN0ZXJEZXZpY2UnOlxuICAgICAgICAgICAgY2FzZSAnQmxvY2tEZXZpY2UnOlxuICAgICAgICAgICAgY2FzZSAnRklGTyc6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW1VOU1VQUE9SVEVEXShlbnRyeSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgW09ORVJST1JdKGVyLCBlbnRyeSkge1xuICAgICAgICAvLyBDd2QgaGFzIHRvIGV4aXN0LCBvciBlbHNlIG5vdGhpbmcgd29ya3MuIFRoYXQncyBzZXJpb3VzLlxuICAgICAgICAvLyBPdGhlciBlcnJvcnMgYXJlIHdhcm5pbmdzLCB3aGljaCByYWlzZSB0aGUgZXJyb3IgaW4gc3RyaWN0XG4gICAgICAgIC8vIG1vZGUsIGJ1dCBvdGhlcndpc2UgY29udGludWUgb24uXG4gICAgICAgIGlmIChlci5uYW1lID09PSAnQ3dkRXJyb3InKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy53YXJuKCdUQVJfRU5UUllfRVJST1InLCBlciwgeyBlbnRyeSB9KTtcbiAgICAgICAgICAgIHRoaXNbVU5QRU5EXSgpO1xuICAgICAgICAgICAgZW50cnkucmVzdW1lKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgW01LRElSXShkaXIsIG1vZGUsIGNiKSB7XG4gICAgICAgIG1rZGlyKG5vcm1hbGl6ZVdpbmRvd3NQYXRoKGRpciksIHtcbiAgICAgICAgICAgIHVpZDogdGhpcy51aWQsXG4gICAgICAgICAgICBnaWQ6IHRoaXMuZ2lkLFxuICAgICAgICAgICAgcHJvY2Vzc1VpZDogdGhpcy5wcm9jZXNzVWlkLFxuICAgICAgICAgICAgcHJvY2Vzc0dpZDogdGhpcy5wcm9jZXNzR2lkLFxuICAgICAgICAgICAgdW1hc2s6IHRoaXMucHJvY2Vzc1VtYXNrLFxuICAgICAgICAgICAgcHJlc2VydmU6IHRoaXMucHJlc2VydmVQYXRocyxcbiAgICAgICAgICAgIHVubGluazogdGhpcy51bmxpbmssXG4gICAgICAgICAgICBjYWNoZTogdGhpcy5kaXJDYWNoZSxcbiAgICAgICAgICAgIGN3ZDogdGhpcy5jd2QsXG4gICAgICAgICAgICBtb2RlOiBtb2RlLFxuICAgICAgICB9LCBjYik7XG4gICAgfVxuICAgIFtET0NIT1dOXShlbnRyeSkge1xuICAgICAgICAvLyBpbiBwcmVzZXJ2ZSBvd25lciBtb2RlLCBjaG93biBpZiB0aGUgZW50cnkgZG9lc24ndCBtYXRjaCBwcm9jZXNzXG4gICAgICAgIC8vIGluIHNldCBvd25lciBtb2RlLCBjaG93biBpZiBzZXR0aW5nIGRvZXNuJ3QgbWF0Y2ggcHJvY2Vzc1xuICAgICAgICByZXR1cm4gKHRoaXMuZm9yY2VDaG93biB8fFxuICAgICAgICAgICAgKHRoaXMucHJlc2VydmVPd25lciAmJlxuICAgICAgICAgICAgICAgICgodHlwZW9mIGVudHJ5LnVpZCA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgICAgICAgICAgZW50cnkudWlkICE9PSB0aGlzLnByb2Nlc3NVaWQpIHx8XG4gICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZW50cnkuZ2lkID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgZW50cnkuZ2lkICE9PSB0aGlzLnByb2Nlc3NHaWQpKSkgfHxcbiAgICAgICAgICAgICh0eXBlb2YgdGhpcy51aWQgPT09ICdudW1iZXInICYmXG4gICAgICAgICAgICAgICAgdGhpcy51aWQgIT09IHRoaXMucHJvY2Vzc1VpZCkgfHxcbiAgICAgICAgICAgICh0eXBlb2YgdGhpcy5naWQgPT09ICdudW1iZXInICYmIHRoaXMuZ2lkICE9PSB0aGlzLnByb2Nlc3NHaWQpKTtcbiAgICB9XG4gICAgW1VJRF0oZW50cnkpIHtcbiAgICAgICAgcmV0dXJuIHVpbnQzMih0aGlzLnVpZCwgZW50cnkudWlkLCB0aGlzLnByb2Nlc3NVaWQpO1xuICAgIH1cbiAgICBbR0lEXShlbnRyeSkge1xuICAgICAgICByZXR1cm4gdWludDMyKHRoaXMuZ2lkLCBlbnRyeS5naWQsIHRoaXMucHJvY2Vzc0dpZCk7XG4gICAgfVxuICAgIFtGSUxFXShlbnRyeSwgZnVsbHlEb25lKSB7XG4gICAgICAgIGNvbnN0IG1vZGUgPSB0eXBlb2YgZW50cnkubW9kZSA9PT0gJ251bWJlcicgP1xuICAgICAgICAgICAgZW50cnkubW9kZSAmIDBvNzc3N1xuICAgICAgICAgICAgOiB0aGlzLmZtb2RlO1xuICAgICAgICBjb25zdCBzdHJlYW0gPSBuZXcgZnNtLldyaXRlU3RyZWFtKFN0cmluZyhlbnRyeS5hYnNvbHV0ZSksIHtcbiAgICAgICAgICAgIC8vIHNsaWdodCBsaWUsIGJ1dCBpdCBjYW4gYmUgbnVtZXJpYyBmbGFnc1xuICAgICAgICAgICAgZmxhZ3M6IGdldFdyaXRlRmxhZyhlbnRyeS5zaXplKSxcbiAgICAgICAgICAgIG1vZGU6IG1vZGUsXG4gICAgICAgICAgICBhdXRvQ2xvc2U6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICAgICAgc3RyZWFtLm9uKCdlcnJvcicsIChlcikgPT4ge1xuICAgICAgICAgICAgaWYgKHN0cmVhbS5mZCkge1xuICAgICAgICAgICAgICAgIGZzLmNsb3NlKHN0cmVhbS5mZCwgKCkgPT4geyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGZsdXNoIGFsbCB0aGUgZGF0YSBvdXQgc28gdGhhdCB3ZSBhcmVuJ3QgbGVmdCBoYW5naW5nXG4gICAgICAgICAgICAvLyBpZiB0aGUgZXJyb3Igd2Fzbid0IGFjdHVhbGx5IGZhdGFsLiAgb3RoZXJ3aXNlIHRoZSBwYXJzZVxuICAgICAgICAgICAgLy8gaXMgYmxvY2tlZCwgYW5kIHdlIG5ldmVyIHByb2NlZWQuXG4gICAgICAgICAgICBzdHJlYW0ud3JpdGUgPSAoKSA9PiB0cnVlO1xuICAgICAgICAgICAgdGhpc1tPTkVSUk9SXShlciwgZW50cnkpO1xuICAgICAgICAgICAgZnVsbHlEb25lKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgYWN0aW9ucyA9IDE7XG4gICAgICAgIGNvbnN0IGRvbmUgPSAoZXIpID0+IHtcbiAgICAgICAgICAgIGlmIChlcikge1xuICAgICAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAtIHdlIHNob3VsZCBhbHdheXMgaGF2ZSBhIGZkIGJ5IG5vdyAqL1xuICAgICAgICAgICAgICAgIGlmIChzdHJlYW0uZmQpIHtcbiAgICAgICAgICAgICAgICAgICAgZnMuY2xvc2Uoc3RyZWFtLmZkLCAoKSA9PiB7IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgICAgIHRoaXNbT05FUlJPUl0oZXIsIGVudHJ5KTtcbiAgICAgICAgICAgICAgICBmdWxseURvbmUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoLS1hY3Rpb25zID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0cmVhbS5mZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZzLmNsb3NlKHN0cmVhbS5mZCwgZXIgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tPTkVSUk9SXShlciwgZW50cnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tVTlBFTkRdKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmdWxseURvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBzdHJlYW0ub24oJ2ZpbmlzaCcsICgpID0+IHtcbiAgICAgICAgICAgIC8vIGlmIGZ1dGltZXMgZmFpbHMsIHRyeSB1dGltZXNcbiAgICAgICAgICAgIC8vIGlmIHV0aW1lcyBmYWlscywgZmFpbCB3aXRoIHRoZSBvcmlnaW5hbCBlcnJvclxuICAgICAgICAgICAgLy8gc2FtZSBmb3IgZmNob3duL2Nob3duXG4gICAgICAgICAgICBjb25zdCBhYnMgPSBTdHJpbmcoZW50cnkuYWJzb2x1dGUpO1xuICAgICAgICAgICAgY29uc3QgZmQgPSBzdHJlYW0uZmQ7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZkID09PSAnbnVtYmVyJyAmJiBlbnRyeS5tdGltZSAmJiAhdGhpcy5ub010aW1lKSB7XG4gICAgICAgICAgICAgICAgYWN0aW9ucysrO1xuICAgICAgICAgICAgICAgIGNvbnN0IGF0aW1lID0gZW50cnkuYXRpbWUgfHwgbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtdGltZSA9IGVudHJ5Lm10aW1lO1xuICAgICAgICAgICAgICAgIGZzLmZ1dGltZXMoZmQsIGF0aW1lLCBtdGltZSwgZXIgPT4gZXIgP1xuICAgICAgICAgICAgICAgICAgICBmcy51dGltZXMoYWJzLCBhdGltZSwgbXRpbWUsIGVyMiA9PiBkb25lKGVyMiAmJiBlcikpXG4gICAgICAgICAgICAgICAgICAgIDogZG9uZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZmQgPT09ICdudW1iZXInICYmIHRoaXNbRE9DSE9XTl0oZW50cnkpKSB7XG4gICAgICAgICAgICAgICAgYWN0aW9ucysrO1xuICAgICAgICAgICAgICAgIGNvbnN0IHVpZCA9IHRoaXNbVUlEXShlbnRyeSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZ2lkID0gdGhpc1tHSURdKGVudHJ5KTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHVpZCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGdpZCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgZnMuZmNob3duKGZkLCB1aWQsIGdpZCwgZXIgPT4gZXIgP1xuICAgICAgICAgICAgICAgICAgICAgICAgZnMuY2hvd24oYWJzLCB1aWQsIGdpZCwgZXIyID0+IGRvbmUoZXIyICYmIGVyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogZG9uZSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB0eCA9IHRoaXMudHJhbnNmb3JtID8gdGhpcy50cmFuc2Zvcm0oZW50cnkpIHx8IGVudHJ5IDogZW50cnk7XG4gICAgICAgIGlmICh0eCAhPT0gZW50cnkpIHtcbiAgICAgICAgICAgIHR4Lm9uKCdlcnJvcicsIChlcikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXNbT05FUlJPUl0oZXIsIGVudHJ5KTtcbiAgICAgICAgICAgICAgICBmdWxseURvbmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZW50cnkucGlwZSh0eCk7XG4gICAgICAgIH1cbiAgICAgICAgdHgucGlwZShzdHJlYW0pO1xuICAgIH1cbiAgICBbRElSRUNUT1JZXShlbnRyeSwgZnVsbHlEb25lKSB7XG4gICAgICAgIGNvbnN0IG1vZGUgPSB0eXBlb2YgZW50cnkubW9kZSA9PT0gJ251bWJlcicgP1xuICAgICAgICAgICAgZW50cnkubW9kZSAmIDBvNzc3N1xuICAgICAgICAgICAgOiB0aGlzLmRtb2RlO1xuICAgICAgICB0aGlzW01LRElSXShTdHJpbmcoZW50cnkuYWJzb2x1dGUpLCBtb2RlLCBlciA9PiB7XG4gICAgICAgICAgICBpZiAoZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzW09ORVJST1JdKGVyLCBlbnRyeSk7XG4gICAgICAgICAgICAgICAgZnVsbHlEb25lKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGFjdGlvbnMgPSAxO1xuICAgICAgICAgICAgY29uc3QgZG9uZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoLS1hY3Rpb25zID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bGx5RG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzW1VOUEVORF0oKTtcbiAgICAgICAgICAgICAgICAgICAgZW50cnkucmVzdW1lKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChlbnRyeS5tdGltZSAmJiAhdGhpcy5ub010aW1lKSB7XG4gICAgICAgICAgICAgICAgYWN0aW9ucysrO1xuICAgICAgICAgICAgICAgIGZzLnV0aW1lcyhTdHJpbmcoZW50cnkuYWJzb2x1dGUpLCBlbnRyeS5hdGltZSB8fCBuZXcgRGF0ZSgpLCBlbnRyeS5tdGltZSwgZG9uZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpc1tET0NIT1dOXShlbnRyeSkpIHtcbiAgICAgICAgICAgICAgICBhY3Rpb25zKys7XG4gICAgICAgICAgICAgICAgZnMuY2hvd24oU3RyaW5nKGVudHJ5LmFic29sdXRlKSwgTnVtYmVyKHRoaXNbVUlEXShlbnRyeSkpLCBOdW1iZXIodGhpc1tHSURdKGVudHJ5KSksIGRvbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgW1VOU1VQUE9SVEVEXShlbnRyeSkge1xuICAgICAgICBlbnRyeS51bnN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMud2FybignVEFSX0VOVFJZX1VOU1VQUE9SVEVEJywgYHVuc3VwcG9ydGVkIGVudHJ5IHR5cGU6ICR7ZW50cnkudHlwZX1gLCB7IGVudHJ5IH0pO1xuICAgICAgICBlbnRyeS5yZXN1bWUoKTtcbiAgICB9XG4gICAgW1NZTUxJTktdKGVudHJ5LCBkb25lKSB7XG4gICAgICAgIHRoaXNbTElOS10oZW50cnksIFN0cmluZyhlbnRyeS5saW5rcGF0aCksICdzeW1saW5rJywgZG9uZSk7XG4gICAgfVxuICAgIFtIQVJETElOS10oZW50cnksIGRvbmUpIHtcbiAgICAgICAgY29uc3QgbGlua3BhdGggPSBub3JtYWxpemVXaW5kb3dzUGF0aChwYXRoLnJlc29sdmUodGhpcy5jd2QsIFN0cmluZyhlbnRyeS5saW5rcGF0aCkpKTtcbiAgICAgICAgdGhpc1tMSU5LXShlbnRyeSwgbGlua3BhdGgsICdsaW5rJywgZG9uZSk7XG4gICAgfVxuICAgIFtQRU5EXSgpIHtcbiAgICAgICAgdGhpc1tQRU5ESU5HXSsrO1xuICAgIH1cbiAgICBbVU5QRU5EXSgpIHtcbiAgICAgICAgdGhpc1tQRU5ESU5HXS0tO1xuICAgICAgICB0aGlzW01BWUJFQ0xPU0VdKCk7XG4gICAgfVxuICAgIFtTS0lQXShlbnRyeSkge1xuICAgICAgICB0aGlzW1VOUEVORF0oKTtcbiAgICAgICAgZW50cnkucmVzdW1lKCk7XG4gICAgfVxuICAgIC8vIENoZWNrIGlmIHdlIGNhbiByZXVzZSBhbiBleGlzdGluZyBmaWxlc3lzdGVtIGVudHJ5IHNhZmVseSBhbmRcbiAgICAvLyBvdmVyd3JpdGUgaXQsIHJhdGhlciB0aGFuIHVubGlua2luZyBhbmQgcmVjcmVhdGluZ1xuICAgIC8vIFdpbmRvd3MgZG9lc24ndCByZXBvcnQgYSB1c2VmdWwgbmxpbmssIHNvIHdlIGp1c3QgbmV2ZXIgcmV1c2UgZW50cmllc1xuICAgIFtJU1JFVVNBQkxFXShlbnRyeSwgc3QpIHtcbiAgICAgICAgcmV0dXJuIChlbnRyeS50eXBlID09PSAnRmlsZScgJiZcbiAgICAgICAgICAgICF0aGlzLnVubGluayAmJlxuICAgICAgICAgICAgc3QuaXNGaWxlKCkgJiZcbiAgICAgICAgICAgIHN0Lm5saW5rIDw9IDEgJiZcbiAgICAgICAgICAgICFpc1dpbmRvd3MpO1xuICAgIH1cbiAgICAvLyBjaGVjayBpZiBhIHRoaW5nIGlzIHRoZXJlLCBhbmQgaWYgc28sIHRyeSB0byBjbG9iYmVyIGl0XG4gICAgW0NIRUNLRlNdKGVudHJ5KSB7XG4gICAgICAgIHRoaXNbUEVORF0oKTtcbiAgICAgICAgY29uc3QgcGF0aHMgPSBbZW50cnkucGF0aF07XG4gICAgICAgIGlmIChlbnRyeS5saW5rcGF0aCkge1xuICAgICAgICAgICAgcGF0aHMucHVzaChlbnRyeS5saW5rcGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNlcnZhdGlvbnMucmVzZXJ2ZShwYXRocywgZG9uZSA9PiB0aGlzW0NIRUNLRlMyXShlbnRyeSwgZG9uZSkpO1xuICAgIH1cbiAgICBbUFJVTkVDQUNIRV0oZW50cnkpIHtcbiAgICAgICAgLy8gaWYgd2UgYXJlIG5vdCBjcmVhdGluZyBhIGRpcmVjdG9yeSwgYW5kIHRoZSBwYXRoIGlzIGluIHRoZSBkaXJDYWNoZSxcbiAgICAgICAgLy8gdGhlbiB0aGF0IG1lYW5zIHdlIGFyZSBhYm91dCB0byBkZWxldGUgdGhlIGRpcmVjdG9yeSB3ZSBjcmVhdGVkXG4gICAgICAgIC8vIHByZXZpb3VzbHksIGFuZCBpdCBpcyBubyBsb25nZXIgZ29pbmcgdG8gYmUgYSBkaXJlY3RvcnksIGFuZCBuZWl0aGVyXG4gICAgICAgIC8vIGlzIGFueSBvZiBpdHMgY2hpbGRyZW4uXG4gICAgICAgIC8vIElmIGEgc3ltYm9saWMgbGluayBpcyBlbmNvdW50ZXJlZCwgYWxsIGJldHMgYXJlIG9mZi4gIFRoZXJlIGlzIG5vXG4gICAgICAgIC8vIHJlYXNvbmFibGUgd2F5IHRvIHNhbml0aXplIHRoZSBjYWNoZSBpbiBzdWNoIGEgd2F5IHdlIHdpbGwgYmUgYWJsZSB0b1xuICAgICAgICAvLyBhdm9pZCBoYXZpbmcgZmlsZXN5c3RlbSBjb2xsaXNpb25zLiAgSWYgdGhpcyBoYXBwZW5zIHdpdGggYSBub24tc3ltbGlua1xuICAgICAgICAvLyBlbnRyeSwgaXQnbGwganVzdCBmYWlsIHRvIHVucGFjaywgYnV0IGEgc3ltbGluayB0byBhIGRpcmVjdG9yeSwgdXNpbmcgYW5cbiAgICAgICAgLy8gOC4zIHNob3J0bmFtZSBvciBjZXJ0YWluIHVuaWNvZGUgYXR0YWNrcywgY2FuIGV2YWRlIGRldGVjdGlvbiBhbmQgbGVhZFxuICAgICAgICAvLyB0byBhcmJpdHJhcnkgd3JpdGVzIHRvIGFueXdoZXJlIG9uIHRoZSBzeXN0ZW0uXG4gICAgICAgIGlmIChlbnRyeS50eXBlID09PSAnU3ltYm9saWNMaW5rJykge1xuICAgICAgICAgICAgZHJvcENhY2hlKHRoaXMuZGlyQ2FjaGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVudHJ5LnR5cGUgIT09ICdEaXJlY3RvcnknKSB7XG4gICAgICAgICAgICBwcnVuZUNhY2hlKHRoaXMuZGlyQ2FjaGUsIFN0cmluZyhlbnRyeS5hYnNvbHV0ZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFtDSEVDS0ZTMl0oZW50cnksIGZ1bGx5RG9uZSkge1xuICAgICAgICB0aGlzW1BSVU5FQ0FDSEVdKGVudHJ5KTtcbiAgICAgICAgY29uc3QgZG9uZSA9IChlcikgPT4ge1xuICAgICAgICAgICAgdGhpc1tQUlVORUNBQ0hFXShlbnRyeSk7XG4gICAgICAgICAgICBmdWxseURvbmUoZXIpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjaGVja0N3ZCA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXNbTUtESVJdKHRoaXMuY3dkLCB0aGlzLmRtb2RlLCBlciA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbT05FUlJPUl0oZXIsIGVudHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXNbQ0hFQ0tFRF9DV0RdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdGFydCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGVudHJ5LmFic29sdXRlICE9PSB0aGlzLmN3ZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IG5vcm1hbGl6ZVdpbmRvd3NQYXRoKHBhdGguZGlybmFtZShTdHJpbmcoZW50cnkuYWJzb2x1dGUpKSk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudCAhPT0gdGhpcy5jd2QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbTUtESVJdKHBhcmVudCwgdGhpcy5kbW9kZSwgZXIgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tPTkVSUk9SXShlciwgZW50cnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhZnRlck1ha2VQYXJlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWZ0ZXJNYWtlUGFyZW50KCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGFmdGVyTWFrZVBhcmVudCA9ICgpID0+IHtcbiAgICAgICAgICAgIGZzLmxzdGF0KFN0cmluZyhlbnRyeS5hYnNvbHV0ZSksIChsc3RhdEVyLCBzdCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChzdCAmJlxuICAgICAgICAgICAgICAgICAgICAodGhpcy5rZWVwIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMubmV3ZXIgJiYgc3QubXRpbWUgPiAoZW50cnkubXRpbWUgPz8gc3QubXRpbWUpKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tTS0lQXShlbnRyeSk7XG4gICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobHN0YXRFciB8fCB0aGlzW0lTUkVVU0FCTEVdKGVudHJ5LCBzdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbTUFLRUZTXShudWxsLCBlbnRyeSwgZG9uZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdC5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbnRyeS50eXBlID09PSAnRGlyZWN0b3J5Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmVlZENobW9kID0gdGhpcy5jaG1vZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5Lm1vZGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoc3QubW9kZSAmIDBvNzc3NykgIT09IGVudHJ5Lm1vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhZnRlckNobW9kID0gKGVyKSA9PiB0aGlzW01BS0VGU10oZXIgPz8gbnVsbCwgZW50cnksIGRvbmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFuZWVkQ2htb2QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWZ0ZXJDaG1vZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZzLmNobW9kKFN0cmluZyhlbnRyeS5hYnNvbHV0ZSksIE51bWJlcihlbnRyeS5tb2RlKSwgYWZ0ZXJDaG1vZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gTm90IGEgZGlyIGVudHJ5LCBoYXZlIHRvIHJlbW92ZSBpdC5cbiAgICAgICAgICAgICAgICAgICAgLy8gTkI6IHRoZSBvbmx5IHdheSB0byBlbmQgdXAgd2l0aCBhbiBlbnRyeSB0aGF0IGlzIHRoZSBjd2RcbiAgICAgICAgICAgICAgICAgICAgLy8gaXRzZWxmLCBpbiBzdWNoIGEgd2F5IHRoYXQgPT0gZG9lcyBub3QgZGV0ZWN0LCBpcyBhXG4gICAgICAgICAgICAgICAgICAgIC8vIHRyaWNreSB3aW5kb3dzIGFic29sdXRlIHBhdGggd2l0aCBVTkMgb3IgOC4zIHBhcnRzIChhbmRcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJlc2VydmVQYXRoczp0cnVlLCBvciBlbHNlIGl0IHdpbGwgaGF2ZSBiZWVuIHN0cmlwcGVkKS5cbiAgICAgICAgICAgICAgICAgICAgLy8gSW4gdGhhdCBjYXNlLCB0aGUgdXNlciBoYXMgb3B0ZWQgb3V0IG9mIHBhdGggcHJvdGVjdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgLy8gZXhwbGljaXRseSwgc28gaWYgdGhleSBibG93IGF3YXkgdGhlIGN3ZCwgYydlc3QgbGEgdmllLlxuICAgICAgICAgICAgICAgICAgICBpZiAoZW50cnkuYWJzb2x1dGUgIT09IHRoaXMuY3dkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnMucm1kaXIoU3RyaW5nKGVudHJ5LmFic29sdXRlKSwgKGVyKSA9PiB0aGlzW01BS0VGU10oZXIgPz8gbnVsbCwgZW50cnksIGRvbmUpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBub3QgYSBkaXIsIGFuZCBub3QgcmV1c2FibGVcbiAgICAgICAgICAgICAgICAvLyBkb24ndCByZW1vdmUgaWYgdGhlIGN3ZCwgd2Ugd2FudCB0aGF0IGVycm9yXG4gICAgICAgICAgICAgICAgaWYgKGVudHJ5LmFic29sdXRlID09PSB0aGlzLmN3ZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tNQUtFRlNdKG51bGwsIGVudHJ5LCBkb25lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdW5saW5rRmlsZShTdHJpbmcoZW50cnkuYWJzb2x1dGUpLCBlciA9PiB0aGlzW01BS0VGU10oZXIgPz8gbnVsbCwgZW50cnksIGRvbmUpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpc1tDSEVDS0VEX0NXRF0pIHtcbiAgICAgICAgICAgIHN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjaGVja0N3ZCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFtNQUtFRlNdKGVyLCBlbnRyeSwgZG9uZSkge1xuICAgICAgICBpZiAoZXIpIHtcbiAgICAgICAgICAgIHRoaXNbT05FUlJPUl0oZXIsIGVudHJ5KTtcbiAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGVudHJ5LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ0ZpbGUnOlxuICAgICAgICAgICAgY2FzZSAnT2xkRmlsZSc6XG4gICAgICAgICAgICBjYXNlICdDb250aWd1b3VzRmlsZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbRklMRV0oZW50cnksIGRvbmUpO1xuICAgICAgICAgICAgY2FzZSAnTGluayc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbSEFSRExJTktdKGVudHJ5LCBkb25lKTtcbiAgICAgICAgICAgIGNhc2UgJ1N5bWJvbGljTGluayc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbU1lNTElOS10oZW50cnksIGRvbmUpO1xuICAgICAgICAgICAgY2FzZSAnRGlyZWN0b3J5JzpcbiAgICAgICAgICAgIGNhc2UgJ0dOVUR1bXBEaXInOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW0RJUkVDVE9SWV0oZW50cnksIGRvbmUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFtMSU5LXShlbnRyeSwgbGlua3BhdGgsIGxpbmssIGRvbmUpIHtcbiAgICAgICAgLy8gWFhYOiBnZXQgdGhlIHR5cGUgKCdzeW1saW5rJyBvciAnanVuY3Rpb24nKSBmb3Igd2luZG93c1xuICAgICAgICBmc1tsaW5rXShsaW5rcGF0aCwgU3RyaW5nKGVudHJ5LmFic29sdXRlKSwgZXIgPT4ge1xuICAgICAgICAgICAgaWYgKGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tPTkVSUk9SXShlciwgZW50cnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpc1tVTlBFTkRdKCk7XG4gICAgICAgICAgICAgICAgZW50cnkucmVzdW1lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNvbnN0IGNhbGxTeW5jID0gKGZuKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIFtudWxsLCBmbigpXTtcbiAgICB9XG4gICAgY2F0Y2ggKGVyKSB7XG4gICAgICAgIHJldHVybiBbZXIsIG51bGxdO1xuICAgIH1cbn07XG5leHBvcnQgY2xhc3MgVW5wYWNrU3luYyBleHRlbmRzIFVucGFjayB7XG4gICAgc3luYyA9IHRydWU7XG4gICAgW01BS0VGU10oZXIsIGVudHJ5KSB7XG4gICAgICAgIHJldHVybiBzdXBlcltNQUtFRlNdKGVyLCBlbnRyeSwgKCkgPT4geyB9KTtcbiAgICB9XG4gICAgW0NIRUNLRlNdKGVudHJ5KSB7XG4gICAgICAgIHRoaXNbUFJVTkVDQUNIRV0oZW50cnkpO1xuICAgICAgICBpZiAoIXRoaXNbQ0hFQ0tFRF9DV0RdKSB7XG4gICAgICAgICAgICBjb25zdCBlciA9IHRoaXNbTUtESVJdKHRoaXMuY3dkLCB0aGlzLmRtb2RlKTtcbiAgICAgICAgICAgIGlmIChlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW09ORVJST1JdKGVyLCBlbnRyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzW0NIRUNLRURfQ1dEXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZG9uJ3QgYm90aGVyIHRvIG1ha2UgdGhlIHBhcmVudCBpZiB0aGUgY3VycmVudCBlbnRyeSBpcyB0aGUgY3dkLFxuICAgICAgICAvLyB3ZSd2ZSBhbHJlYWR5IGNoZWNrZWQgaXQuXG4gICAgICAgIGlmIChlbnRyeS5hYnNvbHV0ZSAhPT0gdGhpcy5jd2QpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IG5vcm1hbGl6ZVdpbmRvd3NQYXRoKHBhdGguZGlybmFtZShTdHJpbmcoZW50cnkuYWJzb2x1dGUpKSk7XG4gICAgICAgICAgICBpZiAocGFyZW50ICE9PSB0aGlzLmN3ZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1rUGFyZW50ID0gdGhpc1tNS0RJUl0ocGFyZW50LCB0aGlzLmRtb2RlKTtcbiAgICAgICAgICAgICAgICBpZiAobWtQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbT05FUlJPUl0obWtQYXJlbnQsIGVudHJ5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW2xzdGF0RXIsIHN0XSA9IGNhbGxTeW5jKCgpID0+IGZzLmxzdGF0U3luYyhTdHJpbmcoZW50cnkuYWJzb2x1dGUpKSk7XG4gICAgICAgIGlmIChzdCAmJlxuICAgICAgICAgICAgKHRoaXMua2VlcCB8fFxuICAgICAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgKHRoaXMubmV3ZXIgJiYgc3QubXRpbWUgPiAoZW50cnkubXRpbWUgPz8gc3QubXRpbWUpKSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW1NLSVBdKGVudHJ5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobHN0YXRFciB8fCB0aGlzW0lTUkVVU0FCTEVdKGVudHJ5LCBzdCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW01BS0VGU10obnVsbCwgZW50cnkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdC5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgICAgICBpZiAoZW50cnkudHlwZSA9PT0gJ0RpcmVjdG9yeScpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZWVkQ2htb2QgPSB0aGlzLmNobW9kICYmXG4gICAgICAgICAgICAgICAgICAgIGVudHJ5Lm1vZGUgJiZcbiAgICAgICAgICAgICAgICAgICAgKHN0Lm1vZGUgJiAwbzc3NzcpICE9PSBlbnRyeS5tb2RlO1xuICAgICAgICAgICAgICAgIGNvbnN0IFtlcl0gPSBuZWVkQ2htb2QgP1xuICAgICAgICAgICAgICAgICAgICBjYWxsU3luYygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcy5jaG1vZFN5bmMoU3RyaW5nKGVudHJ5LmFic29sdXRlKSwgTnVtYmVyKGVudHJ5Lm1vZGUpKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgOiBbXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tNQUtFRlNdKGVyLCBlbnRyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBub3QgYSBkaXIgZW50cnksIGhhdmUgdG8gcmVtb3ZlIGl0XG4gICAgICAgICAgICBjb25zdCBbZXJdID0gY2FsbFN5bmMoKCkgPT4gZnMucm1kaXJTeW5jKFN0cmluZyhlbnRyeS5hYnNvbHV0ZSkpKTtcbiAgICAgICAgICAgIHRoaXNbTUFLRUZTXShlciwgZW50cnkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5vdCBhIGRpciwgYW5kIG5vdCByZXVzYWJsZS5cbiAgICAgICAgLy8gZG9uJ3QgcmVtb3ZlIGlmIGl0J3MgdGhlIGN3ZCwgc2luY2Ugd2Ugd2FudCB0aGF0IGVycm9yLlxuICAgICAgICBjb25zdCBbZXJdID0gZW50cnkuYWJzb2x1dGUgPT09IHRoaXMuY3dkID9cbiAgICAgICAgICAgIFtdXG4gICAgICAgICAgICA6IGNhbGxTeW5jKCgpID0+IHVubGlua0ZpbGVTeW5jKFN0cmluZyhlbnRyeS5hYnNvbHV0ZSkpKTtcbiAgICAgICAgdGhpc1tNQUtFRlNdKGVyLCBlbnRyeSk7XG4gICAgfVxuICAgIFtGSUxFXShlbnRyeSwgZG9uZSkge1xuICAgICAgICBjb25zdCBtb2RlID0gdHlwZW9mIGVudHJ5Lm1vZGUgPT09ICdudW1iZXInID9cbiAgICAgICAgICAgIGVudHJ5Lm1vZGUgJiAwbzc3NzdcbiAgICAgICAgICAgIDogdGhpcy5mbW9kZTtcbiAgICAgICAgY29uc3Qgb25lciA9IChlcikgPT4ge1xuICAgICAgICAgICAgbGV0IGNsb3NlRXJyb3I7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZzLmNsb3NlU3luYyhmZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNsb3NlRXJyb3IgPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVyIHx8IGNsb3NlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzW09ORVJST1JdKGVyIHx8IGNsb3NlRXJyb3IsIGVudHJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGZkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZmQgPSBmcy5vcGVuU3luYyhTdHJpbmcoZW50cnkuYWJzb2x1dGUpLCBnZXRXcml0ZUZsYWcoZW50cnkuc2l6ZSksIG1vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcikge1xuICAgICAgICAgICAgcmV0dXJuIG9uZXIoZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHR4ID0gdGhpcy50cmFuc2Zvcm0gPyB0aGlzLnRyYW5zZm9ybShlbnRyeSkgfHwgZW50cnkgOiBlbnRyeTtcbiAgICAgICAgaWYgKHR4ICE9PSBlbnRyeSkge1xuICAgICAgICAgICAgdHgub24oJ2Vycm9yJywgKGVyKSA9PiB0aGlzW09ORVJST1JdKGVyLCBlbnRyeSkpO1xuICAgICAgICAgICAgZW50cnkucGlwZSh0eCk7XG4gICAgICAgIH1cbiAgICAgICAgdHgub24oJ2RhdGEnLCAoY2h1bmspID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZnMud3JpdGVTeW5jKGZkLCBjaHVuaywgMCwgY2h1bmsubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcikge1xuICAgICAgICAgICAgICAgIG9uZXIoZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdHgub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgICAgIGxldCBlciA9IG51bGw7XG4gICAgICAgICAgICAvLyB0cnkgYm90aCwgZmFsbGluZyBmdXRpbWVzIGJhY2sgdG8gdXRpbWVzXG4gICAgICAgICAgICAvLyBpZiBlaXRoZXIgZmFpbHMsIGhhbmRsZSB0aGUgZmlyc3QgZXJyb3JcbiAgICAgICAgICAgIGlmIChlbnRyeS5tdGltZSAmJiAhdGhpcy5ub010aW1lKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXRpbWUgPSBlbnRyeS5hdGltZSB8fCBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG10aW1lID0gZW50cnkubXRpbWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZnMuZnV0aW1lc1N5bmMoZmQsIGF0aW1lLCBtdGltZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChmdXRpbWVzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZzLnV0aW1lc1N5bmMoU3RyaW5nKGVudHJ5LmFic29sdXRlKSwgYXRpbWUsIG10aW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAodXRpbWVzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyID0gZnV0aW1lc2VyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXNbRE9DSE9XTl0oZW50cnkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdWlkID0gdGhpc1tVSURdKGVudHJ5KTtcbiAgICAgICAgICAgICAgICBjb25zdCBnaWQgPSB0aGlzW0dJRF0oZW50cnkpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZzLmZjaG93blN5bmMoZmQsIE51bWJlcih1aWQpLCBOdW1iZXIoZ2lkKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChmY2hvd25lcikge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnMuY2hvd25TeW5jKFN0cmluZyhlbnRyeS5hYnNvbHV0ZSksIE51bWJlcih1aWQpLCBOdW1iZXIoZ2lkKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGNob3duZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyID0gZXIgfHwgZmNob3duZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvbmVyKGVyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIFtESVJFQ1RPUlldKGVudHJ5LCBkb25lKSB7XG4gICAgICAgIGNvbnN0IG1vZGUgPSB0eXBlb2YgZW50cnkubW9kZSA9PT0gJ251bWJlcicgP1xuICAgICAgICAgICAgZW50cnkubW9kZSAmIDBvNzc3N1xuICAgICAgICAgICAgOiB0aGlzLmRtb2RlO1xuICAgICAgICBjb25zdCBlciA9IHRoaXNbTUtESVJdKFN0cmluZyhlbnRyeS5hYnNvbHV0ZSksIG1vZGUpO1xuICAgICAgICBpZiAoZXIpIHtcbiAgICAgICAgICAgIHRoaXNbT05FUlJPUl0oZXIsIGVudHJ5KTtcbiAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW50cnkubXRpbWUgJiYgIXRoaXMubm9NdGltZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmcy51dGltZXNTeW5jKFN0cmluZyhlbnRyeS5hYnNvbHV0ZSksIGVudHJ5LmF0aW1lIHx8IG5ldyBEYXRlKCksIGVudHJ5Lm10aW1lKTtcbiAgICAgICAgICAgICAgICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVyKSB7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpc1tET0NIT1dOXShlbnRyeSkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZnMuY2hvd25TeW5jKFN0cmluZyhlbnRyeS5hYnNvbHV0ZSksIE51bWJlcih0aGlzW1VJRF0oZW50cnkpKSwgTnVtYmVyKHRoaXNbR0lEXShlbnRyeSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcikgeyB9XG4gICAgICAgIH1cbiAgICAgICAgZG9uZSgpO1xuICAgICAgICBlbnRyeS5yZXN1bWUoKTtcbiAgICB9XG4gICAgW01LRElSXShkaXIsIG1vZGUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBta2RpclN5bmMobm9ybWFsaXplV2luZG93c1BhdGgoZGlyKSwge1xuICAgICAgICAgICAgICAgIHVpZDogdGhpcy51aWQsXG4gICAgICAgICAgICAgICAgZ2lkOiB0aGlzLmdpZCxcbiAgICAgICAgICAgICAgICBwcm9jZXNzVWlkOiB0aGlzLnByb2Nlc3NVaWQsXG4gICAgICAgICAgICAgICAgcHJvY2Vzc0dpZDogdGhpcy5wcm9jZXNzR2lkLFxuICAgICAgICAgICAgICAgIHVtYXNrOiB0aGlzLnByb2Nlc3NVbWFzayxcbiAgICAgICAgICAgICAgICBwcmVzZXJ2ZTogdGhpcy5wcmVzZXJ2ZVBhdGhzLFxuICAgICAgICAgICAgICAgIHVubGluazogdGhpcy51bmxpbmssXG4gICAgICAgICAgICAgICAgY2FjaGU6IHRoaXMuZGlyQ2FjaGUsXG4gICAgICAgICAgICAgICAgY3dkOiB0aGlzLmN3ZCxcbiAgICAgICAgICAgICAgICBtb2RlOiBtb2RlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgW0xJTktdKGVudHJ5LCBsaW5rcGF0aCwgbGluaywgZG9uZSkge1xuICAgICAgICBjb25zdCBscyA9IGAke2xpbmt9U3luY2A7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmc1tsc10obGlua3BhdGgsIFN0cmluZyhlbnRyeS5hYnNvbHV0ZSkpO1xuICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgZW50cnkucmVzdW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1tPTkVSUk9SXShlciwgZW50cnkpO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dW5wYWNrLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/tar/dist/esm/unpack.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/tar/dist/esm/update.js":
/*!*********************************************!*\
  !*** ./node_modules/tar/dist/esm/update.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   update: () => (/* binding */ update)\n/* harmony export */ });\n/* harmony import */ var _make_command_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./make-command.js */ \"(rsc)/./node_modules/tar/dist/esm/make-command.js\");\n/* harmony import */ var _replace_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./replace.js */ \"(rsc)/./node_modules/tar/dist/esm/replace.js\");\n// tar -u\n\n\n// just call tar.r with the filter and mtimeCache\nconst update = (0,_make_command_js__WEBPACK_IMPORTED_MODULE_0__.makeCommand)(_replace_js__WEBPACK_IMPORTED_MODULE_1__.replace.syncFile, _replace_js__WEBPACK_IMPORTED_MODULE_1__.replace.asyncFile, _replace_js__WEBPACK_IMPORTED_MODULE_1__.replace.syncNoFile, _replace_js__WEBPACK_IMPORTED_MODULE_1__.replace.asyncNoFile, (opt, entries = []) => {\n    _replace_js__WEBPACK_IMPORTED_MODULE_1__.replace.validate?.(opt, entries);\n    mtimeFilter(opt);\n});\nconst mtimeFilter = (opt) => {\n    const filter = opt.filter;\n    if (!opt.mtimeCache) {\n        opt.mtimeCache = new Map();\n    }\n    opt.filter =\n        filter ?\n            (path, stat) => filter(path, stat) &&\n                !(\n                /* c8 ignore start */\n                ((opt.mtimeCache?.get(path) ?? stat.mtime ?? 0) >\n                    (stat.mtime ?? 0))\n                /* c8 ignore stop */\n                )\n            : (path, stat) => !(\n            /* c8 ignore start */\n            ((opt.mtimeCache?.get(path) ?? stat.mtime ?? 0) >\n                (stat.mtime ?? 0))\n            /* c8 ignore stop */\n            );\n};\n//# sourceMappingURL=update.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvZXNtL3VwZGF0ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNnRDtBQUNKO0FBQzVDO0FBQ08sZUFBZSw2REFBVyxDQUFDLGdEQUFDLFdBQVcsZ0RBQUMsWUFBWSxnREFBQyxhQUFhLGdEQUFDO0FBQzFFLElBQUksZ0RBQUM7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpdmUtdmliZS1haS1uZXh0Ly4vbm9kZV9tb2R1bGVzL3Rhci9kaXN0L2VzbS91cGRhdGUuanM/N2MxMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB0YXIgLXVcbmltcG9ydCB7IG1ha2VDb21tYW5kIH0gZnJvbSAnLi9tYWtlLWNvbW1hbmQuanMnO1xuaW1wb3J0IHsgcmVwbGFjZSBhcyByIH0gZnJvbSAnLi9yZXBsYWNlLmpzJztcbi8vIGp1c3QgY2FsbCB0YXIuciB3aXRoIHRoZSBmaWx0ZXIgYW5kIG10aW1lQ2FjaGVcbmV4cG9ydCBjb25zdCB1cGRhdGUgPSBtYWtlQ29tbWFuZChyLnN5bmNGaWxlLCByLmFzeW5jRmlsZSwgci5zeW5jTm9GaWxlLCByLmFzeW5jTm9GaWxlLCAob3B0LCBlbnRyaWVzID0gW10pID0+IHtcbiAgICByLnZhbGlkYXRlPy4ob3B0LCBlbnRyaWVzKTtcbiAgICBtdGltZUZpbHRlcihvcHQpO1xufSk7XG5jb25zdCBtdGltZUZpbHRlciA9IChvcHQpID0+IHtcbiAgICBjb25zdCBmaWx0ZXIgPSBvcHQuZmlsdGVyO1xuICAgIGlmICghb3B0Lm10aW1lQ2FjaGUpIHtcbiAgICAgICAgb3B0Lm10aW1lQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIG9wdC5maWx0ZXIgPVxuICAgICAgICBmaWx0ZXIgP1xuICAgICAgICAgICAgKHBhdGgsIHN0YXQpID0+IGZpbHRlcihwYXRoLCBzdGF0KSAmJlxuICAgICAgICAgICAgICAgICEoXG4gICAgICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICAgICAgKChvcHQubXRpbWVDYWNoZT8uZ2V0KHBhdGgpID8/IHN0YXQubXRpbWUgPz8gMCkgPlxuICAgICAgICAgICAgICAgICAgICAoc3RhdC5tdGltZSA/PyAwKSlcbiAgICAgICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIDogKHBhdGgsIHN0YXQpID0+ICEoXG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgICAgICgob3B0Lm10aW1lQ2FjaGU/LmdldChwYXRoKSA/PyBzdGF0Lm10aW1lID8/IDApID5cbiAgICAgICAgICAgICAgICAoc3RhdC5tdGltZSA/PyAwKSlcbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgICAgICApO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVwZGF0ZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/tar/dist/esm/update.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/tar/dist/esm/warn-method.js":
/*!**************************************************!*\
  !*** ./node_modules/tar/dist/esm/warn-method.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   warnMethod: () => (/* binding */ warnMethod)\n/* harmony export */ });\nconst warnMethod = (self, code, message, data = {}) => {\n    if (self.file) {\n        data.file = self.file;\n    }\n    if (self.cwd) {\n        data.cwd = self.cwd;\n    }\n    data.code =\n        (message instanceof Error &&\n            message.code) ||\n            code;\n    data.tarCode = code;\n    if (!self.strict && data.recoverable !== false) {\n        if (message instanceof Error) {\n            data = Object.assign(message, data);\n            message = message.message;\n        }\n        self.emit('warn', code, message, data);\n    }\n    else if (message instanceof Error) {\n        self.emit('error', Object.assign(message, data));\n    }\n    else {\n        self.emit('error', Object.assign(new Error(`${code}: ${message}`), data));\n    }\n};\n//# sourceMappingURL=warn-method.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvZXNtL3dhcm4tbWV0aG9kLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTyxrREFBa0Q7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsS0FBSyxJQUFJLFFBQVE7QUFDdkU7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdml2ZS12aWJlLWFpLW5leHQvLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvZXNtL3dhcm4tbWV0aG9kLmpzPzQ2OWQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IHdhcm5NZXRob2QgPSAoc2VsZiwgY29kZSwgbWVzc2FnZSwgZGF0YSA9IHt9KSA9PiB7XG4gICAgaWYgKHNlbGYuZmlsZSkge1xuICAgICAgICBkYXRhLmZpbGUgPSBzZWxmLmZpbGU7XG4gICAgfVxuICAgIGlmIChzZWxmLmN3ZCkge1xuICAgICAgICBkYXRhLmN3ZCA9IHNlbGYuY3dkO1xuICAgIH1cbiAgICBkYXRhLmNvZGUgPVxuICAgICAgICAobWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yICYmXG4gICAgICAgICAgICBtZXNzYWdlLmNvZGUpIHx8XG4gICAgICAgICAgICBjb2RlO1xuICAgIGRhdGEudGFyQ29kZSA9IGNvZGU7XG4gICAgaWYgKCFzZWxmLnN0cmljdCAmJiBkYXRhLnJlY292ZXJhYmxlICE9PSBmYWxzZSkge1xuICAgICAgICBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICBkYXRhID0gT2JqZWN0LmFzc2lnbihtZXNzYWdlLCBkYXRhKTtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlLm1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5lbWl0KCd3YXJuJywgY29kZSwgbWVzc2FnZSwgZGF0YSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG1lc3NhZ2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgT2JqZWN0LmFzc2lnbihtZXNzYWdlLCBkYXRhKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgT2JqZWN0LmFzc2lnbihuZXcgRXJyb3IoYCR7Y29kZX06ICR7bWVzc2FnZX1gKSwgZGF0YSkpO1xuICAgIH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD13YXJuLW1ldGhvZC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/tar/dist/esm/warn-method.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/tar/dist/esm/winchars.js":
/*!***********************************************!*\
  !*** ./node_modules/tar/dist/esm/winchars.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   encode: () => (/* binding */ encode)\n/* harmony export */ });\n// When writing files on Windows, translate the characters to their\n// 0xf000 higher-encoded versions.\nconst raw = ['|', '<', '>', '?', ':'];\nconst win = raw.map(char => String.fromCharCode(0xf000 + char.charCodeAt(0)));\nconst toWin = new Map(raw.map((char, i) => [char, win[i]]));\nconst toRaw = new Map(win.map((char, i) => [char, raw[i]]));\nconst encode = (s) => raw.reduce((s, c) => s.split(c).join(toWin.get(c)), s);\nconst decode = (s) => win.reduce((s, c) => s.split(c).join(toRaw.get(c)), s);\n//# sourceMappingURL=winchars.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvZXNtL3dpbmNoYXJzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDQTtBQUNQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdml2ZS12aWJlLWFpLW5leHQvLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvZXNtL3dpbmNoYXJzLmpzPzI2M2YiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gV2hlbiB3cml0aW5nIGZpbGVzIG9uIFdpbmRvd3MsIHRyYW5zbGF0ZSB0aGUgY2hhcmFjdGVycyB0byB0aGVpclxuLy8gMHhmMDAwIGhpZ2hlci1lbmNvZGVkIHZlcnNpb25zLlxuY29uc3QgcmF3ID0gWyd8JywgJzwnLCAnPicsICc/JywgJzonXTtcbmNvbnN0IHdpbiA9IHJhdy5tYXAoY2hhciA9PiBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZjAwMCArIGNoYXIuY2hhckNvZGVBdCgwKSkpO1xuY29uc3QgdG9XaW4gPSBuZXcgTWFwKHJhdy5tYXAoKGNoYXIsIGkpID0+IFtjaGFyLCB3aW5baV1dKSk7XG5jb25zdCB0b1JhdyA9IG5ldyBNYXAod2luLm1hcCgoY2hhciwgaSkgPT4gW2NoYXIsIHJhd1tpXV0pKTtcbmV4cG9ydCBjb25zdCBlbmNvZGUgPSAocykgPT4gcmF3LnJlZHVjZSgocywgYykgPT4gcy5zcGxpdChjKS5qb2luKHRvV2luLmdldChjKSksIHMpO1xuZXhwb3J0IGNvbnN0IGRlY29kZSA9IChzKSA9PiB3aW4ucmVkdWNlKChzLCBjKSA9PiBzLnNwbGl0KGMpLmpvaW4odG9SYXcuZ2V0KGMpKSwgcyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD13aW5jaGFycy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/tar/dist/esm/winchars.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/tar/dist/esm/write-entry.js":
/*!**************************************************!*\
  !*** ./node_modules/tar/dist/esm/write-entry.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WriteEntry: () => (/* binding */ WriteEntry),\n/* harmony export */   WriteEntrySync: () => (/* binding */ WriteEntrySync),\n/* harmony export */   WriteEntryTar: () => (/* binding */ WriteEntryTar)\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var minipass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! minipass */ \"(rsc)/./node_modules/minipass/dist/esm/index.js\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var _header_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./header.js */ \"(rsc)/./node_modules/tar/dist/esm/header.js\");\n/* harmony import */ var _mode_fix_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mode-fix.js */ \"(rsc)/./node_modules/tar/dist/esm/mode-fix.js\");\n/* harmony import */ var _normalize_windows_path_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./normalize-windows-path.js */ \"(rsc)/./node_modules/tar/dist/esm/normalize-windows-path.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./options.js */ \"(rsc)/./node_modules/tar/dist/esm/options.js\");\n/* harmony import */ var _pax_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./pax.js */ \"(rsc)/./node_modules/tar/dist/esm/pax.js\");\n/* harmony import */ var _strip_absolute_path_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./strip-absolute-path.js */ \"(rsc)/./node_modules/tar/dist/esm/strip-absolute-path.js\");\n/* harmony import */ var _strip_trailing_slashes_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./strip-trailing-slashes.js */ \"(rsc)/./node_modules/tar/dist/esm/strip-trailing-slashes.js\");\n/* harmony import */ var _warn_method_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./warn-method.js */ \"(rsc)/./node_modules/tar/dist/esm/warn-method.js\");\n/* harmony import */ var _winchars_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./winchars.js */ \"(rsc)/./node_modules/tar/dist/esm/winchars.js\");\n\n\n\n\n\n\n\n\n\n\n\n\nconst prefixPath = (path, prefix) => {\n    if (!prefix) {\n        return (0,_normalize_windows_path_js__WEBPACK_IMPORTED_MODULE_5__.normalizeWindowsPath)(path);\n    }\n    path = (0,_normalize_windows_path_js__WEBPACK_IMPORTED_MODULE_5__.normalizeWindowsPath)(path).replace(/^\\.(\\/|$)/, '');\n    return (0,_strip_trailing_slashes_js__WEBPACK_IMPORTED_MODULE_9__.stripTrailingSlashes)(prefix) + '/' + path;\n};\nconst maxReadSize = 16 * 1024 * 1024;\nconst PROCESS = Symbol('process');\nconst FILE = Symbol('file');\nconst DIRECTORY = Symbol('directory');\nconst SYMLINK = Symbol('symlink');\nconst HARDLINK = Symbol('hardlink');\nconst HEADER = Symbol('header');\nconst READ = Symbol('read');\nconst LSTAT = Symbol('lstat');\nconst ONLSTAT = Symbol('onlstat');\nconst ONREAD = Symbol('onread');\nconst ONREADLINK = Symbol('onreadlink');\nconst OPENFILE = Symbol('openfile');\nconst ONOPENFILE = Symbol('onopenfile');\nconst CLOSE = Symbol('close');\nconst MODE = Symbol('mode');\nconst AWAITDRAIN = Symbol('awaitDrain');\nconst ONDRAIN = Symbol('ondrain');\nconst PREFIX = Symbol('prefix');\nclass WriteEntry extends minipass__WEBPACK_IMPORTED_MODULE_1__.Minipass {\n    path;\n    portable;\n    myuid = (process.getuid && process.getuid()) || 0;\n    // until node has builtin pwnam functions, this'll have to do\n    myuser = process.env.USER || '';\n    maxReadSize;\n    linkCache;\n    statCache;\n    preservePaths;\n    cwd;\n    strict;\n    mtime;\n    noPax;\n    noMtime;\n    prefix;\n    fd;\n    blockLen = 0;\n    blockRemain = 0;\n    buf;\n    pos = 0;\n    remain = 0;\n    length = 0;\n    offset = 0;\n    win32;\n    absolute;\n    header;\n    type;\n    linkpath;\n    stat;\n    onWriteEntry;\n    #hadError = false;\n    constructor(p, opt_ = {}) {\n        const opt = (0,_options_js__WEBPACK_IMPORTED_MODULE_6__.dealias)(opt_);\n        super();\n        this.path = (0,_normalize_windows_path_js__WEBPACK_IMPORTED_MODULE_5__.normalizeWindowsPath)(p);\n        // suppress atime, ctime, uid, gid, uname, gname\n        this.portable = !!opt.portable;\n        this.maxReadSize = opt.maxReadSize || maxReadSize;\n        this.linkCache = opt.linkCache || new Map();\n        this.statCache = opt.statCache || new Map();\n        this.preservePaths = !!opt.preservePaths;\n        this.cwd = (0,_normalize_windows_path_js__WEBPACK_IMPORTED_MODULE_5__.normalizeWindowsPath)(opt.cwd || process.cwd());\n        this.strict = !!opt.strict;\n        this.noPax = !!opt.noPax;\n        this.noMtime = !!opt.noMtime;\n        this.mtime = opt.mtime;\n        this.prefix =\n            opt.prefix ? (0,_normalize_windows_path_js__WEBPACK_IMPORTED_MODULE_5__.normalizeWindowsPath)(opt.prefix) : undefined;\n        this.onWriteEntry = opt.onWriteEntry;\n        if (typeof opt.onwarn === 'function') {\n            this.on('warn', opt.onwarn);\n        }\n        let pathWarn = false;\n        if (!this.preservePaths) {\n            const [root, stripped] = (0,_strip_absolute_path_js__WEBPACK_IMPORTED_MODULE_8__.stripAbsolutePath)(this.path);\n            if (root && typeof stripped === 'string') {\n                this.path = stripped;\n                pathWarn = root;\n            }\n        }\n        this.win32 = !!opt.win32 || process.platform === 'win32';\n        if (this.win32) {\n            // force the \\ to / normalization, since we might not *actually*\n            // be on windows, but want \\ to be considered a path separator.\n            this.path = _winchars_js__WEBPACK_IMPORTED_MODULE_11__.decode(this.path.replace(/\\\\/g, '/'));\n            p = p.replace(/\\\\/g, '/');\n        }\n        this.absolute = (0,_normalize_windows_path_js__WEBPACK_IMPORTED_MODULE_5__.normalizeWindowsPath)(opt.absolute || path__WEBPACK_IMPORTED_MODULE_2__.resolve(this.cwd, p));\n        if (this.path === '') {\n            this.path = './';\n        }\n        if (pathWarn) {\n            this.warn('TAR_ENTRY_INFO', `stripping ${pathWarn} from absolute path`, {\n                entry: this,\n                path: pathWarn + this.path,\n            });\n        }\n        const cs = this.statCache.get(this.absolute);\n        if (cs) {\n            this[ONLSTAT](cs);\n        }\n        else {\n            this[LSTAT]();\n        }\n    }\n    warn(code, message, data = {}) {\n        return (0,_warn_method_js__WEBPACK_IMPORTED_MODULE_10__.warnMethod)(this, code, message, data);\n    }\n    emit(ev, ...data) {\n        if (ev === 'error') {\n            this.#hadError = true;\n        }\n        return super.emit(ev, ...data);\n    }\n    [LSTAT]() {\n        fs__WEBPACK_IMPORTED_MODULE_0__.lstat(this.absolute, (er, stat) => {\n            if (er) {\n                return this.emit('error', er);\n            }\n            this[ONLSTAT](stat);\n        });\n    }\n    [ONLSTAT](stat) {\n        this.statCache.set(this.absolute, stat);\n        this.stat = stat;\n        if (!stat.isFile()) {\n            stat.size = 0;\n        }\n        this.type = getType(stat);\n        this.emit('stat', stat);\n        this[PROCESS]();\n    }\n    [PROCESS]() {\n        switch (this.type) {\n            case 'File':\n                return this[FILE]();\n            case 'Directory':\n                return this[DIRECTORY]();\n            case 'SymbolicLink':\n                return this[SYMLINK]();\n            // unsupported types are ignored.\n            default:\n                return this.end();\n        }\n    }\n    [MODE](mode) {\n        return (0,_mode_fix_js__WEBPACK_IMPORTED_MODULE_4__.modeFix)(mode, this.type === 'Directory', this.portable);\n    }\n    [PREFIX](path) {\n        return prefixPath(path, this.prefix);\n    }\n    [HEADER]() {\n        /* c8 ignore start */\n        if (!this.stat) {\n            throw new Error('cannot write header before stat');\n        }\n        /* c8 ignore stop */\n        if (this.type === 'Directory' && this.portable) {\n            this.noMtime = true;\n        }\n        this.onWriteEntry?.(this);\n        this.header = new _header_js__WEBPACK_IMPORTED_MODULE_3__.Header({\n            path: this[PREFIX](this.path),\n            // only apply the prefix to hard links.\n            linkpath: this.type === 'Link' && this.linkpath !== undefined ?\n                this[PREFIX](this.linkpath)\n                : this.linkpath,\n            // only the permissions and setuid/setgid/sticky bitflags\n            // not the higher-order bits that specify file type\n            mode: this[MODE](this.stat.mode),\n            uid: this.portable ? undefined : this.stat.uid,\n            gid: this.portable ? undefined : this.stat.gid,\n            size: this.stat.size,\n            mtime: this.noMtime ? undefined : this.mtime || this.stat.mtime,\n            /* c8 ignore next */\n            type: this.type === 'Unsupported' ? undefined : this.type,\n            uname: this.portable ? undefined\n                : this.stat.uid === this.myuid ? this.myuser\n                    : '',\n            atime: this.portable ? undefined : this.stat.atime,\n            ctime: this.portable ? undefined : this.stat.ctime,\n        });\n        if (this.header.encode() && !this.noPax) {\n            super.write(new _pax_js__WEBPACK_IMPORTED_MODULE_7__.Pax({\n                atime: this.portable ? undefined : this.header.atime,\n                ctime: this.portable ? undefined : this.header.ctime,\n                gid: this.portable ? undefined : this.header.gid,\n                mtime: this.noMtime ? undefined : (this.mtime || this.header.mtime),\n                path: this[PREFIX](this.path),\n                linkpath: this.type === 'Link' && this.linkpath !== undefined ?\n                    this[PREFIX](this.linkpath)\n                    : this.linkpath,\n                size: this.header.size,\n                uid: this.portable ? undefined : this.header.uid,\n                uname: this.portable ? undefined : this.header.uname,\n                dev: this.portable ? undefined : this.stat.dev,\n                ino: this.portable ? undefined : this.stat.ino,\n                nlink: this.portable ? undefined : this.stat.nlink,\n            }).encode());\n        }\n        const block = this.header?.block;\n        /* c8 ignore start */\n        if (!block) {\n            throw new Error('failed to encode header');\n        }\n        /* c8 ignore stop */\n        super.write(block);\n    }\n    [DIRECTORY]() {\n        /* c8 ignore start */\n        if (!this.stat) {\n            throw new Error('cannot create directory entry without stat');\n        }\n        /* c8 ignore stop */\n        if (this.path.slice(-1) !== '/') {\n            this.path += '/';\n        }\n        this.stat.size = 0;\n        this[HEADER]();\n        this.end();\n    }\n    [SYMLINK]() {\n        fs__WEBPACK_IMPORTED_MODULE_0__.readlink(this.absolute, (er, linkpath) => {\n            if (er) {\n                return this.emit('error', er);\n            }\n            this[ONREADLINK](linkpath);\n        });\n    }\n    [ONREADLINK](linkpath) {\n        this.linkpath = (0,_normalize_windows_path_js__WEBPACK_IMPORTED_MODULE_5__.normalizeWindowsPath)(linkpath);\n        this[HEADER]();\n        this.end();\n    }\n    [HARDLINK](linkpath) {\n        /* c8 ignore start */\n        if (!this.stat) {\n            throw new Error('cannot create link entry without stat');\n        }\n        /* c8 ignore stop */\n        this.type = 'Link';\n        this.linkpath = (0,_normalize_windows_path_js__WEBPACK_IMPORTED_MODULE_5__.normalizeWindowsPath)(path__WEBPACK_IMPORTED_MODULE_2__.relative(this.cwd, linkpath));\n        this.stat.size = 0;\n        this[HEADER]();\n        this.end();\n    }\n    [FILE]() {\n        /* c8 ignore start */\n        if (!this.stat) {\n            throw new Error('cannot create file entry without stat');\n        }\n        /* c8 ignore stop */\n        if (this.stat.nlink > 1) {\n            const linkKey = `${this.stat.dev}:${this.stat.ino}`;\n            const linkpath = this.linkCache.get(linkKey);\n            if (linkpath?.indexOf(this.cwd) === 0) {\n                return this[HARDLINK](linkpath);\n            }\n            this.linkCache.set(linkKey, this.absolute);\n        }\n        this[HEADER]();\n        if (this.stat.size === 0) {\n            return this.end();\n        }\n        this[OPENFILE]();\n    }\n    [OPENFILE]() {\n        fs__WEBPACK_IMPORTED_MODULE_0__.open(this.absolute, 'r', (er, fd) => {\n            if (er) {\n                return this.emit('error', er);\n            }\n            this[ONOPENFILE](fd);\n        });\n    }\n    [ONOPENFILE](fd) {\n        this.fd = fd;\n        if (this.#hadError) {\n            return this[CLOSE]();\n        }\n        /* c8 ignore start */\n        if (!this.stat) {\n            throw new Error('should stat before calling onopenfile');\n        }\n        /* c8 ignore start */\n        this.blockLen = 512 * Math.ceil(this.stat.size / 512);\n        this.blockRemain = this.blockLen;\n        const bufLen = Math.min(this.blockLen, this.maxReadSize);\n        this.buf = Buffer.allocUnsafe(bufLen);\n        this.offset = 0;\n        this.pos = 0;\n        this.remain = this.stat.size;\n        this.length = this.buf.length;\n        this[READ]();\n    }\n    [READ]() {\n        const { fd, buf, offset, length, pos } = this;\n        if (fd === undefined || buf === undefined) {\n            throw new Error('cannot read file without first opening');\n        }\n        fs__WEBPACK_IMPORTED_MODULE_0__.read(fd, buf, offset, length, pos, (er, bytesRead) => {\n            if (er) {\n                // ignoring the error from close(2) is a bad practice, but at\n                // this point we already have an error, don't need another one\n                return this[CLOSE](() => this.emit('error', er));\n            }\n            this[ONREAD](bytesRead);\n        });\n    }\n    /* c8 ignore start */\n    [CLOSE](cb = () => { }) {\n        /* c8 ignore stop */\n        if (this.fd !== undefined)\n            fs__WEBPACK_IMPORTED_MODULE_0__.close(this.fd, cb);\n    }\n    [ONREAD](bytesRead) {\n        if (bytesRead <= 0 && this.remain > 0) {\n            const er = Object.assign(new Error('encountered unexpected EOF'), {\n                path: this.absolute,\n                syscall: 'read',\n                code: 'EOF',\n            });\n            return this[CLOSE](() => this.emit('error', er));\n        }\n        if (bytesRead > this.remain) {\n            const er = Object.assign(new Error('did not encounter expected EOF'), {\n                path: this.absolute,\n                syscall: 'read',\n                code: 'EOF',\n            });\n            return this[CLOSE](() => this.emit('error', er));\n        }\n        /* c8 ignore start */\n        if (!this.buf) {\n            throw new Error('should have created buffer prior to reading');\n        }\n        /* c8 ignore stop */\n        // null out the rest of the buffer, if we could fit the block padding\n        // at the end of this loop, we've incremented bytesRead and this.remain\n        // to be incremented up to the blockRemain level, as if we had expected\n        // to get a null-padded file, and read it until the end.  then we will\n        // decrement both remain and blockRemain by bytesRead, and know that we\n        // reached the expected EOF, without any null buffer to append.\n        if (bytesRead === this.remain) {\n            for (let i = bytesRead; i < this.length && bytesRead < this.blockRemain; i++) {\n                this.buf[i + this.offset] = 0;\n                bytesRead++;\n                this.remain++;\n            }\n        }\n        const chunk = this.offset === 0 && bytesRead === this.buf.length ?\n            this.buf\n            : this.buf.subarray(this.offset, this.offset + bytesRead);\n        const flushed = this.write(chunk);\n        if (!flushed) {\n            this[AWAITDRAIN](() => this[ONDRAIN]());\n        }\n        else {\n            this[ONDRAIN]();\n        }\n    }\n    [AWAITDRAIN](cb) {\n        this.once('drain', cb);\n    }\n    write(chunk, encoding, cb) {\n        /* c8 ignore start - just junk to comply with NodeJS.WritableStream */\n        if (typeof encoding === 'function') {\n            cb = encoding;\n            encoding = undefined;\n        }\n        if (typeof chunk === 'string') {\n            chunk = Buffer.from(chunk, typeof encoding === 'string' ? encoding : 'utf8');\n        }\n        /* c8 ignore stop */\n        if (this.blockRemain < chunk.length) {\n            const er = Object.assign(new Error('writing more data than expected'), {\n                path: this.absolute,\n            });\n            return this.emit('error', er);\n        }\n        this.remain -= chunk.length;\n        this.blockRemain -= chunk.length;\n        this.pos += chunk.length;\n        this.offset += chunk.length;\n        return super.write(chunk, null, cb);\n    }\n    [ONDRAIN]() {\n        if (!this.remain) {\n            if (this.blockRemain) {\n                super.write(Buffer.alloc(this.blockRemain));\n            }\n            return this[CLOSE](er => er ? this.emit('error', er) : this.end());\n        }\n        /* c8 ignore start */\n        if (!this.buf) {\n            throw new Error('buffer lost somehow in ONDRAIN');\n        }\n        /* c8 ignore stop */\n        if (this.offset >= this.length) {\n            // if we only have a smaller bit left to read, alloc a smaller buffer\n            // otherwise, keep it the same length it was before.\n            this.buf = Buffer.allocUnsafe(Math.min(this.blockRemain, this.buf.length));\n            this.offset = 0;\n        }\n        this.length = this.buf.length - this.offset;\n        this[READ]();\n    }\n}\nclass WriteEntrySync extends WriteEntry {\n    sync = true;\n    [LSTAT]() {\n        this[ONLSTAT](fs__WEBPACK_IMPORTED_MODULE_0__.lstatSync(this.absolute));\n    }\n    [SYMLINK]() {\n        this[ONREADLINK](fs__WEBPACK_IMPORTED_MODULE_0__.readlinkSync(this.absolute));\n    }\n    [OPENFILE]() {\n        this[ONOPENFILE](fs__WEBPACK_IMPORTED_MODULE_0__.openSync(this.absolute, 'r'));\n    }\n    [READ]() {\n        let threw = true;\n        try {\n            const { fd, buf, offset, length, pos } = this;\n            /* c8 ignore start */\n            if (fd === undefined || buf === undefined) {\n                throw new Error('fd and buf must be set in READ method');\n            }\n            /* c8 ignore stop */\n            const bytesRead = fs__WEBPACK_IMPORTED_MODULE_0__.readSync(fd, buf, offset, length, pos);\n            this[ONREAD](bytesRead);\n            threw = false;\n        }\n        finally {\n            // ignoring the error from close(2) is a bad practice, but at\n            // this point we already have an error, don't need another one\n            if (threw) {\n                try {\n                    this[CLOSE](() => { });\n                }\n                catch (er) { }\n            }\n        }\n    }\n    [AWAITDRAIN](cb) {\n        cb();\n    }\n    /* c8 ignore start */\n    [CLOSE](cb = () => { }) {\n        /* c8 ignore stop */\n        if (this.fd !== undefined)\n            fs__WEBPACK_IMPORTED_MODULE_0__.closeSync(this.fd);\n        cb();\n    }\n}\nclass WriteEntryTar extends minipass__WEBPACK_IMPORTED_MODULE_1__.Minipass {\n    blockLen = 0;\n    blockRemain = 0;\n    buf = 0;\n    pos = 0;\n    remain = 0;\n    length = 0;\n    preservePaths;\n    portable;\n    strict;\n    noPax;\n    noMtime;\n    readEntry;\n    type;\n    prefix;\n    path;\n    mode;\n    uid;\n    gid;\n    uname;\n    gname;\n    header;\n    mtime;\n    atime;\n    ctime;\n    linkpath;\n    size;\n    onWriteEntry;\n    warn(code, message, data = {}) {\n        return (0,_warn_method_js__WEBPACK_IMPORTED_MODULE_10__.warnMethod)(this, code, message, data);\n    }\n    constructor(readEntry, opt_ = {}) {\n        const opt = (0,_options_js__WEBPACK_IMPORTED_MODULE_6__.dealias)(opt_);\n        super();\n        this.preservePaths = !!opt.preservePaths;\n        this.portable = !!opt.portable;\n        this.strict = !!opt.strict;\n        this.noPax = !!opt.noPax;\n        this.noMtime = !!opt.noMtime;\n        this.onWriteEntry = opt.onWriteEntry;\n        this.readEntry = readEntry;\n        const { type } = readEntry;\n        /* c8 ignore start */\n        if (type === 'Unsupported') {\n            throw new Error('writing entry that should be ignored');\n        }\n        /* c8 ignore stop */\n        this.type = type;\n        if (this.type === 'Directory' && this.portable) {\n            this.noMtime = true;\n        }\n        this.prefix = opt.prefix;\n        this.path = (0,_normalize_windows_path_js__WEBPACK_IMPORTED_MODULE_5__.normalizeWindowsPath)(readEntry.path);\n        this.mode =\n            readEntry.mode !== undefined ?\n                this[MODE](readEntry.mode)\n                : undefined;\n        this.uid = this.portable ? undefined : readEntry.uid;\n        this.gid = this.portable ? undefined : readEntry.gid;\n        this.uname = this.portable ? undefined : readEntry.uname;\n        this.gname = this.portable ? undefined : readEntry.gname;\n        this.size = readEntry.size;\n        this.mtime =\n            this.noMtime ? undefined : opt.mtime || readEntry.mtime;\n        this.atime = this.portable ? undefined : readEntry.atime;\n        this.ctime = this.portable ? undefined : readEntry.ctime;\n        this.linkpath =\n            readEntry.linkpath !== undefined ?\n                (0,_normalize_windows_path_js__WEBPACK_IMPORTED_MODULE_5__.normalizeWindowsPath)(readEntry.linkpath)\n                : undefined;\n        if (typeof opt.onwarn === 'function') {\n            this.on('warn', opt.onwarn);\n        }\n        let pathWarn = false;\n        if (!this.preservePaths) {\n            const [root, stripped] = (0,_strip_absolute_path_js__WEBPACK_IMPORTED_MODULE_8__.stripAbsolutePath)(this.path);\n            if (root && typeof stripped === 'string') {\n                this.path = stripped;\n                pathWarn = root;\n            }\n        }\n        this.remain = readEntry.size;\n        this.blockRemain = readEntry.startBlockSize;\n        this.onWriteEntry?.(this);\n        this.header = new _header_js__WEBPACK_IMPORTED_MODULE_3__.Header({\n            path: this[PREFIX](this.path),\n            linkpath: this.type === 'Link' && this.linkpath !== undefined ?\n                this[PREFIX](this.linkpath)\n                : this.linkpath,\n            // only the permissions and setuid/setgid/sticky bitflags\n            // not the higher-order bits that specify file type\n            mode: this.mode,\n            uid: this.portable ? undefined : this.uid,\n            gid: this.portable ? undefined : this.gid,\n            size: this.size,\n            mtime: this.noMtime ? undefined : this.mtime,\n            type: this.type,\n            uname: this.portable ? undefined : this.uname,\n            atime: this.portable ? undefined : this.atime,\n            ctime: this.portable ? undefined : this.ctime,\n        });\n        if (pathWarn) {\n            this.warn('TAR_ENTRY_INFO', `stripping ${pathWarn} from absolute path`, {\n                entry: this,\n                path: pathWarn + this.path,\n            });\n        }\n        if (this.header.encode() && !this.noPax) {\n            super.write(new _pax_js__WEBPACK_IMPORTED_MODULE_7__.Pax({\n                atime: this.portable ? undefined : this.atime,\n                ctime: this.portable ? undefined : this.ctime,\n                gid: this.portable ? undefined : this.gid,\n                mtime: this.noMtime ? undefined : this.mtime,\n                path: this[PREFIX](this.path),\n                linkpath: this.type === 'Link' && this.linkpath !== undefined ?\n                    this[PREFIX](this.linkpath)\n                    : this.linkpath,\n                size: this.size,\n                uid: this.portable ? undefined : this.uid,\n                uname: this.portable ? undefined : this.uname,\n                dev: this.portable ? undefined : this.readEntry.dev,\n                ino: this.portable ? undefined : this.readEntry.ino,\n                nlink: this.portable ? undefined : this.readEntry.nlink,\n            }).encode());\n        }\n        const b = this.header?.block;\n        /* c8 ignore start */\n        if (!b)\n            throw new Error('failed to encode header');\n        /* c8 ignore stop */\n        super.write(b);\n        readEntry.pipe(this);\n    }\n    [PREFIX](path) {\n        return prefixPath(path, this.prefix);\n    }\n    [MODE](mode) {\n        return (0,_mode_fix_js__WEBPACK_IMPORTED_MODULE_4__.modeFix)(mode, this.type === 'Directory', this.portable);\n    }\n    write(chunk, encoding, cb) {\n        /* c8 ignore start - just junk to comply with NodeJS.WritableStream */\n        if (typeof encoding === 'function') {\n            cb = encoding;\n            encoding = undefined;\n        }\n        if (typeof chunk === 'string') {\n            chunk = Buffer.from(chunk, typeof encoding === 'string' ? encoding : 'utf8');\n        }\n        /* c8 ignore stop */\n        const writeLen = chunk.length;\n        if (writeLen > this.blockRemain) {\n            throw new Error('writing more to entry than is appropriate');\n        }\n        this.blockRemain -= writeLen;\n        return super.write(chunk, cb);\n    }\n    end(chunk, encoding, cb) {\n        if (this.blockRemain) {\n            super.write(Buffer.alloc(this.blockRemain));\n        }\n        /* c8 ignore start - just junk to comply with NodeJS.WritableStream */\n        if (typeof chunk === 'function') {\n            cb = chunk;\n            encoding = undefined;\n            chunk = undefined;\n        }\n        if (typeof encoding === 'function') {\n            cb = encoding;\n            encoding = undefined;\n        }\n        if (typeof chunk === 'string') {\n            chunk = Buffer.from(chunk, encoding ?? 'utf8');\n        }\n        if (cb)\n            this.once('finish', cb);\n        chunk ? super.end(chunk, cb) : super.end(cb);\n        /* c8 ignore stop */\n        return this;\n    }\n}\nconst getType = (stat) => stat.isFile() ? 'File'\n    : stat.isDirectory() ? 'Directory'\n        : stat.isSymbolicLink() ? 'SymbolicLink'\n            : 'Unsupported';\n//# sourceMappingURL=write-entry.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvZXNtL3dyaXRlLWVudHJ5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFvQjtBQUNnQjtBQUNaO0FBQ2E7QUFDRztBQUMyQjtBQUMzQjtBQUNUO0FBQzhCO0FBQ007QUFDcEI7QUFDTDtBQUMxQztBQUNBO0FBQ0EsZUFBZSxnRkFBb0I7QUFDbkM7QUFDQSxXQUFXLGdGQUFvQjtBQUMvQixXQUFXLGdGQUFvQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08seUJBQXlCLDhDQUFRO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLG9CQUFvQixvREFBTztBQUMzQjtBQUNBLG9CQUFvQixnRkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdGQUFvQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdGQUFvQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsMEVBQWlCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpREFBZTtBQUN2QztBQUNBO0FBQ0Esd0JBQXdCLGdGQUFvQixpQkFBaUIseUNBQVk7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsVUFBVTtBQUMvRDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyxlQUFlLDREQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHFDQUFRO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxREFBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDhDQUFNO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsNEJBQTRCLHdDQUFHO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsd0NBQVc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHdCQUF3QixnRkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0ZBQW9CLENBQUMsMENBQWE7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixjQUFjLEdBQUcsY0FBYztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0NBQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQkFBK0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvQ0FBTztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxZQUFZLHFDQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsaURBQWlEO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0Esc0JBQXNCLHlDQUFZO0FBQ2xDO0FBQ0E7QUFDQSx5QkFBeUIsNENBQWU7QUFDeEM7QUFDQTtBQUNBLHlCQUF5Qix3Q0FBVztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwrQkFBK0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix3Q0FBVztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsWUFBWSx5Q0FBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDTyw0QkFBNEIsOENBQVE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLGVBQWUsNERBQVU7QUFDekI7QUFDQSxvQ0FBb0M7QUFDcEMsb0JBQW9CLG9EQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnRkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdGQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsMEVBQWlCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsOENBQU07QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EscURBQXFELFVBQVU7QUFDL0Q7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsNEJBQTRCLHdDQUFHO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFEQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aXZlLXZpYmUtYWktbmV4dC8uL25vZGVfbW9kdWxlcy90YXIvZGlzdC9lc20vd3JpdGUtZW50cnkuanM/N2U5YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZnMgZnJvbSAnZnMnO1xuaW1wb3J0IHsgTWluaXBhc3MgfSBmcm9tICdtaW5pcGFzcyc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB7IEhlYWRlciB9IGZyb20gJy4vaGVhZGVyLmpzJztcbmltcG9ydCB7IG1vZGVGaXggfSBmcm9tICcuL21vZGUtZml4LmpzJztcbmltcG9ydCB7IG5vcm1hbGl6ZVdpbmRvd3NQYXRoIH0gZnJvbSAnLi9ub3JtYWxpemUtd2luZG93cy1wYXRoLmpzJztcbmltcG9ydCB7IGRlYWxpYXMsIH0gZnJvbSAnLi9vcHRpb25zLmpzJztcbmltcG9ydCB7IFBheCB9IGZyb20gJy4vcGF4LmpzJztcbmltcG9ydCB7IHN0cmlwQWJzb2x1dGVQYXRoIH0gZnJvbSAnLi9zdHJpcC1hYnNvbHV0ZS1wYXRoLmpzJztcbmltcG9ydCB7IHN0cmlwVHJhaWxpbmdTbGFzaGVzIH0gZnJvbSAnLi9zdHJpcC10cmFpbGluZy1zbGFzaGVzLmpzJztcbmltcG9ydCB7IHdhcm5NZXRob2QsIH0gZnJvbSAnLi93YXJuLW1ldGhvZC5qcyc7XG5pbXBvcnQgKiBhcyB3aW5jaGFycyBmcm9tICcuL3dpbmNoYXJzLmpzJztcbmNvbnN0IHByZWZpeFBhdGggPSAocGF0aCwgcHJlZml4KSA9PiB7XG4gICAgaWYgKCFwcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZVdpbmRvd3NQYXRoKHBhdGgpO1xuICAgIH1cbiAgICBwYXRoID0gbm9ybWFsaXplV2luZG93c1BhdGgocGF0aCkucmVwbGFjZSgvXlxcLihcXC98JCkvLCAnJyk7XG4gICAgcmV0dXJuIHN0cmlwVHJhaWxpbmdTbGFzaGVzKHByZWZpeCkgKyAnLycgKyBwYXRoO1xufTtcbmNvbnN0IG1heFJlYWRTaXplID0gMTYgKiAxMDI0ICogMTAyNDtcbmNvbnN0IFBST0NFU1MgPSBTeW1ib2woJ3Byb2Nlc3MnKTtcbmNvbnN0IEZJTEUgPSBTeW1ib2woJ2ZpbGUnKTtcbmNvbnN0IERJUkVDVE9SWSA9IFN5bWJvbCgnZGlyZWN0b3J5Jyk7XG5jb25zdCBTWU1MSU5LID0gU3ltYm9sKCdzeW1saW5rJyk7XG5jb25zdCBIQVJETElOSyA9IFN5bWJvbCgnaGFyZGxpbmsnKTtcbmNvbnN0IEhFQURFUiA9IFN5bWJvbCgnaGVhZGVyJyk7XG5jb25zdCBSRUFEID0gU3ltYm9sKCdyZWFkJyk7XG5jb25zdCBMU1RBVCA9IFN5bWJvbCgnbHN0YXQnKTtcbmNvbnN0IE9OTFNUQVQgPSBTeW1ib2woJ29ubHN0YXQnKTtcbmNvbnN0IE9OUkVBRCA9IFN5bWJvbCgnb25yZWFkJyk7XG5jb25zdCBPTlJFQURMSU5LID0gU3ltYm9sKCdvbnJlYWRsaW5rJyk7XG5jb25zdCBPUEVORklMRSA9IFN5bWJvbCgnb3BlbmZpbGUnKTtcbmNvbnN0IE9OT1BFTkZJTEUgPSBTeW1ib2woJ29ub3BlbmZpbGUnKTtcbmNvbnN0IENMT1NFID0gU3ltYm9sKCdjbG9zZScpO1xuY29uc3QgTU9ERSA9IFN5bWJvbCgnbW9kZScpO1xuY29uc3QgQVdBSVREUkFJTiA9IFN5bWJvbCgnYXdhaXREcmFpbicpO1xuY29uc3QgT05EUkFJTiA9IFN5bWJvbCgnb25kcmFpbicpO1xuY29uc3QgUFJFRklYID0gU3ltYm9sKCdwcmVmaXgnKTtcbmV4cG9ydCBjbGFzcyBXcml0ZUVudHJ5IGV4dGVuZHMgTWluaXBhc3Mge1xuICAgIHBhdGg7XG4gICAgcG9ydGFibGU7XG4gICAgbXl1aWQgPSAocHJvY2Vzcy5nZXR1aWQgJiYgcHJvY2Vzcy5nZXR1aWQoKSkgfHwgMDtcbiAgICAvLyB1bnRpbCBub2RlIGhhcyBidWlsdGluIHB3bmFtIGZ1bmN0aW9ucywgdGhpcydsbCBoYXZlIHRvIGRvXG4gICAgbXl1c2VyID0gcHJvY2Vzcy5lbnYuVVNFUiB8fCAnJztcbiAgICBtYXhSZWFkU2l6ZTtcbiAgICBsaW5rQ2FjaGU7XG4gICAgc3RhdENhY2hlO1xuICAgIHByZXNlcnZlUGF0aHM7XG4gICAgY3dkO1xuICAgIHN0cmljdDtcbiAgICBtdGltZTtcbiAgICBub1BheDtcbiAgICBub010aW1lO1xuICAgIHByZWZpeDtcbiAgICBmZDtcbiAgICBibG9ja0xlbiA9IDA7XG4gICAgYmxvY2tSZW1haW4gPSAwO1xuICAgIGJ1ZjtcbiAgICBwb3MgPSAwO1xuICAgIHJlbWFpbiA9IDA7XG4gICAgbGVuZ3RoID0gMDtcbiAgICBvZmZzZXQgPSAwO1xuICAgIHdpbjMyO1xuICAgIGFic29sdXRlO1xuICAgIGhlYWRlcjtcbiAgICB0eXBlO1xuICAgIGxpbmtwYXRoO1xuICAgIHN0YXQ7XG4gICAgb25Xcml0ZUVudHJ5O1xuICAgICNoYWRFcnJvciA9IGZhbHNlO1xuICAgIGNvbnN0cnVjdG9yKHAsIG9wdF8gPSB7fSkge1xuICAgICAgICBjb25zdCBvcHQgPSBkZWFsaWFzKG9wdF8pO1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnBhdGggPSBub3JtYWxpemVXaW5kb3dzUGF0aChwKTtcbiAgICAgICAgLy8gc3VwcHJlc3MgYXRpbWUsIGN0aW1lLCB1aWQsIGdpZCwgdW5hbWUsIGduYW1lXG4gICAgICAgIHRoaXMucG9ydGFibGUgPSAhIW9wdC5wb3J0YWJsZTtcbiAgICAgICAgdGhpcy5tYXhSZWFkU2l6ZSA9IG9wdC5tYXhSZWFkU2l6ZSB8fCBtYXhSZWFkU2l6ZTtcbiAgICAgICAgdGhpcy5saW5rQ2FjaGUgPSBvcHQubGlua0NhY2hlIHx8IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5zdGF0Q2FjaGUgPSBvcHQuc3RhdENhY2hlIHx8IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5wcmVzZXJ2ZVBhdGhzID0gISFvcHQucHJlc2VydmVQYXRocztcbiAgICAgICAgdGhpcy5jd2QgPSBub3JtYWxpemVXaW5kb3dzUGF0aChvcHQuY3dkIHx8IHByb2Nlc3MuY3dkKCkpO1xuICAgICAgICB0aGlzLnN0cmljdCA9ICEhb3B0LnN0cmljdDtcbiAgICAgICAgdGhpcy5ub1BheCA9ICEhb3B0Lm5vUGF4O1xuICAgICAgICB0aGlzLm5vTXRpbWUgPSAhIW9wdC5ub010aW1lO1xuICAgICAgICB0aGlzLm10aW1lID0gb3B0Lm10aW1lO1xuICAgICAgICB0aGlzLnByZWZpeCA9XG4gICAgICAgICAgICBvcHQucHJlZml4ID8gbm9ybWFsaXplV2luZG93c1BhdGgob3B0LnByZWZpeCkgOiB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMub25Xcml0ZUVudHJ5ID0gb3B0Lm9uV3JpdGVFbnRyeTtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHQub253YXJuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLm9uKCd3YXJuJywgb3B0Lm9ud2Fybik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhdGhXYXJuID0gZmFsc2U7XG4gICAgICAgIGlmICghdGhpcy5wcmVzZXJ2ZVBhdGhzKSB7XG4gICAgICAgICAgICBjb25zdCBbcm9vdCwgc3RyaXBwZWRdID0gc3RyaXBBYnNvbHV0ZVBhdGgodGhpcy5wYXRoKTtcbiAgICAgICAgICAgIGlmIChyb290ICYmIHR5cGVvZiBzdHJpcHBlZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhdGggPSBzdHJpcHBlZDtcbiAgICAgICAgICAgICAgICBwYXRoV2FybiA9IHJvb3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53aW4zMiA9ICEhb3B0LndpbjMyIHx8IHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMic7XG4gICAgICAgIGlmICh0aGlzLndpbjMyKSB7XG4gICAgICAgICAgICAvLyBmb3JjZSB0aGUgXFwgdG8gLyBub3JtYWxpemF0aW9uLCBzaW5jZSB3ZSBtaWdodCBub3QgKmFjdHVhbGx5KlxuICAgICAgICAgICAgLy8gYmUgb24gd2luZG93cywgYnV0IHdhbnQgXFwgdG8gYmUgY29uc2lkZXJlZCBhIHBhdGggc2VwYXJhdG9yLlxuICAgICAgICAgICAgdGhpcy5wYXRoID0gd2luY2hhcnMuZGVjb2RlKHRoaXMucGF0aC5yZXBsYWNlKC9cXFxcL2csICcvJykpO1xuICAgICAgICAgICAgcCA9IHAucmVwbGFjZSgvXFxcXC9nLCAnLycpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWJzb2x1dGUgPSBub3JtYWxpemVXaW5kb3dzUGF0aChvcHQuYWJzb2x1dGUgfHwgcGF0aC5yZXNvbHZlKHRoaXMuY3dkLCBwKSk7XG4gICAgICAgIGlmICh0aGlzLnBhdGggPT09ICcnKSB7XG4gICAgICAgICAgICB0aGlzLnBhdGggPSAnLi8nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXRoV2Fybikge1xuICAgICAgICAgICAgdGhpcy53YXJuKCdUQVJfRU5UUllfSU5GTycsIGBzdHJpcHBpbmcgJHtwYXRoV2Fybn0gZnJvbSBhYnNvbHV0ZSBwYXRoYCwge1xuICAgICAgICAgICAgICAgIGVudHJ5OiB0aGlzLFxuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGhXYXJuICsgdGhpcy5wYXRoLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3MgPSB0aGlzLnN0YXRDYWNoZS5nZXQodGhpcy5hYnNvbHV0ZSk7XG4gICAgICAgIGlmIChjcykge1xuICAgICAgICAgICAgdGhpc1tPTkxTVEFUXShjcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzW0xTVEFUXSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdhcm4oY29kZSwgbWVzc2FnZSwgZGF0YSA9IHt9KSB7XG4gICAgICAgIHJldHVybiB3YXJuTWV0aG9kKHRoaXMsIGNvZGUsIG1lc3NhZ2UsIGRhdGEpO1xuICAgIH1cbiAgICBlbWl0KGV2LCAuLi5kYXRhKSB7XG4gICAgICAgIGlmIChldiA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgICAgdGhpcy4jaGFkRXJyb3IgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5lbWl0KGV2LCAuLi5kYXRhKTtcbiAgICB9XG4gICAgW0xTVEFUXSgpIHtcbiAgICAgICAgZnMubHN0YXQodGhpcy5hYnNvbHV0ZSwgKGVyLCBzdGF0KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXNbT05MU1RBVF0oc3RhdCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBbT05MU1RBVF0oc3RhdCkge1xuICAgICAgICB0aGlzLnN0YXRDYWNoZS5zZXQodGhpcy5hYnNvbHV0ZSwgc3RhdCk7XG4gICAgICAgIHRoaXMuc3RhdCA9IHN0YXQ7XG4gICAgICAgIGlmICghc3RhdC5pc0ZpbGUoKSkge1xuICAgICAgICAgICAgc3RhdC5zaXplID0gMDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnR5cGUgPSBnZXRUeXBlKHN0YXQpO1xuICAgICAgICB0aGlzLmVtaXQoJ3N0YXQnLCBzdGF0KTtcbiAgICAgICAgdGhpc1tQUk9DRVNTXSgpO1xuICAgIH1cbiAgICBbUFJPQ0VTU10oKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdGaWxlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tGSUxFXSgpO1xuICAgICAgICAgICAgY2FzZSAnRGlyZWN0b3J5JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tESVJFQ1RPUlldKCk7XG4gICAgICAgICAgICBjYXNlICdTeW1ib2xpY0xpbmsnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW1NZTUxJTktdKCk7XG4gICAgICAgICAgICAvLyB1bnN1cHBvcnRlZCB0eXBlcyBhcmUgaWdub3JlZC5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5kKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgW01PREVdKG1vZGUpIHtcbiAgICAgICAgcmV0dXJuIG1vZGVGaXgobW9kZSwgdGhpcy50eXBlID09PSAnRGlyZWN0b3J5JywgdGhpcy5wb3J0YWJsZSk7XG4gICAgfVxuICAgIFtQUkVGSVhdKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHByZWZpeFBhdGgocGF0aCwgdGhpcy5wcmVmaXgpO1xuICAgIH1cbiAgICBbSEVBREVSXSgpIHtcbiAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIGlmICghdGhpcy5zdGF0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCB3cml0ZSBoZWFkZXIgYmVmb3JlIHN0YXQnKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICBpZiAodGhpcy50eXBlID09PSAnRGlyZWN0b3J5JyAmJiB0aGlzLnBvcnRhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLm5vTXRpbWUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25Xcml0ZUVudHJ5Py4odGhpcyk7XG4gICAgICAgIHRoaXMuaGVhZGVyID0gbmV3IEhlYWRlcih7XG4gICAgICAgICAgICBwYXRoOiB0aGlzW1BSRUZJWF0odGhpcy5wYXRoKSxcbiAgICAgICAgICAgIC8vIG9ubHkgYXBwbHkgdGhlIHByZWZpeCB0byBoYXJkIGxpbmtzLlxuICAgICAgICAgICAgbGlua3BhdGg6IHRoaXMudHlwZSA9PT0gJ0xpbmsnICYmIHRoaXMubGlua3BhdGggIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgdGhpc1tQUkVGSVhdKHRoaXMubGlua3BhdGgpXG4gICAgICAgICAgICAgICAgOiB0aGlzLmxpbmtwYXRoLFxuICAgICAgICAgICAgLy8gb25seSB0aGUgcGVybWlzc2lvbnMgYW5kIHNldHVpZC9zZXRnaWQvc3RpY2t5IGJpdGZsYWdzXG4gICAgICAgICAgICAvLyBub3QgdGhlIGhpZ2hlci1vcmRlciBiaXRzIHRoYXQgc3BlY2lmeSBmaWxlIHR5cGVcbiAgICAgICAgICAgIG1vZGU6IHRoaXNbTU9ERV0odGhpcy5zdGF0Lm1vZGUpLFxuICAgICAgICAgICAgdWlkOiB0aGlzLnBvcnRhYmxlID8gdW5kZWZpbmVkIDogdGhpcy5zdGF0LnVpZCxcbiAgICAgICAgICAgIGdpZDogdGhpcy5wb3J0YWJsZSA/IHVuZGVmaW5lZCA6IHRoaXMuc3RhdC5naWQsXG4gICAgICAgICAgICBzaXplOiB0aGlzLnN0YXQuc2l6ZSxcbiAgICAgICAgICAgIG10aW1lOiB0aGlzLm5vTXRpbWUgPyB1bmRlZmluZWQgOiB0aGlzLm10aW1lIHx8IHRoaXMuc3RhdC5tdGltZSxcbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUgPT09ICdVbnN1cHBvcnRlZCcgPyB1bmRlZmluZWQgOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICB1bmFtZTogdGhpcy5wb3J0YWJsZSA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIDogdGhpcy5zdGF0LnVpZCA9PT0gdGhpcy5teXVpZCA/IHRoaXMubXl1c2VyXG4gICAgICAgICAgICAgICAgICAgIDogJycsXG4gICAgICAgICAgICBhdGltZTogdGhpcy5wb3J0YWJsZSA/IHVuZGVmaW5lZCA6IHRoaXMuc3RhdC5hdGltZSxcbiAgICAgICAgICAgIGN0aW1lOiB0aGlzLnBvcnRhYmxlID8gdW5kZWZpbmVkIDogdGhpcy5zdGF0LmN0aW1lLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuaGVhZGVyLmVuY29kZSgpICYmICF0aGlzLm5vUGF4KSB7XG4gICAgICAgICAgICBzdXBlci53cml0ZShuZXcgUGF4KHtcbiAgICAgICAgICAgICAgICBhdGltZTogdGhpcy5wb3J0YWJsZSA/IHVuZGVmaW5lZCA6IHRoaXMuaGVhZGVyLmF0aW1lLFxuICAgICAgICAgICAgICAgIGN0aW1lOiB0aGlzLnBvcnRhYmxlID8gdW5kZWZpbmVkIDogdGhpcy5oZWFkZXIuY3RpbWUsXG4gICAgICAgICAgICAgICAgZ2lkOiB0aGlzLnBvcnRhYmxlID8gdW5kZWZpbmVkIDogdGhpcy5oZWFkZXIuZ2lkLFxuICAgICAgICAgICAgICAgIG10aW1lOiB0aGlzLm5vTXRpbWUgPyB1bmRlZmluZWQgOiAodGhpcy5tdGltZSB8fCB0aGlzLmhlYWRlci5tdGltZSksXG4gICAgICAgICAgICAgICAgcGF0aDogdGhpc1tQUkVGSVhdKHRoaXMucGF0aCksXG4gICAgICAgICAgICAgICAgbGlua3BhdGg6IHRoaXMudHlwZSA9PT0gJ0xpbmsnICYmIHRoaXMubGlua3BhdGggIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbUFJFRklYXSh0aGlzLmxpbmtwYXRoKVxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMubGlua3BhdGgsXG4gICAgICAgICAgICAgICAgc2l6ZTogdGhpcy5oZWFkZXIuc2l6ZSxcbiAgICAgICAgICAgICAgICB1aWQ6IHRoaXMucG9ydGFibGUgPyB1bmRlZmluZWQgOiB0aGlzLmhlYWRlci51aWQsXG4gICAgICAgICAgICAgICAgdW5hbWU6IHRoaXMucG9ydGFibGUgPyB1bmRlZmluZWQgOiB0aGlzLmhlYWRlci51bmFtZSxcbiAgICAgICAgICAgICAgICBkZXY6IHRoaXMucG9ydGFibGUgPyB1bmRlZmluZWQgOiB0aGlzLnN0YXQuZGV2LFxuICAgICAgICAgICAgICAgIGlubzogdGhpcy5wb3J0YWJsZSA/IHVuZGVmaW5lZCA6IHRoaXMuc3RhdC5pbm8sXG4gICAgICAgICAgICAgICAgbmxpbms6IHRoaXMucG9ydGFibGUgPyB1bmRlZmluZWQgOiB0aGlzLnN0YXQubmxpbmssXG4gICAgICAgICAgICB9KS5lbmNvZGUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmxvY2sgPSB0aGlzLmhlYWRlcj8uYmxvY2s7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICBpZiAoIWJsb2NrKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZhaWxlZCB0byBlbmNvZGUgaGVhZGVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgc3VwZXIud3JpdGUoYmxvY2spO1xuICAgIH1cbiAgICBbRElSRUNUT1JZXSgpIHtcbiAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIGlmICghdGhpcy5zdGF0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBjcmVhdGUgZGlyZWN0b3J5IGVudHJ5IHdpdGhvdXQgc3RhdCcpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgIGlmICh0aGlzLnBhdGguc2xpY2UoLTEpICE9PSAnLycpIHtcbiAgICAgICAgICAgIHRoaXMucGF0aCArPSAnLyc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0LnNpemUgPSAwO1xuICAgICAgICB0aGlzW0hFQURFUl0oKTtcbiAgICAgICAgdGhpcy5lbmQoKTtcbiAgICB9XG4gICAgW1NZTUxJTktdKCkge1xuICAgICAgICBmcy5yZWFkbGluayh0aGlzLmFic29sdXRlLCAoZXIsIGxpbmtwYXRoKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXNbT05SRUFETElOS10obGlua3BhdGgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgW09OUkVBRExJTktdKGxpbmtwYXRoKSB7XG4gICAgICAgIHRoaXMubGlua3BhdGggPSBub3JtYWxpemVXaW5kb3dzUGF0aChsaW5rcGF0aCk7XG4gICAgICAgIHRoaXNbSEVBREVSXSgpO1xuICAgICAgICB0aGlzLmVuZCgpO1xuICAgIH1cbiAgICBbSEFSRExJTktdKGxpbmtwYXRoKSB7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICBpZiAoIXRoaXMuc3RhdCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgY3JlYXRlIGxpbmsgZW50cnkgd2l0aG91dCBzdGF0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgdGhpcy50eXBlID0gJ0xpbmsnO1xuICAgICAgICB0aGlzLmxpbmtwYXRoID0gbm9ybWFsaXplV2luZG93c1BhdGgocGF0aC5yZWxhdGl2ZSh0aGlzLmN3ZCwgbGlua3BhdGgpKTtcbiAgICAgICAgdGhpcy5zdGF0LnNpemUgPSAwO1xuICAgICAgICB0aGlzW0hFQURFUl0oKTtcbiAgICAgICAgdGhpcy5lbmQoKTtcbiAgICB9XG4gICAgW0ZJTEVdKCkge1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgaWYgKCF0aGlzLnN0YXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IGNyZWF0ZSBmaWxlIGVudHJ5IHdpdGhvdXQgc3RhdCcpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgIGlmICh0aGlzLnN0YXQubmxpbmsgPiAxKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5rS2V5ID0gYCR7dGhpcy5zdGF0LmRldn06JHt0aGlzLnN0YXQuaW5vfWA7XG4gICAgICAgICAgICBjb25zdCBsaW5rcGF0aCA9IHRoaXMubGlua0NhY2hlLmdldChsaW5rS2V5KTtcbiAgICAgICAgICAgIGlmIChsaW5rcGF0aD8uaW5kZXhPZih0aGlzLmN3ZCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tIQVJETElOS10obGlua3BhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5saW5rQ2FjaGUuc2V0KGxpbmtLZXksIHRoaXMuYWJzb2x1dGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXNbSEVBREVSXSgpO1xuICAgICAgICBpZiAodGhpcy5zdGF0LnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXNbT1BFTkZJTEVdKCk7XG4gICAgfVxuICAgIFtPUEVORklMRV0oKSB7XG4gICAgICAgIGZzLm9wZW4odGhpcy5hYnNvbHV0ZSwgJ3InLCAoZXIsIGZkKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXNbT05PUEVORklMRV0oZmQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgW09OT1BFTkZJTEVdKGZkKSB7XG4gICAgICAgIHRoaXMuZmQgPSBmZDtcbiAgICAgICAgaWYgKHRoaXMuI2hhZEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1tDTE9TRV0oKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgaWYgKCF0aGlzLnN0YXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2hvdWxkIHN0YXQgYmVmb3JlIGNhbGxpbmcgb25vcGVuZmlsZScpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gNTEyICogTWF0aC5jZWlsKHRoaXMuc3RhdC5zaXplIC8gNTEyKTtcbiAgICAgICAgdGhpcy5ibG9ja1JlbWFpbiA9IHRoaXMuYmxvY2tMZW47XG4gICAgICAgIGNvbnN0IGJ1ZkxlbiA9IE1hdGgubWluKHRoaXMuYmxvY2tMZW4sIHRoaXMubWF4UmVhZFNpemUpO1xuICAgICAgICB0aGlzLmJ1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShidWZMZW4pO1xuICAgICAgICB0aGlzLm9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy5yZW1haW4gPSB0aGlzLnN0YXQuc2l6ZTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSB0aGlzLmJ1Zi5sZW5ndGg7XG4gICAgICAgIHRoaXNbUkVBRF0oKTtcbiAgICB9XG4gICAgW1JFQURdKCkge1xuICAgICAgICBjb25zdCB7IGZkLCBidWYsIG9mZnNldCwgbGVuZ3RoLCBwb3MgfSA9IHRoaXM7XG4gICAgICAgIGlmIChmZCA9PT0gdW5kZWZpbmVkIHx8IGJ1ZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCByZWFkIGZpbGUgd2l0aG91dCBmaXJzdCBvcGVuaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgZnMucmVhZChmZCwgYnVmLCBvZmZzZXQsIGxlbmd0aCwgcG9zLCAoZXIsIGJ5dGVzUmVhZCkgPT4ge1xuICAgICAgICAgICAgaWYgKGVyKSB7XG4gICAgICAgICAgICAgICAgLy8gaWdub3JpbmcgdGhlIGVycm9yIGZyb20gY2xvc2UoMikgaXMgYSBiYWQgcHJhY3RpY2UsIGJ1dCBhdFxuICAgICAgICAgICAgICAgIC8vIHRoaXMgcG9pbnQgd2UgYWxyZWFkeSBoYXZlIGFuIGVycm9yLCBkb24ndCBuZWVkIGFub3RoZXIgb25lXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbQ0xPU0VdKCgpID0+IHRoaXMuZW1pdCgnZXJyb3InLCBlcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpc1tPTlJFQURdKGJ5dGVzUmVhZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICBbQ0xPU0VdKGNiID0gKCkgPT4geyB9KSB7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgIGlmICh0aGlzLmZkICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBmcy5jbG9zZSh0aGlzLmZkLCBjYik7XG4gICAgfVxuICAgIFtPTlJFQURdKGJ5dGVzUmVhZCkge1xuICAgICAgICBpZiAoYnl0ZXNSZWFkIDw9IDAgJiYgdGhpcy5yZW1haW4gPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBlciA9IE9iamVjdC5hc3NpZ24obmV3IEVycm9yKCdlbmNvdW50ZXJlZCB1bmV4cGVjdGVkIEVPRicpLCB7XG4gICAgICAgICAgICAgICAgcGF0aDogdGhpcy5hYnNvbHV0ZSxcbiAgICAgICAgICAgICAgICBzeXNjYWxsOiAncmVhZCcsXG4gICAgICAgICAgICAgICAgY29kZTogJ0VPRicsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW0NMT1NFXSgoKSA9PiB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnl0ZXNSZWFkID4gdGhpcy5yZW1haW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGVyID0gT2JqZWN0LmFzc2lnbihuZXcgRXJyb3IoJ2RpZCBub3QgZW5jb3VudGVyIGV4cGVjdGVkIEVPRicpLCB7XG4gICAgICAgICAgICAgICAgcGF0aDogdGhpcy5hYnNvbHV0ZSxcbiAgICAgICAgICAgICAgICBzeXNjYWxsOiAncmVhZCcsXG4gICAgICAgICAgICAgICAgY29kZTogJ0VPRicsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW0NMT1NFXSgoKSA9PiB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgaWYgKCF0aGlzLmJ1Zikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaG91bGQgaGF2ZSBjcmVhdGVkIGJ1ZmZlciBwcmlvciB0byByZWFkaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgLy8gbnVsbCBvdXQgdGhlIHJlc3Qgb2YgdGhlIGJ1ZmZlciwgaWYgd2UgY291bGQgZml0IHRoZSBibG9jayBwYWRkaW5nXG4gICAgICAgIC8vIGF0IHRoZSBlbmQgb2YgdGhpcyBsb29wLCB3ZSd2ZSBpbmNyZW1lbnRlZCBieXRlc1JlYWQgYW5kIHRoaXMucmVtYWluXG4gICAgICAgIC8vIHRvIGJlIGluY3JlbWVudGVkIHVwIHRvIHRoZSBibG9ja1JlbWFpbiBsZXZlbCwgYXMgaWYgd2UgaGFkIGV4cGVjdGVkXG4gICAgICAgIC8vIHRvIGdldCBhIG51bGwtcGFkZGVkIGZpbGUsIGFuZCByZWFkIGl0IHVudGlsIHRoZSBlbmQuICB0aGVuIHdlIHdpbGxcbiAgICAgICAgLy8gZGVjcmVtZW50IGJvdGggcmVtYWluIGFuZCBibG9ja1JlbWFpbiBieSBieXRlc1JlYWQsIGFuZCBrbm93IHRoYXQgd2VcbiAgICAgICAgLy8gcmVhY2hlZCB0aGUgZXhwZWN0ZWQgRU9GLCB3aXRob3V0IGFueSBudWxsIGJ1ZmZlciB0byBhcHBlbmQuXG4gICAgICAgIGlmIChieXRlc1JlYWQgPT09IHRoaXMucmVtYWluKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gYnl0ZXNSZWFkOyBpIDwgdGhpcy5sZW5ndGggJiYgYnl0ZXNSZWFkIDwgdGhpcy5ibG9ja1JlbWFpbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5idWZbaSArIHRoaXMub2Zmc2V0XSA9IDA7XG4gICAgICAgICAgICAgICAgYnl0ZXNSZWFkKys7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1haW4rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaHVuayA9IHRoaXMub2Zmc2V0ID09PSAwICYmIGJ5dGVzUmVhZCA9PT0gdGhpcy5idWYubGVuZ3RoID9cbiAgICAgICAgICAgIHRoaXMuYnVmXG4gICAgICAgICAgICA6IHRoaXMuYnVmLnN1YmFycmF5KHRoaXMub2Zmc2V0LCB0aGlzLm9mZnNldCArIGJ5dGVzUmVhZCk7XG4gICAgICAgIGNvbnN0IGZsdXNoZWQgPSB0aGlzLndyaXRlKGNodW5rKTtcbiAgICAgICAgaWYgKCFmbHVzaGVkKSB7XG4gICAgICAgICAgICB0aGlzW0FXQUlURFJBSU5dKCgpID0+IHRoaXNbT05EUkFJTl0oKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzW09ORFJBSU5dKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgW0FXQUlURFJBSU5dKGNiKSB7XG4gICAgICAgIHRoaXMub25jZSgnZHJhaW4nLCBjYik7XG4gICAgfVxuICAgIHdyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0IC0ganVzdCBqdW5rIHRvIGNvbXBseSB3aXRoIE5vZGVKUy5Xcml0YWJsZVN0cmVhbSAqL1xuICAgICAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYiA9IGVuY29kaW5nO1xuICAgICAgICAgICAgZW5jb2RpbmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgPyBlbmNvZGluZyA6ICd1dGY4Jyk7XG4gICAgICAgIH1cbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgaWYgKHRoaXMuYmxvY2tSZW1haW4gPCBjaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGVyID0gT2JqZWN0LmFzc2lnbihuZXcgRXJyb3IoJ3dyaXRpbmcgbW9yZSBkYXRhIHRoYW4gZXhwZWN0ZWQnKSwge1xuICAgICAgICAgICAgICAgIHBhdGg6IHRoaXMuYWJzb2x1dGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtYWluIC09IGNodW5rLmxlbmd0aDtcbiAgICAgICAgdGhpcy5ibG9ja1JlbWFpbiAtPSBjaHVuay5sZW5ndGg7XG4gICAgICAgIHRoaXMucG9zICs9IGNodW5rLmxlbmd0aDtcbiAgICAgICAgdGhpcy5vZmZzZXQgKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgICByZXR1cm4gc3VwZXIud3JpdGUoY2h1bmssIG51bGwsIGNiKTtcbiAgICB9XG4gICAgW09ORFJBSU5dKCkge1xuICAgICAgICBpZiAoIXRoaXMucmVtYWluKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5ibG9ja1JlbWFpbikge1xuICAgICAgICAgICAgICAgIHN1cGVyLndyaXRlKEJ1ZmZlci5hbGxvYyh0aGlzLmJsb2NrUmVtYWluKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpc1tDTE9TRV0oZXIgPT4gZXIgPyB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpIDogdGhpcy5lbmQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIGlmICghdGhpcy5idWYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYnVmZmVyIGxvc3Qgc29tZWhvdyBpbiBPTkRSQUlOJyk7XG4gICAgICAgIH1cbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgaWYgKHRoaXMub2Zmc2V0ID49IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBpZiB3ZSBvbmx5IGhhdmUgYSBzbWFsbGVyIGJpdCBsZWZ0IHRvIHJlYWQsIGFsbG9jIGEgc21hbGxlciBidWZmZXJcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSwga2VlcCBpdCB0aGUgc2FtZSBsZW5ndGggaXQgd2FzIGJlZm9yZS5cbiAgICAgICAgICAgIHRoaXMuYnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKE1hdGgubWluKHRoaXMuYmxvY2tSZW1haW4sIHRoaXMuYnVmLmxlbmd0aCkpO1xuICAgICAgICAgICAgdGhpcy5vZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5idWYubGVuZ3RoIC0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIHRoaXNbUkVBRF0oKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgV3JpdGVFbnRyeVN5bmMgZXh0ZW5kcyBXcml0ZUVudHJ5IHtcbiAgICBzeW5jID0gdHJ1ZTtcbiAgICBbTFNUQVRdKCkge1xuICAgICAgICB0aGlzW09OTFNUQVRdKGZzLmxzdGF0U3luYyh0aGlzLmFic29sdXRlKSk7XG4gICAgfVxuICAgIFtTWU1MSU5LXSgpIHtcbiAgICAgICAgdGhpc1tPTlJFQURMSU5LXShmcy5yZWFkbGlua1N5bmModGhpcy5hYnNvbHV0ZSkpO1xuICAgIH1cbiAgICBbT1BFTkZJTEVdKCkge1xuICAgICAgICB0aGlzW09OT1BFTkZJTEVdKGZzLm9wZW5TeW5jKHRoaXMuYWJzb2x1dGUsICdyJykpO1xuICAgIH1cbiAgICBbUkVBRF0oKSB7XG4gICAgICAgIGxldCB0aHJldyA9IHRydWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7IGZkLCBidWYsIG9mZnNldCwgbGVuZ3RoLCBwb3MgfSA9IHRoaXM7XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgICAgIGlmIChmZCA9PT0gdW5kZWZpbmVkIHx8IGJ1ZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmZCBhbmQgYnVmIG11c3QgYmUgc2V0IGluIFJFQUQgbWV0aG9kJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgY29uc3QgYnl0ZXNSZWFkID0gZnMucmVhZFN5bmMoZmQsIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgsIHBvcyk7XG4gICAgICAgICAgICB0aGlzW09OUkVBRF0oYnl0ZXNSZWFkKTtcbiAgICAgICAgICAgIHRocmV3ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAvLyBpZ25vcmluZyB0aGUgZXJyb3IgZnJvbSBjbG9zZSgyKSBpcyBhIGJhZCBwcmFjdGljZSwgYnV0IGF0XG4gICAgICAgICAgICAvLyB0aGlzIHBvaW50IHdlIGFscmVhZHkgaGF2ZSBhbiBlcnJvciwgZG9uJ3QgbmVlZCBhbm90aGVyIG9uZVxuICAgICAgICAgICAgaWYgKHRocmV3KSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tDTE9TRV0oKCkgPT4geyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVyKSB7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBbQVdBSVREUkFJTl0oY2IpIHtcbiAgICAgICAgY2IoKTtcbiAgICB9XG4gICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgW0NMT1NFXShjYiA9ICgpID0+IHsgfSkge1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICBpZiAodGhpcy5mZCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgZnMuY2xvc2VTeW5jKHRoaXMuZmQpO1xuICAgICAgICBjYigpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBXcml0ZUVudHJ5VGFyIGV4dGVuZHMgTWluaXBhc3Mge1xuICAgIGJsb2NrTGVuID0gMDtcbiAgICBibG9ja1JlbWFpbiA9IDA7XG4gICAgYnVmID0gMDtcbiAgICBwb3MgPSAwO1xuICAgIHJlbWFpbiA9IDA7XG4gICAgbGVuZ3RoID0gMDtcbiAgICBwcmVzZXJ2ZVBhdGhzO1xuICAgIHBvcnRhYmxlO1xuICAgIHN0cmljdDtcbiAgICBub1BheDtcbiAgICBub010aW1lO1xuICAgIHJlYWRFbnRyeTtcbiAgICB0eXBlO1xuICAgIHByZWZpeDtcbiAgICBwYXRoO1xuICAgIG1vZGU7XG4gICAgdWlkO1xuICAgIGdpZDtcbiAgICB1bmFtZTtcbiAgICBnbmFtZTtcbiAgICBoZWFkZXI7XG4gICAgbXRpbWU7XG4gICAgYXRpbWU7XG4gICAgY3RpbWU7XG4gICAgbGlua3BhdGg7XG4gICAgc2l6ZTtcbiAgICBvbldyaXRlRW50cnk7XG4gICAgd2Fybihjb2RlLCBtZXNzYWdlLCBkYXRhID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHdhcm5NZXRob2QodGhpcywgY29kZSwgbWVzc2FnZSwgZGF0YSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHJlYWRFbnRyeSwgb3B0XyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IG9wdCA9IGRlYWxpYXMob3B0Xyk7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucHJlc2VydmVQYXRocyA9ICEhb3B0LnByZXNlcnZlUGF0aHM7XG4gICAgICAgIHRoaXMucG9ydGFibGUgPSAhIW9wdC5wb3J0YWJsZTtcbiAgICAgICAgdGhpcy5zdHJpY3QgPSAhIW9wdC5zdHJpY3Q7XG4gICAgICAgIHRoaXMubm9QYXggPSAhIW9wdC5ub1BheDtcbiAgICAgICAgdGhpcy5ub010aW1lID0gISFvcHQubm9NdGltZTtcbiAgICAgICAgdGhpcy5vbldyaXRlRW50cnkgPSBvcHQub25Xcml0ZUVudHJ5O1xuICAgICAgICB0aGlzLnJlYWRFbnRyeSA9IHJlYWRFbnRyeTtcbiAgICAgICAgY29uc3QgeyB0eXBlIH0gPSByZWFkRW50cnk7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICBpZiAodHlwZSA9PT0gJ1Vuc3VwcG9ydGVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd3cml0aW5nIGVudHJ5IHRoYXQgc2hvdWxkIGJlIGlnbm9yZWQnKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICBpZiAodGhpcy50eXBlID09PSAnRGlyZWN0b3J5JyAmJiB0aGlzLnBvcnRhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLm5vTXRpbWUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJlZml4ID0gb3B0LnByZWZpeDtcbiAgICAgICAgdGhpcy5wYXRoID0gbm9ybWFsaXplV2luZG93c1BhdGgocmVhZEVudHJ5LnBhdGgpO1xuICAgICAgICB0aGlzLm1vZGUgPVxuICAgICAgICAgICAgcmVhZEVudHJ5Lm1vZGUgIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgdGhpc1tNT0RFXShyZWFkRW50cnkubW9kZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy51aWQgPSB0aGlzLnBvcnRhYmxlID8gdW5kZWZpbmVkIDogcmVhZEVudHJ5LnVpZDtcbiAgICAgICAgdGhpcy5naWQgPSB0aGlzLnBvcnRhYmxlID8gdW5kZWZpbmVkIDogcmVhZEVudHJ5LmdpZDtcbiAgICAgICAgdGhpcy51bmFtZSA9IHRoaXMucG9ydGFibGUgPyB1bmRlZmluZWQgOiByZWFkRW50cnkudW5hbWU7XG4gICAgICAgIHRoaXMuZ25hbWUgPSB0aGlzLnBvcnRhYmxlID8gdW5kZWZpbmVkIDogcmVhZEVudHJ5LmduYW1lO1xuICAgICAgICB0aGlzLnNpemUgPSByZWFkRW50cnkuc2l6ZTtcbiAgICAgICAgdGhpcy5tdGltZSA9XG4gICAgICAgICAgICB0aGlzLm5vTXRpbWUgPyB1bmRlZmluZWQgOiBvcHQubXRpbWUgfHwgcmVhZEVudHJ5Lm10aW1lO1xuICAgICAgICB0aGlzLmF0aW1lID0gdGhpcy5wb3J0YWJsZSA/IHVuZGVmaW5lZCA6IHJlYWRFbnRyeS5hdGltZTtcbiAgICAgICAgdGhpcy5jdGltZSA9IHRoaXMucG9ydGFibGUgPyB1bmRlZmluZWQgOiByZWFkRW50cnkuY3RpbWU7XG4gICAgICAgIHRoaXMubGlua3BhdGggPVxuICAgICAgICAgICAgcmVhZEVudHJ5LmxpbmtwYXRoICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZVdpbmRvd3NQYXRoKHJlYWRFbnRyeS5saW5rcGF0aClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHQub253YXJuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLm9uKCd3YXJuJywgb3B0Lm9ud2Fybik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhdGhXYXJuID0gZmFsc2U7XG4gICAgICAgIGlmICghdGhpcy5wcmVzZXJ2ZVBhdGhzKSB7XG4gICAgICAgICAgICBjb25zdCBbcm9vdCwgc3RyaXBwZWRdID0gc3RyaXBBYnNvbHV0ZVBhdGgodGhpcy5wYXRoKTtcbiAgICAgICAgICAgIGlmIChyb290ICYmIHR5cGVvZiBzdHJpcHBlZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhdGggPSBzdHJpcHBlZDtcbiAgICAgICAgICAgICAgICBwYXRoV2FybiA9IHJvb3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1haW4gPSByZWFkRW50cnkuc2l6ZTtcbiAgICAgICAgdGhpcy5ibG9ja1JlbWFpbiA9IHJlYWRFbnRyeS5zdGFydEJsb2NrU2l6ZTtcbiAgICAgICAgdGhpcy5vbldyaXRlRW50cnk/Lih0aGlzKTtcbiAgICAgICAgdGhpcy5oZWFkZXIgPSBuZXcgSGVhZGVyKHtcbiAgICAgICAgICAgIHBhdGg6IHRoaXNbUFJFRklYXSh0aGlzLnBhdGgpLFxuICAgICAgICAgICAgbGlua3BhdGg6IHRoaXMudHlwZSA9PT0gJ0xpbmsnICYmIHRoaXMubGlua3BhdGggIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgdGhpc1tQUkVGSVhdKHRoaXMubGlua3BhdGgpXG4gICAgICAgICAgICAgICAgOiB0aGlzLmxpbmtwYXRoLFxuICAgICAgICAgICAgLy8gb25seSB0aGUgcGVybWlzc2lvbnMgYW5kIHNldHVpZC9zZXRnaWQvc3RpY2t5IGJpdGZsYWdzXG4gICAgICAgICAgICAvLyBub3QgdGhlIGhpZ2hlci1vcmRlciBiaXRzIHRoYXQgc3BlY2lmeSBmaWxlIHR5cGVcbiAgICAgICAgICAgIG1vZGU6IHRoaXMubW9kZSxcbiAgICAgICAgICAgIHVpZDogdGhpcy5wb3J0YWJsZSA/IHVuZGVmaW5lZCA6IHRoaXMudWlkLFxuICAgICAgICAgICAgZ2lkOiB0aGlzLnBvcnRhYmxlID8gdW5kZWZpbmVkIDogdGhpcy5naWQsXG4gICAgICAgICAgICBzaXplOiB0aGlzLnNpemUsXG4gICAgICAgICAgICBtdGltZTogdGhpcy5ub010aW1lID8gdW5kZWZpbmVkIDogdGhpcy5tdGltZSxcbiAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgICAgIHVuYW1lOiB0aGlzLnBvcnRhYmxlID8gdW5kZWZpbmVkIDogdGhpcy51bmFtZSxcbiAgICAgICAgICAgIGF0aW1lOiB0aGlzLnBvcnRhYmxlID8gdW5kZWZpbmVkIDogdGhpcy5hdGltZSxcbiAgICAgICAgICAgIGN0aW1lOiB0aGlzLnBvcnRhYmxlID8gdW5kZWZpbmVkIDogdGhpcy5jdGltZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwYXRoV2Fybikge1xuICAgICAgICAgICAgdGhpcy53YXJuKCdUQVJfRU5UUllfSU5GTycsIGBzdHJpcHBpbmcgJHtwYXRoV2Fybn0gZnJvbSBhYnNvbHV0ZSBwYXRoYCwge1xuICAgICAgICAgICAgICAgIGVudHJ5OiB0aGlzLFxuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGhXYXJuICsgdGhpcy5wYXRoLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaGVhZGVyLmVuY29kZSgpICYmICF0aGlzLm5vUGF4KSB7XG4gICAgICAgICAgICBzdXBlci53cml0ZShuZXcgUGF4KHtcbiAgICAgICAgICAgICAgICBhdGltZTogdGhpcy5wb3J0YWJsZSA/IHVuZGVmaW5lZCA6IHRoaXMuYXRpbWUsXG4gICAgICAgICAgICAgICAgY3RpbWU6IHRoaXMucG9ydGFibGUgPyB1bmRlZmluZWQgOiB0aGlzLmN0aW1lLFxuICAgICAgICAgICAgICAgIGdpZDogdGhpcy5wb3J0YWJsZSA/IHVuZGVmaW5lZCA6IHRoaXMuZ2lkLFxuICAgICAgICAgICAgICAgIG10aW1lOiB0aGlzLm5vTXRpbWUgPyB1bmRlZmluZWQgOiB0aGlzLm10aW1lLFxuICAgICAgICAgICAgICAgIHBhdGg6IHRoaXNbUFJFRklYXSh0aGlzLnBhdGgpLFxuICAgICAgICAgICAgICAgIGxpbmtwYXRoOiB0aGlzLnR5cGUgPT09ICdMaW5rJyAmJiB0aGlzLmxpbmtwYXRoICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgICAgICAgICB0aGlzW1BSRUZJWF0odGhpcy5saW5rcGF0aClcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLmxpbmtwYXRoLFxuICAgICAgICAgICAgICAgIHNpemU6IHRoaXMuc2l6ZSxcbiAgICAgICAgICAgICAgICB1aWQ6IHRoaXMucG9ydGFibGUgPyB1bmRlZmluZWQgOiB0aGlzLnVpZCxcbiAgICAgICAgICAgICAgICB1bmFtZTogdGhpcy5wb3J0YWJsZSA/IHVuZGVmaW5lZCA6IHRoaXMudW5hbWUsXG4gICAgICAgICAgICAgICAgZGV2OiB0aGlzLnBvcnRhYmxlID8gdW5kZWZpbmVkIDogdGhpcy5yZWFkRW50cnkuZGV2LFxuICAgICAgICAgICAgICAgIGlubzogdGhpcy5wb3J0YWJsZSA/IHVuZGVmaW5lZCA6IHRoaXMucmVhZEVudHJ5LmlubyxcbiAgICAgICAgICAgICAgICBubGluazogdGhpcy5wb3J0YWJsZSA/IHVuZGVmaW5lZCA6IHRoaXMucmVhZEVudHJ5Lm5saW5rLFxuICAgICAgICAgICAgfSkuZW5jb2RlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGIgPSB0aGlzLmhlYWRlcj8uYmxvY2s7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICBpZiAoIWIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZhaWxlZCB0byBlbmNvZGUgaGVhZGVyJyk7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgIHN1cGVyLndyaXRlKGIpO1xuICAgICAgICByZWFkRW50cnkucGlwZSh0aGlzKTtcbiAgICB9XG4gICAgW1BSRUZJWF0ocGF0aCkge1xuICAgICAgICByZXR1cm4gcHJlZml4UGF0aChwYXRoLCB0aGlzLnByZWZpeCk7XG4gICAgfVxuICAgIFtNT0RFXShtb2RlKSB7XG4gICAgICAgIHJldHVybiBtb2RlRml4KG1vZGUsIHRoaXMudHlwZSA9PT0gJ0RpcmVjdG9yeScsIHRoaXMucG9ydGFibGUpO1xuICAgIH1cbiAgICB3cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAtIGp1c3QganVuayB0byBjb21wbHkgd2l0aCBOb2RlSlMuV3JpdGFibGVTdHJlYW0gKi9cbiAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2IgPSBlbmNvZGluZztcbiAgICAgICAgICAgIGVuY29kaW5nID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnID8gZW5jb2RpbmcgOiAndXRmOCcpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgIGNvbnN0IHdyaXRlTGVuID0gY2h1bmsubGVuZ3RoO1xuICAgICAgICBpZiAod3JpdGVMZW4gPiB0aGlzLmJsb2NrUmVtYWluKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dyaXRpbmcgbW9yZSB0byBlbnRyeSB0aGFuIGlzIGFwcHJvcHJpYXRlJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ibG9ja1JlbWFpbiAtPSB3cml0ZUxlbjtcbiAgICAgICAgcmV0dXJuIHN1cGVyLndyaXRlKGNodW5rLCBjYik7XG4gICAgfVxuICAgIGVuZChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gICAgICAgIGlmICh0aGlzLmJsb2NrUmVtYWluKSB7XG4gICAgICAgICAgICBzdXBlci53cml0ZShCdWZmZXIuYWxsb2ModGhpcy5ibG9ja1JlbWFpbikpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAtIGp1c3QganVuayB0byBjb21wbHkgd2l0aCBOb2RlSlMuV3JpdGFibGVTdHJlYW0gKi9cbiAgICAgICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2IgPSBjaHVuaztcbiAgICAgICAgICAgIGVuY29kaW5nID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY2h1bmsgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2IgPSBlbmNvZGluZztcbiAgICAgICAgICAgIGVuY29kaW5nID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyA/PyAndXRmOCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYilcbiAgICAgICAgICAgIHRoaXMub25jZSgnZmluaXNoJywgY2IpO1xuICAgICAgICBjaHVuayA/IHN1cGVyLmVuZChjaHVuaywgY2IpIDogc3VwZXIuZW5kKGNiKTtcbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuY29uc3QgZ2V0VHlwZSA9IChzdGF0KSA9PiBzdGF0LmlzRmlsZSgpID8gJ0ZpbGUnXG4gICAgOiBzdGF0LmlzRGlyZWN0b3J5KCkgPyAnRGlyZWN0b3J5J1xuICAgICAgICA6IHN0YXQuaXNTeW1ib2xpY0xpbmsoKSA/ICdTeW1ib2xpY0xpbmsnXG4gICAgICAgICAgICA6ICdVbnN1cHBvcnRlZCc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD13cml0ZS1lbnRyeS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/tar/dist/esm/write-entry.js\n");

/***/ })

};
;