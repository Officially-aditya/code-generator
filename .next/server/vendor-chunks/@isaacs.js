"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@isaacs";
exports.ids = ["vendor-chunks/@isaacs"];
exports.modules = {

/***/ "(rsc)/./node_modules/@isaacs/balanced-match/dist/esm/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@isaacs/balanced-match/dist/esm/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   balanced: () => (/* binding */ balanced),\n/* harmony export */   range: () => (/* binding */ range)\n/* harmony export */ });\nconst balanced = (a, b, str) => {\n    const ma = a instanceof RegExp ? maybeMatch(a, str) : a;\n    const mb = b instanceof RegExp ? maybeMatch(b, str) : b;\n    const r = ma !== null && mb != null && range(ma, mb, str);\n    return (r && {\n        start: r[0],\n        end: r[1],\n        pre: str.slice(0, r[0]),\n        body: str.slice(r[0] + ma.length, r[1]),\n        post: str.slice(r[1] + mb.length),\n    });\n};\nconst maybeMatch = (reg, str) => {\n    const m = str.match(reg);\n    return m ? m[0] : null;\n};\nconst range = (a, b, str) => {\n    let begs, beg, left, right = undefined, result;\n    let ai = str.indexOf(a);\n    let bi = str.indexOf(b, ai + 1);\n    let i = ai;\n    if (ai >= 0 && bi > 0) {\n        if (a === b) {\n            return [ai, bi];\n        }\n        begs = [];\n        left = str.length;\n        while (i >= 0 && !result) {\n            if (i === ai) {\n                begs.push(i);\n                ai = str.indexOf(a, i + 1);\n            }\n            else if (begs.length === 1) {\n                const r = begs.pop();\n                if (r !== undefined)\n                    result = [r, bi];\n            }\n            else {\n                beg = begs.pop();\n                if (beg !== undefined && beg < left) {\n                    left = beg;\n                    right = bi;\n                }\n                bi = str.indexOf(b, i + 1);\n            }\n            i = ai < bi && ai >= 0 ? ai : bi;\n        }\n        if (begs.length && right !== undefined) {\n            result = [left, right];\n        }\n    }\n    return result;\n};\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGlzYWFjcy9iYWxhbmNlZC1tYXRjaC9kaXN0L2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdml2ZS12aWJlLWFpLW5leHQvLi9ub2RlX21vZHVsZXMvQGlzYWFjcy9iYWxhbmNlZC1tYXRjaC9kaXN0L2VzbS9pbmRleC5qcz85Njc4Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBiYWxhbmNlZCA9IChhLCBiLCBzdHIpID0+IHtcbiAgICBjb25zdCBtYSA9IGEgaW5zdGFuY2VvZiBSZWdFeHAgPyBtYXliZU1hdGNoKGEsIHN0cikgOiBhO1xuICAgIGNvbnN0IG1iID0gYiBpbnN0YW5jZW9mIFJlZ0V4cCA/IG1heWJlTWF0Y2goYiwgc3RyKSA6IGI7XG4gICAgY29uc3QgciA9IG1hICE9PSBudWxsICYmIG1iICE9IG51bGwgJiYgcmFuZ2UobWEsIG1iLCBzdHIpO1xuICAgIHJldHVybiAociAmJiB7XG4gICAgICAgIHN0YXJ0OiByWzBdLFxuICAgICAgICBlbmQ6IHJbMV0sXG4gICAgICAgIHByZTogc3RyLnNsaWNlKDAsIHJbMF0pLFxuICAgICAgICBib2R5OiBzdHIuc2xpY2UoclswXSArIG1hLmxlbmd0aCwgclsxXSksXG4gICAgICAgIHBvc3Q6IHN0ci5zbGljZShyWzFdICsgbWIubGVuZ3RoKSxcbiAgICB9KTtcbn07XG5jb25zdCBtYXliZU1hdGNoID0gKHJlZywgc3RyKSA9PiB7XG4gICAgY29uc3QgbSA9IHN0ci5tYXRjaChyZWcpO1xuICAgIHJldHVybiBtID8gbVswXSA6IG51bGw7XG59O1xuZXhwb3J0IGNvbnN0IHJhbmdlID0gKGEsIGIsIHN0cikgPT4ge1xuICAgIGxldCBiZWdzLCBiZWcsIGxlZnQsIHJpZ2h0ID0gdW5kZWZpbmVkLCByZXN1bHQ7XG4gICAgbGV0IGFpID0gc3RyLmluZGV4T2YoYSk7XG4gICAgbGV0IGJpID0gc3RyLmluZGV4T2YoYiwgYWkgKyAxKTtcbiAgICBsZXQgaSA9IGFpO1xuICAgIGlmIChhaSA+PSAwICYmIGJpID4gMCkge1xuICAgICAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICAgICAgcmV0dXJuIFthaSwgYmldO1xuICAgICAgICB9XG4gICAgICAgIGJlZ3MgPSBbXTtcbiAgICAgICAgbGVmdCA9IHN0ci5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpID49IDAgJiYgIXJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGkgPT09IGFpKSB7XG4gICAgICAgICAgICAgICAgYmVncy5wdXNoKGkpO1xuICAgICAgICAgICAgICAgIGFpID0gc3RyLmluZGV4T2YoYSwgaSArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYmVncy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByID0gYmVncy5wb3AoKTtcbiAgICAgICAgICAgICAgICBpZiAociAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBbciwgYmldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYmVnID0gYmVncy5wb3AoKTtcbiAgICAgICAgICAgICAgICBpZiAoYmVnICE9PSB1bmRlZmluZWQgJiYgYmVnIDwgbGVmdCkge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gYmVnO1xuICAgICAgICAgICAgICAgICAgICByaWdodCA9IGJpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBiaSA9IHN0ci5pbmRleE9mKGIsIGkgKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkgPSBhaSA8IGJpICYmIGFpID49IDAgPyBhaSA6IGJpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiZWdzLmxlbmd0aCAmJiByaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBbbGVmdCwgcmlnaHRdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@isaacs/balanced-match/dist/esm/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@isaacs/brace-expansion/dist/esm/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@isaacs/brace-expansion/dist/esm/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   expand: () => (/* binding */ expand)\n/* harmony export */ });\n/* harmony import */ var _isaacs_balanced_match__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @isaacs/balanced-match */ \"(rsc)/./node_modules/@isaacs/balanced-match/dist/esm/index.js\");\n\nconst escSlash = '\\0SLASH' + Math.random() + '\\0';\nconst escOpen = '\\0OPEN' + Math.random() + '\\0';\nconst escClose = '\\0CLOSE' + Math.random() + '\\0';\nconst escComma = '\\0COMMA' + Math.random() + '\\0';\nconst escPeriod = '\\0PERIOD' + Math.random() + '\\0';\nconst escSlashPattern = new RegExp(escSlash, 'g');\nconst escOpenPattern = new RegExp(escOpen, 'g');\nconst escClosePattern = new RegExp(escClose, 'g');\nconst escCommaPattern = new RegExp(escComma, 'g');\nconst escPeriodPattern = new RegExp(escPeriod, 'g');\nconst slashPattern = /\\\\\\\\/g;\nconst openPattern = /\\\\{/g;\nconst closePattern = /\\\\}/g;\nconst commaPattern = /\\\\,/g;\nconst periodPattern = /\\\\./g;\nfunction numeric(str) {\n    return !isNaN(str) ? parseInt(str, 10) : str.charCodeAt(0);\n}\nfunction escapeBraces(str) {\n    return str\n        .replace(slashPattern, escSlash)\n        .replace(openPattern, escOpen)\n        .replace(closePattern, escClose)\n        .replace(commaPattern, escComma)\n        .replace(periodPattern, escPeriod);\n}\nfunction unescapeBraces(str) {\n    return str\n        .replace(escSlashPattern, '\\\\')\n        .replace(escOpenPattern, '{')\n        .replace(escClosePattern, '}')\n        .replace(escCommaPattern, ',')\n        .replace(escPeriodPattern, '.');\n}\n/**\n * Basically just str.split(\",\"), but handling cases\n * where we have nested braced sections, which should be\n * treated as individual members, like {a,{b,c},d}\n */\nfunction parseCommaParts(str) {\n    if (!str) {\n        return [''];\n    }\n    const parts = [];\n    const m = (0,_isaacs_balanced_match__WEBPACK_IMPORTED_MODULE_0__.balanced)('{', '}', str);\n    if (!m) {\n        return str.split(',');\n    }\n    const { pre, body, post } = m;\n    const p = pre.split(',');\n    p[p.length - 1] += '{' + body + '}';\n    const postParts = parseCommaParts(post);\n    if (post.length) {\n        ;\n        p[p.length - 1] += postParts.shift();\n        p.push.apply(p, postParts);\n    }\n    parts.push.apply(parts, p);\n    return parts;\n}\nfunction expand(str) {\n    if (!str) {\n        return [];\n    }\n    // I don't know why Bash 4.3 does this, but it does.\n    // Anything starting with {} will have the first two bytes preserved\n    // but *only* at the top level, so {},a}b will not expand to anything,\n    // but a{},b}c will be expanded to [a}c,abc].\n    // One could argue that this is a bug in Bash, but since the goal of\n    // this module is to match Bash's rules, we escape a leading {}\n    if (str.slice(0, 2) === '{}') {\n        str = '\\\\{\\\\}' + str.slice(2);\n    }\n    return expand_(escapeBraces(str), true).map(unescapeBraces);\n}\nfunction embrace(str) {\n    return '{' + str + '}';\n}\nfunction isPadded(el) {\n    return /^-?0\\d/.test(el);\n}\nfunction lte(i, y) {\n    return i <= y;\n}\nfunction gte(i, y) {\n    return i >= y;\n}\nfunction expand_(str, isTop) {\n    /** @type {string[]} */\n    const expansions = [];\n    const m = (0,_isaacs_balanced_match__WEBPACK_IMPORTED_MODULE_0__.balanced)('{', '}', str);\n    if (!m)\n        return [str];\n    // no need to expand pre, since it is guaranteed to be free of brace-sets\n    const pre = m.pre;\n    const post = m.post.length ? expand_(m.post, false) : [''];\n    if (/\\$$/.test(m.pre)) {\n        for (let k = 0; k < post.length; k++) {\n            const expansion = pre + '{' + m.body + '}' + post[k];\n            expansions.push(expansion);\n        }\n    }\n    else {\n        const isNumericSequence = /^-?\\d+\\.\\.-?\\d+(?:\\.\\.-?\\d+)?$/.test(m.body);\n        const isAlphaSequence = /^[a-zA-Z]\\.\\.[a-zA-Z](?:\\.\\.-?\\d+)?$/.test(m.body);\n        const isSequence = isNumericSequence || isAlphaSequence;\n        const isOptions = m.body.indexOf(',') >= 0;\n        if (!isSequence && !isOptions) {\n            // {a},b}\n            if (m.post.match(/,(?!,).*\\}/)) {\n                str = m.pre + '{' + m.body + escClose + m.post;\n                return expand_(str);\n            }\n            return [str];\n        }\n        let n;\n        if (isSequence) {\n            n = m.body.split(/\\.\\./);\n        }\n        else {\n            n = parseCommaParts(m.body);\n            if (n.length === 1 && n[0] !== undefined) {\n                // x{{a,b}}y ==> x{a}y x{b}y\n                n = expand_(n[0], false).map(embrace);\n                //XXX is this necessary? Can't seem to hit it in tests.\n                /* c8 ignore start */\n                if (n.length === 1) {\n                    return post.map(p => m.pre + n[0] + p);\n                }\n                /* c8 ignore stop */\n            }\n        }\n        // at this point, n is the parts, and we know it's not a comma set\n        // with a single entry.\n        let N;\n        if (isSequence && n[0] !== undefined && n[1] !== undefined) {\n            const x = numeric(n[0]);\n            const y = numeric(n[1]);\n            const width = Math.max(n[0].length, n[1].length);\n            let incr = n.length === 3 && n[2] !== undefined ? Math.abs(numeric(n[2])) : 1;\n            let test = lte;\n            const reverse = y < x;\n            if (reverse) {\n                incr *= -1;\n                test = gte;\n            }\n            const pad = n.some(isPadded);\n            N = [];\n            for (let i = x; test(i, y); i += incr) {\n                let c;\n                if (isAlphaSequence) {\n                    c = String.fromCharCode(i);\n                    if (c === '\\\\') {\n                        c = '';\n                    }\n                }\n                else {\n                    c = String(i);\n                    if (pad) {\n                        const need = width - c.length;\n                        if (need > 0) {\n                            const z = new Array(need + 1).join('0');\n                            if (i < 0) {\n                                c = '-' + z + c.slice(1);\n                            }\n                            else {\n                                c = z + c;\n                            }\n                        }\n                    }\n                }\n                N.push(c);\n            }\n        }\n        else {\n            N = [];\n            for (let j = 0; j < n.length; j++) {\n                N.push.apply(N, expand_(n[j], false));\n            }\n        }\n        for (let j = 0; j < N.length; j++) {\n            for (let k = 0; k < post.length; k++) {\n                const expansion = pre + N[j] + post[k];\n                if (!isTop || isSequence || expansion) {\n                    expansions.push(expansion);\n                }\n            }\n        }\n    }\n    return expansions;\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGlzYWFjcy9icmFjZS1leHBhbnNpb24vZGlzdC9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxHQUFHLElBQUk7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxnRUFBUSxHQUFHLEtBQUs7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQSx5QkFBeUIsYUFBYTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLHlDQUF5QyxHQUFHO0FBQzVDLGNBQWMsR0FBRyx5QkFBeUI7QUFDMUM7QUFDQTtBQUNBLCtCQUErQjtBQUMvQixrQkFBa0IsR0FBRztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCO0FBQ0EsY0FBYyxnRUFBUSxHQUFHLEtBQUs7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QyxzQ0FBc0MsZUFBZTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsRUFBRTtBQUNsQix3Q0FBd0M7QUFDeEMsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsS0FBSyxRQUFRLEVBQUUsSUFBSSxFQUFFO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFlBQVk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGNBQWM7QUFDMUM7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGNBQWM7QUFDdEMsNEJBQTRCLGlCQUFpQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpdmUtdmliZS1haS1uZXh0Ly4vbm9kZV9tb2R1bGVzL0Bpc2FhY3MvYnJhY2UtZXhwYW5zaW9uL2Rpc3QvZXNtL2luZGV4LmpzPzNiYWYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYmFsYW5jZWQgfSBmcm9tICdAaXNhYWNzL2JhbGFuY2VkLW1hdGNoJztcbmNvbnN0IGVzY1NsYXNoID0gJ1xcMFNMQVNIJyArIE1hdGgucmFuZG9tKCkgKyAnXFwwJztcbmNvbnN0IGVzY09wZW4gPSAnXFwwT1BFTicgKyBNYXRoLnJhbmRvbSgpICsgJ1xcMCc7XG5jb25zdCBlc2NDbG9zZSA9ICdcXDBDTE9TRScgKyBNYXRoLnJhbmRvbSgpICsgJ1xcMCc7XG5jb25zdCBlc2NDb21tYSA9ICdcXDBDT01NQScgKyBNYXRoLnJhbmRvbSgpICsgJ1xcMCc7XG5jb25zdCBlc2NQZXJpb2QgPSAnXFwwUEVSSU9EJyArIE1hdGgucmFuZG9tKCkgKyAnXFwwJztcbmNvbnN0IGVzY1NsYXNoUGF0dGVybiA9IG5ldyBSZWdFeHAoZXNjU2xhc2gsICdnJyk7XG5jb25zdCBlc2NPcGVuUGF0dGVybiA9IG5ldyBSZWdFeHAoZXNjT3BlbiwgJ2cnKTtcbmNvbnN0IGVzY0Nsb3NlUGF0dGVybiA9IG5ldyBSZWdFeHAoZXNjQ2xvc2UsICdnJyk7XG5jb25zdCBlc2NDb21tYVBhdHRlcm4gPSBuZXcgUmVnRXhwKGVzY0NvbW1hLCAnZycpO1xuY29uc3QgZXNjUGVyaW9kUGF0dGVybiA9IG5ldyBSZWdFeHAoZXNjUGVyaW9kLCAnZycpO1xuY29uc3Qgc2xhc2hQYXR0ZXJuID0gL1xcXFxcXFxcL2c7XG5jb25zdCBvcGVuUGF0dGVybiA9IC9cXFxcey9nO1xuY29uc3QgY2xvc2VQYXR0ZXJuID0gL1xcXFx9L2c7XG5jb25zdCBjb21tYVBhdHRlcm4gPSAvXFxcXCwvZztcbmNvbnN0IHBlcmlvZFBhdHRlcm4gPSAvXFxcXC4vZztcbmZ1bmN0aW9uIG51bWVyaWMoc3RyKSB7XG4gICAgcmV0dXJuICFpc05hTihzdHIpID8gcGFyc2VJbnQoc3RyLCAxMCkgOiBzdHIuY2hhckNvZGVBdCgwKTtcbn1cbmZ1bmN0aW9uIGVzY2FwZUJyYWNlcyhzdHIpIHtcbiAgICByZXR1cm4gc3RyXG4gICAgICAgIC5yZXBsYWNlKHNsYXNoUGF0dGVybiwgZXNjU2xhc2gpXG4gICAgICAgIC5yZXBsYWNlKG9wZW5QYXR0ZXJuLCBlc2NPcGVuKVxuICAgICAgICAucmVwbGFjZShjbG9zZVBhdHRlcm4sIGVzY0Nsb3NlKVxuICAgICAgICAucmVwbGFjZShjb21tYVBhdHRlcm4sIGVzY0NvbW1hKVxuICAgICAgICAucmVwbGFjZShwZXJpb2RQYXR0ZXJuLCBlc2NQZXJpb2QpO1xufVxuZnVuY3Rpb24gdW5lc2NhcGVCcmFjZXMoc3RyKSB7XG4gICAgcmV0dXJuIHN0clxuICAgICAgICAucmVwbGFjZShlc2NTbGFzaFBhdHRlcm4sICdcXFxcJylcbiAgICAgICAgLnJlcGxhY2UoZXNjT3BlblBhdHRlcm4sICd7JylcbiAgICAgICAgLnJlcGxhY2UoZXNjQ2xvc2VQYXR0ZXJuLCAnfScpXG4gICAgICAgIC5yZXBsYWNlKGVzY0NvbW1hUGF0dGVybiwgJywnKVxuICAgICAgICAucmVwbGFjZShlc2NQZXJpb2RQYXR0ZXJuLCAnLicpO1xufVxuLyoqXG4gKiBCYXNpY2FsbHkganVzdCBzdHIuc3BsaXQoXCIsXCIpLCBidXQgaGFuZGxpbmcgY2FzZXNcbiAqIHdoZXJlIHdlIGhhdmUgbmVzdGVkIGJyYWNlZCBzZWN0aW9ucywgd2hpY2ggc2hvdWxkIGJlXG4gKiB0cmVhdGVkIGFzIGluZGl2aWR1YWwgbWVtYmVycywgbGlrZSB7YSx7YixjfSxkfVxuICovXG5mdW5jdGlvbiBwYXJzZUNvbW1hUGFydHMoc3RyKSB7XG4gICAgaWYgKCFzdHIpIHtcbiAgICAgICAgcmV0dXJuIFsnJ107XG4gICAgfVxuICAgIGNvbnN0IHBhcnRzID0gW107XG4gICAgY29uc3QgbSA9IGJhbGFuY2VkKCd7JywgJ30nLCBzdHIpO1xuICAgIGlmICghbSkge1xuICAgICAgICByZXR1cm4gc3RyLnNwbGl0KCcsJyk7XG4gICAgfVxuICAgIGNvbnN0IHsgcHJlLCBib2R5LCBwb3N0IH0gPSBtO1xuICAgIGNvbnN0IHAgPSBwcmUuc3BsaXQoJywnKTtcbiAgICBwW3AubGVuZ3RoIC0gMV0gKz0gJ3snICsgYm9keSArICd9JztcbiAgICBjb25zdCBwb3N0UGFydHMgPSBwYXJzZUNvbW1hUGFydHMocG9zdCk7XG4gICAgaWYgKHBvc3QubGVuZ3RoKSB7XG4gICAgICAgIDtcbiAgICAgICAgcFtwLmxlbmd0aCAtIDFdICs9IHBvc3RQYXJ0cy5zaGlmdCgpO1xuICAgICAgICBwLnB1c2guYXBwbHkocCwgcG9zdFBhcnRzKTtcbiAgICB9XG4gICAgcGFydHMucHVzaC5hcHBseShwYXJ0cywgcCk7XG4gICAgcmV0dXJuIHBhcnRzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGV4cGFuZChzdHIpIHtcbiAgICBpZiAoIXN0cikge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIC8vIEkgZG9uJ3Qga25vdyB3aHkgQmFzaCA0LjMgZG9lcyB0aGlzLCBidXQgaXQgZG9lcy5cbiAgICAvLyBBbnl0aGluZyBzdGFydGluZyB3aXRoIHt9IHdpbGwgaGF2ZSB0aGUgZmlyc3QgdHdvIGJ5dGVzIHByZXNlcnZlZFxuICAgIC8vIGJ1dCAqb25seSogYXQgdGhlIHRvcCBsZXZlbCwgc28ge30sYX1iIHdpbGwgbm90IGV4cGFuZCB0byBhbnl0aGluZyxcbiAgICAvLyBidXQgYXt9LGJ9YyB3aWxsIGJlIGV4cGFuZGVkIHRvIFthfWMsYWJjXS5cbiAgICAvLyBPbmUgY291bGQgYXJndWUgdGhhdCB0aGlzIGlzIGEgYnVnIGluIEJhc2gsIGJ1dCBzaW5jZSB0aGUgZ29hbCBvZlxuICAgIC8vIHRoaXMgbW9kdWxlIGlzIHRvIG1hdGNoIEJhc2gncyBydWxlcywgd2UgZXNjYXBlIGEgbGVhZGluZyB7fVxuICAgIGlmIChzdHIuc2xpY2UoMCwgMikgPT09ICd7fScpIHtcbiAgICAgICAgc3RyID0gJ1xcXFx7XFxcXH0nICsgc3RyLnNsaWNlKDIpO1xuICAgIH1cbiAgICByZXR1cm4gZXhwYW5kXyhlc2NhcGVCcmFjZXMoc3RyKSwgdHJ1ZSkubWFwKHVuZXNjYXBlQnJhY2VzKTtcbn1cbmZ1bmN0aW9uIGVtYnJhY2Uoc3RyKSB7XG4gICAgcmV0dXJuICd7JyArIHN0ciArICd9Jztcbn1cbmZ1bmN0aW9uIGlzUGFkZGVkKGVsKSB7XG4gICAgcmV0dXJuIC9eLT8wXFxkLy50ZXN0KGVsKTtcbn1cbmZ1bmN0aW9uIGx0ZShpLCB5KSB7XG4gICAgcmV0dXJuIGkgPD0geTtcbn1cbmZ1bmN0aW9uIGd0ZShpLCB5KSB7XG4gICAgcmV0dXJuIGkgPj0geTtcbn1cbmZ1bmN0aW9uIGV4cGFuZF8oc3RyLCBpc1RvcCkge1xuICAgIC8qKiBAdHlwZSB7c3RyaW5nW119ICovXG4gICAgY29uc3QgZXhwYW5zaW9ucyA9IFtdO1xuICAgIGNvbnN0IG0gPSBiYWxhbmNlZCgneycsICd9Jywgc3RyKTtcbiAgICBpZiAoIW0pXG4gICAgICAgIHJldHVybiBbc3RyXTtcbiAgICAvLyBubyBuZWVkIHRvIGV4cGFuZCBwcmUsIHNpbmNlIGl0IGlzIGd1YXJhbnRlZWQgdG8gYmUgZnJlZSBvZiBicmFjZS1zZXRzXG4gICAgY29uc3QgcHJlID0gbS5wcmU7XG4gICAgY29uc3QgcG9zdCA9IG0ucG9zdC5sZW5ndGggPyBleHBhbmRfKG0ucG9zdCwgZmFsc2UpIDogWycnXTtcbiAgICBpZiAoL1xcJCQvLnRlc3QobS5wcmUpKSB7XG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgcG9zdC5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgY29uc3QgZXhwYW5zaW9uID0gcHJlICsgJ3snICsgbS5ib2R5ICsgJ30nICsgcG9zdFtrXTtcbiAgICAgICAgICAgIGV4cGFuc2lvbnMucHVzaChleHBhbnNpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBpc051bWVyaWNTZXF1ZW5jZSA9IC9eLT9cXGQrXFwuXFwuLT9cXGQrKD86XFwuXFwuLT9cXGQrKT8kLy50ZXN0KG0uYm9keSk7XG4gICAgICAgIGNvbnN0IGlzQWxwaGFTZXF1ZW5jZSA9IC9eW2EtekEtWl1cXC5cXC5bYS16QS1aXSg/OlxcLlxcLi0/XFxkKyk/JC8udGVzdChtLmJvZHkpO1xuICAgICAgICBjb25zdCBpc1NlcXVlbmNlID0gaXNOdW1lcmljU2VxdWVuY2UgfHwgaXNBbHBoYVNlcXVlbmNlO1xuICAgICAgICBjb25zdCBpc09wdGlvbnMgPSBtLmJvZHkuaW5kZXhPZignLCcpID49IDA7XG4gICAgICAgIGlmICghaXNTZXF1ZW5jZSAmJiAhaXNPcHRpb25zKSB7XG4gICAgICAgICAgICAvLyB7YX0sYn1cbiAgICAgICAgICAgIGlmIChtLnBvc3QubWF0Y2goLywoPyEsKS4qXFx9LykpIHtcbiAgICAgICAgICAgICAgICBzdHIgPSBtLnByZSArICd7JyArIG0uYm9keSArIGVzY0Nsb3NlICsgbS5wb3N0O1xuICAgICAgICAgICAgICAgIHJldHVybiBleHBhbmRfKHN0cik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW3N0cl07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG47XG4gICAgICAgIGlmIChpc1NlcXVlbmNlKSB7XG4gICAgICAgICAgICBuID0gbS5ib2R5LnNwbGl0KC9cXC5cXC4vKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG4gPSBwYXJzZUNvbW1hUGFydHMobS5ib2R5KTtcbiAgICAgICAgICAgIGlmIChuLmxlbmd0aCA9PT0gMSAmJiBuWzBdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyB4e3thLGJ9fXkgPT0+IHh7YX15IHh7Yn15XG4gICAgICAgICAgICAgICAgbiA9IGV4cGFuZF8oblswXSwgZmFsc2UpLm1hcChlbWJyYWNlKTtcbiAgICAgICAgICAgICAgICAvL1hYWCBpcyB0aGlzIG5lY2Vzc2FyeT8gQ2FuJ3Qgc2VlbSB0byBoaXQgaXQgaW4gdGVzdHMuXG4gICAgICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICAgICAgaWYgKG4ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwb3N0Lm1hcChwID0+IG0ucHJlICsgblswXSArIHApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGF0IHRoaXMgcG9pbnQsIG4gaXMgdGhlIHBhcnRzLCBhbmQgd2Uga25vdyBpdCdzIG5vdCBhIGNvbW1hIHNldFxuICAgICAgICAvLyB3aXRoIGEgc2luZ2xlIGVudHJ5LlxuICAgICAgICBsZXQgTjtcbiAgICAgICAgaWYgKGlzU2VxdWVuY2UgJiYgblswXSAhPT0gdW5kZWZpbmVkICYmIG5bMV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgeCA9IG51bWVyaWMoblswXSk7XG4gICAgICAgICAgICBjb25zdCB5ID0gbnVtZXJpYyhuWzFdKTtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gTWF0aC5tYXgoblswXS5sZW5ndGgsIG5bMV0ubGVuZ3RoKTtcbiAgICAgICAgICAgIGxldCBpbmNyID0gbi5sZW5ndGggPT09IDMgJiYgblsyXSAhPT0gdW5kZWZpbmVkID8gTWF0aC5hYnMobnVtZXJpYyhuWzJdKSkgOiAxO1xuICAgICAgICAgICAgbGV0IHRlc3QgPSBsdGU7XG4gICAgICAgICAgICBjb25zdCByZXZlcnNlID0geSA8IHg7XG4gICAgICAgICAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICAgICAgICAgIGluY3IgKj0gLTE7XG4gICAgICAgICAgICAgICAgdGVzdCA9IGd0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhZCA9IG4uc29tZShpc1BhZGRlZCk7XG4gICAgICAgICAgICBOID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0geDsgdGVzdChpLCB5KTsgaSArPSBpbmNyKSB7XG4gICAgICAgICAgICAgICAgbGV0IGM7XG4gICAgICAgICAgICAgICAgaWYgKGlzQWxwaGFTZXF1ZW5jZSkge1xuICAgICAgICAgICAgICAgICAgICBjID0gU3RyaW5nLmZyb21DaGFyQ29kZShpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09ICdcXFxcJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYyA9ICcnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjID0gU3RyaW5nKGkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZWVkID0gd2lkdGggLSBjLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZWVkID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHogPSBuZXcgQXJyYXkobmVlZCArIDEpLmpvaW4oJzAnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA9ICctJyArIHogKyBjLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA9IHogKyBjO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBOLnB1c2goYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBOID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG4ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBOLnB1c2guYXBwbHkoTiwgZXhwYW5kXyhuW2pdLCBmYWxzZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgTi5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBwb3N0Lmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhwYW5zaW9uID0gcHJlICsgTltqXSArIHBvc3Rba107XG4gICAgICAgICAgICAgICAgaWYgKCFpc1RvcCB8fCBpc1NlcXVlbmNlIHx8IGV4cGFuc2lvbikge1xuICAgICAgICAgICAgICAgICAgICBleHBhbnNpb25zLnB1c2goZXhwYW5zaW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGV4cGFuc2lvbnM7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@isaacs/brace-expansion/dist/esm/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@isaacs/fs-minipass/dist/esm/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@isaacs/fs-minipass/dist/esm/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ReadStream: () => (/* binding */ ReadStream),\n/* harmony export */   ReadStreamSync: () => (/* binding */ ReadStreamSync),\n/* harmony export */   WriteStream: () => (/* binding */ WriteStream),\n/* harmony export */   WriteStreamSync: () => (/* binding */ WriteStreamSync)\n/* harmony export */ });\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var minipass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! minipass */ \"(rsc)/./node_modules/minipass/dist/esm/index.js\");\n\n\n\nconst writev = fs__WEBPACK_IMPORTED_MODULE_1__.writev;\nconst _autoClose = Symbol('_autoClose');\nconst _close = Symbol('_close');\nconst _ended = Symbol('_ended');\nconst _fd = Symbol('_fd');\nconst _finished = Symbol('_finished');\nconst _flags = Symbol('_flags');\nconst _flush = Symbol('_flush');\nconst _handleChunk = Symbol('_handleChunk');\nconst _makeBuf = Symbol('_makeBuf');\nconst _mode = Symbol('_mode');\nconst _needDrain = Symbol('_needDrain');\nconst _onerror = Symbol('_onerror');\nconst _onopen = Symbol('_onopen');\nconst _onread = Symbol('_onread');\nconst _onwrite = Symbol('_onwrite');\nconst _open = Symbol('_open');\nconst _path = Symbol('_path');\nconst _pos = Symbol('_pos');\nconst _queue = Symbol('_queue');\nconst _read = Symbol('_read');\nconst _readSize = Symbol('_readSize');\nconst _reading = Symbol('_reading');\nconst _remain = Symbol('_remain');\nconst _size = Symbol('_size');\nconst _write = Symbol('_write');\nconst _writing = Symbol('_writing');\nconst _defaultFlag = Symbol('_defaultFlag');\nconst _errored = Symbol('_errored');\nclass ReadStream extends minipass__WEBPACK_IMPORTED_MODULE_2__.Minipass {\n    [_errored] = false;\n    [_fd];\n    [_path];\n    [_readSize];\n    [_reading] = false;\n    [_size];\n    [_remain];\n    [_autoClose];\n    constructor(path, opt) {\n        opt = opt || {};\n        super(opt);\n        this.readable = true;\n        this.writable = false;\n        if (typeof path !== 'string') {\n            throw new TypeError('path must be a string');\n        }\n        this[_errored] = false;\n        this[_fd] = typeof opt.fd === 'number' ? opt.fd : undefined;\n        this[_path] = path;\n        this[_readSize] = opt.readSize || 16 * 1024 * 1024;\n        this[_reading] = false;\n        this[_size] = typeof opt.size === 'number' ? opt.size : Infinity;\n        this[_remain] = this[_size];\n        this[_autoClose] =\n            typeof opt.autoClose === 'boolean' ? opt.autoClose : true;\n        if (typeof this[_fd] === 'number') {\n            this[_read]();\n        }\n        else {\n            this[_open]();\n        }\n    }\n    get fd() {\n        return this[_fd];\n    }\n    get path() {\n        return this[_path];\n    }\n    //@ts-ignore\n    write() {\n        throw new TypeError('this is a readable stream');\n    }\n    //@ts-ignore\n    end() {\n        throw new TypeError('this is a readable stream');\n    }\n    [_open]() {\n        fs__WEBPACK_IMPORTED_MODULE_1__.open(this[_path], 'r', (er, fd) => this[_onopen](er, fd));\n    }\n    [_onopen](er, fd) {\n        if (er) {\n            this[_onerror](er);\n        }\n        else {\n            this[_fd] = fd;\n            this.emit('open', fd);\n            this[_read]();\n        }\n    }\n    [_makeBuf]() {\n        return Buffer.allocUnsafe(Math.min(this[_readSize], this[_remain]));\n    }\n    [_read]() {\n        if (!this[_reading]) {\n            this[_reading] = true;\n            const buf = this[_makeBuf]();\n            /* c8 ignore start */\n            if (buf.length === 0) {\n                return process.nextTick(() => this[_onread](null, 0, buf));\n            }\n            /* c8 ignore stop */\n            fs__WEBPACK_IMPORTED_MODULE_1__.read(this[_fd], buf, 0, buf.length, null, (er, br, b) => this[_onread](er, br, b));\n        }\n    }\n    [_onread](er, br, buf) {\n        this[_reading] = false;\n        if (er) {\n            this[_onerror](er);\n        }\n        else if (this[_handleChunk](br, buf)) {\n            this[_read]();\n        }\n    }\n    [_close]() {\n        if (this[_autoClose] && typeof this[_fd] === 'number') {\n            const fd = this[_fd];\n            this[_fd] = undefined;\n            fs__WEBPACK_IMPORTED_MODULE_1__.close(fd, er => er ? this.emit('error', er) : this.emit('close'));\n        }\n    }\n    [_onerror](er) {\n        this[_reading] = true;\n        this[_close]();\n        this.emit('error', er);\n    }\n    [_handleChunk](br, buf) {\n        let ret = false;\n        // no effect if infinite\n        this[_remain] -= br;\n        if (br > 0) {\n            ret = super.write(br < buf.length ? buf.subarray(0, br) : buf);\n        }\n        if (br === 0 || this[_remain] <= 0) {\n            ret = false;\n            this[_close]();\n            super.end();\n        }\n        return ret;\n    }\n    emit(ev, ...args) {\n        switch (ev) {\n            case 'prefinish':\n            case 'finish':\n                return false;\n            case 'drain':\n                if (typeof this[_fd] === 'number') {\n                    this[_read]();\n                }\n                return false;\n            case 'error':\n                if (this[_errored]) {\n                    return false;\n                }\n                this[_errored] = true;\n                return super.emit(ev, ...args);\n            default:\n                return super.emit(ev, ...args);\n        }\n    }\n}\nclass ReadStreamSync extends ReadStream {\n    [_open]() {\n        let threw = true;\n        try {\n            this[_onopen](null, fs__WEBPACK_IMPORTED_MODULE_1__.openSync(this[_path], 'r'));\n            threw = false;\n        }\n        finally {\n            if (threw) {\n                this[_close]();\n            }\n        }\n    }\n    [_read]() {\n        let threw = true;\n        try {\n            if (!this[_reading]) {\n                this[_reading] = true;\n                do {\n                    const buf = this[_makeBuf]();\n                    /* c8 ignore start */\n                    const br = buf.length === 0\n                        ? 0\n                        : fs__WEBPACK_IMPORTED_MODULE_1__.readSync(this[_fd], buf, 0, buf.length, null);\n                    /* c8 ignore stop */\n                    if (!this[_handleChunk](br, buf)) {\n                        break;\n                    }\n                } while (true);\n                this[_reading] = false;\n            }\n            threw = false;\n        }\n        finally {\n            if (threw) {\n                this[_close]();\n            }\n        }\n    }\n    [_close]() {\n        if (this[_autoClose] && typeof this[_fd] === 'number') {\n            const fd = this[_fd];\n            this[_fd] = undefined;\n            fs__WEBPACK_IMPORTED_MODULE_1__.closeSync(fd);\n            this.emit('close');\n        }\n    }\n}\nclass WriteStream extends events__WEBPACK_IMPORTED_MODULE_0__ {\n    readable = false;\n    writable = true;\n    [_errored] = false;\n    [_writing] = false;\n    [_ended] = false;\n    [_queue] = [];\n    [_needDrain] = false;\n    [_path];\n    [_mode];\n    [_autoClose];\n    [_fd];\n    [_defaultFlag];\n    [_flags];\n    [_finished] = false;\n    [_pos];\n    constructor(path, opt) {\n        opt = opt || {};\n        super(opt);\n        this[_path] = path;\n        this[_fd] = typeof opt.fd === 'number' ? opt.fd : undefined;\n        this[_mode] = opt.mode === undefined ? 0o666 : opt.mode;\n        this[_pos] = typeof opt.start === 'number' ? opt.start : undefined;\n        this[_autoClose] =\n            typeof opt.autoClose === 'boolean' ? opt.autoClose : true;\n        // truncating makes no sense when writing into the middle\n        const defaultFlag = this[_pos] !== undefined ? 'r+' : 'w';\n        this[_defaultFlag] = opt.flags === undefined;\n        this[_flags] = opt.flags === undefined ? defaultFlag : opt.flags;\n        if (this[_fd] === undefined) {\n            this[_open]();\n        }\n    }\n    emit(ev, ...args) {\n        if (ev === 'error') {\n            if (this[_errored]) {\n                return false;\n            }\n            this[_errored] = true;\n        }\n        return super.emit(ev, ...args);\n    }\n    get fd() {\n        return this[_fd];\n    }\n    get path() {\n        return this[_path];\n    }\n    [_onerror](er) {\n        this[_close]();\n        this[_writing] = true;\n        this.emit('error', er);\n    }\n    [_open]() {\n        fs__WEBPACK_IMPORTED_MODULE_1__.open(this[_path], this[_flags], this[_mode], (er, fd) => this[_onopen](er, fd));\n    }\n    [_onopen](er, fd) {\n        if (this[_defaultFlag] &&\n            this[_flags] === 'r+' &&\n            er &&\n            er.code === 'ENOENT') {\n            this[_flags] = 'w';\n            this[_open]();\n        }\n        else if (er) {\n            this[_onerror](er);\n        }\n        else {\n            this[_fd] = fd;\n            this.emit('open', fd);\n            if (!this[_writing]) {\n                this[_flush]();\n            }\n        }\n    }\n    end(buf, enc) {\n        if (buf) {\n            //@ts-ignore\n            this.write(buf, enc);\n        }\n        this[_ended] = true;\n        // synthetic after-write logic, where drain/finish live\n        if (!this[_writing] &&\n            !this[_queue].length &&\n            typeof this[_fd] === 'number') {\n            this[_onwrite](null, 0);\n        }\n        return this;\n    }\n    write(buf, enc) {\n        if (typeof buf === 'string') {\n            buf = Buffer.from(buf, enc);\n        }\n        if (this[_ended]) {\n            this.emit('error', new Error('write() after end()'));\n            return false;\n        }\n        if (this[_fd] === undefined || this[_writing] || this[_queue].length) {\n            this[_queue].push(buf);\n            this[_needDrain] = true;\n            return false;\n        }\n        this[_writing] = true;\n        this[_write](buf);\n        return true;\n    }\n    [_write](buf) {\n        fs__WEBPACK_IMPORTED_MODULE_1__.write(this[_fd], buf, 0, buf.length, this[_pos], (er, bw) => this[_onwrite](er, bw));\n    }\n    [_onwrite](er, bw) {\n        if (er) {\n            this[_onerror](er);\n        }\n        else {\n            if (this[_pos] !== undefined && typeof bw === 'number') {\n                this[_pos] += bw;\n            }\n            if (this[_queue].length) {\n                this[_flush]();\n            }\n            else {\n                this[_writing] = false;\n                if (this[_ended] && !this[_finished]) {\n                    this[_finished] = true;\n                    this[_close]();\n                    this.emit('finish');\n                }\n                else if (this[_needDrain]) {\n                    this[_needDrain] = false;\n                    this.emit('drain');\n                }\n            }\n        }\n    }\n    [_flush]() {\n        if (this[_queue].length === 0) {\n            if (this[_ended]) {\n                this[_onwrite](null, 0);\n            }\n        }\n        else if (this[_queue].length === 1) {\n            this[_write](this[_queue].pop());\n        }\n        else {\n            const iovec = this[_queue];\n            this[_queue] = [];\n            writev(this[_fd], iovec, this[_pos], (er, bw) => this[_onwrite](er, bw));\n        }\n    }\n    [_close]() {\n        if (this[_autoClose] && typeof this[_fd] === 'number') {\n            const fd = this[_fd];\n            this[_fd] = undefined;\n            fs__WEBPACK_IMPORTED_MODULE_1__.close(fd, er => er ? this.emit('error', er) : this.emit('close'));\n        }\n    }\n}\nclass WriteStreamSync extends WriteStream {\n    [_open]() {\n        let fd;\n        // only wrap in a try{} block if we know we'll retry, to avoid\n        // the rethrow obscuring the error's source frame in most cases.\n        if (this[_defaultFlag] && this[_flags] === 'r+') {\n            try {\n                fd = fs__WEBPACK_IMPORTED_MODULE_1__.openSync(this[_path], this[_flags], this[_mode]);\n            }\n            catch (er) {\n                if (er?.code === 'ENOENT') {\n                    this[_flags] = 'w';\n                    return this[_open]();\n                }\n                else {\n                    throw er;\n                }\n            }\n        }\n        else {\n            fd = fs__WEBPACK_IMPORTED_MODULE_1__.openSync(this[_path], this[_flags], this[_mode]);\n        }\n        this[_onopen](null, fd);\n    }\n    [_close]() {\n        if (this[_autoClose] && typeof this[_fd] === 'number') {\n            const fd = this[_fd];\n            this[_fd] = undefined;\n            fs__WEBPACK_IMPORTED_MODULE_1__.closeSync(fd);\n            this.emit('close');\n        }\n    }\n    [_write](buf) {\n        // throw the original, but try to close if it fails\n        let threw = true;\n        try {\n            this[_onwrite](null, fs__WEBPACK_IMPORTED_MODULE_1__.writeSync(this[_fd], buf, 0, buf.length, this[_pos]));\n            threw = false;\n        }\n        finally {\n            if (threw) {\n                try {\n                    this[_close]();\n                }\n                catch {\n                    // ok error\n                }\n            }\n        }\n    }\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGlzYWFjcy9mcy1taW5pcGFzcy9kaXN0L2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQXdCO0FBQ0o7QUFDZ0I7QUFDcEMsZUFBZSxzQ0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHlCQUF5Qiw4Q0FBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvQ0FBTztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9DQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUNBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msd0NBQVc7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHdDQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlDQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ08sMEJBQTBCLG1DQUFFO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9DQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHFDQUFRO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUNBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix3Q0FBVztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0NBQVc7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlDQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHlDQUFZO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpdmUtdmliZS1haS1uZXh0Ly4vbm9kZV9tb2R1bGVzL0Bpc2FhY3MvZnMtbWluaXBhc3MvZGlzdC9lc20vaW5kZXguanM/ZWNmZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgRUUgZnJvbSAnZXZlbnRzJztcbmltcG9ydCBmcyBmcm9tICdmcyc7XG5pbXBvcnQgeyBNaW5pcGFzcyB9IGZyb20gJ21pbmlwYXNzJztcbmNvbnN0IHdyaXRldiA9IGZzLndyaXRldjtcbmNvbnN0IF9hdXRvQ2xvc2UgPSBTeW1ib2woJ19hdXRvQ2xvc2UnKTtcbmNvbnN0IF9jbG9zZSA9IFN5bWJvbCgnX2Nsb3NlJyk7XG5jb25zdCBfZW5kZWQgPSBTeW1ib2woJ19lbmRlZCcpO1xuY29uc3QgX2ZkID0gU3ltYm9sKCdfZmQnKTtcbmNvbnN0IF9maW5pc2hlZCA9IFN5bWJvbCgnX2ZpbmlzaGVkJyk7XG5jb25zdCBfZmxhZ3MgPSBTeW1ib2woJ19mbGFncycpO1xuY29uc3QgX2ZsdXNoID0gU3ltYm9sKCdfZmx1c2gnKTtcbmNvbnN0IF9oYW5kbGVDaHVuayA9IFN5bWJvbCgnX2hhbmRsZUNodW5rJyk7XG5jb25zdCBfbWFrZUJ1ZiA9IFN5bWJvbCgnX21ha2VCdWYnKTtcbmNvbnN0IF9tb2RlID0gU3ltYm9sKCdfbW9kZScpO1xuY29uc3QgX25lZWREcmFpbiA9IFN5bWJvbCgnX25lZWREcmFpbicpO1xuY29uc3QgX29uZXJyb3IgPSBTeW1ib2woJ19vbmVycm9yJyk7XG5jb25zdCBfb25vcGVuID0gU3ltYm9sKCdfb25vcGVuJyk7XG5jb25zdCBfb25yZWFkID0gU3ltYm9sKCdfb25yZWFkJyk7XG5jb25zdCBfb253cml0ZSA9IFN5bWJvbCgnX29ud3JpdGUnKTtcbmNvbnN0IF9vcGVuID0gU3ltYm9sKCdfb3BlbicpO1xuY29uc3QgX3BhdGggPSBTeW1ib2woJ19wYXRoJyk7XG5jb25zdCBfcG9zID0gU3ltYm9sKCdfcG9zJyk7XG5jb25zdCBfcXVldWUgPSBTeW1ib2woJ19xdWV1ZScpO1xuY29uc3QgX3JlYWQgPSBTeW1ib2woJ19yZWFkJyk7XG5jb25zdCBfcmVhZFNpemUgPSBTeW1ib2woJ19yZWFkU2l6ZScpO1xuY29uc3QgX3JlYWRpbmcgPSBTeW1ib2woJ19yZWFkaW5nJyk7XG5jb25zdCBfcmVtYWluID0gU3ltYm9sKCdfcmVtYWluJyk7XG5jb25zdCBfc2l6ZSA9IFN5bWJvbCgnX3NpemUnKTtcbmNvbnN0IF93cml0ZSA9IFN5bWJvbCgnX3dyaXRlJyk7XG5jb25zdCBfd3JpdGluZyA9IFN5bWJvbCgnX3dyaXRpbmcnKTtcbmNvbnN0IF9kZWZhdWx0RmxhZyA9IFN5bWJvbCgnX2RlZmF1bHRGbGFnJyk7XG5jb25zdCBfZXJyb3JlZCA9IFN5bWJvbCgnX2Vycm9yZWQnKTtcbmV4cG9ydCBjbGFzcyBSZWFkU3RyZWFtIGV4dGVuZHMgTWluaXBhc3Mge1xuICAgIFtfZXJyb3JlZF0gPSBmYWxzZTtcbiAgICBbX2ZkXTtcbiAgICBbX3BhdGhdO1xuICAgIFtfcmVhZFNpemVdO1xuICAgIFtfcmVhZGluZ10gPSBmYWxzZTtcbiAgICBbX3NpemVdO1xuICAgIFtfcmVtYWluXTtcbiAgICBbX2F1dG9DbG9zZV07XG4gICAgY29uc3RydWN0b3IocGF0aCwgb3B0KSB7XG4gICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcbiAgICAgICAgc3VwZXIob3B0KTtcbiAgICAgICAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGF0aCBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1tfZXJyb3JlZF0gPSBmYWxzZTtcbiAgICAgICAgdGhpc1tfZmRdID0gdHlwZW9mIG9wdC5mZCA9PT0gJ251bWJlcicgPyBvcHQuZmQgOiB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXNbX3BhdGhdID0gcGF0aDtcbiAgICAgICAgdGhpc1tfcmVhZFNpemVdID0gb3B0LnJlYWRTaXplIHx8IDE2ICogMTAyNCAqIDEwMjQ7XG4gICAgICAgIHRoaXNbX3JlYWRpbmddID0gZmFsc2U7XG4gICAgICAgIHRoaXNbX3NpemVdID0gdHlwZW9mIG9wdC5zaXplID09PSAnbnVtYmVyJyA/IG9wdC5zaXplIDogSW5maW5pdHk7XG4gICAgICAgIHRoaXNbX3JlbWFpbl0gPSB0aGlzW19zaXplXTtcbiAgICAgICAgdGhpc1tfYXV0b0Nsb3NlXSA9XG4gICAgICAgICAgICB0eXBlb2Ygb3B0LmF1dG9DbG9zZSA9PT0gJ2Jvb2xlYW4nID8gb3B0LmF1dG9DbG9zZSA6IHRydWU7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpc1tfZmRdID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpc1tfcmVhZF0oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXNbX29wZW5dKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGZkKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tfZmRdO1xuICAgIH1cbiAgICBnZXQgcGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbX3BhdGhdO1xuICAgIH1cbiAgICAvL0B0cy1pZ25vcmVcbiAgICB3cml0ZSgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndGhpcyBpcyBhIHJlYWRhYmxlIHN0cmVhbScpO1xuICAgIH1cbiAgICAvL0B0cy1pZ25vcmVcbiAgICBlbmQoKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3RoaXMgaXMgYSByZWFkYWJsZSBzdHJlYW0nKTtcbiAgICB9XG4gICAgW19vcGVuXSgpIHtcbiAgICAgICAgZnMub3Blbih0aGlzW19wYXRoXSwgJ3InLCAoZXIsIGZkKSA9PiB0aGlzW19vbm9wZW5dKGVyLCBmZCkpO1xuICAgIH1cbiAgICBbX29ub3Blbl0oZXIsIGZkKSB7XG4gICAgICAgIGlmIChlcikge1xuICAgICAgICAgICAgdGhpc1tfb25lcnJvcl0oZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpc1tfZmRdID0gZmQ7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ29wZW4nLCBmZCk7XG4gICAgICAgICAgICB0aGlzW19yZWFkXSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFtfbWFrZUJ1Zl0oKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuYWxsb2NVbnNhZmUoTWF0aC5taW4odGhpc1tfcmVhZFNpemVdLCB0aGlzW19yZW1haW5dKSk7XG4gICAgfVxuICAgIFtfcmVhZF0oKSB7XG4gICAgICAgIGlmICghdGhpc1tfcmVhZGluZ10pIHtcbiAgICAgICAgICAgIHRoaXNbX3JlYWRpbmddID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZiA9IHRoaXNbX21ha2VCdWZdKCk7XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgICAgIGlmIChidWYubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soKCkgPT4gdGhpc1tfb25yZWFkXShudWxsLCAwLCBidWYpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgICAgICBmcy5yZWFkKHRoaXNbX2ZkXSwgYnVmLCAwLCBidWYubGVuZ3RoLCBudWxsLCAoZXIsIGJyLCBiKSA9PiB0aGlzW19vbnJlYWRdKGVyLCBiciwgYikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFtfb25yZWFkXShlciwgYnIsIGJ1Zikge1xuICAgICAgICB0aGlzW19yZWFkaW5nXSA9IGZhbHNlO1xuICAgICAgICBpZiAoZXIpIHtcbiAgICAgICAgICAgIHRoaXNbX29uZXJyb3JdKGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzW19oYW5kbGVDaHVua10oYnIsIGJ1ZikpIHtcbiAgICAgICAgICAgIHRoaXNbX3JlYWRdKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgW19jbG9zZV0oKSB7XG4gICAgICAgIGlmICh0aGlzW19hdXRvQ2xvc2VdICYmIHR5cGVvZiB0aGlzW19mZF0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBjb25zdCBmZCA9IHRoaXNbX2ZkXTtcbiAgICAgICAgICAgIHRoaXNbX2ZkXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGZzLmNsb3NlKGZkLCBlciA9PiBlciA/IHRoaXMuZW1pdCgnZXJyb3InLCBlcikgOiB0aGlzLmVtaXQoJ2Nsb3NlJykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFtfb25lcnJvcl0oZXIpIHtcbiAgICAgICAgdGhpc1tfcmVhZGluZ10gPSB0cnVlO1xuICAgICAgICB0aGlzW19jbG9zZV0oKTtcbiAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICB9XG4gICAgW19oYW5kbGVDaHVua10oYnIsIGJ1Zikge1xuICAgICAgICBsZXQgcmV0ID0gZmFsc2U7XG4gICAgICAgIC8vIG5vIGVmZmVjdCBpZiBpbmZpbml0ZVxuICAgICAgICB0aGlzW19yZW1haW5dIC09IGJyO1xuICAgICAgICBpZiAoYnIgPiAwKSB7XG4gICAgICAgICAgICByZXQgPSBzdXBlci53cml0ZShiciA8IGJ1Zi5sZW5ndGggPyBidWYuc3ViYXJyYXkoMCwgYnIpIDogYnVmKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnIgPT09IDAgfHwgdGhpc1tfcmVtYWluXSA8PSAwKSB7XG4gICAgICAgICAgICByZXQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXNbX2Nsb3NlXSgpO1xuICAgICAgICAgICAgc3VwZXIuZW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgZW1pdChldiwgLi4uYXJncykge1xuICAgICAgICBzd2l0Y2ggKGV2KSB7XG4gICAgICAgICAgICBjYXNlICdwcmVmaW5pc2gnOlxuICAgICAgICAgICAgY2FzZSAnZmluaXNoJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjYXNlICdkcmFpbic6XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzW19mZF0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbX3JlYWRdKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgICAgICAgICBpZiAodGhpc1tfZXJyb3JlZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzW19lcnJvcmVkXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1cGVyLmVtaXQoZXYsIC4uLmFyZ3MpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VwZXIuZW1pdChldiwgLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgY2xhc3MgUmVhZFN0cmVhbVN5bmMgZXh0ZW5kcyBSZWFkU3RyZWFtIHtcbiAgICBbX29wZW5dKCkge1xuICAgICAgICBsZXQgdGhyZXcgPSB0cnVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpc1tfb25vcGVuXShudWxsLCBmcy5vcGVuU3luYyh0aGlzW19wYXRoXSwgJ3InKSk7XG4gICAgICAgICAgICB0aHJldyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKHRocmV3KSB7XG4gICAgICAgICAgICAgICAgdGhpc1tfY2xvc2VdKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgW19yZWFkXSgpIHtcbiAgICAgICAgbGV0IHRocmV3ID0gdHJ1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghdGhpc1tfcmVhZGluZ10pIHtcbiAgICAgICAgICAgICAgICB0aGlzW19yZWFkaW5nXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBidWYgPSB0aGlzW19tYWtlQnVmXSgpO1xuICAgICAgICAgICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYnIgPSBidWYubGVuZ3RoID09PSAwXG4gICAgICAgICAgICAgICAgICAgICAgICA/IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIDogZnMucmVhZFN5bmModGhpc1tfZmRdLCBidWYsIDAsIGJ1Zi5sZW5ndGgsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXNbX2hhbmRsZUNodW5rXShiciwgYnVmKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IHdoaWxlICh0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzW19yZWFkaW5nXSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyZXcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmICh0aHJldykge1xuICAgICAgICAgICAgICAgIHRoaXNbX2Nsb3NlXSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFtfY2xvc2VdKCkge1xuICAgICAgICBpZiAodGhpc1tfYXV0b0Nsb3NlXSAmJiB0eXBlb2YgdGhpc1tfZmRdID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgY29uc3QgZmQgPSB0aGlzW19mZF07XG4gICAgICAgICAgICB0aGlzW19mZF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBmcy5jbG9zZVN5bmMoZmQpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdjbG9zZScpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFdyaXRlU3RyZWFtIGV4dGVuZHMgRUUge1xuICAgIHJlYWRhYmxlID0gZmFsc2U7XG4gICAgd3JpdGFibGUgPSB0cnVlO1xuICAgIFtfZXJyb3JlZF0gPSBmYWxzZTtcbiAgICBbX3dyaXRpbmddID0gZmFsc2U7XG4gICAgW19lbmRlZF0gPSBmYWxzZTtcbiAgICBbX3F1ZXVlXSA9IFtdO1xuICAgIFtfbmVlZERyYWluXSA9IGZhbHNlO1xuICAgIFtfcGF0aF07XG4gICAgW19tb2RlXTtcbiAgICBbX2F1dG9DbG9zZV07XG4gICAgW19mZF07XG4gICAgW19kZWZhdWx0RmxhZ107XG4gICAgW19mbGFnc107XG4gICAgW19maW5pc2hlZF0gPSBmYWxzZTtcbiAgICBbX3Bvc107XG4gICAgY29uc3RydWN0b3IocGF0aCwgb3B0KSB7XG4gICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcbiAgICAgICAgc3VwZXIob3B0KTtcbiAgICAgICAgdGhpc1tfcGF0aF0gPSBwYXRoO1xuICAgICAgICB0aGlzW19mZF0gPSB0eXBlb2Ygb3B0LmZkID09PSAnbnVtYmVyJyA/IG9wdC5mZCA6IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpc1tfbW9kZV0gPSBvcHQubW9kZSA9PT0gdW5kZWZpbmVkID8gMG82NjYgOiBvcHQubW9kZTtcbiAgICAgICAgdGhpc1tfcG9zXSA9IHR5cGVvZiBvcHQuc3RhcnQgPT09ICdudW1iZXInID8gb3B0LnN0YXJ0IDogdW5kZWZpbmVkO1xuICAgICAgICB0aGlzW19hdXRvQ2xvc2VdID1cbiAgICAgICAgICAgIHR5cGVvZiBvcHQuYXV0b0Nsb3NlID09PSAnYm9vbGVhbicgPyBvcHQuYXV0b0Nsb3NlIDogdHJ1ZTtcbiAgICAgICAgLy8gdHJ1bmNhdGluZyBtYWtlcyBubyBzZW5zZSB3aGVuIHdyaXRpbmcgaW50byB0aGUgbWlkZGxlXG4gICAgICAgIGNvbnN0IGRlZmF1bHRGbGFnID0gdGhpc1tfcG9zXSAhPT0gdW5kZWZpbmVkID8gJ3IrJyA6ICd3JztcbiAgICAgICAgdGhpc1tfZGVmYXVsdEZsYWddID0gb3B0LmZsYWdzID09PSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXNbX2ZsYWdzXSA9IG9wdC5mbGFncyA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdEZsYWcgOiBvcHQuZmxhZ3M7XG4gICAgICAgIGlmICh0aGlzW19mZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpc1tfb3Blbl0oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbWl0KGV2LCAuLi5hcmdzKSB7XG4gICAgICAgIGlmIChldiA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgICAgaWYgKHRoaXNbX2Vycm9yZWRdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpc1tfZXJyb3JlZF0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5lbWl0KGV2LCAuLi5hcmdzKTtcbiAgICB9XG4gICAgZ2V0IGZkKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tfZmRdO1xuICAgIH1cbiAgICBnZXQgcGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbX3BhdGhdO1xuICAgIH1cbiAgICBbX29uZXJyb3JdKGVyKSB7XG4gICAgICAgIHRoaXNbX2Nsb3NlXSgpO1xuICAgICAgICB0aGlzW193cml0aW5nXSA9IHRydWU7XG4gICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcik7XG4gICAgfVxuICAgIFtfb3Blbl0oKSB7XG4gICAgICAgIGZzLm9wZW4odGhpc1tfcGF0aF0sIHRoaXNbX2ZsYWdzXSwgdGhpc1tfbW9kZV0sIChlciwgZmQpID0+IHRoaXNbX29ub3Blbl0oZXIsIGZkKSk7XG4gICAgfVxuICAgIFtfb25vcGVuXShlciwgZmQpIHtcbiAgICAgICAgaWYgKHRoaXNbX2RlZmF1bHRGbGFnXSAmJlxuICAgICAgICAgICAgdGhpc1tfZmxhZ3NdID09PSAncisnICYmXG4gICAgICAgICAgICBlciAmJlxuICAgICAgICAgICAgZXIuY29kZSA9PT0gJ0VOT0VOVCcpIHtcbiAgICAgICAgICAgIHRoaXNbX2ZsYWdzXSA9ICd3JztcbiAgICAgICAgICAgIHRoaXNbX29wZW5dKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXIpIHtcbiAgICAgICAgICAgIHRoaXNbX29uZXJyb3JdKGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXNbX2ZkXSA9IGZkO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdvcGVuJywgZmQpO1xuICAgICAgICAgICAgaWYgKCF0aGlzW193cml0aW5nXSkge1xuICAgICAgICAgICAgICAgIHRoaXNbX2ZsdXNoXSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVuZChidWYsIGVuYykge1xuICAgICAgICBpZiAoYnVmKSB7XG4gICAgICAgICAgICAvL0B0cy1pZ25vcmVcbiAgICAgICAgICAgIHRoaXMud3JpdGUoYnVmLCBlbmMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXNbX2VuZGVkXSA9IHRydWU7XG4gICAgICAgIC8vIHN5bnRoZXRpYyBhZnRlci13cml0ZSBsb2dpYywgd2hlcmUgZHJhaW4vZmluaXNoIGxpdmVcbiAgICAgICAgaWYgKCF0aGlzW193cml0aW5nXSAmJlxuICAgICAgICAgICAgIXRoaXNbX3F1ZXVlXS5sZW5ndGggJiZcbiAgICAgICAgICAgIHR5cGVvZiB0aGlzW19mZF0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aGlzW19vbndyaXRlXShudWxsLCAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgd3JpdGUoYnVmLCBlbmMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBidWYgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBidWYgPSBCdWZmZXIuZnJvbShidWYsIGVuYyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXNbX2VuZGVkXSkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignd3JpdGUoKSBhZnRlciBlbmQoKScpKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpc1tfZmRdID09PSB1bmRlZmluZWQgfHwgdGhpc1tfd3JpdGluZ10gfHwgdGhpc1tfcXVldWVdLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpc1tfcXVldWVdLnB1c2goYnVmKTtcbiAgICAgICAgICAgIHRoaXNbX25lZWREcmFpbl0gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXNbX3dyaXRpbmddID0gdHJ1ZTtcbiAgICAgICAgdGhpc1tfd3JpdGVdKGJ1Zik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBbX3dyaXRlXShidWYpIHtcbiAgICAgICAgZnMud3JpdGUodGhpc1tfZmRdLCBidWYsIDAsIGJ1Zi5sZW5ndGgsIHRoaXNbX3Bvc10sIChlciwgYncpID0+IHRoaXNbX29ud3JpdGVdKGVyLCBidykpO1xuICAgIH1cbiAgICBbX29ud3JpdGVdKGVyLCBidykge1xuICAgICAgICBpZiAoZXIpIHtcbiAgICAgICAgICAgIHRoaXNbX29uZXJyb3JdKGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzW19wb3NdICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGJ3ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHRoaXNbX3Bvc10gKz0gYnc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpc1tfcXVldWVdLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXNbX2ZsdXNoXSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpc1tfd3JpdGluZ10gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAodGhpc1tfZW5kZWRdICYmICF0aGlzW19maW5pc2hlZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tfZmluaXNoZWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tfY2xvc2VdKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZmluaXNoJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXNbX25lZWREcmFpbl0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tfbmVlZERyYWluXSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2RyYWluJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFtfZmx1c2hdKCkge1xuICAgICAgICBpZiAodGhpc1tfcXVldWVdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXNbX2VuZGVkXSkge1xuICAgICAgICAgICAgICAgIHRoaXNbX29ud3JpdGVdKG51bGwsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXNbX3F1ZXVlXS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXNbX3dyaXRlXSh0aGlzW19xdWV1ZV0ucG9wKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaW92ZWMgPSB0aGlzW19xdWV1ZV07XG4gICAgICAgICAgICB0aGlzW19xdWV1ZV0gPSBbXTtcbiAgICAgICAgICAgIHdyaXRldih0aGlzW19mZF0sIGlvdmVjLCB0aGlzW19wb3NdLCAoZXIsIGJ3KSA9PiB0aGlzW19vbndyaXRlXShlciwgYncpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBbX2Nsb3NlXSgpIHtcbiAgICAgICAgaWYgKHRoaXNbX2F1dG9DbG9zZV0gJiYgdHlwZW9mIHRoaXNbX2ZkXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGNvbnN0IGZkID0gdGhpc1tfZmRdO1xuICAgICAgICAgICAgdGhpc1tfZmRdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgZnMuY2xvc2UoZmQsIGVyID0+IGVyID8gdGhpcy5lbWl0KCdlcnJvcicsIGVyKSA6IHRoaXMuZW1pdCgnY2xvc2UnKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgY2xhc3MgV3JpdGVTdHJlYW1TeW5jIGV4dGVuZHMgV3JpdGVTdHJlYW0ge1xuICAgIFtfb3Blbl0oKSB7XG4gICAgICAgIGxldCBmZDtcbiAgICAgICAgLy8gb25seSB3cmFwIGluIGEgdHJ5e30gYmxvY2sgaWYgd2Uga25vdyB3ZSdsbCByZXRyeSwgdG8gYXZvaWRcbiAgICAgICAgLy8gdGhlIHJldGhyb3cgb2JzY3VyaW5nIHRoZSBlcnJvcidzIHNvdXJjZSBmcmFtZSBpbiBtb3N0IGNhc2VzLlxuICAgICAgICBpZiAodGhpc1tfZGVmYXVsdEZsYWddICYmIHRoaXNbX2ZsYWdzXSA9PT0gJ3IrJykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmZCA9IGZzLm9wZW5TeW5jKHRoaXNbX3BhdGhdLCB0aGlzW19mbGFnc10sIHRoaXNbX21vZGVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcikge1xuICAgICAgICAgICAgICAgIGlmIChlcj8uY29kZSA9PT0gJ0VOT0VOVCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tfZmxhZ3NdID0gJ3cnO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tfb3Blbl0oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZkID0gZnMub3BlblN5bmModGhpc1tfcGF0aF0sIHRoaXNbX2ZsYWdzXSwgdGhpc1tfbW9kZV0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXNbX29ub3Blbl0obnVsbCwgZmQpO1xuICAgIH1cbiAgICBbX2Nsb3NlXSgpIHtcbiAgICAgICAgaWYgKHRoaXNbX2F1dG9DbG9zZV0gJiYgdHlwZW9mIHRoaXNbX2ZkXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGNvbnN0IGZkID0gdGhpc1tfZmRdO1xuICAgICAgICAgICAgdGhpc1tfZmRdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgZnMuY2xvc2VTeW5jKGZkKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnY2xvc2UnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBbX3dyaXRlXShidWYpIHtcbiAgICAgICAgLy8gdGhyb3cgdGhlIG9yaWdpbmFsLCBidXQgdHJ5IHRvIGNsb3NlIGlmIGl0IGZhaWxzXG4gICAgICAgIGxldCB0aHJldyA9IHRydWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzW19vbndyaXRlXShudWxsLCBmcy53cml0ZVN5bmModGhpc1tfZmRdLCBidWYsIDAsIGJ1Zi5sZW5ndGgsIHRoaXNbX3Bvc10pKTtcbiAgICAgICAgICAgIHRocmV3ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBpZiAodGhyZXcpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW19jbG9zZV0oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgICAgICAgICAvLyBvayBlcnJvclxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@isaacs/fs-minipass/dist/esm/index.js\n");

/***/ })

};
;