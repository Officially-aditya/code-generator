"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@dmitryrechkin";
exports.ids = ["vendor-chunks/@dmitryrechkin"];
exports.modules = {

/***/ "(rsc)/./node_modules/@dmitryrechkin/json-schema-to-zod/dist/JSONSchemaToZod.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@dmitryrechkin/json-schema-to-zod/dist/JSONSchemaToZod.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JSONSchemaToZod: () => (/* binding */ JSONSchemaToZod)\n/* harmony export */ });\n/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/v3/ZodError.js\");\n/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/v3/types.js\");\n/* harmony import */ var _Type_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Type.js */ \"(rsc)/./node_modules/@dmitryrechkin/json-schema-to-zod/dist/Type.js\");\n\n\nclass JSONSchemaToZod {\n    /**\n     * Converts a JSON schema to a Zod schema.\n     *\n     * @param {JSONSchema} schema - The JSON schema.\n     * @returns {ZodSchema} - The Zod schema.\n     */\n    static convert(schema) {\n        return this.parseSchema(schema);\n    }\n    /**\n     * Checks if data matches a condition schema.\n     *\n     * @param {JSONValue} data - The data to check.\n     * @param {JSONSchema} condition - The condition schema.\n     * @returns {boolean} - Whether the data matches the condition.\n     */\n    static matchesCondition(data, condition) {\n        // If no properties to check, condition is met\n        if (!condition.properties) {\n            return true;\n        }\n        // If data is not an object or is null, it can't match a schema with properties\n        if (typeof data !== 'object' || data === null || Array.isArray(data)) {\n            return false;\n        }\n        // Now we know data is a JSONObject\n        const objectData = data;\n        // Check all property conditions\n        for (const [key, propCondition] of Object.entries(condition.properties)) {\n            // If property doesn't exist in data\n            if (!(key in objectData)) {\n                // If there's a const condition and property is missing, it doesn't match\n                if ('const' in propCondition) {\n                    return false;\n                }\n                // For other conditions, skip this property\n                continue;\n            }\n            const value = objectData[key];\n            // Check for const condition\n            if ('const' in propCondition && value !== propCondition['const']) {\n                return false;\n            }\n            // Check for minimum condition\n            if ('minimum' in propCondition && typeof value === 'number' && value < propCondition['minimum']) {\n                return false;\n            }\n            // Check for maximum condition\n            if ('maximum' in propCondition && typeof value === 'number' && value > propCondition['maximum']) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Validates data against a conditional schema and adds issues to context if validation fails.\n     *\n     * @param {JSONValue} data - The data to validate.\n     * @param {JSONSchema} schema - The conditional schema.\n     * @param {z.RefinementCtx} ctx - The Zod refinement context.\n     */\n    static validateConditionalSchema(data, schema, ctx) {\n        this.validateRequiredProperties(data, schema, ctx);\n        this.validatePropertyPatterns(data, schema, ctx);\n        this.validateNestedConditions(data, schema, ctx);\n    }\n    /**\n     * Validates that all required properties are present in the data.\n     *\n     * @param {JSONValue} data - The data to validate.\n     * @param {JSONSchema} schema - The schema containing required properties.\n     * @param {z.RefinementCtx} ctx - The Zod refinement context.\n     */\n    static validateRequiredProperties(data, schema, ctx) {\n        if (!schema.required) {\n            return;\n        }\n        // If data is not an object or is null, all required properties are missing\n        if (typeof data !== 'object' || data === null) {\n            for (const requiredProp of schema.required) {\n                ctx.addIssue({\n                    code: zod__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.custom,\n                    message: `Required property '${requiredProp}' is missing`,\n                    path: [requiredProp]\n                });\n            }\n            return;\n        }\n        // Now we know data is an object (either a plain object or an array)\n        for (const requiredProp of schema.required) {\n            if (!(requiredProp in data)) {\n                ctx.addIssue({\n                    code: zod__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.custom,\n                    message: `Required property '${requiredProp}' is missing`,\n                    path: [requiredProp]\n                });\n            }\n        }\n    }\n    /**\n     * Validates property patterns for string properties.\n     *\n     * @param {JSONValue} data - The data to validate.\n     * @param {JSONSchema} schema - The schema containing property patterns.\n     * @param {z.RefinementCtx} ctx - The Zod refinement context.\n     */\n    static validatePropertyPatterns(data, schema, ctx) {\n        if (!schema.properties) {\n            return;\n        }\n        // If data is not an object or is null, we can't validate property patterns\n        if (typeof data !== 'object' || data === null) {\n            return;\n        }\n        // If data is an array, we can't validate property patterns\n        if (Array.isArray(data)) {\n            return;\n        }\n        // Now we know data is a JSONObject\n        const objectData = data;\n        // Process each property in the schema\n        for (const [key, propSchema] of Object.entries(schema.properties)) {\n            // Skip if property doesn't exist in data\n            if (!(key in objectData)) {\n                continue;\n            }\n            const value = objectData[key];\n            // Check pattern validation for strings\n            if (propSchema['pattern'] && typeof value === 'string') {\n                const regex = new RegExp(propSchema['pattern']);\n                if (!regex.test(value)) {\n                    ctx.addIssue({\n                        code: zod__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.custom,\n                        message: `String '${value}' does not match pattern '${propSchema['pattern']}'`,\n                        path: [key]\n                    });\n                }\n            }\n        }\n    }\n    /**\n     * Validates nested if-then-else conditions.\n     *\n     * @param {JSONValue} data - The data to validate.\n     * @param {JSONSchema} schema - The schema containing if-then-else conditions.\n     * @param {z.RefinementCtx} ctx - The Zod refinement context.\n     */\n    static validateNestedConditions(data, schema, ctx) {\n        if (!schema['if'] || !schema['then']) {\n            return;\n        }\n        const matchesIf = this.matchesCondition(data, schema['if']);\n        if (matchesIf) {\n            this.validateConditionalSchema(data, schema['then'], ctx);\n        }\n        else if (schema['else']) {\n            this.validateConditionalSchema(data, schema['else'], ctx);\n        }\n    }\n    /**\n     * Parses a JSON schema and returns the corresponding Zod schema.\n     * This is the main entry point for schema conversion.\n     *\n     * @param {JSONSchema} schema - The JSON schema.\n     * @returns {ZodTypeAny} - The ZodTypeAny schema.\n     */\n    static parseSchema(schema) {\n        // Handle array of types (e.g., ['string', 'null'] for nullable types)\n        if (Array.isArray(schema.type)) {\n            return this.handleTypeArray(schema);\n        }\n        // Handle combinators (oneOf, anyOf, allOf)\n        if (schema.oneOf || schema.anyOf || schema.allOf) {\n            return this.parseCombinator(schema);\n        }\n        // Handle if-then-else conditional validation\n        if (schema['if'] && schema['then']) {\n            return this.parseObject(schema);\n        }\n        // Handle object schema without explicit type but with properties\n        if (schema.properties && (!schema.type || schema.type === 'object')) {\n            return this.parseObject(schema);\n        }\n        // Handle all other types\n        return this.handleSingleType(schema);\n    }\n    /**\n     * Handles schemas with an array of types.\n     *\n     * @param {JSONSchema} schema - The JSON schema with type array.\n     * @returns {ZodTypeAny} - The ZodTypeAny schema.\n     */\n    static handleTypeArray(schema) {\n        if (!Array.isArray(schema.type)) {\n            throw new Error('Expected schema.type to be an array');\n        }\n        // Check if the type array includes 'null' to create a nullable type\n        if (schema.type.includes('null')) {\n            return this.handleNullableType(schema);\n        }\n        // If no 'null' in the type array, handle as a union of types\n        return this.createUnionFromTypes(schema.type, schema);\n    }\n    /**\n     * Handles nullable types by creating a nullable schema.\n     *\n     * @param {JSONSchema} schema - The JSON schema with nullable type.\n     * @returns {ZodTypeAny} - The nullable Zod schema.\n     */\n    static handleNullableType(schema) {\n        if (!Array.isArray(schema.type)) {\n            throw new Error('Expected schema.type to be an array');\n        }\n        // Create a copy of the schema without the 'null' type\n        const nonNullSchema = { ...schema };\n        nonNullSchema.type = schema.type.filter(t => t !== 'null');\n        // If there's only one type left, handle it as a single type and make it nullable\n        if (nonNullSchema.type.length === 1) {\n            const singleTypeSchema = this.handleSingleType({ ...schema, type: nonNullSchema.type[0] });\n            return singleTypeSchema.nullable();\n        }\n        // If multiple non-null types, create a union and make it nullable\n        const unionSchema = this.parseSchema(nonNullSchema);\n        return unionSchema.nullable();\n    }\n    /**\n     * Creates a union type from an array of types.\n     *\n     * @param {string[]} types - Array of type strings.\n     * @param {JSONSchema} baseSchema - The base schema to apply to each type.\n     * @returns {ZodTypeAny} - The union Zod schema.\n     */\n    static createUnionFromTypes(types, baseSchema) {\n        const schemas = types.map(type => {\n            const singleTypeSchema = { ...baseSchema, type };\n            return this.parseSchema(singleTypeSchema);\n        });\n        return zod__WEBPACK_IMPORTED_MODULE_2__.union(schemas);\n    }\n    /**\n     * Handles schemas with a single type.\n     *\n     * @param {JSONSchema} schema - The JSON schema with single type.\n     * @returns {ZodTypeAny} - The ZodTypeAny schema.\n     */\n    static handleSingleType(schema) {\n        // Handle schemas without a type property\n        if (schema.type === undefined) {\n            // Check for combinators first\n            if (schema.oneOf || schema.anyOf || schema.allOf) {\n                return this.parseCombinator(schema);\n            }\n            // Check for object properties\n            if (schema.properties) {\n                return this.parseObject(schema);\n            }\n            // Default to any() for schemas with no type and no other indicators\n            return zod__WEBPACK_IMPORTED_MODULE_2__.any();\n        }\n        // Handle specific types\n        switch (schema.type) {\n            case 'string': return this.parseString(schema);\n            case 'number':\n            case 'integer': return this.parseNumberSchema(schema);\n            case 'boolean': return zod__WEBPACK_IMPORTED_MODULE_2__.boolean();\n            case 'array': return this.parseArray(schema);\n            case 'object': return this.parseObject(schema);\n            default: throw new Error('Unsupported schema type');\n        }\n    }\n    /**\n     * Parses a number schema.\n     *\n     * @param {JSONSchema} schema - The JSON schema for a number.\n     * @returns {ZodTypeAny} - The ZodTypeAny schema.\n     */\n    static parseNumberSchema(schema) {\n        let numberSchema = zod__WEBPACK_IMPORTED_MODULE_2__.number();\n        // Apply all number validations\n        let result = numberSchema;\n        result = this.applyNumberBounds(numberSchema, schema);\n        result = this.applyNumberMultipleOf(numberSchema, schema);\n        result = this.applyNumberEnum(numberSchema, schema);\n        result = this.applyIntegerConstraint(numberSchema, schema);\n        return result;\n    }\n    /**\n     * Applies bounds validation to a number schema.\n     *\n     * @param {z.ZodNumber} numberSchema - The base number schema.\n     * @param {JSONSchema} schema - The JSON schema with bounds.\n     * @returns {z.ZodNumber} - The updated schema with bounds validation.\n     */\n    static applyNumberBounds(numberSchema, schema) {\n        let result = numberSchema;\n        if (schema['minimum'] !== undefined) {\n            result = schema['exclusiveMinimum'] ?\n                result.gt(schema['minimum']) :\n                result.gte(schema['minimum']);\n        }\n        if (schema['maximum'] !== undefined) {\n            result = schema['exclusiveMaximum'] ?\n                result.lt(schema['maximum']) :\n                result.lte(schema['maximum']);\n        }\n        return result;\n    }\n    /**\n     * Applies multipleOf validation to a number schema.\n     *\n     * @param {z.ZodNumber} numberSchema - The base number schema.\n     * @param {JSONSchema} schema - The JSON schema with multipleOf.\n     * @returns {z.ZodNumber} - The updated schema with multipleOf validation.\n     */\n    static applyNumberMultipleOf(numberSchema, schema) {\n        if (schema['multipleOf'] === undefined) {\n            return numberSchema;\n        }\n        return numberSchema.refine(val => val % schema['multipleOf'] === 0, { message: `Number must be a multiple of ${schema['multipleOf']}` });\n    }\n    /**\n     * Applies enum validation to a number schema.\n     *\n     * @param {z.ZodNumber} numberSchema - The base number schema.\n     * @param {JSONSchema} schema - The JSON schema with enum.\n     * @returns {z.ZodNumber} - The updated schema with enum validation.\n     */\n    static applyNumberEnum(numberSchema, schema) {\n        if (!schema.enum) {\n            return numberSchema;\n        }\n        // Filter out non-number values from enum\n        const numberEnums = schema.enum.filter(val => typeof val === 'number');\n        if (numberEnums.length === 0) {\n            return numberSchema;\n        }\n        // Use refinement to validate against enum values\n        return numberSchema.refine(val => numberEnums.includes(val), { message: `Number must be one of: ${numberEnums.join(', ')}` });\n    }\n    /**\n     * Applies integer constraint to a number schema if needed.\n     *\n     * @param {z.ZodNumber} numberSchema - The base number schema.\n     * @param {JSONSchema} schema - The JSON schema.\n     * @returns {z.ZodNumber} - The updated schema with integer validation if needed.\n     */\n    static applyIntegerConstraint(numberSchema, schema) {\n        if (schema.type !== 'integer') {\n            return numberSchema;\n        }\n        return numberSchema.refine(val => Number.isInteger(val), { message: 'Number must be an integer' });\n    }\n    /**\n     * Parses a string schema.\n     *\n     * @param {JSONSchema} schema - The JSON schema for a string.\n     * @returns {ZodTypeAny} - The ZodTypeAny schema.\n     */\n    static parseString(schema) {\n        let stringSchema = zod__WEBPACK_IMPORTED_MODULE_2__.string();\n        let result = stringSchema;\n        // Apply all string validations\n        if (schema.format) {\n            // Handle format-specific string validation\n            return this.applyStringFormat(stringSchema, schema);\n        }\n        else {\n            // Only apply other validations if format is not specified\n            // or apply them to the formatted string\n            result = this.applyStringPattern(stringSchema, schema);\n            result = this.applyStringLength(stringSchema, schema);\n            result = this.applyStringEnum(stringSchema, schema);\n        }\n        return result;\n    }\n    /**\n     * Applies format validation to a string schema.\n     *\n     * @param {z.ZodString} stringSchema - The base string schema.\n     * @param {JSONSchema} schema - The JSON schema with format.\n     * @returns {ZodTypeAny} - The updated schema with format validation.\n     */\n    static applyStringFormat(stringSchema, schema) {\n        if (!schema.format) {\n            return stringSchema;\n        }\n        switch (schema.format) {\n            case 'email':\n                return stringSchema.email();\n            case 'date-time':\n                return stringSchema.datetime();\n            case 'uri':\n                return stringSchema.url();\n            case 'uuid':\n                return stringSchema.uuid();\n            case 'date':\n                return stringSchema.date();\n            default:\n                return stringSchema;\n        }\n    }\n    /**\n     * Applies pattern validation to a string schema.\n     *\n     * @param {z.ZodString} stringSchema - The base string schema.\n     * @param {JSONSchema} schema - The JSON schema with pattern.\n     * @returns {z.ZodString} - The updated schema with pattern validation.\n     */\n    static applyStringPattern(stringSchema, schema) {\n        if (!schema['pattern']) {\n            return stringSchema;\n        }\n        const regex = new RegExp(schema['pattern']);\n        return stringSchema.regex(regex, { message: `String must match pattern: ${schema['pattern']}` });\n    }\n    /**\n     * Applies length constraints to a string schema.\n     *\n     * @param {z.ZodString} stringSchema - The base string schema.\n     * @param {JSONSchema} schema - The JSON schema with length constraints.\n     * @returns {z.ZodString} - The updated schema with length validation.\n     */\n    static applyStringLength(stringSchema, schema) {\n        let result = stringSchema;\n        if (schema['minLength'] !== undefined) {\n            stringSchema = stringSchema.min(schema['minLength']);\n        }\n        if (schema['maxLength'] !== undefined) {\n            stringSchema = stringSchema.max(schema['maxLength']);\n        }\n        return result;\n    }\n    /**\n     * Applies enum validation to a string schema.\n     *\n     * @param {z.ZodString} stringSchema - The base string schema.\n     * @param {JSONSchema} schema - The JSON schema with enum.\n     * @returns {ZodTypeAny} - The updated schema with enum validation.\n     */\n    static applyStringEnum(stringSchema, schema) {\n        if (!schema.enum) {\n            return stringSchema;\n        }\n        // Use refinement to validate against enum values\n        return stringSchema.refine((val) => schema.enum?.includes(val), {\n            message: `Value must be one of: ${schema.enum?.join(', ')}`\n        });\n    }\n    /**\n     * Parses a JSON schema of type array and returns the corresponding Zod schema.\n     *\n     * @param {JSONSchema} schema - The JSON schema.\n     * @returns {ZodTypeAny} - The ZodTypeAny schema.\n     */\n    static parseArray(schema) {\n        // Handle tuple validation (items is an array)\n        if (Array.isArray(schema.items)) {\n            const tupleSchemas = schema.items.map(item => this.parseSchema(item));\n            return zod__WEBPACK_IMPORTED_MODULE_2__.union(tupleSchemas);\n        }\n        // Create regular array schema\n        const itemSchema = schema.items ? this.parseSchema(schema.items) : zod__WEBPACK_IMPORTED_MODULE_2__.any();\n        let arraySchema = zod__WEBPACK_IMPORTED_MODULE_2__.array(itemSchema);\n        // Apply array constraints\n        let result = arraySchema;\n        result = this.applyArrayConstraints(arraySchema, schema);\n        return result;\n    }\n    /**\n     * Applies constraints to an array schema.\n     *\n     * @param {z.ZodArray<any>} arraySchema - The base array schema.\n     * @param {JSONSchema} schema - The JSON schema with array constraints.\n     * @returns {z.ZodTypeAny} - The updated array schema with constraints.\n     */\n    static applyArrayConstraints(arraySchema, schema) {\n        // Handle minItems\n        if (schema['minItems'] !== undefined) {\n            arraySchema = arraySchema.min(schema['minItems']);\n        }\n        // Handle maxItems\n        if (schema['maxItems'] !== undefined) {\n            arraySchema = arraySchema.max(schema['maxItems']);\n        }\n        // Handle uniqueItems\n        if (schema['uniqueItems']) {\n            return arraySchema.refine((items) => new Set(items).size === items.length, { message: 'Array items must be unique' });\n        }\n        return arraySchema;\n    }\n    /**\n     * Parses an object schema.\n     *\n     * @param {JSONSchema} schema - The JSON schema for an object.\n     * @returns {ZodTypeAny} - The ZodTypeAny schema.\n     */\n    static parseObject(schema) {\n        // Handle conditional validation (if-then-else) first\n        if (schema['if'] && schema['then']) {\n            return this.parseConditional(schema);\n        }\n        // Create shape object for Zod\n        const shape = {};\n        // Process properties\n        this.processObjectProperties(schema, shape);\n        // Create the object schema and handle additionalProperties\n        return this.processAdditionalProperties(schema, zod__WEBPACK_IMPORTED_MODULE_2__.object(shape));\n    }\n    /**\n     * Processes object properties and builds the shape object.\n     *\n     * @param {JSONSchema} schema - The JSON schema for an object.\n     * @param {Record<string, ZodTypeAny>} shape - The shape object to populate.\n     */\n    static processObjectProperties(schema, shape) {\n        const required = new Set(schema.required || []);\n        if (!schema.properties) {\n            return;\n        }\n        for (const [key, propSchema] of Object.entries(schema.properties)) {\n            const zodSchema = this.parseSchema(propSchema);\n            shape[key] = required.has(key) ? zodSchema : zodSchema.optional();\n        }\n    }\n    /**\n     * Processes additionalProperties configuration.\n     *\n     * @param {JSONSchema} schema - The JSON schema for an object.\n     * @param {z.ZodObject<any, any>} objectSchema - The Zod object schema.\n     * @returns {z.ZodObject<any, any>} - The updated Zod object schema.\n     */\n    static processAdditionalProperties(schema, objectSchema) {\n        if (schema.additionalProperties === true) {\n            return objectSchema.passthrough();\n        }\n        else if (schema.additionalProperties && typeof schema.additionalProperties === 'object') {\n            // Handle schema for additional properties\n            const additionalPropSchema = this.parseSchema(schema.additionalProperties);\n            return objectSchema.catchall(additionalPropSchema);\n        }\n        else {\n            return objectSchema.strict();\n        }\n    }\n    /**\n     * Parses a conditional schema with if-then-else.\n     *\n     * @param {JSONSchema} schema - The JSON schema with conditional validation.\n     * @returns {ZodTypeAny} - The conditional Zod schema.\n     */\n    static parseConditional(schema) {\n        // Create base object schema\n        const zodObject = this.createBaseObjectSchema(schema);\n        // Extract conditional parts\n        const ifCondition = schema['if'];\n        const thenSchema = schema['then'];\n        const elseSchema = schema['else'];\n        // Apply conditional validation using superRefine\n        return zodObject.superRefine((data, ctx) => {\n            // Apply default values to data for condition checking\n            const dataWithDefaults = this.applyDefaultValues(data, schema);\n            // Apply appropriate validation based on condition\n            if (this.matchesCondition(dataWithDefaults, ifCondition)) {\n                this.validateConditionalSchema(dataWithDefaults, thenSchema, ctx);\n            }\n            else if (elseSchema) {\n                this.validateConditionalSchema(dataWithDefaults, elseSchema, ctx);\n            }\n        });\n    }\n    /**\n     * Creates a base object schema from the given JSON schema.\n     *\n     * @param {JSONSchema} schema - The JSON schema.\n     * @returns {z.ZodObject<any, any>} - The base Zod object schema.\n     */\n    static createBaseObjectSchema(schema) {\n        const shape = {};\n        const required = new Set(schema.required || []);\n        for (const [key, value] of Object.entries(schema.properties || {})) {\n            const zodSchema = this.parseSchema(value);\n            shape[key] = required.has(key) ? zodSchema : zodSchema.optional();\n        }\n        const zodObject = zod__WEBPACK_IMPORTED_MODULE_2__.object(shape);\n        return this.processAdditionalProperties(schema, zodObject);\n    }\n    /**\n     * Applies default values from schema properties to data object.\n     *\n     * @param {JSONValue} data - The original data object.\n     * @param {JSONSchema} schema - The schema with default values.\n     * @returns {JSONValue} - The data object with defaults applied.\n     */\n    static applyDefaultValues(data, schema) {\n        // If data is not an object or is null, we can't apply defaults\n        if (typeof data !== 'object' || data === null) {\n            return data;\n        }\n        // If data is an array, we can't apply defaults from schema properties\n        if (Array.isArray(data)) {\n            return data;\n        }\n        // Now we know data is a JSONObject\n        const objectData = data;\n        const dataWithDefaults = { ...objectData };\n        if (!schema.properties) {\n            return dataWithDefaults;\n        }\n        for (const [key, propSchema] of Object.entries(schema.properties)) {\n            if (!(key in dataWithDefaults) && 'default' in propSchema) {\n                dataWithDefaults[key] = propSchema['default'];\n            }\n        }\n        return dataWithDefaults;\n    }\n    /**\n     * Parses a schema with combinators (oneOf, anyOf, allOf).\n     * Delegates to the appropriate combinator parser based on which combinator is present.\n     *\n     * @param {JSONSchema} schema - The JSON schema with combinators.\n     * @returns {ZodTypeAny} - The ZodTypeAny schema.\n     */\n    static parseCombinator(schema) {\n        if (schema.oneOf) {\n            return this.parseOneOf(schema.oneOf);\n        }\n        if (schema.anyOf) {\n            return this.parseAnyOf(schema.anyOf);\n        }\n        if (schema.allOf) {\n            return this.parseAllOf(schema.allOf);\n        }\n        // Should not reach here if schema has combinators\n        throw new Error('Unsupported schema type');\n    }\n    /**\n     * Parses a oneOf combinator schema.\n     *\n     * @param {JSONSchema[]} schemas - Array of JSON schemas in the oneOf.\n     * @returns {ZodTypeAny} - The ZodTypeAny schema.\n     */\n    static parseOneOf(schemas) {\n        return this.createUnionFromSchemas(schemas);\n    }\n    /**\n     * Parses an anyOf combinator schema.\n     *\n     * @param {JSONSchema[]} schemas - Array of JSON schemas in the anyOf.\n     * @returns {ZodTypeAny} - The ZodTypeAny schema.\n     */\n    static parseAnyOf(schemas) {\n        return this.createUnionFromSchemas(schemas);\n    }\n    /**\n     * Creates a union from an array of schemas, handling special cases.\n     *\n     * @param {JSONSchema[]} schemas - Array of JSON schemas to create a union from.\n     * @returns {ZodTypeAny} - The union Zod schema.\n     */\n    static createUnionFromSchemas(schemas) {\n        // Handle empty array case\n        if (schemas.length === 0) {\n            return zod__WEBPACK_IMPORTED_MODULE_2__.any();\n        }\n        // Handle single schema case\n        if (schemas.length === 1) {\n            return this.parseSchema(schemas[0]);\n        }\n        // Process each subschema individually\n        const zodSchemas = [];\n        for (const subSchema of schemas) {\n            // Handle null type specially\n            if (subSchema.type === 'null') {\n                zodSchemas.push(zod__WEBPACK_IMPORTED_MODULE_2__[\"null\"]());\n            }\n            else {\n                zodSchemas.push(this.parseSchema(subSchema));\n            }\n        }\n        // Return appropriate schema based on number of valid schemas\n        if (zodSchemas.length >= 2) {\n            return zod__WEBPACK_IMPORTED_MODULE_2__.union(zodSchemas);\n        }\n        else if (zodSchemas.length === 1) {\n            return zodSchemas[0];\n        }\n        // Fallback if no valid schemas were created\n        return zod__WEBPACK_IMPORTED_MODULE_2__.any();\n    }\n    /**\n     * Parses an allOf combinator schema by merging all schemas.\n     *\n     * @param {JSONSchema[]} schemas - Array of JSON schemas in the allOf.\n     * @returns {ZodTypeAny} - The ZodTypeAny schema.\n     */\n    static parseAllOf(schemas) {\n        // Handle empty array case\n        if (schemas.length === 0) {\n            return zod__WEBPACK_IMPORTED_MODULE_2__.any();\n        }\n        // Handle single schema case\n        if (schemas.length === 1) {\n            return this.parseSchema(schemas[0]);\n        }\n        // Merge all schemas together\n        const mergedSchema = schemas.reduce((acc, currentSchema) => this.mergeSchemas(acc, currentSchema));\n        return this.parseSchema(mergedSchema);\n    }\n    /**\n     * Merges two JSON schemas together.\n     *\n     * @param {JSONSchema} baseSchema - The base JSON schema.\n     * @param {JSONSchema} addSchema - The JSON schema to add.\n     * @returns {JSONSchema} - The merged JSON schema\n     */\n    static mergeSchemas(baseSchema, addSchema) {\n        const merged = { ...baseSchema, ...addSchema };\n        if (baseSchema.properties && addSchema.properties) {\n            const mergedProperties = { ...baseSchema.properties, ...addSchema.properties };\n            merged.properties = mergedProperties;\n        }\n        if (baseSchema.required && addSchema.required) {\n            const mergedRequired = [...new Set([...baseSchema.required, ...addSchema.required])];\n            merged.required = mergedRequired;\n        }\n        return merged;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGRtaXRyeXJlY2hraW4vanNvbi1zY2hlbWEtdG8tem9kL2Rpc3QvSlNPTlNjaGVtYVRvWm9kLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBbUM7QUFDUjtBQUNwQjtBQUNQO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixpQkFBaUIsV0FBVztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQixlQUFlLFlBQVk7QUFDM0IsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCLGVBQWUsWUFBWTtBQUMzQixlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUIsZUFBZSxZQUFZO0FBQzNCLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw2Q0FBYztBQUN4QyxtREFBbUQsYUFBYTtBQUNoRTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw2Q0FBYztBQUN4QyxtREFBbUQsYUFBYTtBQUNoRTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUIsZUFBZSxZQUFZO0FBQzNCLGVBQWUsaUJBQWlCO0FBQ2hD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bW9kdWxlcy9AZG1pdHJ5cmVjaGtpbi9qc29uLXNjaGVtYS10by16b2QvZGlzdC9KU09OU2NoZW1hVG9ab2QuanM/MmFmZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB6LCBab2RTY2hlbWEgfSBmcm9tICd6b2QnO1xuaW1wb3J0IHt9IGZyb20gJy4vVHlwZS5qcyc7XG5leHBvcnQgY2xhc3MgSlNPTlNjaGVtYVRvWm9kIHtcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIEpTT04gc2NoZW1hIHRvIGEgWm9kIHNjaGVtYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SlNPTlNjaGVtYX0gc2NoZW1hIC0gVGhlIEpTT04gc2NoZW1hLlxuICAgICAqIEByZXR1cm5zIHtab2RTY2hlbWF9IC0gVGhlIFpvZCBzY2hlbWEuXG4gICAgICovXG4gICAgc3RhdGljIGNvbnZlcnQoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlU2NoZW1hKHNjaGVtYSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBkYXRhIG1hdGNoZXMgYSBjb25kaXRpb24gc2NoZW1hLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtKU09OVmFsdWV9IGRhdGEgLSBUaGUgZGF0YSB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge0pTT05TY2hlbWF9IGNvbmRpdGlvbiAtIFRoZSBjb25kaXRpb24gc2NoZW1hLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSAtIFdoZXRoZXIgdGhlIGRhdGEgbWF0Y2hlcyB0aGUgY29uZGl0aW9uLlxuICAgICAqL1xuICAgIHN0YXRpYyBtYXRjaGVzQ29uZGl0aW9uKGRhdGEsIGNvbmRpdGlvbikge1xuICAgICAgICAvLyBJZiBubyBwcm9wZXJ0aWVzIHRvIGNoZWNrLCBjb25kaXRpb24gaXMgbWV0XG4gICAgICAgIGlmICghY29uZGl0aW9uLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIGRhdGEgaXMgbm90IGFuIG9iamVjdCBvciBpcyBudWxsLCBpdCBjYW4ndCBtYXRjaCBhIHNjaGVtYSB3aXRoIHByb3BlcnRpZXNcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhICE9PSAnb2JqZWN0JyB8fCBkYXRhID09PSBudWxsIHx8IEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3cgd2Uga25vdyBkYXRhIGlzIGEgSlNPTk9iamVjdFxuICAgICAgICBjb25zdCBvYmplY3REYXRhID0gZGF0YTtcbiAgICAgICAgLy8gQ2hlY2sgYWxsIHByb3BlcnR5IGNvbmRpdGlvbnNcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCBwcm9wQ29uZGl0aW9uXSBvZiBPYmplY3QuZW50cmllcyhjb25kaXRpb24ucHJvcGVydGllcykpIHtcbiAgICAgICAgICAgIC8vIElmIHByb3BlcnR5IGRvZXNuJ3QgZXhpc3QgaW4gZGF0YVxuICAgICAgICAgICAgaWYgKCEoa2V5IGluIG9iamVjdERhdGEpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBhIGNvbnN0IGNvbmRpdGlvbiBhbmQgcHJvcGVydHkgaXMgbWlzc2luZywgaXQgZG9lc24ndCBtYXRjaFxuICAgICAgICAgICAgICAgIGlmICgnY29uc3QnIGluIHByb3BDb25kaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBGb3Igb3RoZXIgY29uZGl0aW9ucywgc2tpcCB0aGlzIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG9iamVjdERhdGFba2V5XTtcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBjb25zdCBjb25kaXRpb25cbiAgICAgICAgICAgIGlmICgnY29uc3QnIGluIHByb3BDb25kaXRpb24gJiYgdmFsdWUgIT09IHByb3BDb25kaXRpb25bJ2NvbnN0J10pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgbWluaW11bSBjb25kaXRpb25cbiAgICAgICAgICAgIGlmICgnbWluaW11bScgaW4gcHJvcENvbmRpdGlvbiAmJiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIHZhbHVlIDwgcHJvcENvbmRpdGlvblsnbWluaW11bSddKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIG1heGltdW0gY29uZGl0aW9uXG4gICAgICAgICAgICBpZiAoJ21heGltdW0nIGluIHByb3BDb25kaXRpb24gJiYgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiB2YWx1ZSA+IHByb3BDb25kaXRpb25bJ21heGltdW0nXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIGRhdGEgYWdhaW5zdCBhIGNvbmRpdGlvbmFsIHNjaGVtYSBhbmQgYWRkcyBpc3N1ZXMgdG8gY29udGV4dCBpZiB2YWxpZGF0aW9uIGZhaWxzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtKU09OVmFsdWV9IGRhdGEgLSBUaGUgZGF0YSB0byB2YWxpZGF0ZS5cbiAgICAgKiBAcGFyYW0ge0pTT05TY2hlbWF9IHNjaGVtYSAtIFRoZSBjb25kaXRpb25hbCBzY2hlbWEuXG4gICAgICogQHBhcmFtIHt6LlJlZmluZW1lbnRDdHh9IGN0eCAtIFRoZSBab2QgcmVmaW5lbWVudCBjb250ZXh0LlxuICAgICAqL1xuICAgIHN0YXRpYyB2YWxpZGF0ZUNvbmRpdGlvbmFsU2NoZW1hKGRhdGEsIHNjaGVtYSwgY3R4KSB7XG4gICAgICAgIHRoaXMudmFsaWRhdGVSZXF1aXJlZFByb3BlcnRpZXMoZGF0YSwgc2NoZW1hLCBjdHgpO1xuICAgICAgICB0aGlzLnZhbGlkYXRlUHJvcGVydHlQYXR0ZXJucyhkYXRhLCBzY2hlbWEsIGN0eCk7XG4gICAgICAgIHRoaXMudmFsaWRhdGVOZXN0ZWRDb25kaXRpb25zKGRhdGEsIHNjaGVtYSwgY3R4KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIHRoYXQgYWxsIHJlcXVpcmVkIHByb3BlcnRpZXMgYXJlIHByZXNlbnQgaW4gdGhlIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0pTT05WYWx1ZX0gZGF0YSAtIFRoZSBkYXRhIHRvIHZhbGlkYXRlLlxuICAgICAqIEBwYXJhbSB7SlNPTlNjaGVtYX0gc2NoZW1hIC0gVGhlIHNjaGVtYSBjb250YWluaW5nIHJlcXVpcmVkIHByb3BlcnRpZXMuXG4gICAgICogQHBhcmFtIHt6LlJlZmluZW1lbnRDdHh9IGN0eCAtIFRoZSBab2QgcmVmaW5lbWVudCBjb250ZXh0LlxuICAgICAqL1xuICAgIHN0YXRpYyB2YWxpZGF0ZVJlcXVpcmVkUHJvcGVydGllcyhkYXRhLCBzY2hlbWEsIGN0eCkge1xuICAgICAgICBpZiAoIXNjaGVtYS5yZXF1aXJlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIGRhdGEgaXMgbm90IGFuIG9iamVjdCBvciBpcyBudWxsLCBhbGwgcmVxdWlyZWQgcHJvcGVydGllcyBhcmUgbWlzc2luZ1xuICAgICAgICBpZiAodHlwZW9mIGRhdGEgIT09ICdvYmplY3QnIHx8IGRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVxdWlyZWRQcm9wIG9mIHNjaGVtYS5yZXF1aXJlZCkge1xuICAgICAgICAgICAgICAgIGN0eC5hZGRJc3N1ZSh7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IHouWm9kSXNzdWVDb2RlLmN1c3RvbSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYFJlcXVpcmVkIHByb3BlcnR5ICcke3JlcXVpcmVkUHJvcH0nIGlzIG1pc3NpbmdgLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBbcmVxdWlyZWRQcm9wXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdyB3ZSBrbm93IGRhdGEgaXMgYW4gb2JqZWN0IChlaXRoZXIgYSBwbGFpbiBvYmplY3Qgb3IgYW4gYXJyYXkpXG4gICAgICAgIGZvciAoY29uc3QgcmVxdWlyZWRQcm9wIG9mIHNjaGVtYS5yZXF1aXJlZCkge1xuICAgICAgICAgICAgaWYgKCEocmVxdWlyZWRQcm9wIGluIGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgY3R4LmFkZElzc3VlKHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogei5ab2RJc3N1ZUNvZGUuY3VzdG9tLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgUmVxdWlyZWQgcHJvcGVydHkgJyR7cmVxdWlyZWRQcm9wfScgaXMgbWlzc2luZ2AsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IFtyZXF1aXJlZFByb3BdXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIHByb3BlcnR5IHBhdHRlcm5zIGZvciBzdHJpbmcgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SlNPTlZhbHVlfSBkYXRhIC0gVGhlIGRhdGEgdG8gdmFsaWRhdGUuXG4gICAgICogQHBhcmFtIHtKU09OU2NoZW1hfSBzY2hlbWEgLSBUaGUgc2NoZW1hIGNvbnRhaW5pbmcgcHJvcGVydHkgcGF0dGVybnMuXG4gICAgICogQHBhcmFtIHt6LlJlZmluZW1lbnRDdHh9IGN0eCAtIFRoZSBab2QgcmVmaW5lbWVudCBjb250ZXh0LlxuICAgICAqL1xuICAgIHN0YXRpYyB2YWxpZGF0ZVByb3BlcnR5UGF0dGVybnMoZGF0YSwgc2NoZW1hLCBjdHgpIHtcbiAgICAgICAgaWYgKCFzY2hlbWEucHJvcGVydGllcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIGRhdGEgaXMgbm90IGFuIG9iamVjdCBvciBpcyBudWxsLCB3ZSBjYW4ndCB2YWxpZGF0ZSBwcm9wZXJ0eSBwYXR0ZXJuc1xuICAgICAgICBpZiAodHlwZW9mIGRhdGEgIT09ICdvYmplY3QnIHx8IGRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBkYXRhIGlzIGFuIGFycmF5LCB3ZSBjYW4ndCB2YWxpZGF0ZSBwcm9wZXJ0eSBwYXR0ZXJuc1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdyB3ZSBrbm93IGRhdGEgaXMgYSBKU09OT2JqZWN0XG4gICAgICAgIGNvbnN0IG9iamVjdERhdGEgPSBkYXRhO1xuICAgICAgICAvLyBQcm9jZXNzIGVhY2ggcHJvcGVydHkgaW4gdGhlIHNjaGVtYVxuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHByb3BTY2hlbWFdIG9mIE9iamVjdC5lbnRyaWVzKHNjaGVtYS5wcm9wZXJ0aWVzKSkge1xuICAgICAgICAgICAgLy8gU2tpcCBpZiBwcm9wZXJ0eSBkb2Vzbid0IGV4aXN0IGluIGRhdGFcbiAgICAgICAgICAgIGlmICghKGtleSBpbiBvYmplY3REYXRhKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBvYmplY3REYXRhW2tleV07XG4gICAgICAgICAgICAvLyBDaGVjayBwYXR0ZXJuIHZhbGlkYXRpb24gZm9yIHN0cmluZ3NcbiAgICAgICAgICAgIGlmIChwcm9wU2NoZW1hWydwYXR0ZXJuJ10gJiYgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cChwcm9wU2NoZW1hWydwYXR0ZXJuJ10pO1xuICAgICAgICAgICAgICAgIGlmICghcmVnZXgudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmFkZElzc3VlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IHouWm9kSXNzdWVDb2RlLmN1c3RvbSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBTdHJpbmcgJyR7dmFsdWV9JyBkb2VzIG5vdCBtYXRjaCBwYXR0ZXJuICcke3Byb3BTY2hlbWFbJ3BhdHRlcm4nXX0nYCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IFtrZXldXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgbmVzdGVkIGlmLXRoZW4tZWxzZSBjb25kaXRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtKU09OVmFsdWV9IGRhdGEgLSBUaGUgZGF0YSB0byB2YWxpZGF0ZS5cbiAgICAgKiBAcGFyYW0ge0pTT05TY2hlbWF9IHNjaGVtYSAtIFRoZSBzY2hlbWEgY29udGFpbmluZyBpZi10aGVuLWVsc2UgY29uZGl0aW9ucy5cbiAgICAgKiBAcGFyYW0ge3ouUmVmaW5lbWVudEN0eH0gY3R4IC0gVGhlIFpvZCByZWZpbmVtZW50IGNvbnRleHQuXG4gICAgICovXG4gICAgc3RhdGljIHZhbGlkYXRlTmVzdGVkQ29uZGl0aW9ucyhkYXRhLCBzY2hlbWEsIGN0eCkge1xuICAgICAgICBpZiAoIXNjaGVtYVsnaWYnXSB8fCAhc2NoZW1hWyd0aGVuJ10pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtYXRjaGVzSWYgPSB0aGlzLm1hdGNoZXNDb25kaXRpb24oZGF0YSwgc2NoZW1hWydpZiddKTtcbiAgICAgICAgaWYgKG1hdGNoZXNJZikge1xuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZUNvbmRpdGlvbmFsU2NoZW1hKGRhdGEsIHNjaGVtYVsndGhlbiddLCBjdHgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNjaGVtYVsnZWxzZSddKSB7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlQ29uZGl0aW9uYWxTY2hlbWEoZGF0YSwgc2NoZW1hWydlbHNlJ10sIGN0eCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2VzIGEgSlNPTiBzY2hlbWEgYW5kIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgWm9kIHNjaGVtYS5cbiAgICAgKiBUaGlzIGlzIHRoZSBtYWluIGVudHJ5IHBvaW50IGZvciBzY2hlbWEgY29udmVyc2lvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SlNPTlNjaGVtYX0gc2NoZW1hIC0gVGhlIEpTT04gc2NoZW1hLlxuICAgICAqIEByZXR1cm5zIHtab2RUeXBlQW55fSAtIFRoZSBab2RUeXBlQW55IHNjaGVtYS5cbiAgICAgKi9cbiAgICBzdGF0aWMgcGFyc2VTY2hlbWEoc2NoZW1hKSB7XG4gICAgICAgIC8vIEhhbmRsZSBhcnJheSBvZiB0eXBlcyAoZS5nLiwgWydzdHJpbmcnLCAnbnVsbCddIGZvciBudWxsYWJsZSB0eXBlcylcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hLnR5cGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVUeXBlQXJyYXkoc2NoZW1hKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgY29tYmluYXRvcnMgKG9uZU9mLCBhbnlPZiwgYWxsT2YpXG4gICAgICAgIGlmIChzY2hlbWEub25lT2YgfHwgc2NoZW1hLmFueU9mIHx8IHNjaGVtYS5hbGxPZikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VDb21iaW5hdG9yKHNjaGVtYSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIGlmLXRoZW4tZWxzZSBjb25kaXRpb25hbCB2YWxpZGF0aW9uXG4gICAgICAgIGlmIChzY2hlbWFbJ2lmJ10gJiYgc2NoZW1hWyd0aGVuJ10pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlT2JqZWN0KHNjaGVtYSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIG9iamVjdCBzY2hlbWEgd2l0aG91dCBleHBsaWNpdCB0eXBlIGJ1dCB3aXRoIHByb3BlcnRpZXNcbiAgICAgICAgaWYgKHNjaGVtYS5wcm9wZXJ0aWVzICYmICghc2NoZW1hLnR5cGUgfHwgc2NoZW1hLnR5cGUgPT09ICdvYmplY3QnKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPYmplY3Qoc2NoZW1hKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgYWxsIG90aGVyIHR5cGVzXG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVNpbmdsZVR5cGUoc2NoZW1hKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBzY2hlbWFzIHdpdGggYW4gYXJyYXkgb2YgdHlwZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0pTT05TY2hlbWF9IHNjaGVtYSAtIFRoZSBKU09OIHNjaGVtYSB3aXRoIHR5cGUgYXJyYXkuXG4gICAgICogQHJldHVybnMge1pvZFR5cGVBbnl9IC0gVGhlIFpvZFR5cGVBbnkgc2NoZW1hLlxuICAgICAqL1xuICAgIHN0YXRpYyBoYW5kbGVUeXBlQXJyYXkoc2NoZW1hKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzY2hlbWEudHlwZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgc2NoZW1hLnR5cGUgdG8gYmUgYW4gYXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgdHlwZSBhcnJheSBpbmNsdWRlcyAnbnVsbCcgdG8gY3JlYXRlIGEgbnVsbGFibGUgdHlwZVxuICAgICAgICBpZiAoc2NoZW1hLnR5cGUuaW5jbHVkZXMoJ251bGwnKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlTnVsbGFibGVUeXBlKHNjaGVtYSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgbm8gJ251bGwnIGluIHRoZSB0eXBlIGFycmF5LCBoYW5kbGUgYXMgYSB1bmlvbiBvZiB0eXBlc1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVVbmlvbkZyb21UeXBlcyhzY2hlbWEudHlwZSwgc2NoZW1hKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBudWxsYWJsZSB0eXBlcyBieSBjcmVhdGluZyBhIG51bGxhYmxlIHNjaGVtYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SlNPTlNjaGVtYX0gc2NoZW1hIC0gVGhlIEpTT04gc2NoZW1hIHdpdGggbnVsbGFibGUgdHlwZS5cbiAgICAgKiBAcmV0dXJucyB7Wm9kVHlwZUFueX0gLSBUaGUgbnVsbGFibGUgWm9kIHNjaGVtYS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaGFuZGxlTnVsbGFibGVUeXBlKHNjaGVtYSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hLnR5cGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHNjaGVtYS50eXBlIHRvIGJlIGFuIGFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3JlYXRlIGEgY29weSBvZiB0aGUgc2NoZW1hIHdpdGhvdXQgdGhlICdudWxsJyB0eXBlXG4gICAgICAgIGNvbnN0IG5vbk51bGxTY2hlbWEgPSB7IC4uLnNjaGVtYSB9O1xuICAgICAgICBub25OdWxsU2NoZW1hLnR5cGUgPSBzY2hlbWEudHlwZS5maWx0ZXIodCA9PiB0ICE9PSAnbnVsbCcpO1xuICAgICAgICAvLyBJZiB0aGVyZSdzIG9ubHkgb25lIHR5cGUgbGVmdCwgaGFuZGxlIGl0IGFzIGEgc2luZ2xlIHR5cGUgYW5kIG1ha2UgaXQgbnVsbGFibGVcbiAgICAgICAgaWYgKG5vbk51bGxTY2hlbWEudHlwZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IHNpbmdsZVR5cGVTY2hlbWEgPSB0aGlzLmhhbmRsZVNpbmdsZVR5cGUoeyAuLi5zY2hlbWEsIHR5cGU6IG5vbk51bGxTY2hlbWEudHlwZVswXSB9KTtcbiAgICAgICAgICAgIHJldHVybiBzaW5nbGVUeXBlU2NoZW1hLm51bGxhYmxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgbXVsdGlwbGUgbm9uLW51bGwgdHlwZXMsIGNyZWF0ZSBhIHVuaW9uIGFuZCBtYWtlIGl0IG51bGxhYmxlXG4gICAgICAgIGNvbnN0IHVuaW9uU2NoZW1hID0gdGhpcy5wYXJzZVNjaGVtYShub25OdWxsU2NoZW1hKTtcbiAgICAgICAgcmV0dXJuIHVuaW9uU2NoZW1hLm51bGxhYmxlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSB1bmlvbiB0eXBlIGZyb20gYW4gYXJyYXkgb2YgdHlwZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSB0eXBlcyAtIEFycmF5IG9mIHR5cGUgc3RyaW5ncy5cbiAgICAgKiBAcGFyYW0ge0pTT05TY2hlbWF9IGJhc2VTY2hlbWEgLSBUaGUgYmFzZSBzY2hlbWEgdG8gYXBwbHkgdG8gZWFjaCB0eXBlLlxuICAgICAqIEByZXR1cm5zIHtab2RUeXBlQW55fSAtIFRoZSB1bmlvbiBab2Qgc2NoZW1hLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVVbmlvbkZyb21UeXBlcyh0eXBlcywgYmFzZVNjaGVtYSkge1xuICAgICAgICBjb25zdCBzY2hlbWFzID0gdHlwZXMubWFwKHR5cGUgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2luZ2xlVHlwZVNjaGVtYSA9IHsgLi4uYmFzZVNjaGVtYSwgdHlwZSB9O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VTY2hlbWEoc2luZ2xlVHlwZVNjaGVtYSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gei51bmlvbihzY2hlbWFzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBzY2hlbWFzIHdpdGggYSBzaW5nbGUgdHlwZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SlNPTlNjaGVtYX0gc2NoZW1hIC0gVGhlIEpTT04gc2NoZW1hIHdpdGggc2luZ2xlIHR5cGUuXG4gICAgICogQHJldHVybnMge1pvZFR5cGVBbnl9IC0gVGhlIFpvZFR5cGVBbnkgc2NoZW1hLlxuICAgICAqL1xuICAgIHN0YXRpYyBoYW5kbGVTaW5nbGVUeXBlKHNjaGVtYSkge1xuICAgICAgICAvLyBIYW5kbGUgc2NoZW1hcyB3aXRob3V0IGEgdHlwZSBwcm9wZXJ0eVxuICAgICAgICBpZiAoc2NoZW1hLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGNvbWJpbmF0b3JzIGZpcnN0XG4gICAgICAgICAgICBpZiAoc2NoZW1hLm9uZU9mIHx8IHNjaGVtYS5hbnlPZiB8fCBzY2hlbWEuYWxsT2YpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUNvbWJpbmF0b3Ioc2NoZW1hKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBvYmplY3QgcHJvcGVydGllc1xuICAgICAgICAgICAgaWYgKHNjaGVtYS5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPYmplY3Qoc2NoZW1hKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERlZmF1bHQgdG8gYW55KCkgZm9yIHNjaGVtYXMgd2l0aCBubyB0eXBlIGFuZCBubyBvdGhlciBpbmRpY2F0b3JzXG4gICAgICAgICAgICByZXR1cm4gei5hbnkoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgc3BlY2lmaWMgdHlwZXNcbiAgICAgICAgc3dpdGNoIChzY2hlbWEudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzogcmV0dXJuIHRoaXMucGFyc2VTdHJpbmcoc2NoZW1hKTtcbiAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICBjYXNlICdpbnRlZ2VyJzogcmV0dXJuIHRoaXMucGFyc2VOdW1iZXJTY2hlbWEoc2NoZW1hKTtcbiAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOiByZXR1cm4gei5ib29sZWFuKCk7XG4gICAgICAgICAgICBjYXNlICdhcnJheSc6IHJldHVybiB0aGlzLnBhcnNlQXJyYXkoc2NoZW1hKTtcbiAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6IHJldHVybiB0aGlzLnBhcnNlT2JqZWN0KHNjaGVtYSk7XG4gICAgICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHNjaGVtYSB0eXBlJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2VzIGEgbnVtYmVyIHNjaGVtYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SlNPTlNjaGVtYX0gc2NoZW1hIC0gVGhlIEpTT04gc2NoZW1hIGZvciBhIG51bWJlci5cbiAgICAgKiBAcmV0dXJucyB7Wm9kVHlwZUFueX0gLSBUaGUgWm9kVHlwZUFueSBzY2hlbWEuXG4gICAgICovXG4gICAgc3RhdGljIHBhcnNlTnVtYmVyU2NoZW1hKHNjaGVtYSkge1xuICAgICAgICBsZXQgbnVtYmVyU2NoZW1hID0gei5udW1iZXIoKTtcbiAgICAgICAgLy8gQXBwbHkgYWxsIG51bWJlciB2YWxpZGF0aW9uc1xuICAgICAgICBsZXQgcmVzdWx0ID0gbnVtYmVyU2NoZW1hO1xuICAgICAgICByZXN1bHQgPSB0aGlzLmFwcGx5TnVtYmVyQm91bmRzKG51bWJlclNjaGVtYSwgc2NoZW1hKTtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5hcHBseU51bWJlck11bHRpcGxlT2YobnVtYmVyU2NoZW1hLCBzY2hlbWEpO1xuICAgICAgICByZXN1bHQgPSB0aGlzLmFwcGx5TnVtYmVyRW51bShudW1iZXJTY2hlbWEsIHNjaGVtYSk7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuYXBwbHlJbnRlZ2VyQ29uc3RyYWludChudW1iZXJTY2hlbWEsIHNjaGVtYSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgYm91bmRzIHZhbGlkYXRpb24gdG8gYSBudW1iZXIgc2NoZW1hLlxuICAgICAqXG4gICAgICogQHBhcmFtIHt6LlpvZE51bWJlcn0gbnVtYmVyU2NoZW1hIC0gVGhlIGJhc2UgbnVtYmVyIHNjaGVtYS5cbiAgICAgKiBAcGFyYW0ge0pTT05TY2hlbWF9IHNjaGVtYSAtIFRoZSBKU09OIHNjaGVtYSB3aXRoIGJvdW5kcy5cbiAgICAgKiBAcmV0dXJucyB7ei5ab2ROdW1iZXJ9IC0gVGhlIHVwZGF0ZWQgc2NoZW1hIHdpdGggYm91bmRzIHZhbGlkYXRpb24uXG4gICAgICovXG4gICAgc3RhdGljIGFwcGx5TnVtYmVyQm91bmRzKG51bWJlclNjaGVtYSwgc2NoZW1hKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBudW1iZXJTY2hlbWE7XG4gICAgICAgIGlmIChzY2hlbWFbJ21pbmltdW0nXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBzY2hlbWFbJ2V4Y2x1c2l2ZU1pbmltdW0nXSA/XG4gICAgICAgICAgICAgICAgcmVzdWx0Lmd0KHNjaGVtYVsnbWluaW11bSddKSA6XG4gICAgICAgICAgICAgICAgcmVzdWx0Lmd0ZShzY2hlbWFbJ21pbmltdW0nXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjaGVtYVsnbWF4aW11bSddICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHNjaGVtYVsnZXhjbHVzaXZlTWF4aW11bSddID9cbiAgICAgICAgICAgICAgICByZXN1bHQubHQoc2NoZW1hWydtYXhpbXVtJ10pIDpcbiAgICAgICAgICAgICAgICByZXN1bHQubHRlKHNjaGVtYVsnbWF4aW11bSddKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIG11bHRpcGxlT2YgdmFsaWRhdGlvbiB0byBhIG51bWJlciBzY2hlbWEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3ouWm9kTnVtYmVyfSBudW1iZXJTY2hlbWEgLSBUaGUgYmFzZSBudW1iZXIgc2NoZW1hLlxuICAgICAqIEBwYXJhbSB7SlNPTlNjaGVtYX0gc2NoZW1hIC0gVGhlIEpTT04gc2NoZW1hIHdpdGggbXVsdGlwbGVPZi5cbiAgICAgKiBAcmV0dXJucyB7ei5ab2ROdW1iZXJ9IC0gVGhlIHVwZGF0ZWQgc2NoZW1hIHdpdGggbXVsdGlwbGVPZiB2YWxpZGF0aW9uLlxuICAgICAqL1xuICAgIHN0YXRpYyBhcHBseU51bWJlck11bHRpcGxlT2YobnVtYmVyU2NoZW1hLCBzY2hlbWEpIHtcbiAgICAgICAgaWYgKHNjaGVtYVsnbXVsdGlwbGVPZiddID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBudW1iZXJTY2hlbWE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bWJlclNjaGVtYS5yZWZpbmUodmFsID0+IHZhbCAlIHNjaGVtYVsnbXVsdGlwbGVPZiddID09PSAwLCB7IG1lc3NhZ2U6IGBOdW1iZXIgbXVzdCBiZSBhIG11bHRpcGxlIG9mICR7c2NoZW1hWydtdWx0aXBsZU9mJ119YCB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwbGllcyBlbnVtIHZhbGlkYXRpb24gdG8gYSBudW1iZXIgc2NoZW1hLlxuICAgICAqXG4gICAgICogQHBhcmFtIHt6LlpvZE51bWJlcn0gbnVtYmVyU2NoZW1hIC0gVGhlIGJhc2UgbnVtYmVyIHNjaGVtYS5cbiAgICAgKiBAcGFyYW0ge0pTT05TY2hlbWF9IHNjaGVtYSAtIFRoZSBKU09OIHNjaGVtYSB3aXRoIGVudW0uXG4gICAgICogQHJldHVybnMge3ouWm9kTnVtYmVyfSAtIFRoZSB1cGRhdGVkIHNjaGVtYSB3aXRoIGVudW0gdmFsaWRhdGlvbi5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXBwbHlOdW1iZXJFbnVtKG51bWJlclNjaGVtYSwgc2NoZW1hKSB7XG4gICAgICAgIGlmICghc2NoZW1hLmVudW0pIHtcbiAgICAgICAgICAgIHJldHVybiBudW1iZXJTY2hlbWE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmlsdGVyIG91dCBub24tbnVtYmVyIHZhbHVlcyBmcm9tIGVudW1cbiAgICAgICAgY29uc3QgbnVtYmVyRW51bXMgPSBzY2hlbWEuZW51bS5maWx0ZXIodmFsID0+IHR5cGVvZiB2YWwgPT09ICdudW1iZXInKTtcbiAgICAgICAgaWYgKG51bWJlckVudW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlclNjaGVtYTtcbiAgICAgICAgfVxuICAgICAgICAvLyBVc2UgcmVmaW5lbWVudCB0byB2YWxpZGF0ZSBhZ2FpbnN0IGVudW0gdmFsdWVzXG4gICAgICAgIHJldHVybiBudW1iZXJTY2hlbWEucmVmaW5lKHZhbCA9PiBudW1iZXJFbnVtcy5pbmNsdWRlcyh2YWwpLCB7IG1lc3NhZ2U6IGBOdW1iZXIgbXVzdCBiZSBvbmUgb2Y6ICR7bnVtYmVyRW51bXMuam9pbignLCAnKX1gIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGludGVnZXIgY29uc3RyYWludCB0byBhIG51bWJlciBzY2hlbWEgaWYgbmVlZGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHt6LlpvZE51bWJlcn0gbnVtYmVyU2NoZW1hIC0gVGhlIGJhc2UgbnVtYmVyIHNjaGVtYS5cbiAgICAgKiBAcGFyYW0ge0pTT05TY2hlbWF9IHNjaGVtYSAtIFRoZSBKU09OIHNjaGVtYS5cbiAgICAgKiBAcmV0dXJucyB7ei5ab2ROdW1iZXJ9IC0gVGhlIHVwZGF0ZWQgc2NoZW1hIHdpdGggaW50ZWdlciB2YWxpZGF0aW9uIGlmIG5lZWRlZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXBwbHlJbnRlZ2VyQ29uc3RyYWludChudW1iZXJTY2hlbWEsIHNjaGVtYSkge1xuICAgICAgICBpZiAoc2NoZW1hLnR5cGUgIT09ICdpbnRlZ2VyJykge1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlclNjaGVtYTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVtYmVyU2NoZW1hLnJlZmluZSh2YWwgPT4gTnVtYmVyLmlzSW50ZWdlcih2YWwpLCB7IG1lc3NhZ2U6ICdOdW1iZXIgbXVzdCBiZSBhbiBpbnRlZ2VyJyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2VzIGEgc3RyaW5nIHNjaGVtYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SlNPTlNjaGVtYX0gc2NoZW1hIC0gVGhlIEpTT04gc2NoZW1hIGZvciBhIHN0cmluZy5cbiAgICAgKiBAcmV0dXJucyB7Wm9kVHlwZUFueX0gLSBUaGUgWm9kVHlwZUFueSBzY2hlbWEuXG4gICAgICovXG4gICAgc3RhdGljIHBhcnNlU3RyaW5nKHNjaGVtYSkge1xuICAgICAgICBsZXQgc3RyaW5nU2NoZW1hID0gei5zdHJpbmcoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHN0cmluZ1NjaGVtYTtcbiAgICAgICAgLy8gQXBwbHkgYWxsIHN0cmluZyB2YWxpZGF0aW9uc1xuICAgICAgICBpZiAoc2NoZW1hLmZvcm1hdCkge1xuICAgICAgICAgICAgLy8gSGFuZGxlIGZvcm1hdC1zcGVjaWZpYyBzdHJpbmcgdmFsaWRhdGlvblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHlTdHJpbmdGb3JtYXQoc3RyaW5nU2NoZW1hLCBzY2hlbWEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gT25seSBhcHBseSBvdGhlciB2YWxpZGF0aW9ucyBpZiBmb3JtYXQgaXMgbm90IHNwZWNpZmllZFxuICAgICAgICAgICAgLy8gb3IgYXBwbHkgdGhlbSB0byB0aGUgZm9ybWF0dGVkIHN0cmluZ1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5hcHBseVN0cmluZ1BhdHRlcm4oc3RyaW5nU2NoZW1hLCBzY2hlbWEpO1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5hcHBseVN0cmluZ0xlbmd0aChzdHJpbmdTY2hlbWEsIHNjaGVtYSk7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLmFwcGx5U3RyaW5nRW51bShzdHJpbmdTY2hlbWEsIHNjaGVtYSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwbGllcyBmb3JtYXQgdmFsaWRhdGlvbiB0byBhIHN0cmluZyBzY2hlbWEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3ouWm9kU3RyaW5nfSBzdHJpbmdTY2hlbWEgLSBUaGUgYmFzZSBzdHJpbmcgc2NoZW1hLlxuICAgICAqIEBwYXJhbSB7SlNPTlNjaGVtYX0gc2NoZW1hIC0gVGhlIEpTT04gc2NoZW1hIHdpdGggZm9ybWF0LlxuICAgICAqIEByZXR1cm5zIHtab2RUeXBlQW55fSAtIFRoZSB1cGRhdGVkIHNjaGVtYSB3aXRoIGZvcm1hdCB2YWxpZGF0aW9uLlxuICAgICAqL1xuICAgIHN0YXRpYyBhcHBseVN0cmluZ0Zvcm1hdChzdHJpbmdTY2hlbWEsIHNjaGVtYSkge1xuICAgICAgICBpZiAoIXNjaGVtYS5mb3JtYXQpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmdTY2hlbWE7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChzY2hlbWEuZm9ybWF0KSB7XG4gICAgICAgICAgICBjYXNlICdlbWFpbCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ1NjaGVtYS5lbWFpbCgpO1xuICAgICAgICAgICAgY2FzZSAnZGF0ZS10aW1lJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nU2NoZW1hLmRhdGV0aW1lKCk7XG4gICAgICAgICAgICBjYXNlICd1cmknOlxuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdTY2hlbWEudXJsKCk7XG4gICAgICAgICAgICBjYXNlICd1dWlkJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nU2NoZW1hLnV1aWQoKTtcbiAgICAgICAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdTY2hlbWEuZGF0ZSgpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nU2NoZW1hO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgcGF0dGVybiB2YWxpZGF0aW9uIHRvIGEgc3RyaW5nIHNjaGVtYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ei5ab2RTdHJpbmd9IHN0cmluZ1NjaGVtYSAtIFRoZSBiYXNlIHN0cmluZyBzY2hlbWEuXG4gICAgICogQHBhcmFtIHtKU09OU2NoZW1hfSBzY2hlbWEgLSBUaGUgSlNPTiBzY2hlbWEgd2l0aCBwYXR0ZXJuLlxuICAgICAqIEByZXR1cm5zIHt6LlpvZFN0cmluZ30gLSBUaGUgdXBkYXRlZCBzY2hlbWEgd2l0aCBwYXR0ZXJuIHZhbGlkYXRpb24uXG4gICAgICovXG4gICAgc3RhdGljIGFwcGx5U3RyaW5nUGF0dGVybihzdHJpbmdTY2hlbWEsIHNjaGVtYSkge1xuICAgICAgICBpZiAoIXNjaGVtYVsncGF0dGVybiddKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nU2NoZW1hO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cChzY2hlbWFbJ3BhdHRlcm4nXSk7XG4gICAgICAgIHJldHVybiBzdHJpbmdTY2hlbWEucmVnZXgocmVnZXgsIHsgbWVzc2FnZTogYFN0cmluZyBtdXN0IG1hdGNoIHBhdHRlcm46ICR7c2NoZW1hWydwYXR0ZXJuJ119YCB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwbGllcyBsZW5ndGggY29uc3RyYWludHMgdG8gYSBzdHJpbmcgc2NoZW1hLlxuICAgICAqXG4gICAgICogQHBhcmFtIHt6LlpvZFN0cmluZ30gc3RyaW5nU2NoZW1hIC0gVGhlIGJhc2Ugc3RyaW5nIHNjaGVtYS5cbiAgICAgKiBAcGFyYW0ge0pTT05TY2hlbWF9IHNjaGVtYSAtIFRoZSBKU09OIHNjaGVtYSB3aXRoIGxlbmd0aCBjb25zdHJhaW50cy5cbiAgICAgKiBAcmV0dXJucyB7ei5ab2RTdHJpbmd9IC0gVGhlIHVwZGF0ZWQgc2NoZW1hIHdpdGggbGVuZ3RoIHZhbGlkYXRpb24uXG4gICAgICovXG4gICAgc3RhdGljIGFwcGx5U3RyaW5nTGVuZ3RoKHN0cmluZ1NjaGVtYSwgc2NoZW1hKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBzdHJpbmdTY2hlbWE7XG4gICAgICAgIGlmIChzY2hlbWFbJ21pbkxlbmd0aCddICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN0cmluZ1NjaGVtYSA9IHN0cmluZ1NjaGVtYS5taW4oc2NoZW1hWydtaW5MZW5ndGgnXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjaGVtYVsnbWF4TGVuZ3RoJ10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3RyaW5nU2NoZW1hID0gc3RyaW5nU2NoZW1hLm1heChzY2hlbWFbJ21heExlbmd0aCddKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGVudW0gdmFsaWRhdGlvbiB0byBhIHN0cmluZyBzY2hlbWEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3ouWm9kU3RyaW5nfSBzdHJpbmdTY2hlbWEgLSBUaGUgYmFzZSBzdHJpbmcgc2NoZW1hLlxuICAgICAqIEBwYXJhbSB7SlNPTlNjaGVtYX0gc2NoZW1hIC0gVGhlIEpTT04gc2NoZW1hIHdpdGggZW51bS5cbiAgICAgKiBAcmV0dXJucyB7Wm9kVHlwZUFueX0gLSBUaGUgdXBkYXRlZCBzY2hlbWEgd2l0aCBlbnVtIHZhbGlkYXRpb24uXG4gICAgICovXG4gICAgc3RhdGljIGFwcGx5U3RyaW5nRW51bShzdHJpbmdTY2hlbWEsIHNjaGVtYSkge1xuICAgICAgICBpZiAoIXNjaGVtYS5lbnVtKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nU2NoZW1hO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVzZSByZWZpbmVtZW50IHRvIHZhbGlkYXRlIGFnYWluc3QgZW51bSB2YWx1ZXNcbiAgICAgICAgcmV0dXJuIHN0cmluZ1NjaGVtYS5yZWZpbmUoKHZhbCkgPT4gc2NoZW1hLmVudW0/LmluY2x1ZGVzKHZhbCksIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IGBWYWx1ZSBtdXN0IGJlIG9uZSBvZjogJHtzY2hlbWEuZW51bT8uam9pbignLCAnKX1gXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYSBKU09OIHNjaGVtYSBvZiB0eXBlIGFycmF5IGFuZCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIFpvZCBzY2hlbWEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0pTT05TY2hlbWF9IHNjaGVtYSAtIFRoZSBKU09OIHNjaGVtYS5cbiAgICAgKiBAcmV0dXJucyB7Wm9kVHlwZUFueX0gLSBUaGUgWm9kVHlwZUFueSBzY2hlbWEuXG4gICAgICovXG4gICAgc3RhdGljIHBhcnNlQXJyYXkoc2NoZW1hKSB7XG4gICAgICAgIC8vIEhhbmRsZSB0dXBsZSB2YWxpZGF0aW9uIChpdGVtcyBpcyBhbiBhcnJheSlcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hLml0ZW1zKSkge1xuICAgICAgICAgICAgY29uc3QgdHVwbGVTY2hlbWFzID0gc2NoZW1hLml0ZW1zLm1hcChpdGVtID0+IHRoaXMucGFyc2VTY2hlbWEoaXRlbSkpO1xuICAgICAgICAgICAgcmV0dXJuIHoudW5pb24odHVwbGVTY2hlbWFzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgcmVndWxhciBhcnJheSBzY2hlbWFcbiAgICAgICAgY29uc3QgaXRlbVNjaGVtYSA9IHNjaGVtYS5pdGVtcyA/IHRoaXMucGFyc2VTY2hlbWEoc2NoZW1hLml0ZW1zKSA6IHouYW55KCk7XG4gICAgICAgIGxldCBhcnJheVNjaGVtYSA9IHouYXJyYXkoaXRlbVNjaGVtYSk7XG4gICAgICAgIC8vIEFwcGx5IGFycmF5IGNvbnN0cmFpbnRzXG4gICAgICAgIGxldCByZXN1bHQgPSBhcnJheVNjaGVtYTtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5hcHBseUFycmF5Q29uc3RyYWludHMoYXJyYXlTY2hlbWEsIHNjaGVtYSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgY29uc3RyYWludHMgdG8gYW4gYXJyYXkgc2NoZW1hLlxuICAgICAqXG4gICAgICogQHBhcmFtIHt6LlpvZEFycmF5PGFueT59IGFycmF5U2NoZW1hIC0gVGhlIGJhc2UgYXJyYXkgc2NoZW1hLlxuICAgICAqIEBwYXJhbSB7SlNPTlNjaGVtYX0gc2NoZW1hIC0gVGhlIEpTT04gc2NoZW1hIHdpdGggYXJyYXkgY29uc3RyYWludHMuXG4gICAgICogQHJldHVybnMge3ouWm9kVHlwZUFueX0gLSBUaGUgdXBkYXRlZCBhcnJheSBzY2hlbWEgd2l0aCBjb25zdHJhaW50cy5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXBwbHlBcnJheUNvbnN0cmFpbnRzKGFycmF5U2NoZW1hLCBzY2hlbWEpIHtcbiAgICAgICAgLy8gSGFuZGxlIG1pbkl0ZW1zXG4gICAgICAgIGlmIChzY2hlbWFbJ21pbkl0ZW1zJ10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYXJyYXlTY2hlbWEgPSBhcnJheVNjaGVtYS5taW4oc2NoZW1hWydtaW5JdGVtcyddKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgbWF4SXRlbXNcbiAgICAgICAgaWYgKHNjaGVtYVsnbWF4SXRlbXMnXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhcnJheVNjaGVtYSA9IGFycmF5U2NoZW1hLm1heChzY2hlbWFbJ21heEl0ZW1zJ10pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEhhbmRsZSB1bmlxdWVJdGVtc1xuICAgICAgICBpZiAoc2NoZW1hWyd1bmlxdWVJdGVtcyddKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyYXlTY2hlbWEucmVmaW5lKChpdGVtcykgPT4gbmV3IFNldChpdGVtcykuc2l6ZSA9PT0gaXRlbXMubGVuZ3RoLCB7IG1lc3NhZ2U6ICdBcnJheSBpdGVtcyBtdXN0IGJlIHVuaXF1ZScgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5U2NoZW1hO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYW4gb2JqZWN0IHNjaGVtYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SlNPTlNjaGVtYX0gc2NoZW1hIC0gVGhlIEpTT04gc2NoZW1hIGZvciBhbiBvYmplY3QuXG4gICAgICogQHJldHVybnMge1pvZFR5cGVBbnl9IC0gVGhlIFpvZFR5cGVBbnkgc2NoZW1hLlxuICAgICAqL1xuICAgIHN0YXRpYyBwYXJzZU9iamVjdChzY2hlbWEpIHtcbiAgICAgICAgLy8gSGFuZGxlIGNvbmRpdGlvbmFsIHZhbGlkYXRpb24gKGlmLXRoZW4tZWxzZSkgZmlyc3RcbiAgICAgICAgaWYgKHNjaGVtYVsnaWYnXSAmJiBzY2hlbWFbJ3RoZW4nXSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VDb25kaXRpb25hbChzY2hlbWEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSBzaGFwZSBvYmplY3QgZm9yIFpvZFxuICAgICAgICBjb25zdCBzaGFwZSA9IHt9O1xuICAgICAgICAvLyBQcm9jZXNzIHByb3BlcnRpZXNcbiAgICAgICAgdGhpcy5wcm9jZXNzT2JqZWN0UHJvcGVydGllcyhzY2hlbWEsIHNoYXBlKTtcbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBvYmplY3Qgc2NoZW1hIGFuZCBoYW5kbGUgYWRkaXRpb25hbFByb3BlcnRpZXNcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc0FkZGl0aW9uYWxQcm9wZXJ0aWVzKHNjaGVtYSwgei5vYmplY3Qoc2hhcGUpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvY2Vzc2VzIG9iamVjdCBwcm9wZXJ0aWVzIGFuZCBidWlsZHMgdGhlIHNoYXBlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SlNPTlNjaGVtYX0gc2NoZW1hIC0gVGhlIEpTT04gc2NoZW1hIGZvciBhbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBab2RUeXBlQW55Pn0gc2hhcGUgLSBUaGUgc2hhcGUgb2JqZWN0IHRvIHBvcHVsYXRlLlxuICAgICAqL1xuICAgIHN0YXRpYyBwcm9jZXNzT2JqZWN0UHJvcGVydGllcyhzY2hlbWEsIHNoYXBlKSB7XG4gICAgICAgIGNvbnN0IHJlcXVpcmVkID0gbmV3IFNldChzY2hlbWEucmVxdWlyZWQgfHwgW10pO1xuICAgICAgICBpZiAoIXNjaGVtYS5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBba2V5LCBwcm9wU2NoZW1hXSBvZiBPYmplY3QuZW50cmllcyhzY2hlbWEucHJvcGVydGllcykpIHtcbiAgICAgICAgICAgIGNvbnN0IHpvZFNjaGVtYSA9IHRoaXMucGFyc2VTY2hlbWEocHJvcFNjaGVtYSk7XG4gICAgICAgICAgICBzaGFwZVtrZXldID0gcmVxdWlyZWQuaGFzKGtleSkgPyB6b2RTY2hlbWEgOiB6b2RTY2hlbWEub3B0aW9uYWwoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzZXMgYWRkaXRpb25hbFByb3BlcnRpZXMgY29uZmlndXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SlNPTlNjaGVtYX0gc2NoZW1hIC0gVGhlIEpTT04gc2NoZW1hIGZvciBhbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHt6LlpvZE9iamVjdDxhbnksIGFueT59IG9iamVjdFNjaGVtYSAtIFRoZSBab2Qgb2JqZWN0IHNjaGVtYS5cbiAgICAgKiBAcmV0dXJucyB7ei5ab2RPYmplY3Q8YW55LCBhbnk+fSAtIFRoZSB1cGRhdGVkIFpvZCBvYmplY3Qgc2NoZW1hLlxuICAgICAqL1xuICAgIHN0YXRpYyBwcm9jZXNzQWRkaXRpb25hbFByb3BlcnRpZXMoc2NoZW1hLCBvYmplY3RTY2hlbWEpIHtcbiAgICAgICAgaWYgKHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdFNjaGVtYS5wYXNzdGhyb3VnaCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcyAmJiB0eXBlb2Ygc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgLy8gSGFuZGxlIHNjaGVtYSBmb3IgYWRkaXRpb25hbCBwcm9wZXJ0aWVzXG4gICAgICAgICAgICBjb25zdCBhZGRpdGlvbmFsUHJvcFNjaGVtYSA9IHRoaXMucGFyc2VTY2hlbWEoc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3RTY2hlbWEuY2F0Y2hhbGwoYWRkaXRpb25hbFByb3BTY2hlbWEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdFNjaGVtYS5zdHJpY3QoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYSBjb25kaXRpb25hbCBzY2hlbWEgd2l0aCBpZi10aGVuLWVsc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0pTT05TY2hlbWF9IHNjaGVtYSAtIFRoZSBKU09OIHNjaGVtYSB3aXRoIGNvbmRpdGlvbmFsIHZhbGlkYXRpb24uXG4gICAgICogQHJldHVybnMge1pvZFR5cGVBbnl9IC0gVGhlIGNvbmRpdGlvbmFsIFpvZCBzY2hlbWEuXG4gICAgICovXG4gICAgc3RhdGljIHBhcnNlQ29uZGl0aW9uYWwoc2NoZW1hKSB7XG4gICAgICAgIC8vIENyZWF0ZSBiYXNlIG9iamVjdCBzY2hlbWFcbiAgICAgICAgY29uc3Qgem9kT2JqZWN0ID0gdGhpcy5jcmVhdGVCYXNlT2JqZWN0U2NoZW1hKHNjaGVtYSk7XG4gICAgICAgIC8vIEV4dHJhY3QgY29uZGl0aW9uYWwgcGFydHNcbiAgICAgICAgY29uc3QgaWZDb25kaXRpb24gPSBzY2hlbWFbJ2lmJ107XG4gICAgICAgIGNvbnN0IHRoZW5TY2hlbWEgPSBzY2hlbWFbJ3RoZW4nXTtcbiAgICAgICAgY29uc3QgZWxzZVNjaGVtYSA9IHNjaGVtYVsnZWxzZSddO1xuICAgICAgICAvLyBBcHBseSBjb25kaXRpb25hbCB2YWxpZGF0aW9uIHVzaW5nIHN1cGVyUmVmaW5lXG4gICAgICAgIHJldHVybiB6b2RPYmplY3Quc3VwZXJSZWZpbmUoKGRhdGEsIGN0eCkgPT4ge1xuICAgICAgICAgICAgLy8gQXBwbHkgZGVmYXVsdCB2YWx1ZXMgdG8gZGF0YSBmb3IgY29uZGl0aW9uIGNoZWNraW5nXG4gICAgICAgICAgICBjb25zdCBkYXRhV2l0aERlZmF1bHRzID0gdGhpcy5hcHBseURlZmF1bHRWYWx1ZXMoZGF0YSwgc2NoZW1hKTtcbiAgICAgICAgICAgIC8vIEFwcGx5IGFwcHJvcHJpYXRlIHZhbGlkYXRpb24gYmFzZWQgb24gY29uZGl0aW9uXG4gICAgICAgICAgICBpZiAodGhpcy5tYXRjaGVzQ29uZGl0aW9uKGRhdGFXaXRoRGVmYXVsdHMsIGlmQ29uZGl0aW9uKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsaWRhdGVDb25kaXRpb25hbFNjaGVtYShkYXRhV2l0aERlZmF1bHRzLCB0aGVuU2NoZW1hLCBjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZWxzZVNjaGVtYSkge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsaWRhdGVDb25kaXRpb25hbFNjaGVtYShkYXRhV2l0aERlZmF1bHRzLCBlbHNlU2NoZW1hLCBjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGJhc2Ugb2JqZWN0IHNjaGVtYSBmcm9tIHRoZSBnaXZlbiBKU09OIHNjaGVtYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SlNPTlNjaGVtYX0gc2NoZW1hIC0gVGhlIEpTT04gc2NoZW1hLlxuICAgICAqIEByZXR1cm5zIHt6LlpvZE9iamVjdDxhbnksIGFueT59IC0gVGhlIGJhc2UgWm9kIG9iamVjdCBzY2hlbWEuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUJhc2VPYmplY3RTY2hlbWEoc2NoZW1hKSB7XG4gICAgICAgIGNvbnN0IHNoYXBlID0ge307XG4gICAgICAgIGNvbnN0IHJlcXVpcmVkID0gbmV3IFNldChzY2hlbWEucmVxdWlyZWQgfHwgW10pO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhzY2hlbWEucHJvcGVydGllcyB8fCB7fSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHpvZFNjaGVtYSA9IHRoaXMucGFyc2VTY2hlbWEodmFsdWUpO1xuICAgICAgICAgICAgc2hhcGVba2V5XSA9IHJlcXVpcmVkLmhhcyhrZXkpID8gem9kU2NoZW1hIDogem9kU2NoZW1hLm9wdGlvbmFsKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgem9kT2JqZWN0ID0gei5vYmplY3Qoc2hhcGUpO1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzQWRkaXRpb25hbFByb3BlcnRpZXMoc2NoZW1hLCB6b2RPYmplY3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGRlZmF1bHQgdmFsdWVzIGZyb20gc2NoZW1hIHByb3BlcnRpZXMgdG8gZGF0YSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0pTT05WYWx1ZX0gZGF0YSAtIFRoZSBvcmlnaW5hbCBkYXRhIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0pTT05TY2hlbWF9IHNjaGVtYSAtIFRoZSBzY2hlbWEgd2l0aCBkZWZhdWx0IHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7SlNPTlZhbHVlfSAtIFRoZSBkYXRhIG9iamVjdCB3aXRoIGRlZmF1bHRzIGFwcGxpZWQuXG4gICAgICovXG4gICAgc3RhdGljIGFwcGx5RGVmYXVsdFZhbHVlcyhkYXRhLCBzY2hlbWEpIHtcbiAgICAgICAgLy8gSWYgZGF0YSBpcyBub3QgYW4gb2JqZWN0IG9yIGlzIG51bGwsIHdlIGNhbid0IGFwcGx5IGRlZmF1bHRzXG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gJ29iamVjdCcgfHwgZGF0YSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgZGF0YSBpcyBhbiBhcnJheSwgd2UgY2FuJ3QgYXBwbHkgZGVmYXVsdHMgZnJvbSBzY2hlbWEgcHJvcGVydGllc1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm93IHdlIGtub3cgZGF0YSBpcyBhIEpTT05PYmplY3RcbiAgICAgICAgY29uc3Qgb2JqZWN0RGF0YSA9IGRhdGE7XG4gICAgICAgIGNvbnN0IGRhdGFXaXRoRGVmYXVsdHMgPSB7IC4uLm9iamVjdERhdGEgfTtcbiAgICAgICAgaWYgKCFzY2hlbWEucHJvcGVydGllcykge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGFXaXRoRGVmYXVsdHM7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBba2V5LCBwcm9wU2NoZW1hXSBvZiBPYmplY3QuZW50cmllcyhzY2hlbWEucHJvcGVydGllcykpIHtcbiAgICAgICAgICAgIGlmICghKGtleSBpbiBkYXRhV2l0aERlZmF1bHRzKSAmJiAnZGVmYXVsdCcgaW4gcHJvcFNjaGVtYSkge1xuICAgICAgICAgICAgICAgIGRhdGFXaXRoRGVmYXVsdHNba2V5XSA9IHByb3BTY2hlbWFbJ2RlZmF1bHQnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YVdpdGhEZWZhdWx0cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2VzIGEgc2NoZW1hIHdpdGggY29tYmluYXRvcnMgKG9uZU9mLCBhbnlPZiwgYWxsT2YpLlxuICAgICAqIERlbGVnYXRlcyB0byB0aGUgYXBwcm9wcmlhdGUgY29tYmluYXRvciBwYXJzZXIgYmFzZWQgb24gd2hpY2ggY29tYmluYXRvciBpcyBwcmVzZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtKU09OU2NoZW1hfSBzY2hlbWEgLSBUaGUgSlNPTiBzY2hlbWEgd2l0aCBjb21iaW5hdG9ycy5cbiAgICAgKiBAcmV0dXJucyB7Wm9kVHlwZUFueX0gLSBUaGUgWm9kVHlwZUFueSBzY2hlbWEuXG4gICAgICovXG4gICAgc3RhdGljIHBhcnNlQ29tYmluYXRvcihzY2hlbWEpIHtcbiAgICAgICAgaWYgKHNjaGVtYS5vbmVPZikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPbmVPZihzY2hlbWEub25lT2YpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2hlbWEuYW55T2YpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlQW55T2Yoc2NoZW1hLmFueU9mKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZW1hLmFsbE9mKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUFsbE9mKHNjaGVtYS5hbGxPZik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2hvdWxkIG5vdCByZWFjaCBoZXJlIGlmIHNjaGVtYSBoYXMgY29tYmluYXRvcnNcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBzY2hlbWEgdHlwZScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYSBvbmVPZiBjb21iaW5hdG9yIHNjaGVtYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SlNPTlNjaGVtYVtdfSBzY2hlbWFzIC0gQXJyYXkgb2YgSlNPTiBzY2hlbWFzIGluIHRoZSBvbmVPZi5cbiAgICAgKiBAcmV0dXJucyB7Wm9kVHlwZUFueX0gLSBUaGUgWm9kVHlwZUFueSBzY2hlbWEuXG4gICAgICovXG4gICAgc3RhdGljIHBhcnNlT25lT2Yoc2NoZW1hcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVVbmlvbkZyb21TY2hlbWFzKHNjaGVtYXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYW4gYW55T2YgY29tYmluYXRvciBzY2hlbWEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0pTT05TY2hlbWFbXX0gc2NoZW1hcyAtIEFycmF5IG9mIEpTT04gc2NoZW1hcyBpbiB0aGUgYW55T2YuXG4gICAgICogQHJldHVybnMge1pvZFR5cGVBbnl9IC0gVGhlIFpvZFR5cGVBbnkgc2NoZW1hLlxuICAgICAqL1xuICAgIHN0YXRpYyBwYXJzZUFueU9mKHNjaGVtYXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlVW5pb25Gcm9tU2NoZW1hcyhzY2hlbWFzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHVuaW9uIGZyb20gYW4gYXJyYXkgb2Ygc2NoZW1hcywgaGFuZGxpbmcgc3BlY2lhbCBjYXNlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SlNPTlNjaGVtYVtdfSBzY2hlbWFzIC0gQXJyYXkgb2YgSlNPTiBzY2hlbWFzIHRvIGNyZWF0ZSBhIHVuaW9uIGZyb20uXG4gICAgICogQHJldHVybnMge1pvZFR5cGVBbnl9IC0gVGhlIHVuaW9uIFpvZCBzY2hlbWEuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVVuaW9uRnJvbVNjaGVtYXMoc2NoZW1hcykge1xuICAgICAgICAvLyBIYW5kbGUgZW1wdHkgYXJyYXkgY2FzZVxuICAgICAgICBpZiAoc2NoZW1hcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB6LmFueSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEhhbmRsZSBzaW5nbGUgc2NoZW1hIGNhc2VcbiAgICAgICAgaWYgKHNjaGVtYXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVNjaGVtYShzY2hlbWFzWzBdKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQcm9jZXNzIGVhY2ggc3Vic2NoZW1hIGluZGl2aWR1YWxseVxuICAgICAgICBjb25zdCB6b2RTY2hlbWFzID0gW107XG4gICAgICAgIGZvciAoY29uc3Qgc3ViU2NoZW1hIG9mIHNjaGVtYXMpIHtcbiAgICAgICAgICAgIC8vIEhhbmRsZSBudWxsIHR5cGUgc3BlY2lhbGx5XG4gICAgICAgICAgICBpZiAoc3ViU2NoZW1hLnR5cGUgPT09ICdudWxsJykge1xuICAgICAgICAgICAgICAgIHpvZFNjaGVtYXMucHVzaCh6Lm51bGwoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB6b2RTY2hlbWFzLnB1c2godGhpcy5wYXJzZVNjaGVtYShzdWJTY2hlbWEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBSZXR1cm4gYXBwcm9wcmlhdGUgc2NoZW1hIGJhc2VkIG9uIG51bWJlciBvZiB2YWxpZCBzY2hlbWFzXG4gICAgICAgIGlmICh6b2RTY2hlbWFzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICByZXR1cm4gei51bmlvbih6b2RTY2hlbWFzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh6b2RTY2hlbWFzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHpvZFNjaGVtYXNbMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmFsbGJhY2sgaWYgbm8gdmFsaWQgc2NoZW1hcyB3ZXJlIGNyZWF0ZWRcbiAgICAgICAgcmV0dXJuIHouYW55KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhbiBhbGxPZiBjb21iaW5hdG9yIHNjaGVtYSBieSBtZXJnaW5nIGFsbCBzY2hlbWFzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtKU09OU2NoZW1hW119IHNjaGVtYXMgLSBBcnJheSBvZiBKU09OIHNjaGVtYXMgaW4gdGhlIGFsbE9mLlxuICAgICAqIEByZXR1cm5zIHtab2RUeXBlQW55fSAtIFRoZSBab2RUeXBlQW55IHNjaGVtYS5cbiAgICAgKi9cbiAgICBzdGF0aWMgcGFyc2VBbGxPZihzY2hlbWFzKSB7XG4gICAgICAgIC8vIEhhbmRsZSBlbXB0eSBhcnJheSBjYXNlXG4gICAgICAgIGlmIChzY2hlbWFzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHouYW55KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIHNpbmdsZSBzY2hlbWEgY2FzZVxuICAgICAgICBpZiAoc2NoZW1hcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlU2NoZW1hKHNjaGVtYXNbMF0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1lcmdlIGFsbCBzY2hlbWFzIHRvZ2V0aGVyXG4gICAgICAgIGNvbnN0IG1lcmdlZFNjaGVtYSA9IHNjaGVtYXMucmVkdWNlKChhY2MsIGN1cnJlbnRTY2hlbWEpID0+IHRoaXMubWVyZ2VTY2hlbWFzKGFjYywgY3VycmVudFNjaGVtYSkpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVNjaGVtYShtZXJnZWRTY2hlbWEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXJnZXMgdHdvIEpTT04gc2NoZW1hcyB0b2dldGhlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SlNPTlNjaGVtYX0gYmFzZVNjaGVtYSAtIFRoZSBiYXNlIEpTT04gc2NoZW1hLlxuICAgICAqIEBwYXJhbSB7SlNPTlNjaGVtYX0gYWRkU2NoZW1hIC0gVGhlIEpTT04gc2NoZW1hIHRvIGFkZC5cbiAgICAgKiBAcmV0dXJucyB7SlNPTlNjaGVtYX0gLSBUaGUgbWVyZ2VkIEpTT04gc2NoZW1hXG4gICAgICovXG4gICAgc3RhdGljIG1lcmdlU2NoZW1hcyhiYXNlU2NoZW1hLCBhZGRTY2hlbWEpIHtcbiAgICAgICAgY29uc3QgbWVyZ2VkID0geyAuLi5iYXNlU2NoZW1hLCAuLi5hZGRTY2hlbWEgfTtcbiAgICAgICAgaWYgKGJhc2VTY2hlbWEucHJvcGVydGllcyAmJiBhZGRTY2hlbWEucHJvcGVydGllcykge1xuICAgICAgICAgICAgY29uc3QgbWVyZ2VkUHJvcGVydGllcyA9IHsgLi4uYmFzZVNjaGVtYS5wcm9wZXJ0aWVzLCAuLi5hZGRTY2hlbWEucHJvcGVydGllcyB9O1xuICAgICAgICAgICAgbWVyZ2VkLnByb3BlcnRpZXMgPSBtZXJnZWRQcm9wZXJ0aWVzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiYXNlU2NoZW1hLnJlcXVpcmVkICYmIGFkZFNjaGVtYS5yZXF1aXJlZCkge1xuICAgICAgICAgICAgY29uc3QgbWVyZ2VkUmVxdWlyZWQgPSBbLi4ubmV3IFNldChbLi4uYmFzZVNjaGVtYS5yZXF1aXJlZCwgLi4uYWRkU2NoZW1hLnJlcXVpcmVkXSldO1xuICAgICAgICAgICAgbWVyZ2VkLnJlcXVpcmVkID0gbWVyZ2VkUmVxdWlyZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lcmdlZDtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@dmitryrechkin/json-schema-to-zod/dist/JSONSchemaToZod.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@dmitryrechkin/json-schema-to-zod/dist/Type.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@dmitryrechkin/json-schema-to-zod/dist/Type.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGRtaXRyeXJlY2hraW4vanNvbi1zY2hlbWEtdG8tem9kL2Rpc3QvVHlwZS5qcyIsIm1hcHBpbmdzIjoiO0FBQVUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aXZlLXZpYmUtYWktbmV4dC8uL25vZGVfbW9kdWxlcy9AZG1pdHJ5cmVjaGtpbi9qc29uLXNjaGVtYS10by16b2QvZGlzdC9UeXBlLmpzPzNiMDQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHt9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@dmitryrechkin/json-schema-to-zod/dist/Type.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@dmitryrechkin/json-schema-to-zod/dist/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@dmitryrechkin/json-schema-to-zod/dist/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JSONSchemaToZod: () => (/* reexport safe */ _JSONSchemaToZod_js__WEBPACK_IMPORTED_MODULE_0__.JSONSchemaToZod)\n/* harmony export */ });\n/* harmony import */ var _JSONSchemaToZod_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./JSONSchemaToZod.js */ \"(rsc)/./node_modules/@dmitryrechkin/json-schema-to-zod/dist/JSONSchemaToZod.js\");\n/* harmony import */ var _Type_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Type.js */ \"(rsc)/./node_modules/@dmitryrechkin/json-schema-to-zod/dist/Type.js\");\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGRtaXRyeXJlY2hraW4vanNvbi1zY2hlbWEtdG8tem9kL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXFDO0FBQ1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aXZlLXZpYmUtYWktbmV4dC8uL25vZGVfbW9kdWxlcy9AZG1pdHJ5cmVjaGtpbi9qc29uLXNjaGVtYS10by16b2QvZGlzdC9pbmRleC5qcz84NWJlIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gJy4vSlNPTlNjaGVtYVRvWm9kLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vVHlwZS5qcyc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@dmitryrechkin/json-schema-to-zod/dist/index.js\n");

/***/ })

};
;