"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/openapi-fetch";
exports.ids = ["vendor-chunks/openapi-fetch"];
exports.modules = {

/***/ "(rsc)/./node_modules/openapi-fetch/dist/index.js":
/*!**************************************************!*\
  !*** ./node_modules/openapi-fetch/dist/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createFinalURL: () => (/* binding */ createFinalURL),\n/* harmony export */   createQuerySerializer: () => (/* binding */ createQuerySerializer),\n/* harmony export */   \"default\": () => (/* binding */ createClient),\n/* harmony export */   defaultBodySerializer: () => (/* binding */ defaultBodySerializer),\n/* harmony export */   defaultPathSerializer: () => (/* binding */ defaultPathSerializer),\n/* harmony export */   mergeHeaders: () => (/* binding */ mergeHeaders),\n/* harmony export */   serializeArrayParam: () => (/* binding */ serializeArrayParam),\n/* harmony export */   serializeObjectParam: () => (/* binding */ serializeObjectParam),\n/* harmony export */   serializePrimitiveParam: () => (/* binding */ serializePrimitiveParam)\n/* harmony export */ });\n// settings & const\nconst DEFAULT_HEADERS = {\n  \"Content-Type\": \"application/json\",\n};\n\nconst PATH_PARAM_RE = /\\{[^{}]+\\}/g;\n\n/**\n * Add custom parameters to Request object\n */\nclass CustomRequest extends Request {\n  constructor(input, init) {\n    super(input, init);\n\n    // add custom parameters\n    for (const key in init) {\n      if (!(key in this)) {\n        this[key] = init[key];\n      }\n    }\n  }\n}\n\n/**\n * Create an openapi-fetch client.\n * @type {import(\"./index.js\").default}\n */\nfunction createClient(clientOptions) {\n  let {\n    baseUrl = \"\",\n    fetch: baseFetch = globalThis.fetch,\n    querySerializer: globalQuerySerializer,\n    bodySerializer: globalBodySerializer,\n    headers: baseHeaders,\n    ...baseOptions\n  } = { ...clientOptions };\n  if (baseUrl.endsWith(\"/\")) {\n    baseUrl = baseUrl.substring(0, baseUrl.length - 1);\n  }\n  baseHeaders = mergeHeaders(DEFAULT_HEADERS, baseHeaders);\n  const middlewares = [];\n\n  /**\n   * Per-request fetch (keeps settings created in createClient()\n   * @param {T} url\n   * @param {import('./index.js').FetchOptions<T>} fetchOptions\n   */\n  async function coreFetch(url, fetchOptions) {\n    const {\n      fetch = baseFetch,\n      headers,\n      params = {},\n      parseAs = \"json\",\n      querySerializer: requestQuerySerializer,\n      bodySerializer = globalBodySerializer ?? defaultBodySerializer,\n      ...init\n    } = fetchOptions || {};\n\n    let querySerializer =\n      typeof globalQuerySerializer === \"function\"\n        ? globalQuerySerializer\n        : createQuerySerializer(globalQuerySerializer);\n    if (requestQuerySerializer) {\n      querySerializer =\n        typeof requestQuerySerializer === \"function\"\n          ? requestQuerySerializer\n          : createQuerySerializer({\n              ...(typeof globalQuerySerializer === \"object\" ? globalQuerySerializer : {}),\n              ...requestQuerySerializer,\n            });\n    }\n\n    const requestInit = {\n      redirect: \"follow\",\n      ...baseOptions,\n      ...init,\n      headers: mergeHeaders(baseHeaders, headers, params.header),\n    };\n    if (requestInit.body) {\n      requestInit.body = bodySerializer(requestInit.body);\n    }\n    // remove `Content-Type` if serialized body is FormData; browser will correctly set Content-Type & boundary expression\n    if (requestInit.body instanceof FormData) {\n      requestInit.headers.delete(\"Content-Type\");\n    }\n    let request = new CustomRequest(createFinalURL(url, { baseUrl, params, querySerializer }), requestInit);\n    // middleware (request)\n    const mergedOptions = {\n      baseUrl,\n      fetch,\n      parseAs,\n      querySerializer,\n      bodySerializer,\n    };\n    for (const m of middlewares) {\n      if (m && typeof m === \"object\" && typeof m.onRequest === \"function\") {\n        request.schemaPath = url; // (re)attach original URL\n        request.params = params; // (re)attach params\n        const result = await m.onRequest(request, mergedOptions);\n        if (result) {\n          if (!(result instanceof Request)) {\n            throw new Error(\"Middleware must return new Request() when modifying the request\");\n          }\n          request = result;\n        }\n      }\n    }\n\n    // fetch!\n    let response = await fetch(request);\n\n    // middleware (response)\n    // execute in reverse-array order (first priority gets last transform)\n    for (let i = middlewares.length - 1; i >= 0; i--) {\n      const m = middlewares[i];\n      if (m && typeof m === \"object\" && typeof m.onResponse === \"function\") {\n        request.schemaPath = url; // (re)attach original URL\n        request.params = params; // (re)attach params\n        const result = await m.onResponse(response, mergedOptions, request);\n        if (result) {\n          if (!(result instanceof Response)) {\n            throw new Error(\"Middleware must return new Response() when modifying the response\");\n          }\n          response = result;\n        }\n      }\n    }\n\n    // handle empty content\n    // note: we return `{}` because we want user truthy checks for `.data` or `.error` to succeed\n    if (response.status === 204 || response.headers.get(\"Content-Length\") === \"0\") {\n      return response.ok ? { data: {}, response } : { error: {}, response };\n    }\n\n    // parse response (falling back to .text() when necessary)\n    if (response.ok) {\n      // if \"stream\", skip parsing entirely\n      if (parseAs === \"stream\") {\n        return { data: response.body, response };\n      }\n      return { data: await response[parseAs](), response };\n    }\n\n    // handle errors\n    let error = await response.text();\n    try {\n      error = JSON.parse(error); // attempt to parse as JSON\n    } catch {\n      // noop\n    }\n    return { error, response };\n  }\n\n  return {\n    /** Call a GET endpoint */\n    async GET(url, init) {\n      return coreFetch(url, { ...init, method: \"GET\" });\n    },\n    /** Call a PUT endpoint */\n    async PUT(url, init) {\n      return coreFetch(url, { ...init, method: \"PUT\" });\n    },\n    /** Call a POST endpoint */\n    async POST(url, init) {\n      return coreFetch(url, { ...init, method: \"POST\" });\n    },\n    /** Call a DELETE endpoint */\n    async DELETE(url, init) {\n      return coreFetch(url, { ...init, method: \"DELETE\" });\n    },\n    /** Call a OPTIONS endpoint */\n    async OPTIONS(url, init) {\n      return coreFetch(url, { ...init, method: \"OPTIONS\" });\n    },\n    /** Call a HEAD endpoint */\n    async HEAD(url, init) {\n      return coreFetch(url, { ...init, method: \"HEAD\" });\n    },\n    /** Call a PATCH endpoint */\n    async PATCH(url, init) {\n      return coreFetch(url, { ...init, method: \"PATCH\" });\n    },\n    /** Call a TRACE endpoint */\n    async TRACE(url, init) {\n      return coreFetch(url, { ...init, method: \"TRACE\" });\n    },\n    /** Register middleware */\n    use(...middleware) {\n      for (const m of middleware) {\n        if (!m) {\n          continue;\n        }\n        if (typeof m !== \"object\" || !(\"onRequest\" in m || \"onResponse\" in m)) {\n          throw new Error(\"Middleware must be an object with one of `onRequest()` or `onResponse()`\");\n        }\n        middlewares.push(m);\n      }\n    },\n    /** Unregister middleware */\n    eject(...middleware) {\n      for (const m of middleware) {\n        const i = middlewares.indexOf(m);\n        if (i !== -1) {\n          middlewares.splice(i, 1);\n        }\n      }\n    },\n  };\n}\n\n// utils\n\n/**\n * Serialize primitive param values\n * @type {import(\"./index.js\").serializePrimitiveParam}\n */\nfunction serializePrimitiveParam(name, value, options) {\n  if (value === undefined || value === null) {\n    return \"\";\n  }\n  if (typeof value === \"object\") {\n    throw new Error(\n      \"Deeply-nested arrays/objects arenâ€™t supported. Provide your own `querySerializer()` to handle these.\",\n    );\n  }\n  return `${name}=${options?.allowReserved === true ? value : encodeURIComponent(value)}`;\n}\n\n/**\n * Serialize object param (shallow only)\n * @type {import(\"./index.js\").serializeObjectParam}\n */\nfunction serializeObjectParam(name, value, options) {\n  if (!value || typeof value !== \"object\") {\n    return \"\";\n  }\n  const values = [];\n  const joiner =\n    {\n      simple: \",\",\n      label: \".\",\n      matrix: \";\",\n    }[options.style] || \"&\";\n\n  // explode: false\n  if (options.style !== \"deepObject\" && options.explode === false) {\n    for (const k in value) {\n      values.push(k, options.allowReserved === true ? value[k] : encodeURIComponent(value[k]));\n    }\n    const final = values.join(\",\"); // note: values are always joined by comma in explode: false (but joiner can prefix)\n    switch (options.style) {\n      case \"form\": {\n        return `${name}=${final}`;\n      }\n      case \"label\": {\n        return `.${final}`;\n      }\n      case \"matrix\": {\n        return `;${name}=${final}`;\n      }\n      default: {\n        return final;\n      }\n    }\n  }\n\n  // explode: true\n  for (const k in value) {\n    const finalName = options.style === \"deepObject\" ? `${name}[${k}]` : k;\n    values.push(serializePrimitiveParam(finalName, value[k], options));\n  }\n  const final = values.join(joiner);\n  return options.style === \"label\" || options.style === \"matrix\" ? `${joiner}${final}` : final;\n}\n\n/**\n * Serialize array param (shallow only)\n * @type {import(\"./index.js\").serializeArrayParam}\n */\nfunction serializeArrayParam(name, value, options) {\n  if (!Array.isArray(value)) {\n    return \"\";\n  }\n\n  // explode: false\n  if (options.explode === false) {\n    const joiner = { form: \",\", spaceDelimited: \"%20\", pipeDelimited: \"|\" }[options.style] || \",\"; // note: for arrays, joiners vary wildly based on style + explode behavior\n    const final = (options.allowReserved === true ? value : value.map((v) => encodeURIComponent(v))).join(joiner);\n    switch (options.style) {\n      case \"simple\": {\n        return final;\n      }\n      case \"label\": {\n        return `.${final}`;\n      }\n      case \"matrix\": {\n        return `;${name}=${final}`;\n      }\n      // case \"spaceDelimited\":\n      // case \"pipeDelimited\":\n      default: {\n        return `${name}=${final}`;\n      }\n    }\n  }\n\n  // explode: true\n  const joiner = { simple: \",\", label: \".\", matrix: \";\" }[options.style] || \"&\";\n  const values = [];\n  for (const v of value) {\n    if (options.style === \"simple\" || options.style === \"label\") {\n      values.push(options.allowReserved === true ? v : encodeURIComponent(v));\n    } else {\n      values.push(serializePrimitiveParam(name, v, options));\n    }\n  }\n  return options.style === \"label\" || options.style === \"matrix\"\n    ? `${joiner}${values.join(joiner)}`\n    : values.join(joiner);\n}\n\n/**\n * Serialize query params to string\n * @type {import(\"./index.js\").createQuerySerializer}\n */\nfunction createQuerySerializer(options) {\n  return function querySerializer(queryParams) {\n    const search = [];\n    if (queryParams && typeof queryParams === \"object\") {\n      for (const name in queryParams) {\n        const value = queryParams[name];\n        if (value === undefined || value === null) {\n          continue;\n        }\n        if (Array.isArray(value)) {\n          search.push(\n            serializeArrayParam(name, value, {\n              style: \"form\",\n              explode: true,\n              ...options?.array,\n              allowReserved: options?.allowReserved || false,\n            }),\n          );\n          continue;\n        }\n        if (typeof value === \"object\") {\n          search.push(\n            serializeObjectParam(name, value, {\n              style: \"deepObject\",\n              explode: true,\n              ...options?.object,\n              allowReserved: options?.allowReserved || false,\n            }),\n          );\n          continue;\n        }\n        search.push(serializePrimitiveParam(name, value, options));\n      }\n    }\n    return search.join(\"&\");\n  };\n}\n\n/**\n * Handle different OpenAPI 3.x serialization styles\n * @type {import(\"./index.js\").defaultPathSerializer}\n * @see https://swagger.io/docs/specification/serialization/#path\n */\nfunction defaultPathSerializer(pathname, pathParams) {\n  let nextURL = pathname;\n  for (const match of pathname.match(PATH_PARAM_RE) ?? []) {\n    let name = match.substring(1, match.length - 1);\n    let explode = false;\n    let style = \"simple\";\n    if (name.endsWith(\"*\")) {\n      explode = true;\n      name = name.substring(0, name.length - 1);\n    }\n    if (name.startsWith(\".\")) {\n      style = \"label\";\n      name = name.substring(1);\n    } else if (name.startsWith(\";\")) {\n      style = \"matrix\";\n      name = name.substring(1);\n    }\n    if (!pathParams || pathParams[name] === undefined || pathParams[name] === null) {\n      continue;\n    }\n    const value = pathParams[name];\n    if (Array.isArray(value)) {\n      nextURL = nextURL.replace(match, serializeArrayParam(name, value, { style, explode }));\n      continue;\n    }\n    if (typeof value === \"object\") {\n      nextURL = nextURL.replace(match, serializeObjectParam(name, value, { style, explode }));\n      continue;\n    }\n    if (style === \"matrix\") {\n      nextURL = nextURL.replace(match, `;${serializePrimitiveParam(name, value)}`);\n      continue;\n    }\n    nextURL = nextURL.replace(match, style === \"label\" ? `.${value}` : value);\n  }\n  return nextURL;\n}\n\n/**\n * Serialize body object to string\n * @type {import(\"./index.js\").defaultBodySerializer}\n */\nfunction defaultBodySerializer(body) {\n  return JSON.stringify(body);\n}\n\n/**\n * Construct URL string from baseUrl and handle path and query params\n * @type {import(\"./index.js\").createFinalURL}\n */\nfunction createFinalURL(pathname, options) {\n  let finalURL = `${options.baseUrl}${pathname}`;\n  if (options.params?.path) {\n    finalURL = defaultPathSerializer(finalURL, options.params.path);\n  }\n  let search = options.querySerializer(options.params.query ?? {});\n  if (search.startsWith(\"?\")) {\n    search = search.substring(1);\n  }\n  if (search) {\n    finalURL += `?${search}`;\n  }\n  return finalURL;\n}\n\n/**\n * Merge headers a and b, with b taking priority\n * @type {import(\"./index.js\").mergeHeaders}\n */\nfunction mergeHeaders(...allHeaders) {\n  const finalHeaders = new Headers();\n  for (const h of allHeaders) {\n    if (!h || typeof h !== \"object\") {\n      continue;\n    }\n    const iterator = h instanceof Headers ? h.entries() : Object.entries(h);\n    for (const [k, v] of iterator) {\n      if (v === null) {\n        finalHeaders.delete(k);\n      } else if (Array.isArray(v)) {\n        for (const v2 of v) {\n          finalHeaders.append(k, v2);\n        }\n      } else if (v !== undefined) {\n        finalHeaders.set(k, v);\n      }\n    }\n  }\n  return finalHeaders;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvb3BlbmFwaS1mZXRjaC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5QixJQUFJLElBQUk7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFJO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxHQUFHO0FBQ2hCLGFBQWEsc0NBQXNDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdGQUF3RjtBQUN4RjtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGtDQUFrQztBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlDQUF5QyxRQUFRO0FBQ2pEO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEMsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLDZCQUE2QixRQUFRLGFBQWEsSUFBSSxTQUFTO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyxNQUFNO0FBQ047QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsd0JBQXdCO0FBQ3RELEtBQUs7QUFDTDtBQUNBO0FBQ0EsOEJBQThCLHdCQUF3QjtBQUN0RCxLQUFLO0FBQ0w7QUFDQTtBQUNBLDhCQUE4Qix5QkFBeUI7QUFDdkQsS0FBSztBQUNMO0FBQ0E7QUFDQSw4QkFBOEIsMkJBQTJCO0FBQ3pELEtBQUs7QUFDTDtBQUNBO0FBQ0EsOEJBQThCLDRCQUE0QjtBQUMxRCxLQUFLO0FBQ0w7QUFDQTtBQUNBLDhCQUE4Qix5QkFBeUI7QUFDdkQsS0FBSztBQUNMO0FBQ0E7QUFDQSw4QkFBOEIsMEJBQTBCO0FBQ3hELEtBQUs7QUFDTDtBQUNBO0FBQ0EsOEJBQThCLDBCQUEwQjtBQUN4RCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksS0FBSyxHQUFHLG9FQUFvRTtBQUN4Rjs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0Esa0JBQWtCLEtBQUssR0FBRyxNQUFNO0FBQ2hDO0FBQ0E7QUFDQSxtQkFBbUIsTUFBTTtBQUN6QjtBQUNBO0FBQ0EsaUJBQWlCLEVBQUUsS0FBSyxHQUFHLE1BQU07QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwREFBMEQsS0FBSyxHQUFHLEVBQUU7QUFDcEU7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLE9BQU8sRUFBRSxNQUFNO0FBQ3JGOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLHNEQUFzRCx3QkFBd0I7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE1BQU07QUFDekI7QUFDQTtBQUNBLGlCQUFpQixFQUFFLEtBQUssR0FBRyxNQUFNO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLEtBQUssR0FBRyxNQUFNO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixtQ0FBbUMsR0FBRztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsT0FBTyxFQUFFLG9CQUFvQjtBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDJCQUEyQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLGdCQUFnQjtBQUMxRjtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsZ0JBQWdCO0FBQzNGO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxFQUFFLHFDQUFxQztBQUNoRjtBQUNBO0FBQ0EsNkRBQTZELE1BQU07QUFDbkU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNPO0FBQ1Asb0JBQW9CLGdCQUFnQixFQUFFLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdml2ZS12aWJlLWFpLW5leHQvLi9ub2RlX21vZHVsZXMvb3BlbmFwaS1mZXRjaC9kaXN0L2luZGV4LmpzPzlkMWYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc2V0dGluZ3MgJiBjb25zdFxuY29uc3QgREVGQVVMVF9IRUFERVJTID0ge1xuICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbn07XG5cbmNvbnN0IFBBVEhfUEFSQU1fUkUgPSAvXFx7W157fV0rXFx9L2c7XG5cbi8qKlxuICogQWRkIGN1c3RvbSBwYXJhbWV0ZXJzIHRvIFJlcXVlc3Qgb2JqZWN0XG4gKi9cbmNsYXNzIEN1c3RvbVJlcXVlc3QgZXh0ZW5kcyBSZXF1ZXN0IHtcbiAgY29uc3RydWN0b3IoaW5wdXQsIGluaXQpIHtcbiAgICBzdXBlcihpbnB1dCwgaW5pdCk7XG5cbiAgICAvLyBhZGQgY3VzdG9tIHBhcmFtZXRlcnNcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBpbml0KSB7XG4gICAgICBpZiAoIShrZXkgaW4gdGhpcykpIHtcbiAgICAgICAgdGhpc1trZXldID0gaW5pdFtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSBhbiBvcGVuYXBpLWZldGNoIGNsaWVudC5cbiAqIEB0eXBlIHtpbXBvcnQoXCIuL2luZGV4LmpzXCIpLmRlZmF1bHR9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNyZWF0ZUNsaWVudChjbGllbnRPcHRpb25zKSB7XG4gIGxldCB7XG4gICAgYmFzZVVybCA9IFwiXCIsXG4gICAgZmV0Y2g6IGJhc2VGZXRjaCA9IGdsb2JhbFRoaXMuZmV0Y2gsXG4gICAgcXVlcnlTZXJpYWxpemVyOiBnbG9iYWxRdWVyeVNlcmlhbGl6ZXIsXG4gICAgYm9keVNlcmlhbGl6ZXI6IGdsb2JhbEJvZHlTZXJpYWxpemVyLFxuICAgIGhlYWRlcnM6IGJhc2VIZWFkZXJzLFxuICAgIC4uLmJhc2VPcHRpb25zXG4gIH0gPSB7IC4uLmNsaWVudE9wdGlvbnMgfTtcbiAgaWYgKGJhc2VVcmwuZW5kc1dpdGgoXCIvXCIpKSB7XG4gICAgYmFzZVVybCA9IGJhc2VVcmwuc3Vic3RyaW5nKDAsIGJhc2VVcmwubGVuZ3RoIC0gMSk7XG4gIH1cbiAgYmFzZUhlYWRlcnMgPSBtZXJnZUhlYWRlcnMoREVGQVVMVF9IRUFERVJTLCBiYXNlSGVhZGVycyk7XG4gIGNvbnN0IG1pZGRsZXdhcmVzID0gW107XG5cbiAgLyoqXG4gICAqIFBlci1yZXF1ZXN0IGZldGNoIChrZWVwcyBzZXR0aW5ncyBjcmVhdGVkIGluIGNyZWF0ZUNsaWVudCgpXG4gICAqIEBwYXJhbSB7VH0gdXJsXG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuL2luZGV4LmpzJykuRmV0Y2hPcHRpb25zPFQ+fSBmZXRjaE9wdGlvbnNcbiAgICovXG4gIGFzeW5jIGZ1bmN0aW9uIGNvcmVGZXRjaCh1cmwsIGZldGNoT3B0aW9ucykge1xuICAgIGNvbnN0IHtcbiAgICAgIGZldGNoID0gYmFzZUZldGNoLFxuICAgICAgaGVhZGVycyxcbiAgICAgIHBhcmFtcyA9IHt9LFxuICAgICAgcGFyc2VBcyA9IFwianNvblwiLFxuICAgICAgcXVlcnlTZXJpYWxpemVyOiByZXF1ZXN0UXVlcnlTZXJpYWxpemVyLFxuICAgICAgYm9keVNlcmlhbGl6ZXIgPSBnbG9iYWxCb2R5U2VyaWFsaXplciA/PyBkZWZhdWx0Qm9keVNlcmlhbGl6ZXIsXG4gICAgICAuLi5pbml0XG4gICAgfSA9IGZldGNoT3B0aW9ucyB8fCB7fTtcblxuICAgIGxldCBxdWVyeVNlcmlhbGl6ZXIgPVxuICAgICAgdHlwZW9mIGdsb2JhbFF1ZXJ5U2VyaWFsaXplciA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgID8gZ2xvYmFsUXVlcnlTZXJpYWxpemVyXG4gICAgICAgIDogY3JlYXRlUXVlcnlTZXJpYWxpemVyKGdsb2JhbFF1ZXJ5U2VyaWFsaXplcik7XG4gICAgaWYgKHJlcXVlc3RRdWVyeVNlcmlhbGl6ZXIpIHtcbiAgICAgIHF1ZXJ5U2VyaWFsaXplciA9XG4gICAgICAgIHR5cGVvZiByZXF1ZXN0UXVlcnlTZXJpYWxpemVyID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICA/IHJlcXVlc3RRdWVyeVNlcmlhbGl6ZXJcbiAgICAgICAgICA6IGNyZWF0ZVF1ZXJ5U2VyaWFsaXplcih7XG4gICAgICAgICAgICAgIC4uLih0eXBlb2YgZ2xvYmFsUXVlcnlTZXJpYWxpemVyID09PSBcIm9iamVjdFwiID8gZ2xvYmFsUXVlcnlTZXJpYWxpemVyIDoge30pLFxuICAgICAgICAgICAgICAuLi5yZXF1ZXN0UXVlcnlTZXJpYWxpemVyLFxuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVxdWVzdEluaXQgPSB7XG4gICAgICByZWRpcmVjdDogXCJmb2xsb3dcIixcbiAgICAgIC4uLmJhc2VPcHRpb25zLFxuICAgICAgLi4uaW5pdCxcbiAgICAgIGhlYWRlcnM6IG1lcmdlSGVhZGVycyhiYXNlSGVhZGVycywgaGVhZGVycywgcGFyYW1zLmhlYWRlciksXG4gICAgfTtcbiAgICBpZiAocmVxdWVzdEluaXQuYm9keSkge1xuICAgICAgcmVxdWVzdEluaXQuYm9keSA9IGJvZHlTZXJpYWxpemVyKHJlcXVlc3RJbml0LmJvZHkpO1xuICAgIH1cbiAgICAvLyByZW1vdmUgYENvbnRlbnQtVHlwZWAgaWYgc2VyaWFsaXplZCBib2R5IGlzIEZvcm1EYXRhOyBicm93c2VyIHdpbGwgY29ycmVjdGx5IHNldCBDb250ZW50LVR5cGUgJiBib3VuZGFyeSBleHByZXNzaW9uXG4gICAgaWYgKHJlcXVlc3RJbml0LmJvZHkgaW5zdGFuY2VvZiBGb3JtRGF0YSkge1xuICAgICAgcmVxdWVzdEluaXQuaGVhZGVycy5kZWxldGUoXCJDb250ZW50LVR5cGVcIik7XG4gICAgfVxuICAgIGxldCByZXF1ZXN0ID0gbmV3IEN1c3RvbVJlcXVlc3QoY3JlYXRlRmluYWxVUkwodXJsLCB7IGJhc2VVcmwsIHBhcmFtcywgcXVlcnlTZXJpYWxpemVyIH0pLCByZXF1ZXN0SW5pdCk7XG4gICAgLy8gbWlkZGxld2FyZSAocmVxdWVzdClcbiAgICBjb25zdCBtZXJnZWRPcHRpb25zID0ge1xuICAgICAgYmFzZVVybCxcbiAgICAgIGZldGNoLFxuICAgICAgcGFyc2VBcyxcbiAgICAgIHF1ZXJ5U2VyaWFsaXplcixcbiAgICAgIGJvZHlTZXJpYWxpemVyLFxuICAgIH07XG4gICAgZm9yIChjb25zdCBtIG9mIG1pZGRsZXdhcmVzKSB7XG4gICAgICBpZiAobSAmJiB0eXBlb2YgbSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbS5vblJlcXVlc3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXF1ZXN0LnNjaGVtYVBhdGggPSB1cmw7IC8vIChyZSlhdHRhY2ggb3JpZ2luYWwgVVJMXG4gICAgICAgIHJlcXVlc3QucGFyYW1zID0gcGFyYW1zOyAvLyAocmUpYXR0YWNoIHBhcmFtc1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBtLm9uUmVxdWVzdChyZXF1ZXN0LCBtZXJnZWRPcHRpb25zKTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgIGlmICghKHJlc3VsdCBpbnN0YW5jZW9mIFJlcXVlc3QpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaWRkbGV3YXJlIG11c3QgcmV0dXJuIG5ldyBSZXF1ZXN0KCkgd2hlbiBtb2RpZnlpbmcgdGhlIHJlcXVlc3RcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlcXVlc3QgPSByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBmZXRjaCFcbiAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChyZXF1ZXN0KTtcblxuICAgIC8vIG1pZGRsZXdhcmUgKHJlc3BvbnNlKVxuICAgIC8vIGV4ZWN1dGUgaW4gcmV2ZXJzZS1hcnJheSBvcmRlciAoZmlyc3QgcHJpb3JpdHkgZ2V0cyBsYXN0IHRyYW5zZm9ybSlcbiAgICBmb3IgKGxldCBpID0gbWlkZGxld2FyZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGNvbnN0IG0gPSBtaWRkbGV3YXJlc1tpXTtcbiAgICAgIGlmIChtICYmIHR5cGVvZiBtID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtLm9uUmVzcG9uc2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXF1ZXN0LnNjaGVtYVBhdGggPSB1cmw7IC8vIChyZSlhdHRhY2ggb3JpZ2luYWwgVVJMXG4gICAgICAgIHJlcXVlc3QucGFyYW1zID0gcGFyYW1zOyAvLyAocmUpYXR0YWNoIHBhcmFtc1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBtLm9uUmVzcG9uc2UocmVzcG9uc2UsIG1lcmdlZE9wdGlvbnMsIHJlcXVlc3QpO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgaWYgKCEocmVzdWx0IGluc3RhbmNlb2YgUmVzcG9uc2UpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaWRkbGV3YXJlIG11c3QgcmV0dXJuIG5ldyBSZXNwb25zZSgpIHdoZW4gbW9kaWZ5aW5nIHRoZSByZXNwb25zZVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzcG9uc2UgPSByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBoYW5kbGUgZW1wdHkgY29udGVudFxuICAgIC8vIG5vdGU6IHdlIHJldHVybiBge31gIGJlY2F1c2Ugd2Ugd2FudCB1c2VyIHRydXRoeSBjaGVja3MgZm9yIGAuZGF0YWAgb3IgYC5lcnJvcmAgdG8gc3VjY2VlZFxuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwNCB8fCByZXNwb25zZS5oZWFkZXJzLmdldChcIkNvbnRlbnQtTGVuZ3RoXCIpID09PSBcIjBcIikge1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLm9rID8geyBkYXRhOiB7fSwgcmVzcG9uc2UgfSA6IHsgZXJyb3I6IHt9LCByZXNwb25zZSB9O1xuICAgIH1cblxuICAgIC8vIHBhcnNlIHJlc3BvbnNlIChmYWxsaW5nIGJhY2sgdG8gLnRleHQoKSB3aGVuIG5lY2Vzc2FyeSlcbiAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgIC8vIGlmIFwic3RyZWFtXCIsIHNraXAgcGFyc2luZyBlbnRpcmVseVxuICAgICAgaWYgKHBhcnNlQXMgPT09IFwic3RyZWFtXCIpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogcmVzcG9uc2UuYm9keSwgcmVzcG9uc2UgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IGRhdGE6IGF3YWl0IHJlc3BvbnNlW3BhcnNlQXNdKCksIHJlc3BvbnNlIH07XG4gICAgfVxuXG4gICAgLy8gaGFuZGxlIGVycm9yc1xuICAgIGxldCBlcnJvciA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICB0cnkge1xuICAgICAgZXJyb3IgPSBKU09OLnBhcnNlKGVycm9yKTsgLy8gYXR0ZW1wdCB0byBwYXJzZSBhcyBKU09OXG4gICAgfSBjYXRjaCB7XG4gICAgICAvLyBub29wXG4gICAgfVxuICAgIHJldHVybiB7IGVycm9yLCByZXNwb25zZSB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAvKiogQ2FsbCBhIEdFVCBlbmRwb2ludCAqL1xuICAgIGFzeW5jIEdFVCh1cmwsIGluaXQpIHtcbiAgICAgIHJldHVybiBjb3JlRmV0Y2godXJsLCB7IC4uLmluaXQsIG1ldGhvZDogXCJHRVRcIiB9KTtcbiAgICB9LFxuICAgIC8qKiBDYWxsIGEgUFVUIGVuZHBvaW50ICovXG4gICAgYXN5bmMgUFVUKHVybCwgaW5pdCkge1xuICAgICAgcmV0dXJuIGNvcmVGZXRjaCh1cmwsIHsgLi4uaW5pdCwgbWV0aG9kOiBcIlBVVFwiIH0pO1xuICAgIH0sXG4gICAgLyoqIENhbGwgYSBQT1NUIGVuZHBvaW50ICovXG4gICAgYXN5bmMgUE9TVCh1cmwsIGluaXQpIHtcbiAgICAgIHJldHVybiBjb3JlRmV0Y2godXJsLCB7IC4uLmluaXQsIG1ldGhvZDogXCJQT1NUXCIgfSk7XG4gICAgfSxcbiAgICAvKiogQ2FsbCBhIERFTEVURSBlbmRwb2ludCAqL1xuICAgIGFzeW5jIERFTEVURSh1cmwsIGluaXQpIHtcbiAgICAgIHJldHVybiBjb3JlRmV0Y2godXJsLCB7IC4uLmluaXQsIG1ldGhvZDogXCJERUxFVEVcIiB9KTtcbiAgICB9LFxuICAgIC8qKiBDYWxsIGEgT1BUSU9OUyBlbmRwb2ludCAqL1xuICAgIGFzeW5jIE9QVElPTlModXJsLCBpbml0KSB7XG4gICAgICByZXR1cm4gY29yZUZldGNoKHVybCwgeyAuLi5pbml0LCBtZXRob2Q6IFwiT1BUSU9OU1wiIH0pO1xuICAgIH0sXG4gICAgLyoqIENhbGwgYSBIRUFEIGVuZHBvaW50ICovXG4gICAgYXN5bmMgSEVBRCh1cmwsIGluaXQpIHtcbiAgICAgIHJldHVybiBjb3JlRmV0Y2godXJsLCB7IC4uLmluaXQsIG1ldGhvZDogXCJIRUFEXCIgfSk7XG4gICAgfSxcbiAgICAvKiogQ2FsbCBhIFBBVENIIGVuZHBvaW50ICovXG4gICAgYXN5bmMgUEFUQ0godXJsLCBpbml0KSB7XG4gICAgICByZXR1cm4gY29yZUZldGNoKHVybCwgeyAuLi5pbml0LCBtZXRob2Q6IFwiUEFUQ0hcIiB9KTtcbiAgICB9LFxuICAgIC8qKiBDYWxsIGEgVFJBQ0UgZW5kcG9pbnQgKi9cbiAgICBhc3luYyBUUkFDRSh1cmwsIGluaXQpIHtcbiAgICAgIHJldHVybiBjb3JlRmV0Y2godXJsLCB7IC4uLmluaXQsIG1ldGhvZDogXCJUUkFDRVwiIH0pO1xuICAgIH0sXG4gICAgLyoqIFJlZ2lzdGVyIG1pZGRsZXdhcmUgKi9cbiAgICB1c2UoLi4ubWlkZGxld2FyZSkge1xuICAgICAgZm9yIChjb25zdCBtIG9mIG1pZGRsZXdhcmUpIHtcbiAgICAgICAgaWYgKCFtKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBtICE9PSBcIm9iamVjdFwiIHx8ICEoXCJvblJlcXVlc3RcIiBpbiBtIHx8IFwib25SZXNwb25zZVwiIGluIG0pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlkZGxld2FyZSBtdXN0IGJlIGFuIG9iamVjdCB3aXRoIG9uZSBvZiBgb25SZXF1ZXN0KClgIG9yIGBvblJlc3BvbnNlKClgXCIpO1xuICAgICAgICB9XG4gICAgICAgIG1pZGRsZXdhcmVzLnB1c2gobSk7XG4gICAgICB9XG4gICAgfSxcbiAgICAvKiogVW5yZWdpc3RlciBtaWRkbGV3YXJlICovXG4gICAgZWplY3QoLi4ubWlkZGxld2FyZSkge1xuICAgICAgZm9yIChjb25zdCBtIG9mIG1pZGRsZXdhcmUpIHtcbiAgICAgICAgY29uc3QgaSA9IG1pZGRsZXdhcmVzLmluZGV4T2YobSk7XG4gICAgICAgIGlmIChpICE9PSAtMSkge1xuICAgICAgICAgIG1pZGRsZXdhcmVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gIH07XG59XG5cbi8vIHV0aWxzXG5cbi8qKlxuICogU2VyaWFsaXplIHByaW1pdGl2ZSBwYXJhbSB2YWx1ZXNcbiAqIEB0eXBlIHtpbXBvcnQoXCIuL2luZGV4LmpzXCIpLnNlcmlhbGl6ZVByaW1pdGl2ZVBhcmFtfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2VyaWFsaXplUHJpbWl0aXZlUGFyYW0obmFtZSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJEZWVwbHktbmVzdGVkIGFycmF5cy9vYmplY3RzIGFyZW7igJl0IHN1cHBvcnRlZC4gUHJvdmlkZSB5b3VyIG93biBgcXVlcnlTZXJpYWxpemVyKClgIHRvIGhhbmRsZSB0aGVzZS5cIixcbiAgICApO1xuICB9XG4gIHJldHVybiBgJHtuYW1lfT0ke29wdGlvbnM/LmFsbG93UmVzZXJ2ZWQgPT09IHRydWUgPyB2YWx1ZSA6IGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSl9YDtcbn1cblxuLyoqXG4gKiBTZXJpYWxpemUgb2JqZWN0IHBhcmFtIChzaGFsbG93IG9ubHkpXG4gKiBAdHlwZSB7aW1wb3J0KFwiLi9pbmRleC5qc1wiKS5zZXJpYWxpemVPYmplY3RQYXJhbX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlcmlhbGl6ZU9iamVjdFBhcmFtKG5hbWUsIHZhbHVlLCBvcHRpb25zKSB7XG4gIGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgY29uc3QgdmFsdWVzID0gW107XG4gIGNvbnN0IGpvaW5lciA9XG4gICAge1xuICAgICAgc2ltcGxlOiBcIixcIixcbiAgICAgIGxhYmVsOiBcIi5cIixcbiAgICAgIG1hdHJpeDogXCI7XCIsXG4gICAgfVtvcHRpb25zLnN0eWxlXSB8fCBcIiZcIjtcblxuICAvLyBleHBsb2RlOiBmYWxzZVxuICBpZiAob3B0aW9ucy5zdHlsZSAhPT0gXCJkZWVwT2JqZWN0XCIgJiYgb3B0aW9ucy5leHBsb2RlID09PSBmYWxzZSkge1xuICAgIGZvciAoY29uc3QgayBpbiB2YWx1ZSkge1xuICAgICAgdmFsdWVzLnB1c2goaywgb3B0aW9ucy5hbGxvd1Jlc2VydmVkID09PSB0cnVlID8gdmFsdWVba10gOiBlbmNvZGVVUklDb21wb25lbnQodmFsdWVba10pKTtcbiAgICB9XG4gICAgY29uc3QgZmluYWwgPSB2YWx1ZXMuam9pbihcIixcIik7IC8vIG5vdGU6IHZhbHVlcyBhcmUgYWx3YXlzIGpvaW5lZCBieSBjb21tYSBpbiBleHBsb2RlOiBmYWxzZSAoYnV0IGpvaW5lciBjYW4gcHJlZml4KVxuICAgIHN3aXRjaCAob3B0aW9ucy5zdHlsZSkge1xuICAgICAgY2FzZSBcImZvcm1cIjoge1xuICAgICAgICByZXR1cm4gYCR7bmFtZX09JHtmaW5hbH1gO1xuICAgICAgfVxuICAgICAgY2FzZSBcImxhYmVsXCI6IHtcbiAgICAgICAgcmV0dXJuIGAuJHtmaW5hbH1gO1xuICAgICAgfVxuICAgICAgY2FzZSBcIm1hdHJpeFwiOiB7XG4gICAgICAgIHJldHVybiBgOyR7bmFtZX09JHtmaW5hbH1gO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICByZXR1cm4gZmluYWw7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gZXhwbG9kZTogdHJ1ZVxuICBmb3IgKGNvbnN0IGsgaW4gdmFsdWUpIHtcbiAgICBjb25zdCBmaW5hbE5hbWUgPSBvcHRpb25zLnN0eWxlID09PSBcImRlZXBPYmplY3RcIiA/IGAke25hbWV9WyR7a31dYCA6IGs7XG4gICAgdmFsdWVzLnB1c2goc2VyaWFsaXplUHJpbWl0aXZlUGFyYW0oZmluYWxOYW1lLCB2YWx1ZVtrXSwgb3B0aW9ucykpO1xuICB9XG4gIGNvbnN0IGZpbmFsID0gdmFsdWVzLmpvaW4oam9pbmVyKTtcbiAgcmV0dXJuIG9wdGlvbnMuc3R5bGUgPT09IFwibGFiZWxcIiB8fCBvcHRpb25zLnN0eWxlID09PSBcIm1hdHJpeFwiID8gYCR7am9pbmVyfSR7ZmluYWx9YCA6IGZpbmFsO1xufVxuXG4vKipcbiAqIFNlcmlhbGl6ZSBhcnJheSBwYXJhbSAoc2hhbGxvdyBvbmx5KVxuICogQHR5cGUge2ltcG9ydChcIi4vaW5kZXguanNcIikuc2VyaWFsaXplQXJyYXlQYXJhbX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlcmlhbGl6ZUFycmF5UGFyYW0obmFtZSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG5cbiAgLy8gZXhwbG9kZTogZmFsc2VcbiAgaWYgKG9wdGlvbnMuZXhwbG9kZSA9PT0gZmFsc2UpIHtcbiAgICBjb25zdCBqb2luZXIgPSB7IGZvcm06IFwiLFwiLCBzcGFjZURlbGltaXRlZDogXCIlMjBcIiwgcGlwZURlbGltaXRlZDogXCJ8XCIgfVtvcHRpb25zLnN0eWxlXSB8fCBcIixcIjsgLy8gbm90ZTogZm9yIGFycmF5cywgam9pbmVycyB2YXJ5IHdpbGRseSBiYXNlZCBvbiBzdHlsZSArIGV4cGxvZGUgYmVoYXZpb3JcbiAgICBjb25zdCBmaW5hbCA9IChvcHRpb25zLmFsbG93UmVzZXJ2ZWQgPT09IHRydWUgPyB2YWx1ZSA6IHZhbHVlLm1hcCgodikgPT4gZW5jb2RlVVJJQ29tcG9uZW50KHYpKSkuam9pbihqb2luZXIpO1xuICAgIHN3aXRjaCAob3B0aW9ucy5zdHlsZSkge1xuICAgICAgY2FzZSBcInNpbXBsZVwiOiB7XG4gICAgICAgIHJldHVybiBmaW5hbDtcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJsYWJlbFwiOiB7XG4gICAgICAgIHJldHVybiBgLiR7ZmluYWx9YDtcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJtYXRyaXhcIjoge1xuICAgICAgICByZXR1cm4gYDske25hbWV9PSR7ZmluYWx9YDtcbiAgICAgIH1cbiAgICAgIC8vIGNhc2UgXCJzcGFjZURlbGltaXRlZFwiOlxuICAgICAgLy8gY2FzZSBcInBpcGVEZWxpbWl0ZWRcIjpcbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgcmV0dXJuIGAke25hbWV9PSR7ZmluYWx9YDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBleHBsb2RlOiB0cnVlXG4gIGNvbnN0IGpvaW5lciA9IHsgc2ltcGxlOiBcIixcIiwgbGFiZWw6IFwiLlwiLCBtYXRyaXg6IFwiO1wiIH1bb3B0aW9ucy5zdHlsZV0gfHwgXCImXCI7XG4gIGNvbnN0IHZhbHVlcyA9IFtdO1xuICBmb3IgKGNvbnN0IHYgb2YgdmFsdWUpIHtcbiAgICBpZiAob3B0aW9ucy5zdHlsZSA9PT0gXCJzaW1wbGVcIiB8fCBvcHRpb25zLnN0eWxlID09PSBcImxhYmVsXCIpIHtcbiAgICAgIHZhbHVlcy5wdXNoKG9wdGlvbnMuYWxsb3dSZXNlcnZlZCA9PT0gdHJ1ZSA/IHYgOiBlbmNvZGVVUklDb21wb25lbnQodikpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZXMucHVzaChzZXJpYWxpemVQcmltaXRpdmVQYXJhbShuYW1lLCB2LCBvcHRpb25zKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvcHRpb25zLnN0eWxlID09PSBcImxhYmVsXCIgfHwgb3B0aW9ucy5zdHlsZSA9PT0gXCJtYXRyaXhcIlxuICAgID8gYCR7am9pbmVyfSR7dmFsdWVzLmpvaW4oam9pbmVyKX1gXG4gICAgOiB2YWx1ZXMuam9pbihqb2luZXIpO1xufVxuXG4vKipcbiAqIFNlcmlhbGl6ZSBxdWVyeSBwYXJhbXMgdG8gc3RyaW5nXG4gKiBAdHlwZSB7aW1wb3J0KFwiLi9pbmRleC5qc1wiKS5jcmVhdGVRdWVyeVNlcmlhbGl6ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVRdWVyeVNlcmlhbGl6ZXIob3B0aW9ucykge1xuICByZXR1cm4gZnVuY3Rpb24gcXVlcnlTZXJpYWxpemVyKHF1ZXJ5UGFyYW1zKSB7XG4gICAgY29uc3Qgc2VhcmNoID0gW107XG4gICAgaWYgKHF1ZXJ5UGFyYW1zICYmIHR5cGVvZiBxdWVyeVBhcmFtcyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgZm9yIChjb25zdCBuYW1lIGluIHF1ZXJ5UGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcXVlcnlQYXJhbXNbbmFtZV07XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgc2VhcmNoLnB1c2goXG4gICAgICAgICAgICBzZXJpYWxpemVBcnJheVBhcmFtKG5hbWUsIHZhbHVlLCB7XG4gICAgICAgICAgICAgIHN0eWxlOiBcImZvcm1cIixcbiAgICAgICAgICAgICAgZXhwbG9kZTogdHJ1ZSxcbiAgICAgICAgICAgICAgLi4ub3B0aW9ucz8uYXJyYXksXG4gICAgICAgICAgICAgIGFsbG93UmVzZXJ2ZWQ6IG9wdGlvbnM/LmFsbG93UmVzZXJ2ZWQgfHwgZmFsc2UsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICBzZWFyY2gucHVzaChcbiAgICAgICAgICAgIHNlcmlhbGl6ZU9iamVjdFBhcmFtKG5hbWUsIHZhbHVlLCB7XG4gICAgICAgICAgICAgIHN0eWxlOiBcImRlZXBPYmplY3RcIixcbiAgICAgICAgICAgICAgZXhwbG9kZTogdHJ1ZSxcbiAgICAgICAgICAgICAgLi4ub3B0aW9ucz8ub2JqZWN0LFxuICAgICAgICAgICAgICBhbGxvd1Jlc2VydmVkOiBvcHRpb25zPy5hbGxvd1Jlc2VydmVkIHx8IGZhbHNlLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBzZWFyY2gucHVzaChzZXJpYWxpemVQcmltaXRpdmVQYXJhbShuYW1lLCB2YWx1ZSwgb3B0aW9ucykpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VhcmNoLmpvaW4oXCImXCIpO1xuICB9O1xufVxuXG4vKipcbiAqIEhhbmRsZSBkaWZmZXJlbnQgT3BlbkFQSSAzLnggc2VyaWFsaXphdGlvbiBzdHlsZXNcbiAqIEB0eXBlIHtpbXBvcnQoXCIuL2luZGV4LmpzXCIpLmRlZmF1bHRQYXRoU2VyaWFsaXplcn1cbiAqIEBzZWUgaHR0cHM6Ly9zd2FnZ2VyLmlvL2RvY3Mvc3BlY2lmaWNhdGlvbi9zZXJpYWxpemF0aW9uLyNwYXRoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UGF0aFNlcmlhbGl6ZXIocGF0aG5hbWUsIHBhdGhQYXJhbXMpIHtcbiAgbGV0IG5leHRVUkwgPSBwYXRobmFtZTtcbiAgZm9yIChjb25zdCBtYXRjaCBvZiBwYXRobmFtZS5tYXRjaChQQVRIX1BBUkFNX1JFKSA/PyBbXSkge1xuICAgIGxldCBuYW1lID0gbWF0Y2guc3Vic3RyaW5nKDEsIG1hdGNoLmxlbmd0aCAtIDEpO1xuICAgIGxldCBleHBsb2RlID0gZmFsc2U7XG4gICAgbGV0IHN0eWxlID0gXCJzaW1wbGVcIjtcbiAgICBpZiAobmFtZS5lbmRzV2l0aChcIipcIikpIHtcbiAgICAgIGV4cGxvZGUgPSB0cnVlO1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyaW5nKDAsIG5hbWUubGVuZ3RoIC0gMSk7XG4gICAgfVxuICAgIGlmIChuYW1lLnN0YXJ0c1dpdGgoXCIuXCIpKSB7XG4gICAgICBzdHlsZSA9IFwibGFiZWxcIjtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cmluZygxKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUuc3RhcnRzV2l0aChcIjtcIikpIHtcbiAgICAgIHN0eWxlID0gXCJtYXRyaXhcIjtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cmluZygxKTtcbiAgICB9XG4gICAgaWYgKCFwYXRoUGFyYW1zIHx8IHBhdGhQYXJhbXNbbmFtZV0gPT09IHVuZGVmaW5lZCB8fCBwYXRoUGFyYW1zW25hbWVdID09PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSBwYXRoUGFyYW1zW25hbWVdO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgbmV4dFVSTCA9IG5leHRVUkwucmVwbGFjZShtYXRjaCwgc2VyaWFsaXplQXJyYXlQYXJhbShuYW1lLCB2YWx1ZSwgeyBzdHlsZSwgZXhwbG9kZSB9KSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgbmV4dFVSTCA9IG5leHRVUkwucmVwbGFjZShtYXRjaCwgc2VyaWFsaXplT2JqZWN0UGFyYW0obmFtZSwgdmFsdWUsIHsgc3R5bGUsIGV4cGxvZGUgfSkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChzdHlsZSA9PT0gXCJtYXRyaXhcIikge1xuICAgICAgbmV4dFVSTCA9IG5leHRVUkwucmVwbGFjZShtYXRjaCwgYDske3NlcmlhbGl6ZVByaW1pdGl2ZVBhcmFtKG5hbWUsIHZhbHVlKX1gKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBuZXh0VVJMID0gbmV4dFVSTC5yZXBsYWNlKG1hdGNoLCBzdHlsZSA9PT0gXCJsYWJlbFwiID8gYC4ke3ZhbHVlfWAgOiB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIG5leHRVUkw7XG59XG5cbi8qKlxuICogU2VyaWFsaXplIGJvZHkgb2JqZWN0IHRvIHN0cmluZ1xuICogQHR5cGUge2ltcG9ydChcIi4vaW5kZXguanNcIikuZGVmYXVsdEJvZHlTZXJpYWxpemVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdEJvZHlTZXJpYWxpemVyKGJvZHkpIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGJvZHkpO1xufVxuXG4vKipcbiAqIENvbnN0cnVjdCBVUkwgc3RyaW5nIGZyb20gYmFzZVVybCBhbmQgaGFuZGxlIHBhdGggYW5kIHF1ZXJ5IHBhcmFtc1xuICogQHR5cGUge2ltcG9ydChcIi4vaW5kZXguanNcIikuY3JlYXRlRmluYWxVUkx9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGaW5hbFVSTChwYXRobmFtZSwgb3B0aW9ucykge1xuICBsZXQgZmluYWxVUkwgPSBgJHtvcHRpb25zLmJhc2VVcmx9JHtwYXRobmFtZX1gO1xuICBpZiAob3B0aW9ucy5wYXJhbXM/LnBhdGgpIHtcbiAgICBmaW5hbFVSTCA9IGRlZmF1bHRQYXRoU2VyaWFsaXplcihmaW5hbFVSTCwgb3B0aW9ucy5wYXJhbXMucGF0aCk7XG4gIH1cbiAgbGV0IHNlYXJjaCA9IG9wdGlvbnMucXVlcnlTZXJpYWxpemVyKG9wdGlvbnMucGFyYW1zLnF1ZXJ5ID8/IHt9KTtcbiAgaWYgKHNlYXJjaC5zdGFydHNXaXRoKFwiP1wiKSkge1xuICAgIHNlYXJjaCA9IHNlYXJjaC5zdWJzdHJpbmcoMSk7XG4gIH1cbiAgaWYgKHNlYXJjaCkge1xuICAgIGZpbmFsVVJMICs9IGA/JHtzZWFyY2h9YDtcbiAgfVxuICByZXR1cm4gZmluYWxVUkw7XG59XG5cbi8qKlxuICogTWVyZ2UgaGVhZGVycyBhIGFuZCBiLCB3aXRoIGIgdGFraW5nIHByaW9yaXR5XG4gKiBAdHlwZSB7aW1wb3J0KFwiLi9pbmRleC5qc1wiKS5tZXJnZUhlYWRlcnN9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUhlYWRlcnMoLi4uYWxsSGVhZGVycykge1xuICBjb25zdCBmaW5hbEhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xuICBmb3IgKGNvbnN0IGggb2YgYWxsSGVhZGVycykge1xuICAgIGlmICghaCB8fCB0eXBlb2YgaCAhPT0gXCJvYmplY3RcIikge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGl0ZXJhdG9yID0gaCBpbnN0YW5jZW9mIEhlYWRlcnMgPyBoLmVudHJpZXMoKSA6IE9iamVjdC5lbnRyaWVzKGgpO1xuICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIGl0ZXJhdG9yKSB7XG4gICAgICBpZiAodiA9PT0gbnVsbCkge1xuICAgICAgICBmaW5hbEhlYWRlcnMuZGVsZXRlKGspO1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgICAgIGZvciAoY29uc3QgdjIgb2Ygdikge1xuICAgICAgICAgIGZpbmFsSGVhZGVycy5hcHBlbmQoaywgdjIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBmaW5hbEhlYWRlcnMuc2V0KGssIHYpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmluYWxIZWFkZXJzO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/openapi-fetch/dist/index.js\n");

/***/ })

};
;