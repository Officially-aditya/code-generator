"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/minizlib";
exports.ids = ["vendor-chunks/minizlib"];
exports.modules = {

/***/ "(rsc)/./node_modules/minizlib/dist/esm/constants.js":
/*!*****************************************************!*\
  !*** ./node_modules/minizlib/dist/esm/constants.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   constants: () => (/* binding */ constants)\n/* harmony export */ });\n/* harmony import */ var zlib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zlib */ \"zlib\");\n// Update with any zlib constants that are added or changed in the future.\n// Node v6 didn't export this, so we just hard code the version and rely\n// on all the other hard-coded values from zlib v4736.  When node v6\n// support drops, we can just export the realZlibConstants object.\n\n/* c8 ignore start */\nconst realZlibConstants = zlib__WEBPACK_IMPORTED_MODULE_0__.constants || { ZLIB_VERNUM: 4736 };\n/* c8 ignore stop */\nconst constants = Object.freeze(Object.assign(Object.create(null), {\n    Z_NO_FLUSH: 0,\n    Z_PARTIAL_FLUSH: 1,\n    Z_SYNC_FLUSH: 2,\n    Z_FULL_FLUSH: 3,\n    Z_FINISH: 4,\n    Z_BLOCK: 5,\n    Z_OK: 0,\n    Z_STREAM_END: 1,\n    Z_NEED_DICT: 2,\n    Z_ERRNO: -1,\n    Z_STREAM_ERROR: -2,\n    Z_DATA_ERROR: -3,\n    Z_MEM_ERROR: -4,\n    Z_BUF_ERROR: -5,\n    Z_VERSION_ERROR: -6,\n    Z_NO_COMPRESSION: 0,\n    Z_BEST_SPEED: 1,\n    Z_BEST_COMPRESSION: 9,\n    Z_DEFAULT_COMPRESSION: -1,\n    Z_FILTERED: 1,\n    Z_HUFFMAN_ONLY: 2,\n    Z_RLE: 3,\n    Z_FIXED: 4,\n    Z_DEFAULT_STRATEGY: 0,\n    DEFLATE: 1,\n    INFLATE: 2,\n    GZIP: 3,\n    GUNZIP: 4,\n    DEFLATERAW: 5,\n    INFLATERAW: 6,\n    UNZIP: 7,\n    BROTLI_DECODE: 8,\n    BROTLI_ENCODE: 9,\n    Z_MIN_WINDOWBITS: 8,\n    Z_MAX_WINDOWBITS: 15,\n    Z_DEFAULT_WINDOWBITS: 15,\n    Z_MIN_CHUNK: 64,\n    Z_MAX_CHUNK: Infinity,\n    Z_DEFAULT_CHUNK: 16384,\n    Z_MIN_MEMLEVEL: 1,\n    Z_MAX_MEMLEVEL: 9,\n    Z_DEFAULT_MEMLEVEL: 8,\n    Z_MIN_LEVEL: -1,\n    Z_MAX_LEVEL: 9,\n    Z_DEFAULT_LEVEL: -1,\n    BROTLI_OPERATION_PROCESS: 0,\n    BROTLI_OPERATION_FLUSH: 1,\n    BROTLI_OPERATION_FINISH: 2,\n    BROTLI_OPERATION_EMIT_METADATA: 3,\n    BROTLI_MODE_GENERIC: 0,\n    BROTLI_MODE_TEXT: 1,\n    BROTLI_MODE_FONT: 2,\n    BROTLI_DEFAULT_MODE: 0,\n    BROTLI_MIN_QUALITY: 0,\n    BROTLI_MAX_QUALITY: 11,\n    BROTLI_DEFAULT_QUALITY: 11,\n    BROTLI_MIN_WINDOW_BITS: 10,\n    BROTLI_MAX_WINDOW_BITS: 24,\n    BROTLI_LARGE_MAX_WINDOW_BITS: 30,\n    BROTLI_DEFAULT_WINDOW: 22,\n    BROTLI_MIN_INPUT_BLOCK_BITS: 16,\n    BROTLI_MAX_INPUT_BLOCK_BITS: 24,\n    BROTLI_PARAM_MODE: 0,\n    BROTLI_PARAM_QUALITY: 1,\n    BROTLI_PARAM_LGWIN: 2,\n    BROTLI_PARAM_LGBLOCK: 3,\n    BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,\n    BROTLI_PARAM_SIZE_HINT: 5,\n    BROTLI_PARAM_LARGE_WINDOW: 6,\n    BROTLI_PARAM_NPOSTFIX: 7,\n    BROTLI_PARAM_NDIRECT: 8,\n    BROTLI_DECODER_RESULT_ERROR: 0,\n    BROTLI_DECODER_RESULT_SUCCESS: 1,\n    BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,\n    BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,\n    BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,\n    BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,\n    BROTLI_DECODER_NO_ERROR: 0,\n    BROTLI_DECODER_SUCCESS: 1,\n    BROTLI_DECODER_NEEDS_MORE_INPUT: 2,\n    BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,\n    BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,\n    BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,\n    BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,\n    BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,\n    BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,\n    BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,\n    BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,\n    BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,\n    BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,\n    BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,\n    BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,\n    BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,\n    BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,\n    BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,\n    BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,\n    BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,\n    BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,\n    BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,\n    BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,\n    BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,\n    BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,\n    BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,\n    BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,\n    BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,\n    BROTLI_DECODER_ERROR_UNREACHABLE: -31,\n}, realZlibConstants));\n//# sourceMappingURL=constants.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWluaXpsaWIvZGlzdC9lc20vY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDNEI7QUFDNUI7QUFDQSwwQkFBMEIsMkNBQWtCLE1BQU07QUFDbEQ7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdml2ZS12aWJlLWFpLW5leHQvLi9ub2RlX21vZHVsZXMvbWluaXpsaWIvZGlzdC9lc20vY29uc3RhbnRzLmpzPzM2MDMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVXBkYXRlIHdpdGggYW55IHpsaWIgY29uc3RhbnRzIHRoYXQgYXJlIGFkZGVkIG9yIGNoYW5nZWQgaW4gdGhlIGZ1dHVyZS5cbi8vIE5vZGUgdjYgZGlkbid0IGV4cG9ydCB0aGlzLCBzbyB3ZSBqdXN0IGhhcmQgY29kZSB0aGUgdmVyc2lvbiBhbmQgcmVseVxuLy8gb24gYWxsIHRoZSBvdGhlciBoYXJkLWNvZGVkIHZhbHVlcyBmcm9tIHpsaWIgdjQ3MzYuICBXaGVuIG5vZGUgdjZcbi8vIHN1cHBvcnQgZHJvcHMsIHdlIGNhbiBqdXN0IGV4cG9ydCB0aGUgcmVhbFpsaWJDb25zdGFudHMgb2JqZWN0LlxuaW1wb3J0IHJlYWxabGliIGZyb20gJ3psaWInO1xuLyogYzggaWdub3JlIHN0YXJ0ICovXG5jb25zdCByZWFsWmxpYkNvbnN0YW50cyA9IHJlYWxabGliLmNvbnN0YW50cyB8fCB7IFpMSUJfVkVSTlVNOiA0NzM2IH07XG4vKiBjOCBpZ25vcmUgc3RvcCAqL1xuZXhwb3J0IGNvbnN0IGNvbnN0YW50cyA9IE9iamVjdC5mcmVlemUoT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCB7XG4gICAgWl9OT19GTFVTSDogMCxcbiAgICBaX1BBUlRJQUxfRkxVU0g6IDEsXG4gICAgWl9TWU5DX0ZMVVNIOiAyLFxuICAgIFpfRlVMTF9GTFVTSDogMyxcbiAgICBaX0ZJTklTSDogNCxcbiAgICBaX0JMT0NLOiA1LFxuICAgIFpfT0s6IDAsXG4gICAgWl9TVFJFQU1fRU5EOiAxLFxuICAgIFpfTkVFRF9ESUNUOiAyLFxuICAgIFpfRVJSTk86IC0xLFxuICAgIFpfU1RSRUFNX0VSUk9SOiAtMixcbiAgICBaX0RBVEFfRVJST1I6IC0zLFxuICAgIFpfTUVNX0VSUk9SOiAtNCxcbiAgICBaX0JVRl9FUlJPUjogLTUsXG4gICAgWl9WRVJTSU9OX0VSUk9SOiAtNixcbiAgICBaX05PX0NPTVBSRVNTSU9OOiAwLFxuICAgIFpfQkVTVF9TUEVFRDogMSxcbiAgICBaX0JFU1RfQ09NUFJFU1NJT046IDksXG4gICAgWl9ERUZBVUxUX0NPTVBSRVNTSU9OOiAtMSxcbiAgICBaX0ZJTFRFUkVEOiAxLFxuICAgIFpfSFVGRk1BTl9PTkxZOiAyLFxuICAgIFpfUkxFOiAzLFxuICAgIFpfRklYRUQ6IDQsXG4gICAgWl9ERUZBVUxUX1NUUkFURUdZOiAwLFxuICAgIERFRkxBVEU6IDEsXG4gICAgSU5GTEFURTogMixcbiAgICBHWklQOiAzLFxuICAgIEdVTlpJUDogNCxcbiAgICBERUZMQVRFUkFXOiA1LFxuICAgIElORkxBVEVSQVc6IDYsXG4gICAgVU5aSVA6IDcsXG4gICAgQlJPVExJX0RFQ09ERTogOCxcbiAgICBCUk9UTElfRU5DT0RFOiA5LFxuICAgIFpfTUlOX1dJTkRPV0JJVFM6IDgsXG4gICAgWl9NQVhfV0lORE9XQklUUzogMTUsXG4gICAgWl9ERUZBVUxUX1dJTkRPV0JJVFM6IDE1LFxuICAgIFpfTUlOX0NIVU5LOiA2NCxcbiAgICBaX01BWF9DSFVOSzogSW5maW5pdHksXG4gICAgWl9ERUZBVUxUX0NIVU5LOiAxNjM4NCxcbiAgICBaX01JTl9NRU1MRVZFTDogMSxcbiAgICBaX01BWF9NRU1MRVZFTDogOSxcbiAgICBaX0RFRkFVTFRfTUVNTEVWRUw6IDgsXG4gICAgWl9NSU5fTEVWRUw6IC0xLFxuICAgIFpfTUFYX0xFVkVMOiA5LFxuICAgIFpfREVGQVVMVF9MRVZFTDogLTEsXG4gICAgQlJPVExJX09QRVJBVElPTl9QUk9DRVNTOiAwLFxuICAgIEJST1RMSV9PUEVSQVRJT05fRkxVU0g6IDEsXG4gICAgQlJPVExJX09QRVJBVElPTl9GSU5JU0g6IDIsXG4gICAgQlJPVExJX09QRVJBVElPTl9FTUlUX01FVEFEQVRBOiAzLFxuICAgIEJST1RMSV9NT0RFX0dFTkVSSUM6IDAsXG4gICAgQlJPVExJX01PREVfVEVYVDogMSxcbiAgICBCUk9UTElfTU9ERV9GT05UOiAyLFxuICAgIEJST1RMSV9ERUZBVUxUX01PREU6IDAsXG4gICAgQlJPVExJX01JTl9RVUFMSVRZOiAwLFxuICAgIEJST1RMSV9NQVhfUVVBTElUWTogMTEsXG4gICAgQlJPVExJX0RFRkFVTFRfUVVBTElUWTogMTEsXG4gICAgQlJPVExJX01JTl9XSU5ET1dfQklUUzogMTAsXG4gICAgQlJPVExJX01BWF9XSU5ET1dfQklUUzogMjQsXG4gICAgQlJPVExJX0xBUkdFX01BWF9XSU5ET1dfQklUUzogMzAsXG4gICAgQlJPVExJX0RFRkFVTFRfV0lORE9XOiAyMixcbiAgICBCUk9UTElfTUlOX0lOUFVUX0JMT0NLX0JJVFM6IDE2LFxuICAgIEJST1RMSV9NQVhfSU5QVVRfQkxPQ0tfQklUUzogMjQsXG4gICAgQlJPVExJX1BBUkFNX01PREU6IDAsXG4gICAgQlJPVExJX1BBUkFNX1FVQUxJVFk6IDEsXG4gICAgQlJPVExJX1BBUkFNX0xHV0lOOiAyLFxuICAgIEJST1RMSV9QQVJBTV9MR0JMT0NLOiAzLFxuICAgIEJST1RMSV9QQVJBTV9ESVNBQkxFX0xJVEVSQUxfQ09OVEVYVF9NT0RFTElORzogNCxcbiAgICBCUk9UTElfUEFSQU1fU0laRV9ISU5UOiA1LFxuICAgIEJST1RMSV9QQVJBTV9MQVJHRV9XSU5ET1c6IDYsXG4gICAgQlJPVExJX1BBUkFNX05QT1NURklYOiA3LFxuICAgIEJST1RMSV9QQVJBTV9ORElSRUNUOiA4LFxuICAgIEJST1RMSV9ERUNPREVSX1JFU1VMVF9FUlJPUjogMCxcbiAgICBCUk9UTElfREVDT0RFUl9SRVNVTFRfU1VDQ0VTUzogMSxcbiAgICBCUk9UTElfREVDT0RFUl9SRVNVTFRfTkVFRFNfTU9SRV9JTlBVVDogMixcbiAgICBCUk9UTElfREVDT0RFUl9SRVNVTFRfTkVFRFNfTU9SRV9PVVRQVVQ6IDMsXG4gICAgQlJPVExJX0RFQ09ERVJfUEFSQU1fRElTQUJMRV9SSU5HX0JVRkZFUl9SRUFMTE9DQVRJT046IDAsXG4gICAgQlJPVExJX0RFQ09ERVJfUEFSQU1fTEFSR0VfV0lORE9XOiAxLFxuICAgIEJST1RMSV9ERUNPREVSX05PX0VSUk9SOiAwLFxuICAgIEJST1RMSV9ERUNPREVSX1NVQ0NFU1M6IDEsXG4gICAgQlJPVExJX0RFQ09ERVJfTkVFRFNfTU9SRV9JTlBVVDogMixcbiAgICBCUk9UTElfREVDT0RFUl9ORUVEU19NT1JFX09VVFBVVDogMyxcbiAgICBCUk9UTElfREVDT0RFUl9FUlJPUl9GT1JNQVRfRVhVQkVSQU5UX05JQkJMRTogLTEsXG4gICAgQlJPVExJX0RFQ09ERVJfRVJST1JfRk9STUFUX1JFU0VSVkVEOiAtMixcbiAgICBCUk9UTElfREVDT0RFUl9FUlJPUl9GT1JNQVRfRVhVQkVSQU5UX01FVEFfTklCQkxFOiAtMyxcbiAgICBCUk9UTElfREVDT0RFUl9FUlJPUl9GT1JNQVRfU0lNUExFX0hVRkZNQU5fQUxQSEFCRVQ6IC00LFxuICAgIEJST1RMSV9ERUNPREVSX0VSUk9SX0ZPUk1BVF9TSU1QTEVfSFVGRk1BTl9TQU1FOiAtNSxcbiAgICBCUk9UTElfREVDT0RFUl9FUlJPUl9GT1JNQVRfQ0xfU1BBQ0U6IC02LFxuICAgIEJST1RMSV9ERUNPREVSX0VSUk9SX0ZPUk1BVF9IVUZGTUFOX1NQQUNFOiAtNyxcbiAgICBCUk9UTElfREVDT0RFUl9FUlJPUl9GT1JNQVRfQ09OVEVYVF9NQVBfUkVQRUFUOiAtOCxcbiAgICBCUk9UTElfREVDT0RFUl9FUlJPUl9GT1JNQVRfQkxPQ0tfTEVOR1RIXzE6IC05LFxuICAgIEJST1RMSV9ERUNPREVSX0VSUk9SX0ZPUk1BVF9CTE9DS19MRU5HVEhfMjogLTEwLFxuICAgIEJST1RMSV9ERUNPREVSX0VSUk9SX0ZPUk1BVF9UUkFOU0ZPUk06IC0xMSxcbiAgICBCUk9UTElfREVDT0RFUl9FUlJPUl9GT1JNQVRfRElDVElPTkFSWTogLTEyLFxuICAgIEJST1RMSV9ERUNPREVSX0VSUk9SX0ZPUk1BVF9XSU5ET1dfQklUUzogLTEzLFxuICAgIEJST1RMSV9ERUNPREVSX0VSUk9SX0ZPUk1BVF9QQURESU5HXzE6IC0xNCxcbiAgICBCUk9UTElfREVDT0RFUl9FUlJPUl9GT1JNQVRfUEFERElOR18yOiAtMTUsXG4gICAgQlJPVExJX0RFQ09ERVJfRVJST1JfRk9STUFUX0RJU1RBTkNFOiAtMTYsXG4gICAgQlJPVExJX0RFQ09ERVJfRVJST1JfRElDVElPTkFSWV9OT1RfU0VUOiAtMTksXG4gICAgQlJPVExJX0RFQ09ERVJfRVJST1JfSU5WQUxJRF9BUkdVTUVOVFM6IC0yMCxcbiAgICBCUk9UTElfREVDT0RFUl9FUlJPUl9BTExPQ19DT05URVhUX01PREVTOiAtMjEsXG4gICAgQlJPVExJX0RFQ09ERVJfRVJST1JfQUxMT0NfVFJFRV9HUk9VUFM6IC0yMixcbiAgICBCUk9UTElfREVDT0RFUl9FUlJPUl9BTExPQ19DT05URVhUX01BUDogLTI1LFxuICAgIEJST1RMSV9ERUNPREVSX0VSUk9SX0FMTE9DX1JJTkdfQlVGRkVSXzE6IC0yNixcbiAgICBCUk9UTElfREVDT0RFUl9FUlJPUl9BTExPQ19SSU5HX0JVRkZFUl8yOiAtMjcsXG4gICAgQlJPVExJX0RFQ09ERVJfRVJST1JfQUxMT0NfQkxPQ0tfVFlQRV9UUkVFUzogLTMwLFxuICAgIEJST1RMSV9ERUNPREVSX0VSUk9SX1VOUkVBQ0hBQkxFOiAtMzEsXG59LCByZWFsWmxpYkNvbnN0YW50cykpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/minizlib/dist/esm/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/minizlib/dist/esm/index.js":
/*!*************************************************!*\
  !*** ./node_modules/minizlib/dist/esm/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var zlib__WEBPACK_IMPORTED_MODULE_3___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Brotli: () => (/* binding */ Brotli),\n/* harmony export */   BrotliCompress: () => (/* binding */ BrotliCompress),\n/* harmony export */   BrotliDecompress: () => (/* binding */ BrotliDecompress),\n/* harmony export */   Deflate: () => (/* binding */ Deflate),\n/* harmony export */   DeflateRaw: () => (/* binding */ DeflateRaw),\n/* harmony export */   Gunzip: () => (/* binding */ Gunzip),\n/* harmony export */   Gzip: () => (/* binding */ Gzip),\n/* harmony export */   Inflate: () => (/* binding */ Inflate),\n/* harmony export */   InflateRaw: () => (/* binding */ InflateRaw),\n/* harmony export */   Unzip: () => (/* binding */ Unzip),\n/* harmony export */   Zlib: () => (/* binding */ Zlib),\n/* harmony export */   ZlibError: () => (/* binding */ ZlibError),\n/* harmony export */   constants: () => (/* reexport safe */ _constants_js__WEBPACK_IMPORTED_MODULE_4__.constants)\n/* harmony export */ });\n/* harmony import */ var assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! assert */ \"assert\");\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! buffer */ \"buffer\");\n/* harmony import */ var minipass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! minipass */ \"(rsc)/./node_modules/minipass/dist/esm/index.js\");\n/* harmony import */ var zlib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! zlib */ \"zlib\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./constants.js */ \"(rsc)/./node_modules/minizlib/dist/esm/constants.js\");\n\n\n\n\n\n\nconst OriginalBufferConcat = buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.concat;\nconst desc = Object.getOwnPropertyDescriptor(buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer, 'concat');\nconst noop = (args) => args;\nconst passthroughBufferConcat = desc?.writable === true || desc?.set !== undefined\n    ? (makeNoOp) => {\n        buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.concat = makeNoOp ? noop : OriginalBufferConcat;\n    }\n    : (_) => { };\nconst _superWrite = Symbol('_superWrite');\nclass ZlibError extends Error {\n    code;\n    errno;\n    constructor(err) {\n        super('zlib: ' + err.message);\n        this.code = err.code;\n        this.errno = err.errno;\n        /* c8 ignore next */\n        if (!this.code)\n            this.code = 'ZLIB_ERROR';\n        this.message = 'zlib: ' + err.message;\n        Error.captureStackTrace(this, this.constructor);\n    }\n    get name() {\n        return 'ZlibError';\n    }\n}\n// the Zlib class they all inherit from\n// This thing manages the queue of requests, and returns\n// true or false if there is anything in the queue when\n// you call the .write() method.\nconst _flushFlag = Symbol('flushFlag');\nclass ZlibBase extends minipass__WEBPACK_IMPORTED_MODULE_2__.Minipass {\n    #sawError = false;\n    #ended = false;\n    #flushFlag;\n    #finishFlushFlag;\n    #fullFlushFlag;\n    #handle;\n    #onError;\n    get sawError() {\n        return this.#sawError;\n    }\n    get handle() {\n        return this.#handle;\n    }\n    /* c8 ignore start */\n    get flushFlag() {\n        return this.#flushFlag;\n    }\n    /* c8 ignore stop */\n    constructor(opts, mode) {\n        if (!opts || typeof opts !== 'object')\n            throw new TypeError('invalid options for ZlibBase constructor');\n        //@ts-ignore\n        super(opts);\n        /* c8 ignore start */\n        this.#flushFlag = opts.flush ?? 0;\n        this.#finishFlushFlag = opts.finishFlush ?? 0;\n        this.#fullFlushFlag = opts.fullFlushFlag ?? 0;\n        /* c8 ignore stop */\n        // this will throw if any options are invalid for the class selected\n        try {\n            // @types/node doesn't know that it exports the classes, but they're there\n            //@ts-ignore\n            this.#handle = new /*#__PURE__*/ (zlib__WEBPACK_IMPORTED_MODULE_3___namespace_cache || (zlib__WEBPACK_IMPORTED_MODULE_3___namespace_cache = __webpack_require__.t(zlib__WEBPACK_IMPORTED_MODULE_3__, 2)))[mode](opts);\n        }\n        catch (er) {\n            // make sure that all errors get decorated properly\n            throw new ZlibError(er);\n        }\n        this.#onError = err => {\n            // no sense raising multiple errors, since we abort on the first one.\n            if (this.#sawError)\n                return;\n            this.#sawError = true;\n            // there is no way to cleanly recover.\n            // continuing only obscures problems.\n            this.close();\n            this.emit('error', err);\n        };\n        this.#handle?.on('error', er => this.#onError(new ZlibError(er)));\n        this.once('end', () => this.close);\n    }\n    close() {\n        if (this.#handle) {\n            this.#handle.close();\n            this.#handle = undefined;\n            this.emit('close');\n        }\n    }\n    reset() {\n        if (!this.#sawError) {\n            assert__WEBPACK_IMPORTED_MODULE_0__(this.#handle, 'zlib binding closed');\n            //@ts-ignore\n            return this.#handle.reset?.();\n        }\n    }\n    flush(flushFlag) {\n        if (this.ended)\n            return;\n        if (typeof flushFlag !== 'number')\n            flushFlag = this.#fullFlushFlag;\n        this.write(Object.assign(buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.alloc(0), { [_flushFlag]: flushFlag }));\n    }\n    end(chunk, encoding, cb) {\n        /* c8 ignore start */\n        if (typeof chunk === 'function') {\n            cb = chunk;\n            encoding = undefined;\n            chunk = undefined;\n        }\n        if (typeof encoding === 'function') {\n            cb = encoding;\n            encoding = undefined;\n        }\n        /* c8 ignore stop */\n        if (chunk) {\n            if (encoding)\n                this.write(chunk, encoding);\n            else\n                this.write(chunk);\n        }\n        this.flush(this.#finishFlushFlag);\n        this.#ended = true;\n        return super.end(cb);\n    }\n    get ended() {\n        return this.#ended;\n    }\n    // overridden in the gzip classes to do portable writes\n    [_superWrite](data) {\n        return super.write(data);\n    }\n    write(chunk, encoding, cb) {\n        // process the chunk using the sync process\n        // then super.write() all the outputted chunks\n        if (typeof encoding === 'function')\n            (cb = encoding), (encoding = 'utf8');\n        if (typeof chunk === 'string')\n            chunk = buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(chunk, encoding);\n        if (this.#sawError)\n            return;\n        assert__WEBPACK_IMPORTED_MODULE_0__(this.#handle, 'zlib binding closed');\n        // _processChunk tries to .close() the native handle after it's done, so we\n        // intercept that by temporarily making it a no-op.\n        // diving into the node:zlib internals a bit here\n        const nativeHandle = this.#handle\n            ._handle;\n        const originalNativeClose = nativeHandle.close;\n        nativeHandle.close = () => { };\n        const originalClose = this.#handle.close;\n        this.#handle.close = () => { };\n        // It also calls `Buffer.concat()` at the end, which may be convenient\n        // for some, but which we are not interested in as it slows us down.\n        passthroughBufferConcat(true);\n        let result = undefined;\n        try {\n            const flushFlag = typeof chunk[_flushFlag] === 'number'\n                ? chunk[_flushFlag]\n                : this.#flushFlag;\n            result = this.#handle._processChunk(chunk, flushFlag);\n            // if we don't throw, reset it back how it was\n            passthroughBufferConcat(false);\n        }\n        catch (err) {\n            // or if we do, put Buffer.concat() back before we emit error\n            // Error events call into user code, which may call Buffer.concat()\n            passthroughBufferConcat(false);\n            this.#onError(new ZlibError(err));\n        }\n        finally {\n            if (this.#handle) {\n                // Core zlib resets `_handle` to null after attempting to close the\n                // native handle. Our no-op handler prevented actual closure, but we\n                // need to restore the `._handle` property.\n                ;\n                this.#handle._handle =\n                    nativeHandle;\n                nativeHandle.close = originalNativeClose;\n                this.#handle.close = originalClose;\n                // `_processChunk()` adds an 'error' listener. If we don't remove it\n                // after each call, these handlers start piling up.\n                this.#handle.removeAllListeners('error');\n                // make sure OUR error listener is still attached tho\n            }\n        }\n        if (this.#handle)\n            this.#handle.on('error', er => this.#onError(new ZlibError(er)));\n        let writeReturn;\n        if (result) {\n            if (Array.isArray(result) && result.length > 0) {\n                const r = result[0];\n                // The first buffer is always `handle._outBuffer`, which would be\n                // re-used for later invocations; so, we always have to copy that one.\n                writeReturn = this[_superWrite](buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(r));\n                for (let i = 1; i < result.length; i++) {\n                    writeReturn = this[_superWrite](result[i]);\n                }\n            }\n            else {\n                // either a single Buffer or an empty array\n                writeReturn = this[_superWrite](buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(result));\n            }\n        }\n        if (cb)\n            cb();\n        return writeReturn;\n    }\n}\nclass Zlib extends ZlibBase {\n    #level;\n    #strategy;\n    constructor(opts, mode) {\n        opts = opts || {};\n        opts.flush = opts.flush || _constants_js__WEBPACK_IMPORTED_MODULE_4__.constants.Z_NO_FLUSH;\n        opts.finishFlush = opts.finishFlush || _constants_js__WEBPACK_IMPORTED_MODULE_4__.constants.Z_FINISH;\n        opts.fullFlushFlag = _constants_js__WEBPACK_IMPORTED_MODULE_4__.constants.Z_FULL_FLUSH;\n        super(opts, mode);\n        this.#level = opts.level;\n        this.#strategy = opts.strategy;\n    }\n    params(level, strategy) {\n        if (this.sawError)\n            return;\n        if (!this.handle)\n            throw new Error('cannot switch params when binding is closed');\n        // no way to test this without also not supporting params at all\n        /* c8 ignore start */\n        if (!this.handle.params)\n            throw new Error('not supported in this implementation');\n        /* c8 ignore stop */\n        if (this.#level !== level || this.#strategy !== strategy) {\n            this.flush(_constants_js__WEBPACK_IMPORTED_MODULE_4__.constants.Z_SYNC_FLUSH);\n            assert__WEBPACK_IMPORTED_MODULE_0__(this.handle, 'zlib binding closed');\n            // .params() calls .flush(), but the latter is always async in the\n            // core zlib. We override .flush() temporarily to intercept that and\n            // flush synchronously.\n            const origFlush = this.handle.flush;\n            this.handle.flush = (flushFlag, cb) => {\n                /* c8 ignore start */\n                if (typeof flushFlag === 'function') {\n                    cb = flushFlag;\n                    flushFlag = this.flushFlag;\n                }\n                /* c8 ignore stop */\n                this.flush(flushFlag);\n                cb?.();\n            };\n            try {\n                ;\n                this.handle.params(level, strategy);\n            }\n            finally {\n                this.handle.flush = origFlush;\n            }\n            /* c8 ignore start */\n            if (this.handle) {\n                this.#level = level;\n                this.#strategy = strategy;\n            }\n            /* c8 ignore stop */\n        }\n    }\n}\n// minimal 2-byte header\nclass Deflate extends Zlib {\n    constructor(opts) {\n        super(opts, 'Deflate');\n    }\n}\nclass Inflate extends Zlib {\n    constructor(opts) {\n        super(opts, 'Inflate');\n    }\n}\nclass Gzip extends Zlib {\n    #portable;\n    constructor(opts) {\n        super(opts, 'Gzip');\n        this.#portable = opts && !!opts.portable;\n    }\n    [_superWrite](data) {\n        if (!this.#portable)\n            return super[_superWrite](data);\n        // we'll always get the header emitted in one first chunk\n        // overwrite the OS indicator byte with 0xFF\n        this.#portable = false;\n        data[9] = 255;\n        return super[_superWrite](data);\n    }\n}\nclass Gunzip extends Zlib {\n    constructor(opts) {\n        super(opts, 'Gunzip');\n    }\n}\n// raw - no header\nclass DeflateRaw extends Zlib {\n    constructor(opts) {\n        super(opts, 'DeflateRaw');\n    }\n}\nclass InflateRaw extends Zlib {\n    constructor(opts) {\n        super(opts, 'InflateRaw');\n    }\n}\n// auto-detect header.\nclass Unzip extends Zlib {\n    constructor(opts) {\n        super(opts, 'Unzip');\n    }\n}\nclass Brotli extends ZlibBase {\n    constructor(opts, mode) {\n        opts = opts || {};\n        opts.flush = opts.flush || _constants_js__WEBPACK_IMPORTED_MODULE_4__.constants.BROTLI_OPERATION_PROCESS;\n        opts.finishFlush =\n            opts.finishFlush || _constants_js__WEBPACK_IMPORTED_MODULE_4__.constants.BROTLI_OPERATION_FINISH;\n        opts.fullFlushFlag = _constants_js__WEBPACK_IMPORTED_MODULE_4__.constants.BROTLI_OPERATION_FLUSH;\n        super(opts, mode);\n    }\n}\nclass BrotliCompress extends Brotli {\n    constructor(opts) {\n        super(opts, 'BrotliCompress');\n    }\n}\nclass BrotliDecompress extends Brotli {\n    constructor(opts) {\n        super(opts, 'BrotliDecompress');\n    }\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWluaXpsaWIvZGlzdC9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE0QjtBQUNJO0FBQ0k7QUFDSDtBQUNVO0FBQ0E7QUFDM0MsNkJBQTZCLDBDQUFNO0FBQ25DLDZDQUE2QywwQ0FBTTtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxRQUFRLDBDQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsOENBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixzTEFBUTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1DQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywwQ0FBTSxhQUFhLHlCQUF5QjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMENBQU07QUFDMUI7QUFDQTtBQUNBLFFBQVEsbUNBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xELGdEQUFnRCwwQ0FBTTtBQUN0RCxnQ0FBZ0MsbUJBQW1CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsMENBQU07QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLG9EQUFTO0FBQzVDLCtDQUErQyxvREFBUztBQUN4RCw2QkFBNkIsb0RBQVM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG9EQUFTO0FBQ2hDLFlBQVksbUNBQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxtQ0FBbUMsb0RBQVM7QUFDNUM7QUFDQSxnQ0FBZ0Msb0RBQVM7QUFDekMsNkJBQTZCLG9EQUFTO0FBQ3RDO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aXZlLXZpYmUtYWktbmV4dC8uL25vZGVfbW9kdWxlcy9taW5pemxpYi9kaXN0L2VzbS9pbmRleC5qcz9iODQ3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcbmltcG9ydCB7IEJ1ZmZlciB9IGZyb20gJ2J1ZmZlcic7XG5pbXBvcnQgeyBNaW5pcGFzcyB9IGZyb20gJ21pbmlwYXNzJztcbmltcG9ydCAqIGFzIHJlYWxabGliIGZyb20gJ3psaWInO1xuaW1wb3J0IHsgY29uc3RhbnRzIH0gZnJvbSAnLi9jb25zdGFudHMuanMnO1xuZXhwb3J0IHsgY29uc3RhbnRzIH0gZnJvbSAnLi9jb25zdGFudHMuanMnO1xuY29uc3QgT3JpZ2luYWxCdWZmZXJDb25jYXQgPSBCdWZmZXIuY29uY2F0O1xuY29uc3QgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoQnVmZmVyLCAnY29uY2F0Jyk7XG5jb25zdCBub29wID0gKGFyZ3MpID0+IGFyZ3M7XG5jb25zdCBwYXNzdGhyb3VnaEJ1ZmZlckNvbmNhdCA9IGRlc2M/LndyaXRhYmxlID09PSB0cnVlIHx8IGRlc2M/LnNldCAhPT0gdW5kZWZpbmVkXG4gICAgPyAobWFrZU5vT3ApID0+IHtcbiAgICAgICAgQnVmZmVyLmNvbmNhdCA9IG1ha2VOb09wID8gbm9vcCA6IE9yaWdpbmFsQnVmZmVyQ29uY2F0O1xuICAgIH1cbiAgICA6IChfKSA9PiB7IH07XG5jb25zdCBfc3VwZXJXcml0ZSA9IFN5bWJvbCgnX3N1cGVyV3JpdGUnKTtcbmV4cG9ydCBjbGFzcyBabGliRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29kZTtcbiAgICBlcnJubztcbiAgICBjb25zdHJ1Y3RvcihlcnIpIHtcbiAgICAgICAgc3VwZXIoJ3psaWI6ICcgKyBlcnIubWVzc2FnZSk7XG4gICAgICAgIHRoaXMuY29kZSA9IGVyci5jb2RlO1xuICAgICAgICB0aGlzLmVycm5vID0gZXJyLmVycm5vO1xuICAgICAgICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBpZiAoIXRoaXMuY29kZSlcbiAgICAgICAgICAgIHRoaXMuY29kZSA9ICdaTElCX0VSUk9SJztcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gJ3psaWI6ICcgKyBlcnIubWVzc2FnZTtcbiAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gICAgfVxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gJ1psaWJFcnJvcic7XG4gICAgfVxufVxuLy8gdGhlIFpsaWIgY2xhc3MgdGhleSBhbGwgaW5oZXJpdCBmcm9tXG4vLyBUaGlzIHRoaW5nIG1hbmFnZXMgdGhlIHF1ZXVlIG9mIHJlcXVlc3RzLCBhbmQgcmV0dXJuc1xuLy8gdHJ1ZSBvciBmYWxzZSBpZiB0aGVyZSBpcyBhbnl0aGluZyBpbiB0aGUgcXVldWUgd2hlblxuLy8geW91IGNhbGwgdGhlIC53cml0ZSgpIG1ldGhvZC5cbmNvbnN0IF9mbHVzaEZsYWcgPSBTeW1ib2woJ2ZsdXNoRmxhZycpO1xuY2xhc3MgWmxpYkJhc2UgZXh0ZW5kcyBNaW5pcGFzcyB7XG4gICAgI3Nhd0Vycm9yID0gZmFsc2U7XG4gICAgI2VuZGVkID0gZmFsc2U7XG4gICAgI2ZsdXNoRmxhZztcbiAgICAjZmluaXNoRmx1c2hGbGFnO1xuICAgICNmdWxsRmx1c2hGbGFnO1xuICAgICNoYW5kbGU7XG4gICAgI29uRXJyb3I7XG4gICAgZ2V0IHNhd0Vycm9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jc2F3RXJyb3I7XG4gICAgfVxuICAgIGdldCBoYW5kbGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNoYW5kbGU7XG4gICAgfVxuICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgIGdldCBmbHVzaEZsYWcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNmbHVzaEZsYWc7XG4gICAgfVxuICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgY29uc3RydWN0b3Iob3B0cywgbW9kZSkge1xuICAgICAgICBpZiAoIW9wdHMgfHwgdHlwZW9mIG9wdHMgIT09ICdvYmplY3QnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBvcHRpb25zIGZvciBabGliQmFzZSBjb25zdHJ1Y3RvcicpO1xuICAgICAgICAvL0B0cy1pZ25vcmVcbiAgICAgICAgc3VwZXIob3B0cyk7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICB0aGlzLiNmbHVzaEZsYWcgPSBvcHRzLmZsdXNoID8/IDA7XG4gICAgICAgIHRoaXMuI2ZpbmlzaEZsdXNoRmxhZyA9IG9wdHMuZmluaXNoRmx1c2ggPz8gMDtcbiAgICAgICAgdGhpcy4jZnVsbEZsdXNoRmxhZyA9IG9wdHMuZnVsbEZsdXNoRmxhZyA/PyAwO1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAvLyB0aGlzIHdpbGwgdGhyb3cgaWYgYW55IG9wdGlvbnMgYXJlIGludmFsaWQgZm9yIHRoZSBjbGFzcyBzZWxlY3RlZFxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gQHR5cGVzL25vZGUgZG9lc24ndCBrbm93IHRoYXQgaXQgZXhwb3J0cyB0aGUgY2xhc3NlcywgYnV0IHRoZXkncmUgdGhlcmVcbiAgICAgICAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgICAgICAgdGhpcy4jaGFuZGxlID0gbmV3IHJlYWxabGliW21vZGVdKG9wdHMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcikge1xuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHRoYXQgYWxsIGVycm9ycyBnZXQgZGVjb3JhdGVkIHByb3Blcmx5XG4gICAgICAgICAgICB0aHJvdyBuZXcgWmxpYkVycm9yKGVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNvbkVycm9yID0gZXJyID0+IHtcbiAgICAgICAgICAgIC8vIG5vIHNlbnNlIHJhaXNpbmcgbXVsdGlwbGUgZXJyb3JzLCBzaW5jZSB3ZSBhYm9ydCBvbiB0aGUgZmlyc3Qgb25lLlxuICAgICAgICAgICAgaWYgKHRoaXMuI3Nhd0Vycm9yKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuI3Nhd0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIHRoZXJlIGlzIG5vIHdheSB0byBjbGVhbmx5IHJlY292ZXIuXG4gICAgICAgICAgICAvLyBjb250aW51aW5nIG9ubHkgb2JzY3VyZXMgcHJvYmxlbXMuXG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy4jaGFuZGxlPy5vbignZXJyb3InLCBlciA9PiB0aGlzLiNvbkVycm9yKG5ldyBabGliRXJyb3IoZXIpKSk7XG4gICAgICAgIHRoaXMub25jZSgnZW5kJywgKCkgPT4gdGhpcy5jbG9zZSk7XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICBpZiAodGhpcy4jaGFuZGxlKSB7XG4gICAgICAgICAgICB0aGlzLiNoYW5kbGUuY2xvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuI2hhbmRsZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnY2xvc2UnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLiNzYXdFcnJvcikge1xuICAgICAgICAgICAgYXNzZXJ0KHRoaXMuI2hhbmRsZSwgJ3psaWIgYmluZGluZyBjbG9zZWQnKTtcbiAgICAgICAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI2hhbmRsZS5yZXNldD8uKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmx1c2goZmx1c2hGbGFnKSB7XG4gICAgICAgIGlmICh0aGlzLmVuZGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodHlwZW9mIGZsdXNoRmxhZyAhPT0gJ251bWJlcicpXG4gICAgICAgICAgICBmbHVzaEZsYWcgPSB0aGlzLiNmdWxsRmx1c2hGbGFnO1xuICAgICAgICB0aGlzLndyaXRlKE9iamVjdC5hc3NpZ24oQnVmZmVyLmFsbG9jKDApLCB7IFtfZmx1c2hGbGFnXTogZmx1c2hGbGFnIH0pKTtcbiAgICB9XG4gICAgZW5kKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNiID0gY2h1bms7XG4gICAgICAgICAgICBlbmNvZGluZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNodW5rID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgICAgICAgICBlbmNvZGluZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICBpZiAoY2h1bmspIHtcbiAgICAgICAgICAgIGlmIChlbmNvZGluZylcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZShjaHVuayk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mbHVzaCh0aGlzLiNmaW5pc2hGbHVzaEZsYWcpO1xuICAgICAgICB0aGlzLiNlbmRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBzdXBlci5lbmQoY2IpO1xuICAgIH1cbiAgICBnZXQgZW5kZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNlbmRlZDtcbiAgICB9XG4gICAgLy8gb3ZlcnJpZGRlbiBpbiB0aGUgZ3ppcCBjbGFzc2VzIHRvIGRvIHBvcnRhYmxlIHdyaXRlc1xuICAgIFtfc3VwZXJXcml0ZV0oZGF0YSkge1xuICAgICAgICByZXR1cm4gc3VwZXIud3JpdGUoZGF0YSk7XG4gICAgfVxuICAgIHdyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgICAgICAgLy8gcHJvY2VzcyB0aGUgY2h1bmsgdXNpbmcgdGhlIHN5bmMgcHJvY2Vzc1xuICAgICAgICAvLyB0aGVuIHN1cGVyLndyaXRlKCkgYWxsIHRoZSBvdXRwdXR0ZWQgY2h1bmtzXG4gICAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAoY2IgPSBlbmNvZGluZyksIChlbmNvZGluZyA9ICd1dGY4Jyk7XG4gICAgICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgICBpZiAodGhpcy4jc2F3RXJyb3IpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGFzc2VydCh0aGlzLiNoYW5kbGUsICd6bGliIGJpbmRpbmcgY2xvc2VkJyk7XG4gICAgICAgIC8vIF9wcm9jZXNzQ2h1bmsgdHJpZXMgdG8gLmNsb3NlKCkgdGhlIG5hdGl2ZSBoYW5kbGUgYWZ0ZXIgaXQncyBkb25lLCBzbyB3ZVxuICAgICAgICAvLyBpbnRlcmNlcHQgdGhhdCBieSB0ZW1wb3JhcmlseSBtYWtpbmcgaXQgYSBuby1vcC5cbiAgICAgICAgLy8gZGl2aW5nIGludG8gdGhlIG5vZGU6emxpYiBpbnRlcm5hbHMgYSBiaXQgaGVyZVxuICAgICAgICBjb25zdCBuYXRpdmVIYW5kbGUgPSB0aGlzLiNoYW5kbGVcbiAgICAgICAgICAgIC5faGFuZGxlO1xuICAgICAgICBjb25zdCBvcmlnaW5hbE5hdGl2ZUNsb3NlID0gbmF0aXZlSGFuZGxlLmNsb3NlO1xuICAgICAgICBuYXRpdmVIYW5kbGUuY2xvc2UgPSAoKSA9PiB7IH07XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsQ2xvc2UgPSB0aGlzLiNoYW5kbGUuY2xvc2U7XG4gICAgICAgIHRoaXMuI2hhbmRsZS5jbG9zZSA9ICgpID0+IHsgfTtcbiAgICAgICAgLy8gSXQgYWxzbyBjYWxscyBgQnVmZmVyLmNvbmNhdCgpYCBhdCB0aGUgZW5kLCB3aGljaCBtYXkgYmUgY29udmVuaWVudFxuICAgICAgICAvLyBmb3Igc29tZSwgYnV0IHdoaWNoIHdlIGFyZSBub3QgaW50ZXJlc3RlZCBpbiBhcyBpdCBzbG93cyB1cyBkb3duLlxuICAgICAgICBwYXNzdGhyb3VnaEJ1ZmZlckNvbmNhdCh0cnVlKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGZsdXNoRmxhZyA9IHR5cGVvZiBjaHVua1tfZmx1c2hGbGFnXSA9PT0gJ251bWJlcidcbiAgICAgICAgICAgICAgICA/IGNodW5rW19mbHVzaEZsYWddXG4gICAgICAgICAgICAgICAgOiB0aGlzLiNmbHVzaEZsYWc7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLiNoYW5kbGUuX3Byb2Nlc3NDaHVuayhjaHVuaywgZmx1c2hGbGFnKTtcbiAgICAgICAgICAgIC8vIGlmIHdlIGRvbid0IHRocm93LCByZXNldCBpdCBiYWNrIGhvdyBpdCB3YXNcbiAgICAgICAgICAgIHBhc3N0aHJvdWdoQnVmZmVyQ29uY2F0KGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAvLyBvciBpZiB3ZSBkbywgcHV0IEJ1ZmZlci5jb25jYXQoKSBiYWNrIGJlZm9yZSB3ZSBlbWl0IGVycm9yXG4gICAgICAgICAgICAvLyBFcnJvciBldmVudHMgY2FsbCBpbnRvIHVzZXIgY29kZSwgd2hpY2ggbWF5IGNhbGwgQnVmZmVyLmNvbmNhdCgpXG4gICAgICAgICAgICBwYXNzdGhyb3VnaEJ1ZmZlckNvbmNhdChmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLiNvbkVycm9yKG5ldyBabGliRXJyb3IoZXJyKSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBpZiAodGhpcy4jaGFuZGxlKSB7XG4gICAgICAgICAgICAgICAgLy8gQ29yZSB6bGliIHJlc2V0cyBgX2hhbmRsZWAgdG8gbnVsbCBhZnRlciBhdHRlbXB0aW5nIHRvIGNsb3NlIHRoZVxuICAgICAgICAgICAgICAgIC8vIG5hdGl2ZSBoYW5kbGUuIE91ciBuby1vcCBoYW5kbGVyIHByZXZlbnRlZCBhY3R1YWwgY2xvc3VyZSwgYnV0IHdlXG4gICAgICAgICAgICAgICAgLy8gbmVlZCB0byByZXN0b3JlIHRoZSBgLl9oYW5kbGVgIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICB0aGlzLiNoYW5kbGUuX2hhbmRsZSA9XG4gICAgICAgICAgICAgICAgICAgIG5hdGl2ZUhhbmRsZTtcbiAgICAgICAgICAgICAgICBuYXRpdmVIYW5kbGUuY2xvc2UgPSBvcmlnaW5hbE5hdGl2ZUNsb3NlO1xuICAgICAgICAgICAgICAgIHRoaXMuI2hhbmRsZS5jbG9zZSA9IG9yaWdpbmFsQ2xvc2U7XG4gICAgICAgICAgICAgICAgLy8gYF9wcm9jZXNzQ2h1bmsoKWAgYWRkcyBhbiAnZXJyb3InIGxpc3RlbmVyLiBJZiB3ZSBkb24ndCByZW1vdmUgaXRcbiAgICAgICAgICAgICAgICAvLyBhZnRlciBlYWNoIGNhbGwsIHRoZXNlIGhhbmRsZXJzIHN0YXJ0IHBpbGluZyB1cC5cbiAgICAgICAgICAgICAgICB0aGlzLiNoYW5kbGUucmVtb3ZlQWxsTGlzdGVuZXJzKCdlcnJvcicpO1xuICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBPVVIgZXJyb3IgbGlzdGVuZXIgaXMgc3RpbGwgYXR0YWNoZWQgdGhvXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuI2hhbmRsZSlcbiAgICAgICAgICAgIHRoaXMuI2hhbmRsZS5vbignZXJyb3InLCBlciA9PiB0aGlzLiNvbkVycm9yKG5ldyBabGliRXJyb3IoZXIpKSk7XG4gICAgICAgIGxldCB3cml0ZVJldHVybjtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSAmJiByZXN1bHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHIgPSByZXN1bHRbMF07XG4gICAgICAgICAgICAgICAgLy8gVGhlIGZpcnN0IGJ1ZmZlciBpcyBhbHdheXMgYGhhbmRsZS5fb3V0QnVmZmVyYCwgd2hpY2ggd291bGQgYmVcbiAgICAgICAgICAgICAgICAvLyByZS11c2VkIGZvciBsYXRlciBpbnZvY2F0aW9uczsgc28sIHdlIGFsd2F5cyBoYXZlIHRvIGNvcHkgdGhhdCBvbmUuXG4gICAgICAgICAgICAgICAgd3JpdGVSZXR1cm4gPSB0aGlzW19zdXBlcldyaXRlXShCdWZmZXIuZnJvbShyKSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVSZXR1cm4gPSB0aGlzW19zdXBlcldyaXRlXShyZXN1bHRbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGVpdGhlciBhIHNpbmdsZSBCdWZmZXIgb3IgYW4gZW1wdHkgYXJyYXlcbiAgICAgICAgICAgICAgICB3cml0ZVJldHVybiA9IHRoaXNbX3N1cGVyV3JpdGVdKEJ1ZmZlci5mcm9tKHJlc3VsdCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjYilcbiAgICAgICAgICAgIGNiKCk7XG4gICAgICAgIHJldHVybiB3cml0ZVJldHVybjtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgWmxpYiBleHRlbmRzIFpsaWJCYXNlIHtcbiAgICAjbGV2ZWw7XG4gICAgI3N0cmF0ZWd5O1xuICAgIGNvbnN0cnVjdG9yKG9wdHMsIG1vZGUpIHtcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgICAgIG9wdHMuZmx1c2ggPSBvcHRzLmZsdXNoIHx8IGNvbnN0YW50cy5aX05PX0ZMVVNIO1xuICAgICAgICBvcHRzLmZpbmlzaEZsdXNoID0gb3B0cy5maW5pc2hGbHVzaCB8fCBjb25zdGFudHMuWl9GSU5JU0g7XG4gICAgICAgIG9wdHMuZnVsbEZsdXNoRmxhZyA9IGNvbnN0YW50cy5aX0ZVTExfRkxVU0g7XG4gICAgICAgIHN1cGVyKG9wdHMsIG1vZGUpO1xuICAgICAgICB0aGlzLiNsZXZlbCA9IG9wdHMubGV2ZWw7XG4gICAgICAgIHRoaXMuI3N0cmF0ZWd5ID0gb3B0cy5zdHJhdGVneTtcbiAgICB9XG4gICAgcGFyYW1zKGxldmVsLCBzdHJhdGVneSkge1xuICAgICAgICBpZiAodGhpcy5zYXdFcnJvcilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCF0aGlzLmhhbmRsZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHN3aXRjaCBwYXJhbXMgd2hlbiBiaW5kaW5nIGlzIGNsb3NlZCcpO1xuICAgICAgICAvLyBubyB3YXkgdG8gdGVzdCB0aGlzIHdpdGhvdXQgYWxzbyBub3Qgc3VwcG9ydGluZyBwYXJhbXMgYXQgYWxsXG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICBpZiAoIXRoaXMuaGFuZGxlLnBhcmFtcylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbm90IHN1cHBvcnRlZCBpbiB0aGlzIGltcGxlbWVudGF0aW9uJyk7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgIGlmICh0aGlzLiNsZXZlbCAhPT0gbGV2ZWwgfHwgdGhpcy4jc3RyYXRlZ3kgIT09IHN0cmF0ZWd5KSB7XG4gICAgICAgICAgICB0aGlzLmZsdXNoKGNvbnN0YW50cy5aX1NZTkNfRkxVU0gpO1xuICAgICAgICAgICAgYXNzZXJ0KHRoaXMuaGFuZGxlLCAnemxpYiBiaW5kaW5nIGNsb3NlZCcpO1xuICAgICAgICAgICAgLy8gLnBhcmFtcygpIGNhbGxzIC5mbHVzaCgpLCBidXQgdGhlIGxhdHRlciBpcyBhbHdheXMgYXN5bmMgaW4gdGhlXG4gICAgICAgICAgICAvLyBjb3JlIHpsaWIuIFdlIG92ZXJyaWRlIC5mbHVzaCgpIHRlbXBvcmFyaWx5IHRvIGludGVyY2VwdCB0aGF0IGFuZFxuICAgICAgICAgICAgLy8gZmx1c2ggc3luY2hyb25vdXNseS5cbiAgICAgICAgICAgIGNvbnN0IG9yaWdGbHVzaCA9IHRoaXMuaGFuZGxlLmZsdXNoO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGUuZmx1c2ggPSAoZmx1c2hGbGFnLCBjYikgPT4ge1xuICAgICAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZmx1c2hGbGFnID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNiID0gZmx1c2hGbGFnO1xuICAgICAgICAgICAgICAgICAgICBmbHVzaEZsYWcgPSB0aGlzLmZsdXNoRmxhZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgICAgICAgICB0aGlzLmZsdXNoKGZsdXNoRmxhZyk7XG4gICAgICAgICAgICAgICAgY2I/LigpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlLnBhcmFtcyhsZXZlbCwgc3RyYXRlZ3kpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGUuZmx1c2ggPSBvcmlnRmx1c2g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLmhhbmRsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuI2xldmVsID0gbGV2ZWw7XG4gICAgICAgICAgICAgICAgdGhpcy4jc3RyYXRlZ3kgPSBzdHJhdGVneTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgIH1cbiAgICB9XG59XG4vLyBtaW5pbWFsIDItYnl0ZSBoZWFkZXJcbmV4cG9ydCBjbGFzcyBEZWZsYXRlIGV4dGVuZHMgWmxpYiB7XG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICBzdXBlcihvcHRzLCAnRGVmbGF0ZScpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBJbmZsYXRlIGV4dGVuZHMgWmxpYiB7XG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICBzdXBlcihvcHRzLCAnSW5mbGF0ZScpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBHemlwIGV4dGVuZHMgWmxpYiB7XG4gICAgI3BvcnRhYmxlO1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgc3VwZXIob3B0cywgJ0d6aXAnKTtcbiAgICAgICAgdGhpcy4jcG9ydGFibGUgPSBvcHRzICYmICEhb3B0cy5wb3J0YWJsZTtcbiAgICB9XG4gICAgW19zdXBlcldyaXRlXShkYXRhKSB7XG4gICAgICAgIGlmICghdGhpcy4jcG9ydGFibGUpXG4gICAgICAgICAgICByZXR1cm4gc3VwZXJbX3N1cGVyV3JpdGVdKGRhdGEpO1xuICAgICAgICAvLyB3ZSdsbCBhbHdheXMgZ2V0IHRoZSBoZWFkZXIgZW1pdHRlZCBpbiBvbmUgZmlyc3QgY2h1bmtcbiAgICAgICAgLy8gb3ZlcndyaXRlIHRoZSBPUyBpbmRpY2F0b3IgYnl0ZSB3aXRoIDB4RkZcbiAgICAgICAgdGhpcy4jcG9ydGFibGUgPSBmYWxzZTtcbiAgICAgICAgZGF0YVs5XSA9IDI1NTtcbiAgICAgICAgcmV0dXJuIHN1cGVyW19zdXBlcldyaXRlXShkYXRhKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgR3VuemlwIGV4dGVuZHMgWmxpYiB7XG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICBzdXBlcihvcHRzLCAnR3VuemlwJyk7XG4gICAgfVxufVxuLy8gcmF3IC0gbm8gaGVhZGVyXG5leHBvcnQgY2xhc3MgRGVmbGF0ZVJhdyBleHRlbmRzIFpsaWIge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgc3VwZXIob3B0cywgJ0RlZmxhdGVSYXcnKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgSW5mbGF0ZVJhdyBleHRlbmRzIFpsaWIge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgc3VwZXIob3B0cywgJ0luZmxhdGVSYXcnKTtcbiAgICB9XG59XG4vLyBhdXRvLWRldGVjdCBoZWFkZXIuXG5leHBvcnQgY2xhc3MgVW56aXAgZXh0ZW5kcyBabGliIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHN1cGVyKG9wdHMsICdVbnppcCcpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBCcm90bGkgZXh0ZW5kcyBabGliQmFzZSB7XG4gICAgY29uc3RydWN0b3Iob3B0cywgbW9kZSkge1xuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICAgICAgb3B0cy5mbHVzaCA9IG9wdHMuZmx1c2ggfHwgY29uc3RhbnRzLkJST1RMSV9PUEVSQVRJT05fUFJPQ0VTUztcbiAgICAgICAgb3B0cy5maW5pc2hGbHVzaCA9XG4gICAgICAgICAgICBvcHRzLmZpbmlzaEZsdXNoIHx8IGNvbnN0YW50cy5CUk9UTElfT1BFUkFUSU9OX0ZJTklTSDtcbiAgICAgICAgb3B0cy5mdWxsRmx1c2hGbGFnID0gY29uc3RhbnRzLkJST1RMSV9PUEVSQVRJT05fRkxVU0g7XG4gICAgICAgIHN1cGVyKG9wdHMsIG1vZGUpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBCcm90bGlDb21wcmVzcyBleHRlbmRzIEJyb3RsaSB7XG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICBzdXBlcihvcHRzLCAnQnJvdGxpQ29tcHJlc3MnKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQnJvdGxpRGVjb21wcmVzcyBleHRlbmRzIEJyb3RsaSB7XG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICBzdXBlcihvcHRzLCAnQnJvdGxpRGVjb21wcmVzcycpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/minizlib/dist/esm/index.js\n");

/***/ })

};
;