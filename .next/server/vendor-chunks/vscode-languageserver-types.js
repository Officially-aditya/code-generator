/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/vscode-languageserver-types";
exports.ids = ["vendor-chunks/vscode-languageserver-types"];
exports.modules = {

/***/ "(rsc)/./node_modules/vscode-languageserver-types/lib/umd/main.js":
/*!******************************************************************!*\
  !*** ./node_modules/vscode-languageserver-types/lib/umd/main.js ***!
  \******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n    if ( true && typeof module.exports === \"object\") {\n        var v = factory(__webpack_require__(\"(rsc)/./node_modules/vscode-languageserver-types/lib/umd sync recursive\"), exports);\n        if (v !== undefined) module.exports = v;\n    }\n    else if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    }\n})(function (require, exports) {\n    /* --------------------------------------------------------------------------------------------\n     * Copyright (c) Microsoft Corporation. All rights reserved.\n     * Licensed under the MIT License. See License.txt in the project root for license information.\n     * ------------------------------------------------------------------------------------------ */\n    'use strict';\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.TextDocument = exports.EOL = exports.WorkspaceFolder = exports.InlineCompletionContext = exports.SelectedCompletionInfo = exports.InlineCompletionTriggerKind = exports.InlineCompletionList = exports.InlineCompletionItem = exports.StringValue = exports.InlayHint = exports.InlayHintLabelPart = exports.InlayHintKind = exports.InlineValueContext = exports.InlineValueEvaluatableExpression = exports.InlineValueVariableLookup = exports.InlineValueText = exports.SemanticTokens = exports.SemanticTokenModifiers = exports.SemanticTokenTypes = exports.SelectionRange = exports.DocumentLink = exports.FormattingOptions = exports.CodeLens = exports.CodeAction = exports.CodeActionContext = exports.CodeActionTriggerKind = exports.CodeActionKind = exports.DocumentSymbol = exports.WorkspaceSymbol = exports.SymbolInformation = exports.SymbolTag = exports.SymbolKind = exports.DocumentHighlight = exports.DocumentHighlightKind = exports.SignatureInformation = exports.ParameterInformation = exports.Hover = exports.MarkedString = exports.CompletionList = exports.CompletionItem = exports.CompletionItemLabelDetails = exports.InsertTextMode = exports.InsertReplaceEdit = exports.CompletionItemTag = exports.InsertTextFormat = exports.CompletionItemKind = exports.MarkupContent = exports.MarkupKind = exports.TextDocumentItem = exports.OptionalVersionedTextDocumentIdentifier = exports.VersionedTextDocumentIdentifier = exports.TextDocumentIdentifier = exports.WorkspaceChange = exports.WorkspaceEdit = exports.DeleteFile = exports.RenameFile = exports.CreateFile = exports.TextDocumentEdit = exports.AnnotatedTextEdit = exports.ChangeAnnotationIdentifier = exports.ChangeAnnotation = exports.TextEdit = exports.Command = exports.Diagnostic = exports.CodeDescription = exports.DiagnosticTag = exports.DiagnosticSeverity = exports.DiagnosticRelatedInformation = exports.FoldingRange = exports.FoldingRangeKind = exports.ColorPresentation = exports.ColorInformation = exports.Color = exports.LocationLink = exports.Location = exports.Range = exports.Position = exports.uinteger = exports.integer = exports.URI = exports.DocumentUri = void 0;\n    var DocumentUri;\n    (function (DocumentUri) {\n        function is(value) {\n            return typeof value === 'string';\n        }\n        DocumentUri.is = is;\n    })(DocumentUri || (exports.DocumentUri = DocumentUri = {}));\n    var URI;\n    (function (URI) {\n        function is(value) {\n            return typeof value === 'string';\n        }\n        URI.is = is;\n    })(URI || (exports.URI = URI = {}));\n    var integer;\n    (function (integer) {\n        integer.MIN_VALUE = -2147483648;\n        integer.MAX_VALUE = 2147483647;\n        function is(value) {\n            return typeof value === 'number' && integer.MIN_VALUE <= value && value <= integer.MAX_VALUE;\n        }\n        integer.is = is;\n    })(integer || (exports.integer = integer = {}));\n    var uinteger;\n    (function (uinteger) {\n        uinteger.MIN_VALUE = 0;\n        uinteger.MAX_VALUE = 2147483647;\n        function is(value) {\n            return typeof value === 'number' && uinteger.MIN_VALUE <= value && value <= uinteger.MAX_VALUE;\n        }\n        uinteger.is = is;\n    })(uinteger || (exports.uinteger = uinteger = {}));\n    /**\n     * The Position namespace provides helper functions to work with\n     * {@link Position} literals.\n     */\n    var Position;\n    (function (Position) {\n        /**\n         * Creates a new Position literal from the given line and character.\n         * @param line The position's line.\n         * @param character The position's character.\n         */\n        function create(line, character) {\n            if (line === Number.MAX_VALUE) {\n                line = uinteger.MAX_VALUE;\n            }\n            if (character === Number.MAX_VALUE) {\n                character = uinteger.MAX_VALUE;\n            }\n            return { line: line, character: character };\n        }\n        Position.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link Position} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);\n        }\n        Position.is = is;\n    })(Position || (exports.Position = Position = {}));\n    /**\n     * The Range namespace provides helper functions to work with\n     * {@link Range} literals.\n     */\n    var Range;\n    (function (Range) {\n        function create(one, two, three, four) {\n            if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {\n                return { start: Position.create(one, two), end: Position.create(three, four) };\n            }\n            else if (Position.is(one) && Position.is(two)) {\n                return { start: one, end: two };\n            }\n            else {\n                throw new Error(\"Range#create called with invalid arguments[\".concat(one, \", \").concat(two, \", \").concat(three, \", \").concat(four, \"]\"));\n            }\n        }\n        Range.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link Range} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);\n        }\n        Range.is = is;\n    })(Range || (exports.Range = Range = {}));\n    /**\n     * The Location namespace provides helper functions to work with\n     * {@link Location} literals.\n     */\n    var Location;\n    (function (Location) {\n        /**\n         * Creates a Location literal.\n         * @param uri The location's uri.\n         * @param range The location's range.\n         */\n        function create(uri, range) {\n            return { uri: uri, range: range };\n        }\n        Location.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link Location} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));\n        }\n        Location.is = is;\n    })(Location || (exports.Location = Location = {}));\n    /**\n     * The LocationLink namespace provides helper functions to work with\n     * {@link LocationLink} literals.\n     */\n    var LocationLink;\n    (function (LocationLink) {\n        /**\n         * Creates a LocationLink literal.\n         * @param targetUri The definition's uri.\n         * @param targetRange The full range of the definition.\n         * @param targetSelectionRange The span of the symbol definition at the target.\n         * @param originSelectionRange The span of the symbol being defined in the originating source file.\n         */\n        function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {\n            return { targetUri: targetUri, targetRange: targetRange, targetSelectionRange: targetSelectionRange, originSelectionRange: originSelectionRange };\n        }\n        LocationLink.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link LocationLink} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri)\n                && Range.is(candidate.targetSelectionRange)\n                && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));\n        }\n        LocationLink.is = is;\n    })(LocationLink || (exports.LocationLink = LocationLink = {}));\n    /**\n     * The Color namespace provides helper functions to work with\n     * {@link Color} literals.\n     */\n    var Color;\n    (function (Color) {\n        /**\n         * Creates a new Color literal.\n         */\n        function create(red, green, blue, alpha) {\n            return {\n                red: red,\n                green: green,\n                blue: blue,\n                alpha: alpha,\n            };\n        }\n        Color.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link Color} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1)\n                && Is.numberRange(candidate.green, 0, 1)\n                && Is.numberRange(candidate.blue, 0, 1)\n                && Is.numberRange(candidate.alpha, 0, 1);\n        }\n        Color.is = is;\n    })(Color || (exports.Color = Color = {}));\n    /**\n     * The ColorInformation namespace provides helper functions to work with\n     * {@link ColorInformation} literals.\n     */\n    var ColorInformation;\n    (function (ColorInformation) {\n        /**\n         * Creates a new ColorInformation literal.\n         */\n        function create(range, color) {\n            return {\n                range: range,\n                color: color,\n            };\n        }\n        ColorInformation.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link ColorInformation} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);\n        }\n        ColorInformation.is = is;\n    })(ColorInformation || (exports.ColorInformation = ColorInformation = {}));\n    /**\n     * The Color namespace provides helper functions to work with\n     * {@link ColorPresentation} literals.\n     */\n    var ColorPresentation;\n    (function (ColorPresentation) {\n        /**\n         * Creates a new ColorInformation literal.\n         */\n        function create(label, textEdit, additionalTextEdits) {\n            return {\n                label: label,\n                textEdit: textEdit,\n                additionalTextEdits: additionalTextEdits,\n            };\n        }\n        ColorPresentation.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link ColorInformation} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Is.string(candidate.label)\n                && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate))\n                && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));\n        }\n        ColorPresentation.is = is;\n    })(ColorPresentation || (exports.ColorPresentation = ColorPresentation = {}));\n    /**\n     * A set of predefined range kinds.\n     */\n    var FoldingRangeKind;\n    (function (FoldingRangeKind) {\n        /**\n         * Folding range for a comment\n         */\n        FoldingRangeKind.Comment = 'comment';\n        /**\n         * Folding range for an import or include\n         */\n        FoldingRangeKind.Imports = 'imports';\n        /**\n         * Folding range for a region (e.g. `#region`)\n         */\n        FoldingRangeKind.Region = 'region';\n    })(FoldingRangeKind || (exports.FoldingRangeKind = FoldingRangeKind = {}));\n    /**\n     * The folding range namespace provides helper functions to work with\n     * {@link FoldingRange} literals.\n     */\n    var FoldingRange;\n    (function (FoldingRange) {\n        /**\n         * Creates a new FoldingRange literal.\n         */\n        function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {\n            var result = {\n                startLine: startLine,\n                endLine: endLine\n            };\n            if (Is.defined(startCharacter)) {\n                result.startCharacter = startCharacter;\n            }\n            if (Is.defined(endCharacter)) {\n                result.endCharacter = endCharacter;\n            }\n            if (Is.defined(kind)) {\n                result.kind = kind;\n            }\n            if (Is.defined(collapsedText)) {\n                result.collapsedText = collapsedText;\n            }\n            return result;\n        }\n        FoldingRange.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link FoldingRange} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine)\n                && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter))\n                && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter))\n                && (Is.undefined(candidate.kind) || Is.string(candidate.kind));\n        }\n        FoldingRange.is = is;\n    })(FoldingRange || (exports.FoldingRange = FoldingRange = {}));\n    /**\n     * The DiagnosticRelatedInformation namespace provides helper functions to work with\n     * {@link DiagnosticRelatedInformation} literals.\n     */\n    var DiagnosticRelatedInformation;\n    (function (DiagnosticRelatedInformation) {\n        /**\n         * Creates a new DiagnosticRelatedInformation literal.\n         */\n        function create(location, message) {\n            return {\n                location: location,\n                message: message\n            };\n        }\n        DiagnosticRelatedInformation.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link DiagnosticRelatedInformation} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);\n        }\n        DiagnosticRelatedInformation.is = is;\n    })(DiagnosticRelatedInformation || (exports.DiagnosticRelatedInformation = DiagnosticRelatedInformation = {}));\n    /**\n     * The diagnostic's severity.\n     */\n    var DiagnosticSeverity;\n    (function (DiagnosticSeverity) {\n        /**\n         * Reports an error.\n         */\n        DiagnosticSeverity.Error = 1;\n        /**\n         * Reports a warning.\n         */\n        DiagnosticSeverity.Warning = 2;\n        /**\n         * Reports an information.\n         */\n        DiagnosticSeverity.Information = 3;\n        /**\n         * Reports a hint.\n         */\n        DiagnosticSeverity.Hint = 4;\n    })(DiagnosticSeverity || (exports.DiagnosticSeverity = DiagnosticSeverity = {}));\n    /**\n     * The diagnostic tags.\n     *\n     * @since 3.15.0\n     */\n    var DiagnosticTag;\n    (function (DiagnosticTag) {\n        /**\n         * Unused or unnecessary code.\n         *\n         * Clients are allowed to render diagnostics with this tag faded out instead of having\n         * an error squiggle.\n         */\n        DiagnosticTag.Unnecessary = 1;\n        /**\n         * Deprecated or obsolete code.\n         *\n         * Clients are allowed to rendered diagnostics with this tag strike through.\n         */\n        DiagnosticTag.Deprecated = 2;\n    })(DiagnosticTag || (exports.DiagnosticTag = DiagnosticTag = {}));\n    /**\n     * The CodeDescription namespace provides functions to deal with descriptions for diagnostic codes.\n     *\n     * @since 3.16.0\n     */\n    var CodeDescription;\n    (function (CodeDescription) {\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Is.string(candidate.href);\n        }\n        CodeDescription.is = is;\n    })(CodeDescription || (exports.CodeDescription = CodeDescription = {}));\n    /**\n     * The Diagnostic namespace provides helper functions to work with\n     * {@link Diagnostic} literals.\n     */\n    var Diagnostic;\n    (function (Diagnostic) {\n        /**\n         * Creates a new Diagnostic literal.\n         */\n        function create(range, message, severity, code, source, relatedInformation) {\n            var result = { range: range, message: message };\n            if (Is.defined(severity)) {\n                result.severity = severity;\n            }\n            if (Is.defined(code)) {\n                result.code = code;\n            }\n            if (Is.defined(source)) {\n                result.source = source;\n            }\n            if (Is.defined(relatedInformation)) {\n                result.relatedInformation = relatedInformation;\n            }\n            return result;\n        }\n        Diagnostic.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link Diagnostic} interface.\n         */\n        function is(value) {\n            var _a;\n            var candidate = value;\n            return Is.defined(candidate)\n                && Range.is(candidate.range)\n                && Is.string(candidate.message)\n                && (Is.number(candidate.severity) || Is.undefined(candidate.severity))\n                && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code))\n                && (Is.undefined(candidate.codeDescription) || (Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)))\n                && (Is.string(candidate.source) || Is.undefined(candidate.source))\n                && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));\n        }\n        Diagnostic.is = is;\n    })(Diagnostic || (exports.Diagnostic = Diagnostic = {}));\n    /**\n     * The Command namespace provides helper functions to work with\n     * {@link Command} literals.\n     */\n    var Command;\n    (function (Command) {\n        /**\n         * Creates a new Command literal.\n         */\n        function create(title, command) {\n            var args = [];\n            for (var _i = 2; _i < arguments.length; _i++) {\n                args[_i - 2] = arguments[_i];\n            }\n            var result = { title: title, command: command };\n            if (Is.defined(args) && args.length > 0) {\n                result.arguments = args;\n            }\n            return result;\n        }\n        Command.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link Command} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);\n        }\n        Command.is = is;\n    })(Command || (exports.Command = Command = {}));\n    /**\n     * The TextEdit namespace provides helper function to create replace,\n     * insert and delete edits more easily.\n     */\n    var TextEdit;\n    (function (TextEdit) {\n        /**\n         * Creates a replace text edit.\n         * @param range The range of text to be replaced.\n         * @param newText The new text.\n         */\n        function replace(range, newText) {\n            return { range: range, newText: newText };\n        }\n        TextEdit.replace = replace;\n        /**\n         * Creates an insert text edit.\n         * @param position The position to insert the text at.\n         * @param newText The text to be inserted.\n         */\n        function insert(position, newText) {\n            return { range: { start: position, end: position }, newText: newText };\n        }\n        TextEdit.insert = insert;\n        /**\n         * Creates a delete text edit.\n         * @param range The range of text to be deleted.\n         */\n        function del(range) {\n            return { range: range, newText: '' };\n        }\n        TextEdit.del = del;\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate)\n                && Is.string(candidate.newText)\n                && Range.is(candidate.range);\n        }\n        TextEdit.is = is;\n    })(TextEdit || (exports.TextEdit = TextEdit = {}));\n    var ChangeAnnotation;\n    (function (ChangeAnnotation) {\n        function create(label, needsConfirmation, description) {\n            var result = { label: label };\n            if (needsConfirmation !== undefined) {\n                result.needsConfirmation = needsConfirmation;\n            }\n            if (description !== undefined) {\n                result.description = description;\n            }\n            return result;\n        }\n        ChangeAnnotation.create = create;\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Is.string(candidate.label) &&\n                (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === undefined) &&\n                (Is.string(candidate.description) || candidate.description === undefined);\n        }\n        ChangeAnnotation.is = is;\n    })(ChangeAnnotation || (exports.ChangeAnnotation = ChangeAnnotation = {}));\n    var ChangeAnnotationIdentifier;\n    (function (ChangeAnnotationIdentifier) {\n        function is(value) {\n            var candidate = value;\n            return Is.string(candidate);\n        }\n        ChangeAnnotationIdentifier.is = is;\n    })(ChangeAnnotationIdentifier || (exports.ChangeAnnotationIdentifier = ChangeAnnotationIdentifier = {}));\n    var AnnotatedTextEdit;\n    (function (AnnotatedTextEdit) {\n        /**\n         * Creates an annotated replace text edit.\n         *\n         * @param range The range of text to be replaced.\n         * @param newText The new text.\n         * @param annotation The annotation.\n         */\n        function replace(range, newText, annotation) {\n            return { range: range, newText: newText, annotationId: annotation };\n        }\n        AnnotatedTextEdit.replace = replace;\n        /**\n         * Creates an annotated insert text edit.\n         *\n         * @param position The position to insert the text at.\n         * @param newText The text to be inserted.\n         * @param annotation The annotation.\n         */\n        function insert(position, newText, annotation) {\n            return { range: { start: position, end: position }, newText: newText, annotationId: annotation };\n        }\n        AnnotatedTextEdit.insert = insert;\n        /**\n         * Creates an annotated delete text edit.\n         *\n         * @param range The range of text to be deleted.\n         * @param annotation The annotation.\n         */\n        function del(range, annotation) {\n            return { range: range, newText: '', annotationId: annotation };\n        }\n        AnnotatedTextEdit.del = del;\n        function is(value) {\n            var candidate = value;\n            return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));\n        }\n        AnnotatedTextEdit.is = is;\n    })(AnnotatedTextEdit || (exports.AnnotatedTextEdit = AnnotatedTextEdit = {}));\n    /**\n     * The TextDocumentEdit namespace provides helper function to create\n     * an edit that manipulates a text document.\n     */\n    var TextDocumentEdit;\n    (function (TextDocumentEdit) {\n        /**\n         * Creates a new `TextDocumentEdit`\n         */\n        function create(textDocument, edits) {\n            return { textDocument: textDocument, edits: edits };\n        }\n        TextDocumentEdit.create = create;\n        function is(value) {\n            var candidate = value;\n            return Is.defined(candidate)\n                && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument)\n                && Array.isArray(candidate.edits);\n        }\n        TextDocumentEdit.is = is;\n    })(TextDocumentEdit || (exports.TextDocumentEdit = TextDocumentEdit = {}));\n    var CreateFile;\n    (function (CreateFile) {\n        function create(uri, options, annotation) {\n            var result = {\n                kind: 'create',\n                uri: uri\n            };\n            if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {\n                result.options = options;\n            }\n            if (annotation !== undefined) {\n                result.annotationId = annotation;\n            }\n            return result;\n        }\n        CreateFile.create = create;\n        function is(value) {\n            var candidate = value;\n            return candidate && candidate.kind === 'create' && Is.string(candidate.uri) && (candidate.options === undefined ||\n                ((candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));\n        }\n        CreateFile.is = is;\n    })(CreateFile || (exports.CreateFile = CreateFile = {}));\n    var RenameFile;\n    (function (RenameFile) {\n        function create(oldUri, newUri, options, annotation) {\n            var result = {\n                kind: 'rename',\n                oldUri: oldUri,\n                newUri: newUri\n            };\n            if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {\n                result.options = options;\n            }\n            if (annotation !== undefined) {\n                result.annotationId = annotation;\n            }\n            return result;\n        }\n        RenameFile.create = create;\n        function is(value) {\n            var candidate = value;\n            return candidate && candidate.kind === 'rename' && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === undefined ||\n                ((candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));\n        }\n        RenameFile.is = is;\n    })(RenameFile || (exports.RenameFile = RenameFile = {}));\n    var DeleteFile;\n    (function (DeleteFile) {\n        function create(uri, options, annotation) {\n            var result = {\n                kind: 'delete',\n                uri: uri\n            };\n            if (options !== undefined && (options.recursive !== undefined || options.ignoreIfNotExists !== undefined)) {\n                result.options = options;\n            }\n            if (annotation !== undefined) {\n                result.annotationId = annotation;\n            }\n            return result;\n        }\n        DeleteFile.create = create;\n        function is(value) {\n            var candidate = value;\n            return candidate && candidate.kind === 'delete' && Is.string(candidate.uri) && (candidate.options === undefined ||\n                ((candidate.options.recursive === undefined || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === undefined || Is.boolean(candidate.options.ignoreIfNotExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));\n        }\n        DeleteFile.is = is;\n    })(DeleteFile || (exports.DeleteFile = DeleteFile = {}));\n    var WorkspaceEdit;\n    (function (WorkspaceEdit) {\n        function is(value) {\n            var candidate = value;\n            return candidate &&\n                (candidate.changes !== undefined || candidate.documentChanges !== undefined) &&\n                (candidate.documentChanges === undefined || candidate.documentChanges.every(function (change) {\n                    if (Is.string(change.kind)) {\n                        return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);\n                    }\n                    else {\n                        return TextDocumentEdit.is(change);\n                    }\n                }));\n        }\n        WorkspaceEdit.is = is;\n    })(WorkspaceEdit || (exports.WorkspaceEdit = WorkspaceEdit = {}));\n    var TextEditChangeImpl = /** @class */ (function () {\n        function TextEditChangeImpl(edits, changeAnnotations) {\n            this.edits = edits;\n            this.changeAnnotations = changeAnnotations;\n        }\n        TextEditChangeImpl.prototype.insert = function (position, newText, annotation) {\n            var edit;\n            var id;\n            if (annotation === undefined) {\n                edit = TextEdit.insert(position, newText);\n            }\n            else if (ChangeAnnotationIdentifier.is(annotation)) {\n                id = annotation;\n                edit = AnnotatedTextEdit.insert(position, newText, annotation);\n            }\n            else {\n                this.assertChangeAnnotations(this.changeAnnotations);\n                id = this.changeAnnotations.manage(annotation);\n                edit = AnnotatedTextEdit.insert(position, newText, id);\n            }\n            this.edits.push(edit);\n            if (id !== undefined) {\n                return id;\n            }\n        };\n        TextEditChangeImpl.prototype.replace = function (range, newText, annotation) {\n            var edit;\n            var id;\n            if (annotation === undefined) {\n                edit = TextEdit.replace(range, newText);\n            }\n            else if (ChangeAnnotationIdentifier.is(annotation)) {\n                id = annotation;\n                edit = AnnotatedTextEdit.replace(range, newText, annotation);\n            }\n            else {\n                this.assertChangeAnnotations(this.changeAnnotations);\n                id = this.changeAnnotations.manage(annotation);\n                edit = AnnotatedTextEdit.replace(range, newText, id);\n            }\n            this.edits.push(edit);\n            if (id !== undefined) {\n                return id;\n            }\n        };\n        TextEditChangeImpl.prototype.delete = function (range, annotation) {\n            var edit;\n            var id;\n            if (annotation === undefined) {\n                edit = TextEdit.del(range);\n            }\n            else if (ChangeAnnotationIdentifier.is(annotation)) {\n                id = annotation;\n                edit = AnnotatedTextEdit.del(range, annotation);\n            }\n            else {\n                this.assertChangeAnnotations(this.changeAnnotations);\n                id = this.changeAnnotations.manage(annotation);\n                edit = AnnotatedTextEdit.del(range, id);\n            }\n            this.edits.push(edit);\n            if (id !== undefined) {\n                return id;\n            }\n        };\n        TextEditChangeImpl.prototype.add = function (edit) {\n            this.edits.push(edit);\n        };\n        TextEditChangeImpl.prototype.all = function () {\n            return this.edits;\n        };\n        TextEditChangeImpl.prototype.clear = function () {\n            this.edits.splice(0, this.edits.length);\n        };\n        TextEditChangeImpl.prototype.assertChangeAnnotations = function (value) {\n            if (value === undefined) {\n                throw new Error(\"Text edit change is not configured to manage change annotations.\");\n            }\n        };\n        return TextEditChangeImpl;\n    }());\n    /**\n     * A helper class\n     */\n    var ChangeAnnotations = /** @class */ (function () {\n        function ChangeAnnotations(annotations) {\n            this._annotations = annotations === undefined ? Object.create(null) : annotations;\n            this._counter = 0;\n            this._size = 0;\n        }\n        ChangeAnnotations.prototype.all = function () {\n            return this._annotations;\n        };\n        Object.defineProperty(ChangeAnnotations.prototype, \"size\", {\n            get: function () {\n                return this._size;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        ChangeAnnotations.prototype.manage = function (idOrAnnotation, annotation) {\n            var id;\n            if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {\n                id = idOrAnnotation;\n            }\n            else {\n                id = this.nextId();\n                annotation = idOrAnnotation;\n            }\n            if (this._annotations[id] !== undefined) {\n                throw new Error(\"Id \".concat(id, \" is already in use.\"));\n            }\n            if (annotation === undefined) {\n                throw new Error(\"No annotation provided for id \".concat(id));\n            }\n            this._annotations[id] = annotation;\n            this._size++;\n            return id;\n        };\n        ChangeAnnotations.prototype.nextId = function () {\n            this._counter++;\n            return this._counter.toString();\n        };\n        return ChangeAnnotations;\n    }());\n    /**\n     * A workspace change helps constructing changes to a workspace.\n     */\n    var WorkspaceChange = /** @class */ (function () {\n        function WorkspaceChange(workspaceEdit) {\n            var _this = this;\n            this._textEditChanges = Object.create(null);\n            if (workspaceEdit !== undefined) {\n                this._workspaceEdit = workspaceEdit;\n                if (workspaceEdit.documentChanges) {\n                    this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);\n                    workspaceEdit.changeAnnotations = this._changeAnnotations.all();\n                    workspaceEdit.documentChanges.forEach(function (change) {\n                        if (TextDocumentEdit.is(change)) {\n                            var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);\n                            _this._textEditChanges[change.textDocument.uri] = textEditChange;\n                        }\n                    });\n                }\n                else if (workspaceEdit.changes) {\n                    Object.keys(workspaceEdit.changes).forEach(function (key) {\n                        var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);\n                        _this._textEditChanges[key] = textEditChange;\n                    });\n                }\n            }\n            else {\n                this._workspaceEdit = {};\n            }\n        }\n        Object.defineProperty(WorkspaceChange.prototype, \"edit\", {\n            /**\n             * Returns the underlying {@link WorkspaceEdit} literal\n             * use to be returned from a workspace edit operation like rename.\n             */\n            get: function () {\n                this.initDocumentChanges();\n                if (this._changeAnnotations !== undefined) {\n                    if (this._changeAnnotations.size === 0) {\n                        this._workspaceEdit.changeAnnotations = undefined;\n                    }\n                    else {\n                        this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();\n                    }\n                }\n                return this._workspaceEdit;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        WorkspaceChange.prototype.getTextEditChange = function (key) {\n            if (OptionalVersionedTextDocumentIdentifier.is(key)) {\n                this.initDocumentChanges();\n                if (this._workspaceEdit.documentChanges === undefined) {\n                    throw new Error('Workspace edit is not configured for document changes.');\n                }\n                var textDocument = { uri: key.uri, version: key.version };\n                var result = this._textEditChanges[textDocument.uri];\n                if (!result) {\n                    var edits = [];\n                    var textDocumentEdit = {\n                        textDocument: textDocument,\n                        edits: edits\n                    };\n                    this._workspaceEdit.documentChanges.push(textDocumentEdit);\n                    result = new TextEditChangeImpl(edits, this._changeAnnotations);\n                    this._textEditChanges[textDocument.uri] = result;\n                }\n                return result;\n            }\n            else {\n                this.initChanges();\n                if (this._workspaceEdit.changes === undefined) {\n                    throw new Error('Workspace edit is not configured for normal text edit changes.');\n                }\n                var result = this._textEditChanges[key];\n                if (!result) {\n                    var edits = [];\n                    this._workspaceEdit.changes[key] = edits;\n                    result = new TextEditChangeImpl(edits);\n                    this._textEditChanges[key] = result;\n                }\n                return result;\n            }\n        };\n        WorkspaceChange.prototype.initDocumentChanges = function () {\n            if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {\n                this._changeAnnotations = new ChangeAnnotations();\n                this._workspaceEdit.documentChanges = [];\n                this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();\n            }\n        };\n        WorkspaceChange.prototype.initChanges = function () {\n            if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {\n                this._workspaceEdit.changes = Object.create(null);\n            }\n        };\n        WorkspaceChange.prototype.createFile = function (uri, optionsOrAnnotation, options) {\n            this.initDocumentChanges();\n            if (this._workspaceEdit.documentChanges === undefined) {\n                throw new Error('Workspace edit is not configured for document changes.');\n            }\n            var annotation;\n            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {\n                annotation = optionsOrAnnotation;\n            }\n            else {\n                options = optionsOrAnnotation;\n            }\n            var operation;\n            var id;\n            if (annotation === undefined) {\n                operation = CreateFile.create(uri, options);\n            }\n            else {\n                id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);\n                operation = CreateFile.create(uri, options, id);\n            }\n            this._workspaceEdit.documentChanges.push(operation);\n            if (id !== undefined) {\n                return id;\n            }\n        };\n        WorkspaceChange.prototype.renameFile = function (oldUri, newUri, optionsOrAnnotation, options) {\n            this.initDocumentChanges();\n            if (this._workspaceEdit.documentChanges === undefined) {\n                throw new Error('Workspace edit is not configured for document changes.');\n            }\n            var annotation;\n            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {\n                annotation = optionsOrAnnotation;\n            }\n            else {\n                options = optionsOrAnnotation;\n            }\n            var operation;\n            var id;\n            if (annotation === undefined) {\n                operation = RenameFile.create(oldUri, newUri, options);\n            }\n            else {\n                id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);\n                operation = RenameFile.create(oldUri, newUri, options, id);\n            }\n            this._workspaceEdit.documentChanges.push(operation);\n            if (id !== undefined) {\n                return id;\n            }\n        };\n        WorkspaceChange.prototype.deleteFile = function (uri, optionsOrAnnotation, options) {\n            this.initDocumentChanges();\n            if (this._workspaceEdit.documentChanges === undefined) {\n                throw new Error('Workspace edit is not configured for document changes.');\n            }\n            var annotation;\n            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {\n                annotation = optionsOrAnnotation;\n            }\n            else {\n                options = optionsOrAnnotation;\n            }\n            var operation;\n            var id;\n            if (annotation === undefined) {\n                operation = DeleteFile.create(uri, options);\n            }\n            else {\n                id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);\n                operation = DeleteFile.create(uri, options, id);\n            }\n            this._workspaceEdit.documentChanges.push(operation);\n            if (id !== undefined) {\n                return id;\n            }\n        };\n        return WorkspaceChange;\n    }());\n    exports.WorkspaceChange = WorkspaceChange;\n    /**\n     * The TextDocumentIdentifier namespace provides helper functions to work with\n     * {@link TextDocumentIdentifier} literals.\n     */\n    var TextDocumentIdentifier;\n    (function (TextDocumentIdentifier) {\n        /**\n         * Creates a new TextDocumentIdentifier literal.\n         * @param uri The document's uri.\n         */\n        function create(uri) {\n            return { uri: uri };\n        }\n        TextDocumentIdentifier.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link TextDocumentIdentifier} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Is.string(candidate.uri);\n        }\n        TextDocumentIdentifier.is = is;\n    })(TextDocumentIdentifier || (exports.TextDocumentIdentifier = TextDocumentIdentifier = {}));\n    /**\n     * The VersionedTextDocumentIdentifier namespace provides helper functions to work with\n     * {@link VersionedTextDocumentIdentifier} literals.\n     */\n    var VersionedTextDocumentIdentifier;\n    (function (VersionedTextDocumentIdentifier) {\n        /**\n         * Creates a new VersionedTextDocumentIdentifier literal.\n         * @param uri The document's uri.\n         * @param version The document's version.\n         */\n        function create(uri, version) {\n            return { uri: uri, version: version };\n        }\n        VersionedTextDocumentIdentifier.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link VersionedTextDocumentIdentifier} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);\n        }\n        VersionedTextDocumentIdentifier.is = is;\n    })(VersionedTextDocumentIdentifier || (exports.VersionedTextDocumentIdentifier = VersionedTextDocumentIdentifier = {}));\n    /**\n     * The OptionalVersionedTextDocumentIdentifier namespace provides helper functions to work with\n     * {@link OptionalVersionedTextDocumentIdentifier} literals.\n     */\n    var OptionalVersionedTextDocumentIdentifier;\n    (function (OptionalVersionedTextDocumentIdentifier) {\n        /**\n         * Creates a new OptionalVersionedTextDocumentIdentifier literal.\n         * @param uri The document's uri.\n         * @param version The document's version.\n         */\n        function create(uri, version) {\n            return { uri: uri, version: version };\n        }\n        OptionalVersionedTextDocumentIdentifier.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link OptionalVersionedTextDocumentIdentifier} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));\n        }\n        OptionalVersionedTextDocumentIdentifier.is = is;\n    })(OptionalVersionedTextDocumentIdentifier || (exports.OptionalVersionedTextDocumentIdentifier = OptionalVersionedTextDocumentIdentifier = {}));\n    /**\n     * The TextDocumentItem namespace provides helper functions to work with\n     * {@link TextDocumentItem} literals.\n     */\n    var TextDocumentItem;\n    (function (TextDocumentItem) {\n        /**\n         * Creates a new TextDocumentItem literal.\n         * @param uri The document's uri.\n         * @param languageId The document's language identifier.\n         * @param version The document's version number.\n         * @param text The document's text.\n         */\n        function create(uri, languageId, version, text) {\n            return { uri: uri, languageId: languageId, version: version, text: text };\n        }\n        TextDocumentItem.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link TextDocumentItem} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);\n        }\n        TextDocumentItem.is = is;\n    })(TextDocumentItem || (exports.TextDocumentItem = TextDocumentItem = {}));\n    /**\n     * Describes the content type that a client supports in various\n     * result literals like `Hover`, `ParameterInfo` or `CompletionItem`.\n     *\n     * Please note that `MarkupKinds` must not start with a `$`. This kinds\n     * are reserved for internal usage.\n     */\n    var MarkupKind;\n    (function (MarkupKind) {\n        /**\n         * Plain text is supported as a content format\n         */\n        MarkupKind.PlainText = 'plaintext';\n        /**\n         * Markdown is supported as a content format\n         */\n        MarkupKind.Markdown = 'markdown';\n        /**\n         * Checks whether the given value is a value of the {@link MarkupKind} type.\n         */\n        function is(value) {\n            var candidate = value;\n            return candidate === MarkupKind.PlainText || candidate === MarkupKind.Markdown;\n        }\n        MarkupKind.is = is;\n    })(MarkupKind || (exports.MarkupKind = MarkupKind = {}));\n    var MarkupContent;\n    (function (MarkupContent) {\n        /**\n         * Checks whether the given value conforms to the {@link MarkupContent} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);\n        }\n        MarkupContent.is = is;\n    })(MarkupContent || (exports.MarkupContent = MarkupContent = {}));\n    /**\n     * The kind of a completion entry.\n     */\n    var CompletionItemKind;\n    (function (CompletionItemKind) {\n        CompletionItemKind.Text = 1;\n        CompletionItemKind.Method = 2;\n        CompletionItemKind.Function = 3;\n        CompletionItemKind.Constructor = 4;\n        CompletionItemKind.Field = 5;\n        CompletionItemKind.Variable = 6;\n        CompletionItemKind.Class = 7;\n        CompletionItemKind.Interface = 8;\n        CompletionItemKind.Module = 9;\n        CompletionItemKind.Property = 10;\n        CompletionItemKind.Unit = 11;\n        CompletionItemKind.Value = 12;\n        CompletionItemKind.Enum = 13;\n        CompletionItemKind.Keyword = 14;\n        CompletionItemKind.Snippet = 15;\n        CompletionItemKind.Color = 16;\n        CompletionItemKind.File = 17;\n        CompletionItemKind.Reference = 18;\n        CompletionItemKind.Folder = 19;\n        CompletionItemKind.EnumMember = 20;\n        CompletionItemKind.Constant = 21;\n        CompletionItemKind.Struct = 22;\n        CompletionItemKind.Event = 23;\n        CompletionItemKind.Operator = 24;\n        CompletionItemKind.TypeParameter = 25;\n    })(CompletionItemKind || (exports.CompletionItemKind = CompletionItemKind = {}));\n    /**\n     * Defines whether the insert text in a completion item should be interpreted as\n     * plain text or a snippet.\n     */\n    var InsertTextFormat;\n    (function (InsertTextFormat) {\n        /**\n         * The primary text to be inserted is treated as a plain string.\n         */\n        InsertTextFormat.PlainText = 1;\n        /**\n         * The primary text to be inserted is treated as a snippet.\n         *\n         * A snippet can define tab stops and placeholders with `$1`, `$2`\n         * and `${3:foo}`. `$0` defines the final tab stop, it defaults to\n         * the end of the snippet. Placeholders with equal identifiers are linked,\n         * that is typing in one will update others too.\n         *\n         * See also: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#snippet_syntax\n         */\n        InsertTextFormat.Snippet = 2;\n    })(InsertTextFormat || (exports.InsertTextFormat = InsertTextFormat = {}));\n    /**\n     * Completion item tags are extra annotations that tweak the rendering of a completion\n     * item.\n     *\n     * @since 3.15.0\n     */\n    var CompletionItemTag;\n    (function (CompletionItemTag) {\n        /**\n         * Render a completion as obsolete, usually using a strike-out.\n         */\n        CompletionItemTag.Deprecated = 1;\n    })(CompletionItemTag || (exports.CompletionItemTag = CompletionItemTag = {}));\n    /**\n     * The InsertReplaceEdit namespace provides functions to deal with insert / replace edits.\n     *\n     * @since 3.16.0\n     */\n    var InsertReplaceEdit;\n    (function (InsertReplaceEdit) {\n        /**\n         * Creates a new insert / replace edit\n         */\n        function create(newText, insert, replace) {\n            return { newText: newText, insert: insert, replace: replace };\n        }\n        InsertReplaceEdit.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link InsertReplaceEdit} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);\n        }\n        InsertReplaceEdit.is = is;\n    })(InsertReplaceEdit || (exports.InsertReplaceEdit = InsertReplaceEdit = {}));\n    /**\n     * How whitespace and indentation is handled during completion\n     * item insertion.\n     *\n     * @since 3.16.0\n     */\n    var InsertTextMode;\n    (function (InsertTextMode) {\n        /**\n         * The insertion or replace strings is taken as it is. If the\n         * value is multi line the lines below the cursor will be\n         * inserted using the indentation defined in the string value.\n         * The client will not apply any kind of adjustments to the\n         * string.\n         */\n        InsertTextMode.asIs = 1;\n        /**\n         * The editor adjusts leading whitespace of new lines so that\n         * they match the indentation up to the cursor of the line for\n         * which the item is accepted.\n         *\n         * Consider a line like this: <2tabs><cursor><3tabs>foo. Accepting a\n         * multi line completion item is indented using 2 tabs and all\n         * following lines inserted will be indented using 2 tabs as well.\n         */\n        InsertTextMode.adjustIndentation = 2;\n    })(InsertTextMode || (exports.InsertTextMode = InsertTextMode = {}));\n    var CompletionItemLabelDetails;\n    (function (CompletionItemLabelDetails) {\n        function is(value) {\n            var candidate = value;\n            return candidate && (Is.string(candidate.detail) || candidate.detail === undefined) &&\n                (Is.string(candidate.description) || candidate.description === undefined);\n        }\n        CompletionItemLabelDetails.is = is;\n    })(CompletionItemLabelDetails || (exports.CompletionItemLabelDetails = CompletionItemLabelDetails = {}));\n    /**\n     * The CompletionItem namespace provides functions to deal with\n     * completion items.\n     */\n    var CompletionItem;\n    (function (CompletionItem) {\n        /**\n         * Create a completion item and seed it with a label.\n         * @param label The completion item's label\n         */\n        function create(label) {\n            return { label: label };\n        }\n        CompletionItem.create = create;\n    })(CompletionItem || (exports.CompletionItem = CompletionItem = {}));\n    /**\n     * The CompletionList namespace provides functions to deal with\n     * completion lists.\n     */\n    var CompletionList;\n    (function (CompletionList) {\n        /**\n         * Creates a new completion list.\n         *\n         * @param items The completion items.\n         * @param isIncomplete The list is not complete.\n         */\n        function create(items, isIncomplete) {\n            return { items: items ? items : [], isIncomplete: !!isIncomplete };\n        }\n        CompletionList.create = create;\n    })(CompletionList || (exports.CompletionList = CompletionList = {}));\n    var MarkedString;\n    (function (MarkedString) {\n        /**\n         * Creates a marked string from plain text.\n         *\n         * @param plainText The plain text.\n         */\n        function fromPlainText(plainText) {\n            return plainText.replace(/[\\\\`*_{}[\\]()#+\\-.!]/g, '\\\\$&'); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash\n        }\n        MarkedString.fromPlainText = fromPlainText;\n        /**\n         * Checks whether the given value conforms to the {@link MarkedString} type.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.string(candidate) || (Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value));\n        }\n        MarkedString.is = is;\n    })(MarkedString || (exports.MarkedString = MarkedString = {}));\n    var Hover;\n    (function (Hover) {\n        /**\n         * Checks whether the given value conforms to the {@link Hover} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) ||\n                MarkedString.is(candidate.contents) ||\n                Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === undefined || Range.is(value.range));\n        }\n        Hover.is = is;\n    })(Hover || (exports.Hover = Hover = {}));\n    /**\n     * The ParameterInformation namespace provides helper functions to work with\n     * {@link ParameterInformation} literals.\n     */\n    var ParameterInformation;\n    (function (ParameterInformation) {\n        /**\n         * Creates a new parameter information literal.\n         *\n         * @param label A label string.\n         * @param documentation A doc string.\n         */\n        function create(label, documentation) {\n            return documentation ? { label: label, documentation: documentation } : { label: label };\n        }\n        ParameterInformation.create = create;\n    })(ParameterInformation || (exports.ParameterInformation = ParameterInformation = {}));\n    /**\n     * The SignatureInformation namespace provides helper functions to work with\n     * {@link SignatureInformation} literals.\n     */\n    var SignatureInformation;\n    (function (SignatureInformation) {\n        function create(label, documentation) {\n            var parameters = [];\n            for (var _i = 2; _i < arguments.length; _i++) {\n                parameters[_i - 2] = arguments[_i];\n            }\n            var result = { label: label };\n            if (Is.defined(documentation)) {\n                result.documentation = documentation;\n            }\n            if (Is.defined(parameters)) {\n                result.parameters = parameters;\n            }\n            else {\n                result.parameters = [];\n            }\n            return result;\n        }\n        SignatureInformation.create = create;\n    })(SignatureInformation || (exports.SignatureInformation = SignatureInformation = {}));\n    /**\n     * A document highlight kind.\n     */\n    var DocumentHighlightKind;\n    (function (DocumentHighlightKind) {\n        /**\n         * A textual occurrence.\n         */\n        DocumentHighlightKind.Text = 1;\n        /**\n         * Read-access of a symbol, like reading a variable.\n         */\n        DocumentHighlightKind.Read = 2;\n        /**\n         * Write-access of a symbol, like writing to a variable.\n         */\n        DocumentHighlightKind.Write = 3;\n    })(DocumentHighlightKind || (exports.DocumentHighlightKind = DocumentHighlightKind = {}));\n    /**\n     * DocumentHighlight namespace to provide helper functions to work with\n     * {@link DocumentHighlight} literals.\n     */\n    var DocumentHighlight;\n    (function (DocumentHighlight) {\n        /**\n         * Create a DocumentHighlight object.\n         * @param range The range the highlight applies to.\n         * @param kind The highlight kind\n         */\n        function create(range, kind) {\n            var result = { range: range };\n            if (Is.number(kind)) {\n                result.kind = kind;\n            }\n            return result;\n        }\n        DocumentHighlight.create = create;\n    })(DocumentHighlight || (exports.DocumentHighlight = DocumentHighlight = {}));\n    /**\n     * A symbol kind.\n     */\n    var SymbolKind;\n    (function (SymbolKind) {\n        SymbolKind.File = 1;\n        SymbolKind.Module = 2;\n        SymbolKind.Namespace = 3;\n        SymbolKind.Package = 4;\n        SymbolKind.Class = 5;\n        SymbolKind.Method = 6;\n        SymbolKind.Property = 7;\n        SymbolKind.Field = 8;\n        SymbolKind.Constructor = 9;\n        SymbolKind.Enum = 10;\n        SymbolKind.Interface = 11;\n        SymbolKind.Function = 12;\n        SymbolKind.Variable = 13;\n        SymbolKind.Constant = 14;\n        SymbolKind.String = 15;\n        SymbolKind.Number = 16;\n        SymbolKind.Boolean = 17;\n        SymbolKind.Array = 18;\n        SymbolKind.Object = 19;\n        SymbolKind.Key = 20;\n        SymbolKind.Null = 21;\n        SymbolKind.EnumMember = 22;\n        SymbolKind.Struct = 23;\n        SymbolKind.Event = 24;\n        SymbolKind.Operator = 25;\n        SymbolKind.TypeParameter = 26;\n    })(SymbolKind || (exports.SymbolKind = SymbolKind = {}));\n    /**\n     * Symbol tags are extra annotations that tweak the rendering of a symbol.\n     *\n     * @since 3.16\n     */\n    var SymbolTag;\n    (function (SymbolTag) {\n        /**\n         * Render a symbol as obsolete, usually using a strike-out.\n         */\n        SymbolTag.Deprecated = 1;\n    })(SymbolTag || (exports.SymbolTag = SymbolTag = {}));\n    var SymbolInformation;\n    (function (SymbolInformation) {\n        /**\n         * Creates a new symbol information literal.\n         *\n         * @param name The name of the symbol.\n         * @param kind The kind of the symbol.\n         * @param range The range of the location of the symbol.\n         * @param uri The resource of the location of symbol.\n         * @param containerName The name of the symbol containing the symbol.\n         */\n        function create(name, kind, range, uri, containerName) {\n            var result = {\n                name: name,\n                kind: kind,\n                location: { uri: uri, range: range }\n            };\n            if (containerName) {\n                result.containerName = containerName;\n            }\n            return result;\n        }\n        SymbolInformation.create = create;\n    })(SymbolInformation || (exports.SymbolInformation = SymbolInformation = {}));\n    var WorkspaceSymbol;\n    (function (WorkspaceSymbol) {\n        /**\n         * Create a new workspace symbol.\n         *\n         * @param name The name of the symbol.\n         * @param kind The kind of the symbol.\n         * @param uri The resource of the location of the symbol.\n         * @param range An options range of the location.\n         * @returns A WorkspaceSymbol.\n         */\n        function create(name, kind, uri, range) {\n            return range !== undefined\n                ? { name: name, kind: kind, location: { uri: uri, range: range } }\n                : { name: name, kind: kind, location: { uri: uri } };\n        }\n        WorkspaceSymbol.create = create;\n    })(WorkspaceSymbol || (exports.WorkspaceSymbol = WorkspaceSymbol = {}));\n    var DocumentSymbol;\n    (function (DocumentSymbol) {\n        /**\n         * Creates a new symbol information literal.\n         *\n         * @param name The name of the symbol.\n         * @param detail The detail of the symbol.\n         * @param kind The kind of the symbol.\n         * @param range The range of the symbol.\n         * @param selectionRange The selectionRange of the symbol.\n         * @param children Children of the symbol.\n         */\n        function create(name, detail, kind, range, selectionRange, children) {\n            var result = {\n                name: name,\n                detail: detail,\n                kind: kind,\n                range: range,\n                selectionRange: selectionRange\n            };\n            if (children !== undefined) {\n                result.children = children;\n            }\n            return result;\n        }\n        DocumentSymbol.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link DocumentSymbol} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return candidate &&\n                Is.string(candidate.name) && Is.number(candidate.kind) &&\n                Range.is(candidate.range) && Range.is(candidate.selectionRange) &&\n                (candidate.detail === undefined || Is.string(candidate.detail)) &&\n                (candidate.deprecated === undefined || Is.boolean(candidate.deprecated)) &&\n                (candidate.children === undefined || Array.isArray(candidate.children)) &&\n                (candidate.tags === undefined || Array.isArray(candidate.tags));\n        }\n        DocumentSymbol.is = is;\n    })(DocumentSymbol || (exports.DocumentSymbol = DocumentSymbol = {}));\n    /**\n     * A set of predefined code action kinds\n     */\n    var CodeActionKind;\n    (function (CodeActionKind) {\n        /**\n         * Empty kind.\n         */\n        CodeActionKind.Empty = '';\n        /**\n         * Base kind for quickfix actions: 'quickfix'\n         */\n        CodeActionKind.QuickFix = 'quickfix';\n        /**\n         * Base kind for refactoring actions: 'refactor'\n         */\n        CodeActionKind.Refactor = 'refactor';\n        /**\n         * Base kind for refactoring extraction actions: 'refactor.extract'\n         *\n         * Example extract actions:\n         *\n         * - Extract method\n         * - Extract function\n         * - Extract variable\n         * - Extract interface from class\n         * - ...\n         */\n        CodeActionKind.RefactorExtract = 'refactor.extract';\n        /**\n         * Base kind for refactoring inline actions: 'refactor.inline'\n         *\n         * Example inline actions:\n         *\n         * - Inline function\n         * - Inline variable\n         * - Inline constant\n         * - ...\n         */\n        CodeActionKind.RefactorInline = 'refactor.inline';\n        /**\n         * Base kind for refactoring rewrite actions: 'refactor.rewrite'\n         *\n         * Example rewrite actions:\n         *\n         * - Convert JavaScript function to class\n         * - Add or remove parameter\n         * - Encapsulate field\n         * - Make method static\n         * - Move method to base class\n         * - ...\n         */\n        CodeActionKind.RefactorRewrite = 'refactor.rewrite';\n        /**\n         * Base kind for source actions: `source`\n         *\n         * Source code actions apply to the entire file.\n         */\n        CodeActionKind.Source = 'source';\n        /**\n         * Base kind for an organize imports source action: `source.organizeImports`\n         */\n        CodeActionKind.SourceOrganizeImports = 'source.organizeImports';\n        /**\n         * Base kind for auto-fix source actions: `source.fixAll`.\n         *\n         * Fix all actions automatically fix errors that have a clear fix that do not require user input.\n         * They should not suppress errors or perform unsafe fixes such as generating new types or classes.\n         *\n         * @since 3.15.0\n         */\n        CodeActionKind.SourceFixAll = 'source.fixAll';\n    })(CodeActionKind || (exports.CodeActionKind = CodeActionKind = {}));\n    /**\n     * The reason why code actions were requested.\n     *\n     * @since 3.17.0\n     */\n    var CodeActionTriggerKind;\n    (function (CodeActionTriggerKind) {\n        /**\n         * Code actions were explicitly requested by the user or by an extension.\n         */\n        CodeActionTriggerKind.Invoked = 1;\n        /**\n         * Code actions were requested automatically.\n         *\n         * This typically happens when current selection in a file changes, but can\n         * also be triggered when file content changes.\n         */\n        CodeActionTriggerKind.Automatic = 2;\n    })(CodeActionTriggerKind || (exports.CodeActionTriggerKind = CodeActionTriggerKind = {}));\n    /**\n     * The CodeActionContext namespace provides helper functions to work with\n     * {@link CodeActionContext} literals.\n     */\n    var CodeActionContext;\n    (function (CodeActionContext) {\n        /**\n         * Creates a new CodeActionContext literal.\n         */\n        function create(diagnostics, only, triggerKind) {\n            var result = { diagnostics: diagnostics };\n            if (only !== undefined && only !== null) {\n                result.only = only;\n            }\n            if (triggerKind !== undefined && triggerKind !== null) {\n                result.triggerKind = triggerKind;\n            }\n            return result;\n        }\n        CodeActionContext.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link CodeActionContext} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is)\n                && (candidate.only === undefined || Is.typedArray(candidate.only, Is.string))\n                && (candidate.triggerKind === undefined || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);\n        }\n        CodeActionContext.is = is;\n    })(CodeActionContext || (exports.CodeActionContext = CodeActionContext = {}));\n    var CodeAction;\n    (function (CodeAction) {\n        function create(title, kindOrCommandOrEdit, kind) {\n            var result = { title: title };\n            var checkKind = true;\n            if (typeof kindOrCommandOrEdit === 'string') {\n                checkKind = false;\n                result.kind = kindOrCommandOrEdit;\n            }\n            else if (Command.is(kindOrCommandOrEdit)) {\n                result.command = kindOrCommandOrEdit;\n            }\n            else {\n                result.edit = kindOrCommandOrEdit;\n            }\n            if (checkKind && kind !== undefined) {\n                result.kind = kind;\n            }\n            return result;\n        }\n        CodeAction.create = create;\n        function is(value) {\n            var candidate = value;\n            return candidate && Is.string(candidate.title) &&\n                (candidate.diagnostics === undefined || Is.typedArray(candidate.diagnostics, Diagnostic.is)) &&\n                (candidate.kind === undefined || Is.string(candidate.kind)) &&\n                (candidate.edit !== undefined || candidate.command !== undefined) &&\n                (candidate.command === undefined || Command.is(candidate.command)) &&\n                (candidate.isPreferred === undefined || Is.boolean(candidate.isPreferred)) &&\n                (candidate.edit === undefined || WorkspaceEdit.is(candidate.edit));\n        }\n        CodeAction.is = is;\n    })(CodeAction || (exports.CodeAction = CodeAction = {}));\n    /**\n     * The CodeLens namespace provides helper functions to work with\n     * {@link CodeLens} literals.\n     */\n    var CodeLens;\n    (function (CodeLens) {\n        /**\n         * Creates a new CodeLens literal.\n         */\n        function create(range, data) {\n            var result = { range: range };\n            if (Is.defined(data)) {\n                result.data = data;\n            }\n            return result;\n        }\n        CodeLens.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link CodeLens} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));\n        }\n        CodeLens.is = is;\n    })(CodeLens || (exports.CodeLens = CodeLens = {}));\n    /**\n     * The FormattingOptions namespace provides helper functions to work with\n     * {@link FormattingOptions} literals.\n     */\n    var FormattingOptions;\n    (function (FormattingOptions) {\n        /**\n         * Creates a new FormattingOptions literal.\n         */\n        function create(tabSize, insertSpaces) {\n            return { tabSize: tabSize, insertSpaces: insertSpaces };\n        }\n        FormattingOptions.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link FormattingOptions} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);\n        }\n        FormattingOptions.is = is;\n    })(FormattingOptions || (exports.FormattingOptions = FormattingOptions = {}));\n    /**\n     * The DocumentLink namespace provides helper functions to work with\n     * {@link DocumentLink} literals.\n     */\n    var DocumentLink;\n    (function (DocumentLink) {\n        /**\n         * Creates a new DocumentLink literal.\n         */\n        function create(range, target, data) {\n            return { range: range, target: target, data: data };\n        }\n        DocumentLink.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link DocumentLink} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));\n        }\n        DocumentLink.is = is;\n    })(DocumentLink || (exports.DocumentLink = DocumentLink = {}));\n    /**\n     * The SelectionRange namespace provides helper function to work with\n     * SelectionRange literals.\n     */\n    var SelectionRange;\n    (function (SelectionRange) {\n        /**\n         * Creates a new SelectionRange\n         * @param range the range.\n         * @param parent an optional parent.\n         */\n        function create(range, parent) {\n            return { range: range, parent: parent };\n        }\n        SelectionRange.create = create;\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === undefined || SelectionRange.is(candidate.parent));\n        }\n        SelectionRange.is = is;\n    })(SelectionRange || (exports.SelectionRange = SelectionRange = {}));\n    /**\n     * A set of predefined token types. This set is not fixed\n     * an clients can specify additional token types via the\n     * corresponding client capabilities.\n     *\n     * @since 3.16.0\n     */\n    var SemanticTokenTypes;\n    (function (SemanticTokenTypes) {\n        SemanticTokenTypes[\"namespace\"] = \"namespace\";\n        /**\n         * Represents a generic type. Acts as a fallback for types which can't be mapped to\n         * a specific type like class or enum.\n         */\n        SemanticTokenTypes[\"type\"] = \"type\";\n        SemanticTokenTypes[\"class\"] = \"class\";\n        SemanticTokenTypes[\"enum\"] = \"enum\";\n        SemanticTokenTypes[\"interface\"] = \"interface\";\n        SemanticTokenTypes[\"struct\"] = \"struct\";\n        SemanticTokenTypes[\"typeParameter\"] = \"typeParameter\";\n        SemanticTokenTypes[\"parameter\"] = \"parameter\";\n        SemanticTokenTypes[\"variable\"] = \"variable\";\n        SemanticTokenTypes[\"property\"] = \"property\";\n        SemanticTokenTypes[\"enumMember\"] = \"enumMember\";\n        SemanticTokenTypes[\"event\"] = \"event\";\n        SemanticTokenTypes[\"function\"] = \"function\";\n        SemanticTokenTypes[\"method\"] = \"method\";\n        SemanticTokenTypes[\"macro\"] = \"macro\";\n        SemanticTokenTypes[\"keyword\"] = \"keyword\";\n        SemanticTokenTypes[\"modifier\"] = \"modifier\";\n        SemanticTokenTypes[\"comment\"] = \"comment\";\n        SemanticTokenTypes[\"string\"] = \"string\";\n        SemanticTokenTypes[\"number\"] = \"number\";\n        SemanticTokenTypes[\"regexp\"] = \"regexp\";\n        SemanticTokenTypes[\"operator\"] = \"operator\";\n        /**\n         * @since 3.17.0\n         */\n        SemanticTokenTypes[\"decorator\"] = \"decorator\";\n    })(SemanticTokenTypes || (exports.SemanticTokenTypes = SemanticTokenTypes = {}));\n    /**\n     * A set of predefined token modifiers. This set is not fixed\n     * an clients can specify additional token types via the\n     * corresponding client capabilities.\n     *\n     * @since 3.16.0\n     */\n    var SemanticTokenModifiers;\n    (function (SemanticTokenModifiers) {\n        SemanticTokenModifiers[\"declaration\"] = \"declaration\";\n        SemanticTokenModifiers[\"definition\"] = \"definition\";\n        SemanticTokenModifiers[\"readonly\"] = \"readonly\";\n        SemanticTokenModifiers[\"static\"] = \"static\";\n        SemanticTokenModifiers[\"deprecated\"] = \"deprecated\";\n        SemanticTokenModifiers[\"abstract\"] = \"abstract\";\n        SemanticTokenModifiers[\"async\"] = \"async\";\n        SemanticTokenModifiers[\"modification\"] = \"modification\";\n        SemanticTokenModifiers[\"documentation\"] = \"documentation\";\n        SemanticTokenModifiers[\"defaultLibrary\"] = \"defaultLibrary\";\n    })(SemanticTokenModifiers || (exports.SemanticTokenModifiers = SemanticTokenModifiers = {}));\n    /**\n     * @since 3.16.0\n     */\n    var SemanticTokens;\n    (function (SemanticTokens) {\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && (candidate.resultId === undefined || typeof candidate.resultId === 'string') &&\n                Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === 'number');\n        }\n        SemanticTokens.is = is;\n    })(SemanticTokens || (exports.SemanticTokens = SemanticTokens = {}));\n    /**\n     * The InlineValueText namespace provides functions to deal with InlineValueTexts.\n     *\n     * @since 3.17.0\n     */\n    var InlineValueText;\n    (function (InlineValueText) {\n        /**\n         * Creates a new InlineValueText literal.\n         */\n        function create(range, text) {\n            return { range: range, text: text };\n        }\n        InlineValueText.create = create;\n        function is(value) {\n            var candidate = value;\n            return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);\n        }\n        InlineValueText.is = is;\n    })(InlineValueText || (exports.InlineValueText = InlineValueText = {}));\n    /**\n     * The InlineValueVariableLookup namespace provides functions to deal with InlineValueVariableLookups.\n     *\n     * @since 3.17.0\n     */\n    var InlineValueVariableLookup;\n    (function (InlineValueVariableLookup) {\n        /**\n         * Creates a new InlineValueText literal.\n         */\n        function create(range, variableName, caseSensitiveLookup) {\n            return { range: range, variableName: variableName, caseSensitiveLookup: caseSensitiveLookup };\n        }\n        InlineValueVariableLookup.create = create;\n        function is(value) {\n            var candidate = value;\n            return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup)\n                && (Is.string(candidate.variableName) || candidate.variableName === undefined);\n        }\n        InlineValueVariableLookup.is = is;\n    })(InlineValueVariableLookup || (exports.InlineValueVariableLookup = InlineValueVariableLookup = {}));\n    /**\n     * The InlineValueEvaluatableExpression namespace provides functions to deal with InlineValueEvaluatableExpression.\n     *\n     * @since 3.17.0\n     */\n    var InlineValueEvaluatableExpression;\n    (function (InlineValueEvaluatableExpression) {\n        /**\n         * Creates a new InlineValueEvaluatableExpression literal.\n         */\n        function create(range, expression) {\n            return { range: range, expression: expression };\n        }\n        InlineValueEvaluatableExpression.create = create;\n        function is(value) {\n            var candidate = value;\n            return candidate !== undefined && candidate !== null && Range.is(candidate.range)\n                && (Is.string(candidate.expression) || candidate.expression === undefined);\n        }\n        InlineValueEvaluatableExpression.is = is;\n    })(InlineValueEvaluatableExpression || (exports.InlineValueEvaluatableExpression = InlineValueEvaluatableExpression = {}));\n    /**\n     * The InlineValueContext namespace provides helper functions to work with\n     * {@link InlineValueContext} literals.\n     *\n     * @since 3.17.0\n     */\n    var InlineValueContext;\n    (function (InlineValueContext) {\n        /**\n         * Creates a new InlineValueContext literal.\n         */\n        function create(frameId, stoppedLocation) {\n            return { frameId: frameId, stoppedLocation: stoppedLocation };\n        }\n        InlineValueContext.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link InlineValueContext} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Range.is(value.stoppedLocation);\n        }\n        InlineValueContext.is = is;\n    })(InlineValueContext || (exports.InlineValueContext = InlineValueContext = {}));\n    /**\n     * Inlay hint kinds.\n     *\n     * @since 3.17.0\n     */\n    var InlayHintKind;\n    (function (InlayHintKind) {\n        /**\n         * An inlay hint that for a type annotation.\n         */\n        InlayHintKind.Type = 1;\n        /**\n         * An inlay hint that is for a parameter.\n         */\n        InlayHintKind.Parameter = 2;\n        function is(value) {\n            return value === 1 || value === 2;\n        }\n        InlayHintKind.is = is;\n    })(InlayHintKind || (exports.InlayHintKind = InlayHintKind = {}));\n    var InlayHintLabelPart;\n    (function (InlayHintLabelPart) {\n        function create(value) {\n            return { value: value };\n        }\n        InlayHintLabelPart.create = create;\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate)\n                && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip))\n                && (candidate.location === undefined || Location.is(candidate.location))\n                && (candidate.command === undefined || Command.is(candidate.command));\n        }\n        InlayHintLabelPart.is = is;\n    })(InlayHintLabelPart || (exports.InlayHintLabelPart = InlayHintLabelPart = {}));\n    var InlayHint;\n    (function (InlayHint) {\n        function create(position, label, kind) {\n            var result = { position: position, label: label };\n            if (kind !== undefined) {\n                result.kind = kind;\n            }\n            return result;\n        }\n        InlayHint.create = create;\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Position.is(candidate.position)\n                && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is))\n                && (candidate.kind === undefined || InlayHintKind.is(candidate.kind))\n                && (candidate.textEdits === undefined) || Is.typedArray(candidate.textEdits, TextEdit.is)\n                && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip))\n                && (candidate.paddingLeft === undefined || Is.boolean(candidate.paddingLeft))\n                && (candidate.paddingRight === undefined || Is.boolean(candidate.paddingRight));\n        }\n        InlayHint.is = is;\n    })(InlayHint || (exports.InlayHint = InlayHint = {}));\n    var StringValue;\n    (function (StringValue) {\n        function createSnippet(value) {\n            return { kind: 'snippet', value: value };\n        }\n        StringValue.createSnippet = createSnippet;\n    })(StringValue || (exports.StringValue = StringValue = {}));\n    var InlineCompletionItem;\n    (function (InlineCompletionItem) {\n        function create(insertText, filterText, range, command) {\n            return { insertText: insertText, filterText: filterText, range: range, command: command };\n        }\n        InlineCompletionItem.create = create;\n    })(InlineCompletionItem || (exports.InlineCompletionItem = InlineCompletionItem = {}));\n    var InlineCompletionList;\n    (function (InlineCompletionList) {\n        function create(items) {\n            return { items: items };\n        }\n        InlineCompletionList.create = create;\n    })(InlineCompletionList || (exports.InlineCompletionList = InlineCompletionList = {}));\n    /**\n     * Describes how an {@link InlineCompletionItemProvider inline completion provider} was triggered.\n     *\n     * @since 3.18.0\n     * @proposed\n     */\n    var InlineCompletionTriggerKind;\n    (function (InlineCompletionTriggerKind) {\n        /**\n         * Completion was triggered explicitly by a user gesture.\n         */\n        InlineCompletionTriggerKind.Invoked = 0;\n        /**\n         * Completion was triggered automatically while editing.\n         */\n        InlineCompletionTriggerKind.Automatic = 1;\n    })(InlineCompletionTriggerKind || (exports.InlineCompletionTriggerKind = InlineCompletionTriggerKind = {}));\n    var SelectedCompletionInfo;\n    (function (SelectedCompletionInfo) {\n        function create(range, text) {\n            return { range: range, text: text };\n        }\n        SelectedCompletionInfo.create = create;\n    })(SelectedCompletionInfo || (exports.SelectedCompletionInfo = SelectedCompletionInfo = {}));\n    var InlineCompletionContext;\n    (function (InlineCompletionContext) {\n        function create(triggerKind, selectedCompletionInfo) {\n            return { triggerKind: triggerKind, selectedCompletionInfo: selectedCompletionInfo };\n        }\n        InlineCompletionContext.create = create;\n    })(InlineCompletionContext || (exports.InlineCompletionContext = InlineCompletionContext = {}));\n    var WorkspaceFolder;\n    (function (WorkspaceFolder) {\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && URI.is(candidate.uri) && Is.string(candidate.name);\n        }\n        WorkspaceFolder.is = is;\n    })(WorkspaceFolder || (exports.WorkspaceFolder = WorkspaceFolder = {}));\n    exports.EOL = ['\\n', '\\r\\n', '\\r'];\n    /**\n     * @deprecated Use the text document from the new vscode-languageserver-textdocument package.\n     */\n    var TextDocument;\n    (function (TextDocument) {\n        /**\n         * Creates a new ITextDocument literal from the given uri and content.\n         * @param uri The document's uri.\n         * @param languageId The document's language Id.\n         * @param version The document's version.\n         * @param content The document's content.\n         */\n        function create(uri, languageId, version, content) {\n            return new FullTextDocument(uri, languageId, version, content);\n        }\n        TextDocument.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link ITextDocument} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount)\n                && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;\n        }\n        TextDocument.is = is;\n        function applyEdits(document, edits) {\n            var text = document.getText();\n            var sortedEdits = mergeSort(edits, function (a, b) {\n                var diff = a.range.start.line - b.range.start.line;\n                if (diff === 0) {\n                    return a.range.start.character - b.range.start.character;\n                }\n                return diff;\n            });\n            var lastModifiedOffset = text.length;\n            for (var i = sortedEdits.length - 1; i >= 0; i--) {\n                var e = sortedEdits[i];\n                var startOffset = document.offsetAt(e.range.start);\n                var endOffset = document.offsetAt(e.range.end);\n                if (endOffset <= lastModifiedOffset) {\n                    text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);\n                }\n                else {\n                    throw new Error('Overlapping edit');\n                }\n                lastModifiedOffset = startOffset;\n            }\n            return text;\n        }\n        TextDocument.applyEdits = applyEdits;\n        function mergeSort(data, compare) {\n            if (data.length <= 1) {\n                // sorted\n                return data;\n            }\n            var p = (data.length / 2) | 0;\n            var left = data.slice(0, p);\n            var right = data.slice(p);\n            mergeSort(left, compare);\n            mergeSort(right, compare);\n            var leftIdx = 0;\n            var rightIdx = 0;\n            var i = 0;\n            while (leftIdx < left.length && rightIdx < right.length) {\n                var ret = compare(left[leftIdx], right[rightIdx]);\n                if (ret <= 0) {\n                    // smaller_equal -> take left to preserve order\n                    data[i++] = left[leftIdx++];\n                }\n                else {\n                    // greater -> take right\n                    data[i++] = right[rightIdx++];\n                }\n            }\n            while (leftIdx < left.length) {\n                data[i++] = left[leftIdx++];\n            }\n            while (rightIdx < right.length) {\n                data[i++] = right[rightIdx++];\n            }\n            return data;\n        }\n    })(TextDocument || (exports.TextDocument = TextDocument = {}));\n    /**\n     * @deprecated Use the text document from the new vscode-languageserver-textdocument package.\n     */\n    var FullTextDocument = /** @class */ (function () {\n        function FullTextDocument(uri, languageId, version, content) {\n            this._uri = uri;\n            this._languageId = languageId;\n            this._version = version;\n            this._content = content;\n            this._lineOffsets = undefined;\n        }\n        Object.defineProperty(FullTextDocument.prototype, \"uri\", {\n            get: function () {\n                return this._uri;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(FullTextDocument.prototype, \"languageId\", {\n            get: function () {\n                return this._languageId;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(FullTextDocument.prototype, \"version\", {\n            get: function () {\n                return this._version;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        FullTextDocument.prototype.getText = function (range) {\n            if (range) {\n                var start = this.offsetAt(range.start);\n                var end = this.offsetAt(range.end);\n                return this._content.substring(start, end);\n            }\n            return this._content;\n        };\n        FullTextDocument.prototype.update = function (event, version) {\n            this._content = event.text;\n            this._version = version;\n            this._lineOffsets = undefined;\n        };\n        FullTextDocument.prototype.getLineOffsets = function () {\n            if (this._lineOffsets === undefined) {\n                var lineOffsets = [];\n                var text = this._content;\n                var isLineStart = true;\n                for (var i = 0; i < text.length; i++) {\n                    if (isLineStart) {\n                        lineOffsets.push(i);\n                        isLineStart = false;\n                    }\n                    var ch = text.charAt(i);\n                    isLineStart = (ch === '\\r' || ch === '\\n');\n                    if (ch === '\\r' && i + 1 < text.length && text.charAt(i + 1) === '\\n') {\n                        i++;\n                    }\n                }\n                if (isLineStart && text.length > 0) {\n                    lineOffsets.push(text.length);\n                }\n                this._lineOffsets = lineOffsets;\n            }\n            return this._lineOffsets;\n        };\n        FullTextDocument.prototype.positionAt = function (offset) {\n            offset = Math.max(Math.min(offset, this._content.length), 0);\n            var lineOffsets = this.getLineOffsets();\n            var low = 0, high = lineOffsets.length;\n            if (high === 0) {\n                return Position.create(0, offset);\n            }\n            while (low < high) {\n                var mid = Math.floor((low + high) / 2);\n                if (lineOffsets[mid] > offset) {\n                    high = mid;\n                }\n                else {\n                    low = mid + 1;\n                }\n            }\n            // low is the least x for which the line offset is larger than the current offset\n            // or array.length if no line offset is larger than the current offset\n            var line = low - 1;\n            return Position.create(line, offset - lineOffsets[line]);\n        };\n        FullTextDocument.prototype.offsetAt = function (position) {\n            var lineOffsets = this.getLineOffsets();\n            if (position.line >= lineOffsets.length) {\n                return this._content.length;\n            }\n            else if (position.line < 0) {\n                return 0;\n            }\n            var lineOffset = lineOffsets[position.line];\n            var nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;\n            return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);\n        };\n        Object.defineProperty(FullTextDocument.prototype, \"lineCount\", {\n            get: function () {\n                return this.getLineOffsets().length;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        return FullTextDocument;\n    }());\n    var Is;\n    (function (Is) {\n        var toString = Object.prototype.toString;\n        function defined(value) {\n            return typeof value !== 'undefined';\n        }\n        Is.defined = defined;\n        function undefined(value) {\n            return typeof value === 'undefined';\n        }\n        Is.undefined = undefined;\n        function boolean(value) {\n            return value === true || value === false;\n        }\n        Is.boolean = boolean;\n        function string(value) {\n            return toString.call(value) === '[object String]';\n        }\n        Is.string = string;\n        function number(value) {\n            return toString.call(value) === '[object Number]';\n        }\n        Is.number = number;\n        function numberRange(value, min, max) {\n            return toString.call(value) === '[object Number]' && min <= value && value <= max;\n        }\n        Is.numberRange = numberRange;\n        function integer(value) {\n            return toString.call(value) === '[object Number]' && -2147483648 <= value && value <= 2147483647;\n        }\n        Is.integer = integer;\n        function uinteger(value) {\n            return toString.call(value) === '[object Number]' && 0 <= value && value <= 2147483647;\n        }\n        Is.uinteger = uinteger;\n        function func(value) {\n            return toString.call(value) === '[object Function]';\n        }\n        Is.func = func;\n        function objectLiteral(value) {\n            // Strictly speaking class instances pass this check as well. Since the LSP\n            // doesn't use classes we ignore this for now. If we do we need to add something\n            // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`\n            return value !== null && typeof value === 'object';\n        }\n        Is.objectLiteral = objectLiteral;\n        function typedArray(value, check) {\n            return Array.isArray(value) && value.every(check);\n        }\n        Is.typedArray = typedArray;\n    })(Is || (Is = {}));\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdnNjb2RlLWxhbmd1YWdlc2VydmVyLXR5cGVzL2xpYi91bWQvbWFpbi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLFFBQVEsS0FBMEI7QUFDbEMsd0JBQXdCLDhGQUFPO0FBQy9CO0FBQ0E7QUFDQSxhQUFhLElBQTBDO0FBQ3ZELFFBQVEsaUNBQU8sQ0FBQyxtQkFBUyxFQUFFLE9BQVMsQ0FBQyxvQ0FBRSxPQUFPO0FBQUE7QUFBQTtBQUFBLGtHQUFDO0FBQy9DO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsYUFBYTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssd0RBQXdEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssZ0NBQWdDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLDRDQUE0QztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSywrQ0FBK0M7QUFDcEQ7QUFDQTtBQUNBLFFBQVEsZ0JBQWdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsZ0JBQWdCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssK0NBQStDO0FBQ3BEO0FBQ0E7QUFDQSxRQUFRLGFBQWE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGFBQWE7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxzQ0FBc0M7QUFDM0M7QUFDQTtBQUNBLFFBQVEsZ0JBQWdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsZ0JBQWdCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssK0NBQStDO0FBQ3BEO0FBQ0E7QUFDQSxRQUFRLG9CQUFvQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxvQkFBb0I7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssMkRBQTJEO0FBQ2hFO0FBQ0E7QUFDQSxRQUFRLGFBQWE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsYUFBYTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLHNDQUFzQztBQUMzQztBQUNBO0FBQ0EsUUFBUSx3QkFBd0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCx3QkFBd0I7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyx1RUFBdUU7QUFDNUU7QUFDQTtBQUNBLFFBQVEseUJBQXlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCx3QkFBd0I7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssMEVBQTBFO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLHVFQUF1RTtBQUM1RTtBQUNBO0FBQ0EsUUFBUSxvQkFBb0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELG9CQUFvQjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLDJEQUEyRDtBQUNoRTtBQUNBO0FBQ0EsUUFBUSxvQ0FBb0M7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxvQ0FBb0M7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSywyR0FBMkc7QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyw2RUFBNkU7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssOERBQThEO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssb0VBQW9FO0FBQ3pFO0FBQ0E7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxrQkFBa0I7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUsscURBQXFEO0FBQzFEO0FBQ0E7QUFDQSxRQUFRLGVBQWU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix1QkFBdUI7QUFDcEQ7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxlQUFlO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssNENBQTRDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFNBQVMsZ0NBQWdDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssK0NBQStDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssdUVBQXVFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxxR0FBcUc7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUyxnQ0FBZ0M7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSywwRUFBMEU7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyx1RUFBdUU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLHFEQUFxRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxxREFBcUQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLHFEQUFxRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsS0FBSyw4REFBOEQ7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMscUJBQXFCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLGdCQUFnQjtBQUNyQixDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdml2ZS12aWJlLWFpLW5leHQvLi9ub2RlX21vZHVsZXMvdnNjb2RlLWxhbmd1YWdlc2VydmVyLXR5cGVzL2xpYi91bWQvbWFpbi5qcz84ODdmIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZmFjdG9yeSkge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICB2YXIgdiA9IGZhY3RvcnkocmVxdWlyZSwgZXhwb3J0cyk7XG4gICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIG1vZHVsZS5leHBvcnRzID0gdjtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCJdLCBmYWN0b3J5KTtcbiAgICB9XG59KShmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cykge1xuICAgIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbiAgICAndXNlIHN0cmljdCc7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuICAgIGV4cG9ydHMuVGV4dERvY3VtZW50ID0gZXhwb3J0cy5FT0wgPSBleHBvcnRzLldvcmtzcGFjZUZvbGRlciA9IGV4cG9ydHMuSW5saW5lQ29tcGxldGlvbkNvbnRleHQgPSBleHBvcnRzLlNlbGVjdGVkQ29tcGxldGlvbkluZm8gPSBleHBvcnRzLklubGluZUNvbXBsZXRpb25UcmlnZ2VyS2luZCA9IGV4cG9ydHMuSW5saW5lQ29tcGxldGlvbkxpc3QgPSBleHBvcnRzLklubGluZUNvbXBsZXRpb25JdGVtID0gZXhwb3J0cy5TdHJpbmdWYWx1ZSA9IGV4cG9ydHMuSW5sYXlIaW50ID0gZXhwb3J0cy5JbmxheUhpbnRMYWJlbFBhcnQgPSBleHBvcnRzLklubGF5SGludEtpbmQgPSBleHBvcnRzLklubGluZVZhbHVlQ29udGV4dCA9IGV4cG9ydHMuSW5saW5lVmFsdWVFdmFsdWF0YWJsZUV4cHJlc3Npb24gPSBleHBvcnRzLklubGluZVZhbHVlVmFyaWFibGVMb29rdXAgPSBleHBvcnRzLklubGluZVZhbHVlVGV4dCA9IGV4cG9ydHMuU2VtYW50aWNUb2tlbnMgPSBleHBvcnRzLlNlbWFudGljVG9rZW5Nb2RpZmllcnMgPSBleHBvcnRzLlNlbWFudGljVG9rZW5UeXBlcyA9IGV4cG9ydHMuU2VsZWN0aW9uUmFuZ2UgPSBleHBvcnRzLkRvY3VtZW50TGluayA9IGV4cG9ydHMuRm9ybWF0dGluZ09wdGlvbnMgPSBleHBvcnRzLkNvZGVMZW5zID0gZXhwb3J0cy5Db2RlQWN0aW9uID0gZXhwb3J0cy5Db2RlQWN0aW9uQ29udGV4dCA9IGV4cG9ydHMuQ29kZUFjdGlvblRyaWdnZXJLaW5kID0gZXhwb3J0cy5Db2RlQWN0aW9uS2luZCA9IGV4cG9ydHMuRG9jdW1lbnRTeW1ib2wgPSBleHBvcnRzLldvcmtzcGFjZVN5bWJvbCA9IGV4cG9ydHMuU3ltYm9sSW5mb3JtYXRpb24gPSBleHBvcnRzLlN5bWJvbFRhZyA9IGV4cG9ydHMuU3ltYm9sS2luZCA9IGV4cG9ydHMuRG9jdW1lbnRIaWdobGlnaHQgPSBleHBvcnRzLkRvY3VtZW50SGlnaGxpZ2h0S2luZCA9IGV4cG9ydHMuU2lnbmF0dXJlSW5mb3JtYXRpb24gPSBleHBvcnRzLlBhcmFtZXRlckluZm9ybWF0aW9uID0gZXhwb3J0cy5Ib3ZlciA9IGV4cG9ydHMuTWFya2VkU3RyaW5nID0gZXhwb3J0cy5Db21wbGV0aW9uTGlzdCA9IGV4cG9ydHMuQ29tcGxldGlvbkl0ZW0gPSBleHBvcnRzLkNvbXBsZXRpb25JdGVtTGFiZWxEZXRhaWxzID0gZXhwb3J0cy5JbnNlcnRUZXh0TW9kZSA9IGV4cG9ydHMuSW5zZXJ0UmVwbGFjZUVkaXQgPSBleHBvcnRzLkNvbXBsZXRpb25JdGVtVGFnID0gZXhwb3J0cy5JbnNlcnRUZXh0Rm9ybWF0ID0gZXhwb3J0cy5Db21wbGV0aW9uSXRlbUtpbmQgPSBleHBvcnRzLk1hcmt1cENvbnRlbnQgPSBleHBvcnRzLk1hcmt1cEtpbmQgPSBleHBvcnRzLlRleHREb2N1bWVudEl0ZW0gPSBleHBvcnRzLk9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciA9IGV4cG9ydHMuVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciA9IGV4cG9ydHMuVGV4dERvY3VtZW50SWRlbnRpZmllciA9IGV4cG9ydHMuV29ya3NwYWNlQ2hhbmdlID0gZXhwb3J0cy5Xb3Jrc3BhY2VFZGl0ID0gZXhwb3J0cy5EZWxldGVGaWxlID0gZXhwb3J0cy5SZW5hbWVGaWxlID0gZXhwb3J0cy5DcmVhdGVGaWxlID0gZXhwb3J0cy5UZXh0RG9jdW1lbnRFZGl0ID0gZXhwb3J0cy5Bbm5vdGF0ZWRUZXh0RWRpdCA9IGV4cG9ydHMuQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIgPSBleHBvcnRzLkNoYW5nZUFubm90YXRpb24gPSBleHBvcnRzLlRleHRFZGl0ID0gZXhwb3J0cy5Db21tYW5kID0gZXhwb3J0cy5EaWFnbm9zdGljID0gZXhwb3J0cy5Db2RlRGVzY3JpcHRpb24gPSBleHBvcnRzLkRpYWdub3N0aWNUYWcgPSBleHBvcnRzLkRpYWdub3N0aWNTZXZlcml0eSA9IGV4cG9ydHMuRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbiA9IGV4cG9ydHMuRm9sZGluZ1JhbmdlID0gZXhwb3J0cy5Gb2xkaW5nUmFuZ2VLaW5kID0gZXhwb3J0cy5Db2xvclByZXNlbnRhdGlvbiA9IGV4cG9ydHMuQ29sb3JJbmZvcm1hdGlvbiA9IGV4cG9ydHMuQ29sb3IgPSBleHBvcnRzLkxvY2F0aW9uTGluayA9IGV4cG9ydHMuTG9jYXRpb24gPSBleHBvcnRzLlJhbmdlID0gZXhwb3J0cy5Qb3NpdGlvbiA9IGV4cG9ydHMudWludGVnZXIgPSBleHBvcnRzLmludGVnZXIgPSBleHBvcnRzLlVSSSA9IGV4cG9ydHMuRG9jdW1lbnRVcmkgPSB2b2lkIDA7XG4gICAgdmFyIERvY3VtZW50VXJpO1xuICAgIChmdW5jdGlvbiAoRG9jdW1lbnRVcmkpIHtcbiAgICAgICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xuICAgICAgICB9XG4gICAgICAgIERvY3VtZW50VXJpLmlzID0gaXM7XG4gICAgfSkoRG9jdW1lbnRVcmkgfHwgKGV4cG9ydHMuRG9jdW1lbnRVcmkgPSBEb2N1bWVudFVyaSA9IHt9KSk7XG4gICAgdmFyIFVSSTtcbiAgICAoZnVuY3Rpb24gKFVSSSkge1xuICAgICAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG4gICAgICAgIH1cbiAgICAgICAgVVJJLmlzID0gaXM7XG4gICAgfSkoVVJJIHx8IChleHBvcnRzLlVSSSA9IFVSSSA9IHt9KSk7XG4gICAgdmFyIGludGVnZXI7XG4gICAgKGZ1bmN0aW9uIChpbnRlZ2VyKSB7XG4gICAgICAgIGludGVnZXIuTUlOX1ZBTFVFID0gLTIxNDc0ODM2NDg7XG4gICAgICAgIGludGVnZXIuTUFYX1ZBTFVFID0gMjE0NzQ4MzY0NztcbiAgICAgICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGludGVnZXIuTUlOX1ZBTFVFIDw9IHZhbHVlICYmIHZhbHVlIDw9IGludGVnZXIuTUFYX1ZBTFVFO1xuICAgICAgICB9XG4gICAgICAgIGludGVnZXIuaXMgPSBpcztcbiAgICB9KShpbnRlZ2VyIHx8IChleHBvcnRzLmludGVnZXIgPSBpbnRlZ2VyID0ge30pKTtcbiAgICB2YXIgdWludGVnZXI7XG4gICAgKGZ1bmN0aW9uICh1aW50ZWdlcikge1xuICAgICAgICB1aW50ZWdlci5NSU5fVkFMVUUgPSAwO1xuICAgICAgICB1aW50ZWdlci5NQVhfVkFMVUUgPSAyMTQ3NDgzNjQ3O1xuICAgICAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgdWludGVnZXIuTUlOX1ZBTFVFIDw9IHZhbHVlICYmIHZhbHVlIDw9IHVpbnRlZ2VyLk1BWF9WQUxVRTtcbiAgICAgICAgfVxuICAgICAgICB1aW50ZWdlci5pcyA9IGlzO1xuICAgIH0pKHVpbnRlZ2VyIHx8IChleHBvcnRzLnVpbnRlZ2VyID0gdWludGVnZXIgPSB7fSkpO1xuICAgIC8qKlxuICAgICAqIFRoZSBQb3NpdGlvbiBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAgICAgKiB7QGxpbmsgUG9zaXRpb259IGxpdGVyYWxzLlxuICAgICAqL1xuICAgIHZhciBQb3NpdGlvbjtcbiAgICAoZnVuY3Rpb24gKFBvc2l0aW9uKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IFBvc2l0aW9uIGxpdGVyYWwgZnJvbSB0aGUgZ2l2ZW4gbGluZSBhbmQgY2hhcmFjdGVyLlxuICAgICAgICAgKiBAcGFyYW0gbGluZSBUaGUgcG9zaXRpb24ncyBsaW5lLlxuICAgICAgICAgKiBAcGFyYW0gY2hhcmFjdGVyIFRoZSBwb3NpdGlvbidzIGNoYXJhY3Rlci5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZShsaW5lLCBjaGFyYWN0ZXIpIHtcbiAgICAgICAgICAgIGlmIChsaW5lID09PSBOdW1iZXIuTUFYX1ZBTFVFKSB7XG4gICAgICAgICAgICAgICAgbGluZSA9IHVpbnRlZ2VyLk1BWF9WQUxVRTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGFyYWN0ZXIgPT09IE51bWJlci5NQVhfVkFMVUUpIHtcbiAgICAgICAgICAgICAgICBjaGFyYWN0ZXIgPSB1aW50ZWdlci5NQVhfVkFMVUU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBsaW5lOiBsaW5lLCBjaGFyYWN0ZXI6IGNoYXJhY3RlciB9O1xuICAgICAgICB9XG4gICAgICAgIFBvc2l0aW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgUG9zaXRpb259IGludGVyZmFjZS5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIElzLnVpbnRlZ2VyKGNhbmRpZGF0ZS5saW5lKSAmJiBJcy51aW50ZWdlcihjYW5kaWRhdGUuY2hhcmFjdGVyKTtcbiAgICAgICAgfVxuICAgICAgICBQb3NpdGlvbi5pcyA9IGlzO1xuICAgIH0pKFBvc2l0aW9uIHx8IChleHBvcnRzLlBvc2l0aW9uID0gUG9zaXRpb24gPSB7fSkpO1xuICAgIC8qKlxuICAgICAqIFRoZSBSYW5nZSBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAgICAgKiB7QGxpbmsgUmFuZ2V9IGxpdGVyYWxzLlxuICAgICAqL1xuICAgIHZhciBSYW5nZTtcbiAgICAoZnVuY3Rpb24gKFJhbmdlKSB7XG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZShvbmUsIHR3bywgdGhyZWUsIGZvdXIpIHtcbiAgICAgICAgICAgIGlmIChJcy51aW50ZWdlcihvbmUpICYmIElzLnVpbnRlZ2VyKHR3bykgJiYgSXMudWludGVnZXIodGhyZWUpICYmIElzLnVpbnRlZ2VyKGZvdXIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhcnQ6IFBvc2l0aW9uLmNyZWF0ZShvbmUsIHR3byksIGVuZDogUG9zaXRpb24uY3JlYXRlKHRocmVlLCBmb3VyKSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoUG9zaXRpb24uaXMob25lKSAmJiBQb3NpdGlvbi5pcyh0d28pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhcnQ6IG9uZSwgZW5kOiB0d28gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJhbmdlI2NyZWF0ZSBjYWxsZWQgd2l0aCBpbnZhbGlkIGFyZ3VtZW50c1tcIi5jb25jYXQob25lLCBcIiwgXCIpLmNvbmNhdCh0d28sIFwiLCBcIikuY29uY2F0KHRocmVlLCBcIiwgXCIpLmNvbmNhdChmb3VyLCBcIl1cIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFJhbmdlLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgUmFuZ2V9IGludGVyZmFjZS5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIFBvc2l0aW9uLmlzKGNhbmRpZGF0ZS5zdGFydCkgJiYgUG9zaXRpb24uaXMoY2FuZGlkYXRlLmVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgUmFuZ2UuaXMgPSBpcztcbiAgICB9KShSYW5nZSB8fCAoZXhwb3J0cy5SYW5nZSA9IFJhbmdlID0ge30pKTtcbiAgICAvKipcbiAgICAgKiBUaGUgTG9jYXRpb24gbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gICAgICoge0BsaW5rIExvY2F0aW9ufSBsaXRlcmFscy5cbiAgICAgKi9cbiAgICB2YXIgTG9jYXRpb247XG4gICAgKGZ1bmN0aW9uIChMb2NhdGlvbikge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIExvY2F0aW9uIGxpdGVyYWwuXG4gICAgICAgICAqIEBwYXJhbSB1cmkgVGhlIGxvY2F0aW9uJ3MgdXJpLlxuICAgICAgICAgKiBAcGFyYW0gcmFuZ2UgVGhlIGxvY2F0aW9uJ3MgcmFuZ2UuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBjcmVhdGUodXJpLCByYW5nZSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdXJpOiB1cmksIHJhbmdlOiByYW5nZSB9O1xuICAgICAgICB9XG4gICAgICAgIExvY2F0aW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgTG9jYXRpb259IGludGVyZmFjZS5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5yYW5nZSkgJiYgKElzLnN0cmluZyhjYW5kaWRhdGUudXJpKSB8fCBJcy51bmRlZmluZWQoY2FuZGlkYXRlLnVyaSkpO1xuICAgICAgICB9XG4gICAgICAgIExvY2F0aW9uLmlzID0gaXM7XG4gICAgfSkoTG9jYXRpb24gfHwgKGV4cG9ydHMuTG9jYXRpb24gPSBMb2NhdGlvbiA9IHt9KSk7XG4gICAgLyoqXG4gICAgICogVGhlIExvY2F0aW9uTGluayBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAgICAgKiB7QGxpbmsgTG9jYXRpb25MaW5rfSBsaXRlcmFscy5cbiAgICAgKi9cbiAgICB2YXIgTG9jYXRpb25MaW5rO1xuICAgIChmdW5jdGlvbiAoTG9jYXRpb25MaW5rKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgTG9jYXRpb25MaW5rIGxpdGVyYWwuXG4gICAgICAgICAqIEBwYXJhbSB0YXJnZXRVcmkgVGhlIGRlZmluaXRpb24ncyB1cmkuXG4gICAgICAgICAqIEBwYXJhbSB0YXJnZXRSYW5nZSBUaGUgZnVsbCByYW5nZSBvZiB0aGUgZGVmaW5pdGlvbi5cbiAgICAgICAgICogQHBhcmFtIHRhcmdldFNlbGVjdGlvblJhbmdlIFRoZSBzcGFuIG9mIHRoZSBzeW1ib2wgZGVmaW5pdGlvbiBhdCB0aGUgdGFyZ2V0LlxuICAgICAgICAgKiBAcGFyYW0gb3JpZ2luU2VsZWN0aW9uUmFuZ2UgVGhlIHNwYW4gb2YgdGhlIHN5bWJvbCBiZWluZyBkZWZpbmVkIGluIHRoZSBvcmlnaW5hdGluZyBzb3VyY2UgZmlsZS5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZSh0YXJnZXRVcmksIHRhcmdldFJhbmdlLCB0YXJnZXRTZWxlY3Rpb25SYW5nZSwgb3JpZ2luU2VsZWN0aW9uUmFuZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHRhcmdldFVyaTogdGFyZ2V0VXJpLCB0YXJnZXRSYW5nZTogdGFyZ2V0UmFuZ2UsIHRhcmdldFNlbGVjdGlvblJhbmdlOiB0YXJnZXRTZWxlY3Rpb25SYW5nZSwgb3JpZ2luU2VsZWN0aW9uUmFuZ2U6IG9yaWdpblNlbGVjdGlvblJhbmdlIH07XG4gICAgICAgIH1cbiAgICAgICAgTG9jYXRpb25MaW5rLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgTG9jYXRpb25MaW5rfSBpbnRlcmZhY2UuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBSYW5nZS5pcyhjYW5kaWRhdGUudGFyZ2V0UmFuZ2UpICYmIElzLnN0cmluZyhjYW5kaWRhdGUudGFyZ2V0VXJpKVxuICAgICAgICAgICAgICAgICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS50YXJnZXRTZWxlY3Rpb25SYW5nZSlcbiAgICAgICAgICAgICAgICAmJiAoUmFuZ2UuaXMoY2FuZGlkYXRlLm9yaWdpblNlbGVjdGlvblJhbmdlKSB8fCBJcy51bmRlZmluZWQoY2FuZGlkYXRlLm9yaWdpblNlbGVjdGlvblJhbmdlKSk7XG4gICAgICAgIH1cbiAgICAgICAgTG9jYXRpb25MaW5rLmlzID0gaXM7XG4gICAgfSkoTG9jYXRpb25MaW5rIHx8IChleHBvcnRzLkxvY2F0aW9uTGluayA9IExvY2F0aW9uTGluayA9IHt9KSk7XG4gICAgLyoqXG4gICAgICogVGhlIENvbG9yIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICAgICAqIHtAbGluayBDb2xvcn0gbGl0ZXJhbHMuXG4gICAgICovXG4gICAgdmFyIENvbG9yO1xuICAgIChmdW5jdGlvbiAoQ29sb3IpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgQ29sb3IgbGl0ZXJhbC5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZShyZWQsIGdyZWVuLCBibHVlLCBhbHBoYSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICByZWQ6IHJlZCxcbiAgICAgICAgICAgICAgICBncmVlbjogZ3JlZW4sXG4gICAgICAgICAgICAgICAgYmx1ZTogYmx1ZSxcbiAgICAgICAgICAgICAgICBhbHBoYTogYWxwaGEsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIENvbG9yLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgQ29sb3J9IGludGVyZmFjZS5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIElzLm51bWJlclJhbmdlKGNhbmRpZGF0ZS5yZWQsIDAsIDEpXG4gICAgICAgICAgICAgICAgJiYgSXMubnVtYmVyUmFuZ2UoY2FuZGlkYXRlLmdyZWVuLCAwLCAxKVxuICAgICAgICAgICAgICAgICYmIElzLm51bWJlclJhbmdlKGNhbmRpZGF0ZS5ibHVlLCAwLCAxKVxuICAgICAgICAgICAgICAgICYmIElzLm51bWJlclJhbmdlKGNhbmRpZGF0ZS5hbHBoYSwgMCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgQ29sb3IuaXMgPSBpcztcbiAgICB9KShDb2xvciB8fCAoZXhwb3J0cy5Db2xvciA9IENvbG9yID0ge30pKTtcbiAgICAvKipcbiAgICAgKiBUaGUgQ29sb3JJbmZvcm1hdGlvbiBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAgICAgKiB7QGxpbmsgQ29sb3JJbmZvcm1hdGlvbn0gbGl0ZXJhbHMuXG4gICAgICovXG4gICAgdmFyIENvbG9ySW5mb3JtYXRpb247XG4gICAgKGZ1bmN0aW9uIChDb2xvckluZm9ybWF0aW9uKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IENvbG9ySW5mb3JtYXRpb24gbGl0ZXJhbC5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZShyYW5nZSwgY29sb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcmFuZ2U6IHJhbmdlLFxuICAgICAgICAgICAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgQ29sb3JJbmZvcm1hdGlvbi5jcmVhdGUgPSBjcmVhdGU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIENvbG9ySW5mb3JtYXRpb259IGludGVyZmFjZS5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5yYW5nZSkgJiYgQ29sb3IuaXMoY2FuZGlkYXRlLmNvbG9yKTtcbiAgICAgICAgfVxuICAgICAgICBDb2xvckluZm9ybWF0aW9uLmlzID0gaXM7XG4gICAgfSkoQ29sb3JJbmZvcm1hdGlvbiB8fCAoZXhwb3J0cy5Db2xvckluZm9ybWF0aW9uID0gQ29sb3JJbmZvcm1hdGlvbiA9IHt9KSk7XG4gICAgLyoqXG4gICAgICogVGhlIENvbG9yIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICAgICAqIHtAbGluayBDb2xvclByZXNlbnRhdGlvbn0gbGl0ZXJhbHMuXG4gICAgICovXG4gICAgdmFyIENvbG9yUHJlc2VudGF0aW9uO1xuICAgIChmdW5jdGlvbiAoQ29sb3JQcmVzZW50YXRpb24pIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgQ29sb3JJbmZvcm1hdGlvbiBsaXRlcmFsLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlKGxhYmVsLCB0ZXh0RWRpdCwgYWRkaXRpb25hbFRleHRFZGl0cykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBsYWJlbDogbGFiZWwsXG4gICAgICAgICAgICAgICAgdGV4dEVkaXQ6IHRleHRFZGl0LFxuICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxUZXh0RWRpdHM6IGFkZGl0aW9uYWxUZXh0RWRpdHMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIENvbG9yUHJlc2VudGF0aW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgQ29sb3JJbmZvcm1hdGlvbn0gaW50ZXJmYWNlLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5sYWJlbClcbiAgICAgICAgICAgICAgICAmJiAoSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS50ZXh0RWRpdCkgfHwgVGV4dEVkaXQuaXMoY2FuZGlkYXRlKSlcbiAgICAgICAgICAgICAgICAmJiAoSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5hZGRpdGlvbmFsVGV4dEVkaXRzKSB8fCBJcy50eXBlZEFycmF5KGNhbmRpZGF0ZS5hZGRpdGlvbmFsVGV4dEVkaXRzLCBUZXh0RWRpdC5pcykpO1xuICAgICAgICB9XG4gICAgICAgIENvbG9yUHJlc2VudGF0aW9uLmlzID0gaXM7XG4gICAgfSkoQ29sb3JQcmVzZW50YXRpb24gfHwgKGV4cG9ydHMuQ29sb3JQcmVzZW50YXRpb24gPSBDb2xvclByZXNlbnRhdGlvbiA9IHt9KSk7XG4gICAgLyoqXG4gICAgICogQSBzZXQgb2YgcHJlZGVmaW5lZCByYW5nZSBraW5kcy5cbiAgICAgKi9cbiAgICB2YXIgRm9sZGluZ1JhbmdlS2luZDtcbiAgICAoZnVuY3Rpb24gKEZvbGRpbmdSYW5nZUtpbmQpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZvbGRpbmcgcmFuZ2UgZm9yIGEgY29tbWVudFxuICAgICAgICAgKi9cbiAgICAgICAgRm9sZGluZ1JhbmdlS2luZC5Db21tZW50ID0gJ2NvbW1lbnQnO1xuICAgICAgICAvKipcbiAgICAgICAgICogRm9sZGluZyByYW5nZSBmb3IgYW4gaW1wb3J0IG9yIGluY2x1ZGVcbiAgICAgICAgICovXG4gICAgICAgIEZvbGRpbmdSYW5nZUtpbmQuSW1wb3J0cyA9ICdpbXBvcnRzJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZvbGRpbmcgcmFuZ2UgZm9yIGEgcmVnaW9uIChlLmcuIGAjcmVnaW9uYClcbiAgICAgICAgICovXG4gICAgICAgIEZvbGRpbmdSYW5nZUtpbmQuUmVnaW9uID0gJ3JlZ2lvbic7XG4gICAgfSkoRm9sZGluZ1JhbmdlS2luZCB8fCAoZXhwb3J0cy5Gb2xkaW5nUmFuZ2VLaW5kID0gRm9sZGluZ1JhbmdlS2luZCA9IHt9KSk7XG4gICAgLyoqXG4gICAgICogVGhlIGZvbGRpbmcgcmFuZ2UgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gICAgICoge0BsaW5rIEZvbGRpbmdSYW5nZX0gbGl0ZXJhbHMuXG4gICAgICovXG4gICAgdmFyIEZvbGRpbmdSYW5nZTtcbiAgICAoZnVuY3Rpb24gKEZvbGRpbmdSYW5nZSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBGb2xkaW5nUmFuZ2UgbGl0ZXJhbC5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZShzdGFydExpbmUsIGVuZExpbmUsIHN0YXJ0Q2hhcmFjdGVyLCBlbmRDaGFyYWN0ZXIsIGtpbmQsIGNvbGxhcHNlZFRleHQpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgc3RhcnRMaW5lOiBzdGFydExpbmUsXG4gICAgICAgICAgICAgICAgZW5kTGluZTogZW5kTGluZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChJcy5kZWZpbmVkKHN0YXJ0Q2hhcmFjdGVyKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydENoYXJhY3RlciA9IHN0YXJ0Q2hhcmFjdGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKElzLmRlZmluZWQoZW5kQ2hhcmFjdGVyKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5lbmRDaGFyYWN0ZXIgPSBlbmRDaGFyYWN0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoSXMuZGVmaW5lZChraW5kKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5raW5kID0ga2luZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChJcy5kZWZpbmVkKGNvbGxhcHNlZFRleHQpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmNvbGxhcHNlZFRleHQgPSBjb2xsYXBzZWRUZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBGb2xkaW5nUmFuZ2UuY3JlYXRlID0gY3JlYXRlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBGb2xkaW5nUmFuZ2V9IGludGVyZmFjZS5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIElzLnVpbnRlZ2VyKGNhbmRpZGF0ZS5zdGFydExpbmUpICYmIElzLnVpbnRlZ2VyKGNhbmRpZGF0ZS5zdGFydExpbmUpXG4gICAgICAgICAgICAgICAgJiYgKElzLnVuZGVmaW5lZChjYW5kaWRhdGUuc3RhcnRDaGFyYWN0ZXIpIHx8IElzLnVpbnRlZ2VyKGNhbmRpZGF0ZS5zdGFydENoYXJhY3RlcikpXG4gICAgICAgICAgICAgICAgJiYgKElzLnVuZGVmaW5lZChjYW5kaWRhdGUuZW5kQ2hhcmFjdGVyKSB8fCBJcy51aW50ZWdlcihjYW5kaWRhdGUuZW5kQ2hhcmFjdGVyKSlcbiAgICAgICAgICAgICAgICAmJiAoSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5raW5kKSB8fCBJcy5zdHJpbmcoY2FuZGlkYXRlLmtpbmQpKTtcbiAgICAgICAgfVxuICAgICAgICBGb2xkaW5nUmFuZ2UuaXMgPSBpcztcbiAgICB9KShGb2xkaW5nUmFuZ2UgfHwgKGV4cG9ydHMuRm9sZGluZ1JhbmdlID0gRm9sZGluZ1JhbmdlID0ge30pKTtcbiAgICAvKipcbiAgICAgKiBUaGUgRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbiBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAgICAgKiB7QGxpbmsgRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbn0gbGl0ZXJhbHMuXG4gICAgICovXG4gICAgdmFyIERpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb247XG4gICAgKGZ1bmN0aW9uIChEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IERpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb24gbGl0ZXJhbC5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZShsb2NhdGlvbiwgbWVzc2FnZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbn0gaW50ZXJmYWNlLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgTG9jYXRpb24uaXMoY2FuZGlkYXRlLmxvY2F0aW9uKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIERpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb24uaXMgPSBpcztcbiAgICB9KShEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uIHx8IChleHBvcnRzLkRpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb24gPSBEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uID0ge30pKTtcbiAgICAvKipcbiAgICAgKiBUaGUgZGlhZ25vc3RpYydzIHNldmVyaXR5LlxuICAgICAqL1xuICAgIHZhciBEaWFnbm9zdGljU2V2ZXJpdHk7XG4gICAgKGZ1bmN0aW9uIChEaWFnbm9zdGljU2V2ZXJpdHkpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlcG9ydHMgYW4gZXJyb3IuXG4gICAgICAgICAqL1xuICAgICAgICBEaWFnbm9zdGljU2V2ZXJpdHkuRXJyb3IgPSAxO1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVwb3J0cyBhIHdhcm5pbmcuXG4gICAgICAgICAqL1xuICAgICAgICBEaWFnbm9zdGljU2V2ZXJpdHkuV2FybmluZyA9IDI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXBvcnRzIGFuIGluZm9ybWF0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgRGlhZ25vc3RpY1NldmVyaXR5LkluZm9ybWF0aW9uID0gMztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlcG9ydHMgYSBoaW50LlxuICAgICAgICAgKi9cbiAgICAgICAgRGlhZ25vc3RpY1NldmVyaXR5LkhpbnQgPSA0O1xuICAgIH0pKERpYWdub3N0aWNTZXZlcml0eSB8fCAoZXhwb3J0cy5EaWFnbm9zdGljU2V2ZXJpdHkgPSBEaWFnbm9zdGljU2V2ZXJpdHkgPSB7fSkpO1xuICAgIC8qKlxuICAgICAqIFRoZSBkaWFnbm9zdGljIHRhZ3MuXG4gICAgICpcbiAgICAgKiBAc2luY2UgMy4xNS4wXG4gICAgICovXG4gICAgdmFyIERpYWdub3N0aWNUYWc7XG4gICAgKGZ1bmN0aW9uIChEaWFnbm9zdGljVGFnKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVbnVzZWQgb3IgdW5uZWNlc3NhcnkgY29kZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQ2xpZW50cyBhcmUgYWxsb3dlZCB0byByZW5kZXIgZGlhZ25vc3RpY3Mgd2l0aCB0aGlzIHRhZyBmYWRlZCBvdXQgaW5zdGVhZCBvZiBoYXZpbmdcbiAgICAgICAgICogYW4gZXJyb3Igc3F1aWdnbGUuXG4gICAgICAgICAqL1xuICAgICAgICBEaWFnbm9zdGljVGFnLlVubmVjZXNzYXJ5ID0gMTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlcHJlY2F0ZWQgb3Igb2Jzb2xldGUgY29kZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQ2xpZW50cyBhcmUgYWxsb3dlZCB0byByZW5kZXJlZCBkaWFnbm9zdGljcyB3aXRoIHRoaXMgdGFnIHN0cmlrZSB0aHJvdWdoLlxuICAgICAgICAgKi9cbiAgICAgICAgRGlhZ25vc3RpY1RhZy5EZXByZWNhdGVkID0gMjtcbiAgICB9KShEaWFnbm9zdGljVGFnIHx8IChleHBvcnRzLkRpYWdub3N0aWNUYWcgPSBEaWFnbm9zdGljVGFnID0ge30pKTtcbiAgICAvKipcbiAgICAgKiBUaGUgQ29kZURlc2NyaXB0aW9uIG5hbWVzcGFjZSBwcm92aWRlcyBmdW5jdGlvbnMgdG8gZGVhbCB3aXRoIGRlc2NyaXB0aW9ucyBmb3IgZGlhZ25vc3RpYyBjb2Rlcy5cbiAgICAgKlxuICAgICAqIEBzaW5jZSAzLjE2LjBcbiAgICAgKi9cbiAgICB2YXIgQ29kZURlc2NyaXB0aW9uO1xuICAgIChmdW5jdGlvbiAoQ29kZURlc2NyaXB0aW9uKSB7XG4gICAgICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUuaHJlZik7XG4gICAgICAgIH1cbiAgICAgICAgQ29kZURlc2NyaXB0aW9uLmlzID0gaXM7XG4gICAgfSkoQ29kZURlc2NyaXB0aW9uIHx8IChleHBvcnRzLkNvZGVEZXNjcmlwdGlvbiA9IENvZGVEZXNjcmlwdGlvbiA9IHt9KSk7XG4gICAgLyoqXG4gICAgICogVGhlIERpYWdub3N0aWMgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gICAgICoge0BsaW5rIERpYWdub3N0aWN9IGxpdGVyYWxzLlxuICAgICAqL1xuICAgIHZhciBEaWFnbm9zdGljO1xuICAgIChmdW5jdGlvbiAoRGlhZ25vc3RpYykge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBEaWFnbm9zdGljIGxpdGVyYWwuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBjcmVhdGUocmFuZ2UsIG1lc3NhZ2UsIHNldmVyaXR5LCBjb2RlLCBzb3VyY2UsIHJlbGF0ZWRJbmZvcm1hdGlvbikge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHsgcmFuZ2U6IHJhbmdlLCBtZXNzYWdlOiBtZXNzYWdlIH07XG4gICAgICAgICAgICBpZiAoSXMuZGVmaW5lZChzZXZlcml0eSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuc2V2ZXJpdHkgPSBzZXZlcml0eTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChJcy5kZWZpbmVkKGNvZGUpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmNvZGUgPSBjb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKElzLmRlZmluZWQoc291cmNlKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoSXMuZGVmaW5lZChyZWxhdGVkSW5mb3JtYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnJlbGF0ZWRJbmZvcm1hdGlvbiA9IHJlbGF0ZWRJbmZvcm1hdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgRGlhZ25vc3RpYy5jcmVhdGUgPSBjcmVhdGU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIERpYWdub3N0aWN9IGludGVyZmFjZS5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpXG4gICAgICAgICAgICAgICAgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKVxuICAgICAgICAgICAgICAgICYmIElzLnN0cmluZyhjYW5kaWRhdGUubWVzc2FnZSlcbiAgICAgICAgICAgICAgICAmJiAoSXMubnVtYmVyKGNhbmRpZGF0ZS5zZXZlcml0eSkgfHwgSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5zZXZlcml0eSkpXG4gICAgICAgICAgICAgICAgJiYgKElzLmludGVnZXIoY2FuZGlkYXRlLmNvZGUpIHx8IElzLnN0cmluZyhjYW5kaWRhdGUuY29kZSkgfHwgSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5jb2RlKSlcbiAgICAgICAgICAgICAgICAmJiAoSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5jb2RlRGVzY3JpcHRpb24pIHx8IChJcy5zdHJpbmcoKF9hID0gY2FuZGlkYXRlLmNvZGVEZXNjcmlwdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhyZWYpKSlcbiAgICAgICAgICAgICAgICAmJiAoSXMuc3RyaW5nKGNhbmRpZGF0ZS5zb3VyY2UpIHx8IElzLnVuZGVmaW5lZChjYW5kaWRhdGUuc291cmNlKSlcbiAgICAgICAgICAgICAgICAmJiAoSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5yZWxhdGVkSW5mb3JtYXRpb24pIHx8IElzLnR5cGVkQXJyYXkoY2FuZGlkYXRlLnJlbGF0ZWRJbmZvcm1hdGlvbiwgRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbi5pcykpO1xuICAgICAgICB9XG4gICAgICAgIERpYWdub3N0aWMuaXMgPSBpcztcbiAgICB9KShEaWFnbm9zdGljIHx8IChleHBvcnRzLkRpYWdub3N0aWMgPSBEaWFnbm9zdGljID0ge30pKTtcbiAgICAvKipcbiAgICAgKiBUaGUgQ29tbWFuZCBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAgICAgKiB7QGxpbmsgQ29tbWFuZH0gbGl0ZXJhbHMuXG4gICAgICovXG4gICAgdmFyIENvbW1hbmQ7XG4gICAgKGZ1bmN0aW9uIChDb21tYW5kKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IENvbW1hbmQgbGl0ZXJhbC5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZSh0aXRsZSwgY29tbWFuZCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMjsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfaSAtIDJdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7IHRpdGxlOiB0aXRsZSwgY29tbWFuZDogY29tbWFuZCB9O1xuICAgICAgICAgICAgaWYgKElzLmRlZmluZWQoYXJncykgJiYgYXJncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmFyZ3VtZW50cyA9IGFyZ3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIENvbW1hbmQuY3JlYXRlID0gY3JlYXRlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBDb21tYW5kfSBpbnRlcmZhY2UuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnRpdGxlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLmNvbW1hbmQpO1xuICAgICAgICB9XG4gICAgICAgIENvbW1hbmQuaXMgPSBpcztcbiAgICB9KShDb21tYW5kIHx8IChleHBvcnRzLkNvbW1hbmQgPSBDb21tYW5kID0ge30pKTtcbiAgICAvKipcbiAgICAgKiBUaGUgVGV4dEVkaXQgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgcmVwbGFjZSxcbiAgICAgKiBpbnNlcnQgYW5kIGRlbGV0ZSBlZGl0cyBtb3JlIGVhc2lseS5cbiAgICAgKi9cbiAgICB2YXIgVGV4dEVkaXQ7XG4gICAgKGZ1bmN0aW9uIChUZXh0RWRpdCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIHJlcGxhY2UgdGV4dCBlZGl0LlxuICAgICAgICAgKiBAcGFyYW0gcmFuZ2UgVGhlIHJhbmdlIG9mIHRleHQgdG8gYmUgcmVwbGFjZWQuXG4gICAgICAgICAqIEBwYXJhbSBuZXdUZXh0IFRoZSBuZXcgdGV4dC5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIHJlcGxhY2UocmFuZ2UsIG5ld1RleHQpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHJhbmdlOiByYW5nZSwgbmV3VGV4dDogbmV3VGV4dCB9O1xuICAgICAgICB9XG4gICAgICAgIFRleHRFZGl0LnJlcGxhY2UgPSByZXBsYWNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhbiBpbnNlcnQgdGV4dCBlZGl0LlxuICAgICAgICAgKiBAcGFyYW0gcG9zaXRpb24gVGhlIHBvc2l0aW9uIHRvIGluc2VydCB0aGUgdGV4dCBhdC5cbiAgICAgICAgICogQHBhcmFtIG5ld1RleHQgVGhlIHRleHQgdG8gYmUgaW5zZXJ0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBpbnNlcnQocG9zaXRpb24sIG5ld1RleHQpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHJhbmdlOiB7IHN0YXJ0OiBwb3NpdGlvbiwgZW5kOiBwb3NpdGlvbiB9LCBuZXdUZXh0OiBuZXdUZXh0IH07XG4gICAgICAgIH1cbiAgICAgICAgVGV4dEVkaXQuaW5zZXJ0ID0gaW5zZXJ0O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIGRlbGV0ZSB0ZXh0IGVkaXQuXG4gICAgICAgICAqIEBwYXJhbSByYW5nZSBUaGUgcmFuZ2Ugb2YgdGV4dCB0byBiZSBkZWxldGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gZGVsKHJhbmdlKSB7XG4gICAgICAgICAgICByZXR1cm4geyByYW5nZTogcmFuZ2UsIG5ld1RleHQ6ICcnIH07XG4gICAgICAgIH1cbiAgICAgICAgVGV4dEVkaXQuZGVsID0gZGVsO1xuICAgICAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKVxuICAgICAgICAgICAgICAgICYmIElzLnN0cmluZyhjYW5kaWRhdGUubmV3VGV4dClcbiAgICAgICAgICAgICAgICAmJiBSYW5nZS5pcyhjYW5kaWRhdGUucmFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIFRleHRFZGl0LmlzID0gaXM7XG4gICAgfSkoVGV4dEVkaXQgfHwgKGV4cG9ydHMuVGV4dEVkaXQgPSBUZXh0RWRpdCA9IHt9KSk7XG4gICAgdmFyIENoYW5nZUFubm90YXRpb247XG4gICAgKGZ1bmN0aW9uIChDaGFuZ2VBbm5vdGF0aW9uKSB7XG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZShsYWJlbCwgbmVlZHNDb25maXJtYXRpb24sIGRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0geyBsYWJlbDogbGFiZWwgfTtcbiAgICAgICAgICAgIGlmIChuZWVkc0NvbmZpcm1hdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0Lm5lZWRzQ29uZmlybWF0aW9uID0gbmVlZHNDb25maXJtYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGVzY3JpcHRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBDaGFuZ2VBbm5vdGF0aW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAgICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5sYWJlbCkgJiZcbiAgICAgICAgICAgICAgICAoSXMuYm9vbGVhbihjYW5kaWRhdGUubmVlZHNDb25maXJtYXRpb24pIHx8IGNhbmRpZGF0ZS5uZWVkc0NvbmZpcm1hdGlvbiA9PT0gdW5kZWZpbmVkKSAmJlxuICAgICAgICAgICAgICAgIChJcy5zdHJpbmcoY2FuZGlkYXRlLmRlc2NyaXB0aW9uKSB8fCBjYW5kaWRhdGUuZGVzY3JpcHRpb24gPT09IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgQ2hhbmdlQW5ub3RhdGlvbi5pcyA9IGlzO1xuICAgIH0pKENoYW5nZUFubm90YXRpb24gfHwgKGV4cG9ydHMuQ2hhbmdlQW5ub3RhdGlvbiA9IENoYW5nZUFubm90YXRpb24gPSB7fSkpO1xuICAgIHZhciBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllcjtcbiAgICAoZnVuY3Rpb24gKENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyKSB7XG4gICAgICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gSXMuc3RyaW5nKGNhbmRpZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMgPSBpcztcbiAgICB9KShDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllciB8fCAoZXhwb3J0cy5DaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllciA9IENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyID0ge30pKTtcbiAgICB2YXIgQW5ub3RhdGVkVGV4dEVkaXQ7XG4gICAgKGZ1bmN0aW9uIChBbm5vdGF0ZWRUZXh0RWRpdCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhbiBhbm5vdGF0ZWQgcmVwbGFjZSB0ZXh0IGVkaXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSByYW5nZSBUaGUgcmFuZ2Ugb2YgdGV4dCB0byBiZSByZXBsYWNlZC5cbiAgICAgICAgICogQHBhcmFtIG5ld1RleHQgVGhlIG5ldyB0ZXh0LlxuICAgICAgICAgKiBAcGFyYW0gYW5ub3RhdGlvbiBUaGUgYW5ub3RhdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIHJlcGxhY2UocmFuZ2UsIG5ld1RleHQsIGFubm90YXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB7IHJhbmdlOiByYW5nZSwgbmV3VGV4dDogbmV3VGV4dCwgYW5ub3RhdGlvbklkOiBhbm5vdGF0aW9uIH07XG4gICAgICAgIH1cbiAgICAgICAgQW5ub3RhdGVkVGV4dEVkaXQucmVwbGFjZSA9IHJlcGxhY2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGFuIGFubm90YXRlZCBpbnNlcnQgdGV4dCBlZGl0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcG9zaXRpb24gVGhlIHBvc2l0aW9uIHRvIGluc2VydCB0aGUgdGV4dCBhdC5cbiAgICAgICAgICogQHBhcmFtIG5ld1RleHQgVGhlIHRleHQgdG8gYmUgaW5zZXJ0ZWQuXG4gICAgICAgICAqIEBwYXJhbSBhbm5vdGF0aW9uIFRoZSBhbm5vdGF0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gaW5zZXJ0KHBvc2l0aW9uLCBuZXdUZXh0LCBhbm5vdGF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4geyByYW5nZTogeyBzdGFydDogcG9zaXRpb24sIGVuZDogcG9zaXRpb24gfSwgbmV3VGV4dDogbmV3VGV4dCwgYW5ub3RhdGlvbklkOiBhbm5vdGF0aW9uIH07XG4gICAgICAgIH1cbiAgICAgICAgQW5ub3RhdGVkVGV4dEVkaXQuaW5zZXJ0ID0gaW5zZXJ0O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhbiBhbm5vdGF0ZWQgZGVsZXRlIHRleHQgZWRpdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHJhbmdlIFRoZSByYW5nZSBvZiB0ZXh0IHRvIGJlIGRlbGV0ZWQuXG4gICAgICAgICAqIEBwYXJhbSBhbm5vdGF0aW9uIFRoZSBhbm5vdGF0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gZGVsKHJhbmdlLCBhbm5vdGF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4geyByYW5nZTogcmFuZ2UsIG5ld1RleHQ6ICcnLCBhbm5vdGF0aW9uSWQ6IGFubm90YXRpb24gfTtcbiAgICAgICAgfVxuICAgICAgICBBbm5vdGF0ZWRUZXh0RWRpdC5kZWwgPSBkZWw7XG4gICAgICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gVGV4dEVkaXQuaXMoY2FuZGlkYXRlKSAmJiAoQ2hhbmdlQW5ub3RhdGlvbi5pcyhjYW5kaWRhdGUuYW5ub3RhdGlvbklkKSB8fCBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhjYW5kaWRhdGUuYW5ub3RhdGlvbklkKSk7XG4gICAgICAgIH1cbiAgICAgICAgQW5ub3RhdGVkVGV4dEVkaXQuaXMgPSBpcztcbiAgICB9KShBbm5vdGF0ZWRUZXh0RWRpdCB8fCAoZXhwb3J0cy5Bbm5vdGF0ZWRUZXh0RWRpdCA9IEFubm90YXRlZFRleHRFZGl0ID0ge30pKTtcbiAgICAvKipcbiAgICAgKiBUaGUgVGV4dERvY3VtZW50RWRpdCBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZVxuICAgICAqIGFuIGVkaXQgdGhhdCBtYW5pcHVsYXRlcyBhIHRleHQgZG9jdW1lbnQuXG4gICAgICovXG4gICAgdmFyIFRleHREb2N1bWVudEVkaXQ7XG4gICAgKGZ1bmN0aW9uIChUZXh0RG9jdW1lbnRFZGl0KSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IGBUZXh0RG9jdW1lbnRFZGl0YFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlKHRleHREb2N1bWVudCwgZWRpdHMpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHRleHREb2N1bWVudDogdGV4dERvY3VtZW50LCBlZGl0czogZWRpdHMgfTtcbiAgICAgICAgfVxuICAgICAgICBUZXh0RG9jdW1lbnRFZGl0LmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAgICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSlcbiAgICAgICAgICAgICAgICAmJiBPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIuaXMoY2FuZGlkYXRlLnRleHREb2N1bWVudClcbiAgICAgICAgICAgICAgICAmJiBBcnJheS5pc0FycmF5KGNhbmRpZGF0ZS5lZGl0cyk7XG4gICAgICAgIH1cbiAgICAgICAgVGV4dERvY3VtZW50RWRpdC5pcyA9IGlzO1xuICAgIH0pKFRleHREb2N1bWVudEVkaXQgfHwgKGV4cG9ydHMuVGV4dERvY3VtZW50RWRpdCA9IFRleHREb2N1bWVudEVkaXQgPSB7fSkpO1xuICAgIHZhciBDcmVhdGVGaWxlO1xuICAgIChmdW5jdGlvbiAoQ3JlYXRlRmlsZSkge1xuICAgICAgICBmdW5jdGlvbiBjcmVhdGUodXJpLCBvcHRpb25zLCBhbm5vdGF0aW9uKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgIGtpbmQ6ICdjcmVhdGUnLFxuICAgICAgICAgICAgICAgIHVyaTogdXJpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiAob3B0aW9ucy5vdmVyd3JpdGUgIT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmlnbm9yZUlmRXhpc3RzICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0Lm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFubm90YXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5hbm5vdGF0aW9uSWQgPSBhbm5vdGF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBDcmVhdGVGaWxlLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAgICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgY2FuZGlkYXRlLmtpbmQgPT09ICdjcmVhdGUnICYmIElzLnN0cmluZyhjYW5kaWRhdGUudXJpKSAmJiAoY2FuZGlkYXRlLm9wdGlvbnMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgICgoY2FuZGlkYXRlLm9wdGlvbnMub3ZlcndyaXRlID09PSB1bmRlZmluZWQgfHwgSXMuYm9vbGVhbihjYW5kaWRhdGUub3B0aW9ucy5vdmVyd3JpdGUpKSAmJiAoY2FuZGlkYXRlLm9wdGlvbnMuaWdub3JlSWZFeGlzdHMgPT09IHVuZGVmaW5lZCB8fCBJcy5ib29sZWFuKGNhbmRpZGF0ZS5vcHRpb25zLmlnbm9yZUlmRXhpc3RzKSkpKSAmJiAoY2FuZGlkYXRlLmFubm90YXRpb25JZCA9PT0gdW5kZWZpbmVkIHx8IENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGNhbmRpZGF0ZS5hbm5vdGF0aW9uSWQpKTtcbiAgICAgICAgfVxuICAgICAgICBDcmVhdGVGaWxlLmlzID0gaXM7XG4gICAgfSkoQ3JlYXRlRmlsZSB8fCAoZXhwb3J0cy5DcmVhdGVGaWxlID0gQ3JlYXRlRmlsZSA9IHt9KSk7XG4gICAgdmFyIFJlbmFtZUZpbGU7XG4gICAgKGZ1bmN0aW9uIChSZW5hbWVGaWxlKSB7XG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZShvbGRVcmksIG5ld1VyaSwgb3B0aW9ucywgYW5ub3RhdGlvbikge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICBraW5kOiAncmVuYW1lJyxcbiAgICAgICAgICAgICAgICBvbGRVcmk6IG9sZFVyaSxcbiAgICAgICAgICAgICAgICBuZXdVcmk6IG5ld1VyaVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQgJiYgKG9wdGlvbnMub3ZlcndyaXRlICE9PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5pZ25vcmVJZkV4aXN0cyAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbm5vdGF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuYW5ub3RhdGlvbklkID0gYW5ub3RhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgUmVuYW1lRmlsZS5jcmVhdGUgPSBjcmVhdGU7XG4gICAgICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIGNhbmRpZGF0ZS5raW5kID09PSAncmVuYW1lJyAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLm9sZFVyaSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5uZXdVcmkpICYmIChjYW5kaWRhdGUub3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgKChjYW5kaWRhdGUub3B0aW9ucy5vdmVyd3JpdGUgPT09IHVuZGVmaW5lZCB8fCBJcy5ib29sZWFuKGNhbmRpZGF0ZS5vcHRpb25zLm92ZXJ3cml0ZSkpICYmIChjYW5kaWRhdGUub3B0aW9ucy5pZ25vcmVJZkV4aXN0cyA9PT0gdW5kZWZpbmVkIHx8IElzLmJvb2xlYW4oY2FuZGlkYXRlLm9wdGlvbnMuaWdub3JlSWZFeGlzdHMpKSkpICYmIChjYW5kaWRhdGUuYW5ub3RhdGlvbklkID09PSB1bmRlZmluZWQgfHwgQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMoY2FuZGlkYXRlLmFubm90YXRpb25JZCkpO1xuICAgICAgICB9XG4gICAgICAgIFJlbmFtZUZpbGUuaXMgPSBpcztcbiAgICB9KShSZW5hbWVGaWxlIHx8IChleHBvcnRzLlJlbmFtZUZpbGUgPSBSZW5hbWVGaWxlID0ge30pKTtcbiAgICB2YXIgRGVsZXRlRmlsZTtcbiAgICAoZnVuY3Rpb24gKERlbGV0ZUZpbGUpIHtcbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlKHVyaSwgb3B0aW9ucywgYW5ub3RhdGlvbikge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICBraW5kOiAnZGVsZXRlJyxcbiAgICAgICAgICAgICAgICB1cmk6IHVyaVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQgJiYgKG9wdGlvbnMucmVjdXJzaXZlICE9PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5pZ25vcmVJZk5vdEV4aXN0cyAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbm5vdGF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuYW5ub3RhdGlvbklkID0gYW5ub3RhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgRGVsZXRlRmlsZS5jcmVhdGUgPSBjcmVhdGU7XG4gICAgICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIGNhbmRpZGF0ZS5raW5kID09PSAnZGVsZXRlJyAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnVyaSkgJiYgKGNhbmRpZGF0ZS5vcHRpb25zID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAoKGNhbmRpZGF0ZS5vcHRpb25zLnJlY3Vyc2l2ZSA9PT0gdW5kZWZpbmVkIHx8IElzLmJvb2xlYW4oY2FuZGlkYXRlLm9wdGlvbnMucmVjdXJzaXZlKSkgJiYgKGNhbmRpZGF0ZS5vcHRpb25zLmlnbm9yZUlmTm90RXhpc3RzID09PSB1bmRlZmluZWQgfHwgSXMuYm9vbGVhbihjYW5kaWRhdGUub3B0aW9ucy5pZ25vcmVJZk5vdEV4aXN0cykpKSkgJiYgKGNhbmRpZGF0ZS5hbm5vdGF0aW9uSWQgPT09IHVuZGVmaW5lZCB8fCBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhjYW5kaWRhdGUuYW5ub3RhdGlvbklkKSk7XG4gICAgICAgIH1cbiAgICAgICAgRGVsZXRlRmlsZS5pcyA9IGlzO1xuICAgIH0pKERlbGV0ZUZpbGUgfHwgKGV4cG9ydHMuRGVsZXRlRmlsZSA9IERlbGV0ZUZpbGUgPSB7fSkpO1xuICAgIHZhciBXb3Jrc3BhY2VFZGl0O1xuICAgIChmdW5jdGlvbiAoV29ya3NwYWNlRWRpdCkge1xuICAgICAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJlxuICAgICAgICAgICAgICAgIChjYW5kaWRhdGUuY2hhbmdlcyAhPT0gdW5kZWZpbmVkIHx8IGNhbmRpZGF0ZS5kb2N1bWVudENoYW5nZXMgIT09IHVuZGVmaW5lZCkgJiZcbiAgICAgICAgICAgICAgICAoY2FuZGlkYXRlLmRvY3VtZW50Q2hhbmdlcyA9PT0gdW5kZWZpbmVkIHx8IGNhbmRpZGF0ZS5kb2N1bWVudENoYW5nZXMuZXZlcnkoZnVuY3Rpb24gKGNoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoSXMuc3RyaW5nKGNoYW5nZS5raW5kKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIENyZWF0ZUZpbGUuaXMoY2hhbmdlKSB8fCBSZW5hbWVGaWxlLmlzKGNoYW5nZSkgfHwgRGVsZXRlRmlsZS5pcyhjaGFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFRleHREb2N1bWVudEVkaXQuaXMoY2hhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBXb3Jrc3BhY2VFZGl0LmlzID0gaXM7XG4gICAgfSkoV29ya3NwYWNlRWRpdCB8fCAoZXhwb3J0cy5Xb3Jrc3BhY2VFZGl0ID0gV29ya3NwYWNlRWRpdCA9IHt9KSk7XG4gICAgdmFyIFRleHRFZGl0Q2hhbmdlSW1wbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gVGV4dEVkaXRDaGFuZ2VJbXBsKGVkaXRzLCBjaGFuZ2VBbm5vdGF0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5lZGl0cyA9IGVkaXRzO1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VBbm5vdGF0aW9ucyA9IGNoYW5nZUFubm90YXRpb25zO1xuICAgICAgICB9XG4gICAgICAgIFRleHRFZGl0Q2hhbmdlSW1wbC5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKHBvc2l0aW9uLCBuZXdUZXh0LCBhbm5vdGF0aW9uKSB7XG4gICAgICAgICAgICB2YXIgZWRpdDtcbiAgICAgICAgICAgIHZhciBpZDtcbiAgICAgICAgICAgIGlmIChhbm5vdGF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBlZGl0ID0gVGV4dEVkaXQuaW5zZXJ0KHBvc2l0aW9uLCBuZXdUZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGFubm90YXRpb24pKSB7XG4gICAgICAgICAgICAgICAgaWQgPSBhbm5vdGF0aW9uO1xuICAgICAgICAgICAgICAgIGVkaXQgPSBBbm5vdGF0ZWRUZXh0RWRpdC5pbnNlcnQocG9zaXRpb24sIG5ld1RleHQsIGFubm90YXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hc3NlcnRDaGFuZ2VBbm5vdGF0aW9ucyh0aGlzLmNoYW5nZUFubm90YXRpb25zKTtcbiAgICAgICAgICAgICAgICBpZCA9IHRoaXMuY2hhbmdlQW5ub3RhdGlvbnMubWFuYWdlKGFubm90YXRpb24pO1xuICAgICAgICAgICAgICAgIGVkaXQgPSBBbm5vdGF0ZWRUZXh0RWRpdC5pbnNlcnQocG9zaXRpb24sIG5ld1RleHQsIGlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZWRpdHMucHVzaChlZGl0KTtcbiAgICAgICAgICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBUZXh0RWRpdENoYW5nZUltcGwucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiAocmFuZ2UsIG5ld1RleHQsIGFubm90YXRpb24pIHtcbiAgICAgICAgICAgIHZhciBlZGl0O1xuICAgICAgICAgICAgdmFyIGlkO1xuICAgICAgICAgICAgaWYgKGFubm90YXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGVkaXQgPSBUZXh0RWRpdC5yZXBsYWNlKHJhbmdlLCBuZXdUZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGFubm90YXRpb24pKSB7XG4gICAgICAgICAgICAgICAgaWQgPSBhbm5vdGF0aW9uO1xuICAgICAgICAgICAgICAgIGVkaXQgPSBBbm5vdGF0ZWRUZXh0RWRpdC5yZXBsYWNlKHJhbmdlLCBuZXdUZXh0LCBhbm5vdGF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYXNzZXJ0Q2hhbmdlQW5ub3RhdGlvbnModGhpcy5jaGFuZ2VBbm5vdGF0aW9ucyk7XG4gICAgICAgICAgICAgICAgaWQgPSB0aGlzLmNoYW5nZUFubm90YXRpb25zLm1hbmFnZShhbm5vdGF0aW9uKTtcbiAgICAgICAgICAgICAgICBlZGl0ID0gQW5ub3RhdGVkVGV4dEVkaXQucmVwbGFjZShyYW5nZSwgbmV3VGV4dCwgaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lZGl0cy5wdXNoKGVkaXQpO1xuICAgICAgICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFRleHRFZGl0Q2hhbmdlSW1wbC5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKHJhbmdlLCBhbm5vdGF0aW9uKSB7XG4gICAgICAgICAgICB2YXIgZWRpdDtcbiAgICAgICAgICAgIHZhciBpZDtcbiAgICAgICAgICAgIGlmIChhbm5vdGF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBlZGl0ID0gVGV4dEVkaXQuZGVsKHJhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGFubm90YXRpb24pKSB7XG4gICAgICAgICAgICAgICAgaWQgPSBhbm5vdGF0aW9uO1xuICAgICAgICAgICAgICAgIGVkaXQgPSBBbm5vdGF0ZWRUZXh0RWRpdC5kZWwocmFuZ2UsIGFubm90YXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hc3NlcnRDaGFuZ2VBbm5vdGF0aW9ucyh0aGlzLmNoYW5nZUFubm90YXRpb25zKTtcbiAgICAgICAgICAgICAgICBpZCA9IHRoaXMuY2hhbmdlQW5ub3RhdGlvbnMubWFuYWdlKGFubm90YXRpb24pO1xuICAgICAgICAgICAgICAgIGVkaXQgPSBBbm5vdGF0ZWRUZXh0RWRpdC5kZWwocmFuZ2UsIGlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZWRpdHMucHVzaChlZGl0KTtcbiAgICAgICAgICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBUZXh0RWRpdENoYW5nZUltcGwucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChlZGl0KSB7XG4gICAgICAgICAgICB0aGlzLmVkaXRzLnB1c2goZWRpdCk7XG4gICAgICAgIH07XG4gICAgICAgIFRleHRFZGl0Q2hhbmdlSW1wbC5wcm90b3R5cGUuYWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWRpdHM7XG4gICAgICAgIH07XG4gICAgICAgIFRleHRFZGl0Q2hhbmdlSW1wbC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmVkaXRzLnNwbGljZSgwLCB0aGlzLmVkaXRzLmxlbmd0aCk7XG4gICAgICAgIH07XG4gICAgICAgIFRleHRFZGl0Q2hhbmdlSW1wbC5wcm90b3R5cGUuYXNzZXJ0Q2hhbmdlQW5ub3RhdGlvbnMgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGV4dCBlZGl0IGNoYW5nZSBpcyBub3QgY29uZmlndXJlZCB0byBtYW5hZ2UgY2hhbmdlIGFubm90YXRpb25zLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFRleHRFZGl0Q2hhbmdlSW1wbDtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIEEgaGVscGVyIGNsYXNzXG4gICAgICovXG4gICAgdmFyIENoYW5nZUFubm90YXRpb25zID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBDaGFuZ2VBbm5vdGF0aW9ucyhhbm5vdGF0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5fYW5ub3RhdGlvbnMgPSBhbm5vdGF0aW9ucyA9PT0gdW5kZWZpbmVkID8gT2JqZWN0LmNyZWF0ZShudWxsKSA6IGFubm90YXRpb25zO1xuICAgICAgICAgICAgdGhpcy5fY291bnRlciA9IDA7XG4gICAgICAgICAgICB0aGlzLl9zaXplID0gMDtcbiAgICAgICAgfVxuICAgICAgICBDaGFuZ2VBbm5vdGF0aW9ucy5wcm90b3R5cGUuYWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Fubm90YXRpb25zO1xuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2hhbmdlQW5ub3RhdGlvbnMucHJvdG90eXBlLCBcInNpemVcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpemU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIENoYW5nZUFubm90YXRpb25zLnByb3RvdHlwZS5tYW5hZ2UgPSBmdW5jdGlvbiAoaWRPckFubm90YXRpb24sIGFubm90YXRpb24pIHtcbiAgICAgICAgICAgIHZhciBpZDtcbiAgICAgICAgICAgIGlmIChDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhpZE9yQW5ub3RhdGlvbikpIHtcbiAgICAgICAgICAgICAgICBpZCA9IGlkT3JBbm5vdGF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWQgPSB0aGlzLm5leHRJZCgpO1xuICAgICAgICAgICAgICAgIGFubm90YXRpb24gPSBpZE9yQW5ub3RhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9hbm5vdGF0aW9uc1tpZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklkIFwiLmNvbmNhdChpZCwgXCIgaXMgYWxyZWFkeSBpbiB1c2UuXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbm5vdGF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBhbm5vdGF0aW9uIHByb3ZpZGVkIGZvciBpZCBcIi5jb25jYXQoaWQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2Fubm90YXRpb25zW2lkXSA9IGFubm90YXRpb247XG4gICAgICAgICAgICB0aGlzLl9zaXplKys7XG4gICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgIH07XG4gICAgICAgIENoYW5nZUFubm90YXRpb25zLnByb3RvdHlwZS5uZXh0SWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9jb3VudGVyKys7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY291bnRlci50b1N0cmluZygpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gQ2hhbmdlQW5ub3RhdGlvbnM7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBBIHdvcmtzcGFjZSBjaGFuZ2UgaGVscHMgY29uc3RydWN0aW5nIGNoYW5nZXMgdG8gYSB3b3Jrc3BhY2UuXG4gICAgICovXG4gICAgdmFyIFdvcmtzcGFjZUNoYW5nZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gV29ya3NwYWNlQ2hhbmdlKHdvcmtzcGFjZUVkaXQpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLl90ZXh0RWRpdENoYW5nZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgaWYgKHdvcmtzcGFjZUVkaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQgPSB3b3Jrc3BhY2VFZGl0O1xuICAgICAgICAgICAgICAgIGlmICh3b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucyA9IG5ldyBDaGFuZ2VBbm5vdGF0aW9ucyh3b3Jrc3BhY2VFZGl0LmNoYW5nZUFubm90YXRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgd29ya3NwYWNlRWRpdC5jaGFuZ2VBbm5vdGF0aW9ucyA9IHRoaXMuX2NoYW5nZUFubm90YXRpb25zLmFsbCgpO1xuICAgICAgICAgICAgICAgICAgICB3b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcy5mb3JFYWNoKGZ1bmN0aW9uIChjaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChUZXh0RG9jdW1lbnRFZGl0LmlzKGNoYW5nZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dEVkaXRDaGFuZ2UgPSBuZXcgVGV4dEVkaXRDaGFuZ2VJbXBsKGNoYW5nZS5lZGl0cywgX3RoaXMuX2NoYW5nZUFubm90YXRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fdGV4dEVkaXRDaGFuZ2VzW2NoYW5nZS50ZXh0RG9jdW1lbnQudXJpXSA9IHRleHRFZGl0Q2hhbmdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAod29ya3NwYWNlRWRpdC5jaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHdvcmtzcGFjZUVkaXQuY2hhbmdlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dEVkaXRDaGFuZ2UgPSBuZXcgVGV4dEVkaXRDaGFuZ2VJbXBsKHdvcmtzcGFjZUVkaXQuY2hhbmdlc1trZXldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl90ZXh0RWRpdENoYW5nZXNba2V5XSA9IHRleHRFZGl0Q2hhbmdlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93b3Jrc3BhY2VFZGl0ID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdvcmtzcGFjZUNoYW5nZS5wcm90b3R5cGUsIFwiZWRpdFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJldHVybnMgdGhlIHVuZGVybHlpbmcge0BsaW5rIFdvcmtzcGFjZUVkaXR9IGxpdGVyYWxcbiAgICAgICAgICAgICAqIHVzZSB0byBiZSByZXR1cm5lZCBmcm9tIGEgd29ya3NwYWNlIGVkaXQgb3BlcmF0aW9uIGxpa2UgcmVuYW1lLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluaXREb2N1bWVudENoYW5nZXMoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY2hhbmdlQW5ub3RhdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fY2hhbmdlQW5ub3RhdGlvbnMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdC5jaGFuZ2VBbm5vdGF0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuY2hhbmdlQW5ub3RhdGlvbnMgPSB0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucy5hbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd29ya3NwYWNlRWRpdDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgV29ya3NwYWNlQ2hhbmdlLnByb3RvdHlwZS5nZXRUZXh0RWRpdENoYW5nZSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmIChPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIuaXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdERvY3VtZW50Q2hhbmdlcygpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl93b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV29ya3NwYWNlIGVkaXQgaXMgbm90IGNvbmZpZ3VyZWQgZm9yIGRvY3VtZW50IGNoYW5nZXMuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB0ZXh0RG9jdW1lbnQgPSB7IHVyaToga2V5LnVyaSwgdmVyc2lvbjoga2V5LnZlcnNpb24gfTtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fdGV4dEVkaXRDaGFuZ2VzW3RleHREb2N1bWVudC51cmldO1xuICAgICAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlZGl0cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dERvY3VtZW50RWRpdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHREb2N1bWVudDogdGV4dERvY3VtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdHM6IGVkaXRzXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzLnB1c2godGV4dERvY3VtZW50RWRpdCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBUZXh0RWRpdENoYW5nZUltcGwoZWRpdHMsIHRoaXMuX2NoYW5nZUFubm90YXRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGV4dEVkaXRDaGFuZ2VzW3RleHREb2N1bWVudC51cmldID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0Q2hhbmdlcygpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl93b3Jrc3BhY2VFZGl0LmNoYW5nZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dvcmtzcGFjZSBlZGl0IGlzIG5vdCBjb25maWd1cmVkIGZvciBub3JtYWwgdGV4dCBlZGl0IGNoYW5nZXMuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl90ZXh0RWRpdENoYW5nZXNba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWRpdHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdC5jaGFuZ2VzW2tleV0gPSBlZGl0cztcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IFRleHRFZGl0Q2hhbmdlSW1wbChlZGl0cyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RleHRFZGl0Q2hhbmdlc1trZXldID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBXb3Jrc3BhY2VDaGFuZ2UucHJvdG90eXBlLmluaXREb2N1bWVudENoYW5nZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMgPT09IHVuZGVmaW5lZCAmJiB0aGlzLl93b3Jrc3BhY2VFZGl0LmNoYW5nZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZUFubm90YXRpb25zID0gbmV3IENoYW5nZUFubm90YXRpb25zKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLl93b3Jrc3BhY2VFZGl0LmNoYW5nZUFubm90YXRpb25zID0gdGhpcy5fY2hhbmdlQW5ub3RhdGlvbnMuYWxsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFdvcmtzcGFjZUNoYW5nZS5wcm90b3R5cGUuaW5pdENoYW5nZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMgPT09IHVuZGVmaW5lZCAmJiB0aGlzLl93b3Jrc3BhY2VFZGl0LmNoYW5nZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuY2hhbmdlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFdvcmtzcGFjZUNoYW5nZS5wcm90b3R5cGUuY3JlYXRlRmlsZSA9IGZ1bmN0aW9uICh1cmksIG9wdGlvbnNPckFubm90YXRpb24sIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdERvY3VtZW50Q2hhbmdlcygpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3dvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dvcmtzcGFjZSBlZGl0IGlzIG5vdCBjb25maWd1cmVkIGZvciBkb2N1bWVudCBjaGFuZ2VzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGFubm90YXRpb247XG4gICAgICAgICAgICBpZiAoQ2hhbmdlQW5ub3RhdGlvbi5pcyhvcHRpb25zT3JBbm5vdGF0aW9uKSB8fCBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhvcHRpb25zT3JBbm5vdGF0aW9uKSkge1xuICAgICAgICAgICAgICAgIGFubm90YXRpb24gPSBvcHRpb25zT3JBbm5vdGF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnNPckFubm90YXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgb3BlcmF0aW9uO1xuICAgICAgICAgICAgdmFyIGlkO1xuICAgICAgICAgICAgaWYgKGFubm90YXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbiA9IENyZWF0ZUZpbGUuY3JlYXRlKHVyaSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZCA9IENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGFubm90YXRpb24pID8gYW5ub3RhdGlvbiA6IHRoaXMuX2NoYW5nZUFubm90YXRpb25zLm1hbmFnZShhbm5vdGF0aW9uKTtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb24gPSBDcmVhdGVGaWxlLmNyZWF0ZSh1cmksIG9wdGlvbnMsIGlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzLnB1c2gob3BlcmF0aW9uKTtcbiAgICAgICAgICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBXb3Jrc3BhY2VDaGFuZ2UucHJvdG90eXBlLnJlbmFtZUZpbGUgPSBmdW5jdGlvbiAob2xkVXJpLCBuZXdVcmksIG9wdGlvbnNPckFubm90YXRpb24sIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdERvY3VtZW50Q2hhbmdlcygpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3dvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dvcmtzcGFjZSBlZGl0IGlzIG5vdCBjb25maWd1cmVkIGZvciBkb2N1bWVudCBjaGFuZ2VzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGFubm90YXRpb247XG4gICAgICAgICAgICBpZiAoQ2hhbmdlQW5ub3RhdGlvbi5pcyhvcHRpb25zT3JBbm5vdGF0aW9uKSB8fCBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhvcHRpb25zT3JBbm5vdGF0aW9uKSkge1xuICAgICAgICAgICAgICAgIGFubm90YXRpb24gPSBvcHRpb25zT3JBbm5vdGF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnNPckFubm90YXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgb3BlcmF0aW9uO1xuICAgICAgICAgICAgdmFyIGlkO1xuICAgICAgICAgICAgaWYgKGFubm90YXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbiA9IFJlbmFtZUZpbGUuY3JlYXRlKG9sZFVyaSwgbmV3VXJpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlkID0gQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMoYW5ub3RhdGlvbikgPyBhbm5vdGF0aW9uIDogdGhpcy5fY2hhbmdlQW5ub3RhdGlvbnMubWFuYWdlKGFubm90YXRpb24pO1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbiA9IFJlbmFtZUZpbGUuY3JlYXRlKG9sZFVyaSwgbmV3VXJpLCBvcHRpb25zLCBpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl93b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcy5wdXNoKG9wZXJhdGlvbik7XG4gICAgICAgICAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgV29ya3NwYWNlQ2hhbmdlLnByb3RvdHlwZS5kZWxldGVGaWxlID0gZnVuY3Rpb24gKHVyaSwgb3B0aW9uc09yQW5ub3RhdGlvbiwgb3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5pbml0RG9jdW1lbnRDaGFuZ2VzKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV29ya3NwYWNlIGVkaXQgaXMgbm90IGNvbmZpZ3VyZWQgZm9yIGRvY3VtZW50IGNoYW5nZXMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYW5ub3RhdGlvbjtcbiAgICAgICAgICAgIGlmIChDaGFuZ2VBbm5vdGF0aW9uLmlzKG9wdGlvbnNPckFubm90YXRpb24pIHx8IENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKG9wdGlvbnNPckFubm90YXRpb24pKSB7XG4gICAgICAgICAgICAgICAgYW5ub3RhdGlvbiA9IG9wdGlvbnNPckFubm90YXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gb3B0aW9uc09yQW5ub3RhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBvcGVyYXRpb247XG4gICAgICAgICAgICB2YXIgaWQ7XG4gICAgICAgICAgICBpZiAoYW5ub3RhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uID0gRGVsZXRlRmlsZS5jcmVhdGUodXJpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlkID0gQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMoYW5ub3RhdGlvbikgPyBhbm5vdGF0aW9uIDogdGhpcy5fY2hhbmdlQW5ub3RhdGlvbnMubWFuYWdlKGFubm90YXRpb24pO1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbiA9IERlbGV0ZUZpbGUuY3JlYXRlKHVyaSwgb3B0aW9ucywgaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMucHVzaChvcGVyYXRpb24pO1xuICAgICAgICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBXb3Jrc3BhY2VDaGFuZ2U7XG4gICAgfSgpKTtcbiAgICBleHBvcnRzLldvcmtzcGFjZUNoYW5nZSA9IFdvcmtzcGFjZUNoYW5nZTtcbiAgICAvKipcbiAgICAgKiBUaGUgVGV4dERvY3VtZW50SWRlbnRpZmllciBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAgICAgKiB7QGxpbmsgVGV4dERvY3VtZW50SWRlbnRpZmllcn0gbGl0ZXJhbHMuXG4gICAgICovXG4gICAgdmFyIFRleHREb2N1bWVudElkZW50aWZpZXI7XG4gICAgKGZ1bmN0aW9uIChUZXh0RG9jdW1lbnRJZGVudGlmaWVyKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IFRleHREb2N1bWVudElkZW50aWZpZXIgbGl0ZXJhbC5cbiAgICAgICAgICogQHBhcmFtIHVyaSBUaGUgZG9jdW1lbnQncyB1cmkuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBjcmVhdGUodXJpKSB7XG4gICAgICAgICAgICByZXR1cm4geyB1cmk6IHVyaSB9O1xuICAgICAgICB9XG4gICAgICAgIFRleHREb2N1bWVudElkZW50aWZpZXIuY3JlYXRlID0gY3JlYXRlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBUZXh0RG9jdW1lbnRJZGVudGlmaWVyfSBpbnRlcmZhY2UuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnVyaSk7XG4gICAgICAgIH1cbiAgICAgICAgVGV4dERvY3VtZW50SWRlbnRpZmllci5pcyA9IGlzO1xuICAgIH0pKFRleHREb2N1bWVudElkZW50aWZpZXIgfHwgKGV4cG9ydHMuVGV4dERvY3VtZW50SWRlbnRpZmllciA9IFRleHREb2N1bWVudElkZW50aWZpZXIgPSB7fSkpO1xuICAgIC8qKlxuICAgICAqIFRoZSBWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICAgICAqIHtAbGluayBWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyfSBsaXRlcmFscy5cbiAgICAgKi9cbiAgICB2YXIgVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllcjtcbiAgICAoZnVuY3Rpb24gKFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciBsaXRlcmFsLlxuICAgICAgICAgKiBAcGFyYW0gdXJpIFRoZSBkb2N1bWVudCdzIHVyaS5cbiAgICAgICAgICogQHBhcmFtIHZlcnNpb24gVGhlIGRvY3VtZW50J3MgdmVyc2lvbi5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZSh1cmksIHZlcnNpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB7IHVyaTogdXJpLCB2ZXJzaW9uOiB2ZXJzaW9uIH07XG4gICAgICAgIH1cbiAgICAgICAgVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllci5jcmVhdGUgPSBjcmVhdGU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXJ9IGludGVyZmFjZS5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUudXJpKSAmJiBJcy5pbnRlZ2VyKGNhbmRpZGF0ZS52ZXJzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICBWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyLmlzID0gaXM7XG4gICAgfSkoVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciB8fCAoZXhwb3J0cy5WZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyID0gVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciA9IHt9KSk7XG4gICAgLyoqXG4gICAgICogVGhlIE9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAgICAgKiB7QGxpbmsgT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyfSBsaXRlcmFscy5cbiAgICAgKi9cbiAgICB2YXIgT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyO1xuICAgIChmdW5jdGlvbiAoT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IE9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciBsaXRlcmFsLlxuICAgICAgICAgKiBAcGFyYW0gdXJpIFRoZSBkb2N1bWVudCdzIHVyaS5cbiAgICAgICAgICogQHBhcmFtIHZlcnNpb24gVGhlIGRvY3VtZW50J3MgdmVyc2lvbi5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZSh1cmksIHZlcnNpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB7IHVyaTogdXJpLCB2ZXJzaW9uOiB2ZXJzaW9uIH07XG4gICAgICAgIH1cbiAgICAgICAgT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyfSBpbnRlcmZhY2UuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnVyaSkgJiYgKGNhbmRpZGF0ZS52ZXJzaW9uID09PSBudWxsIHx8IElzLmludGVnZXIoY2FuZGlkYXRlLnZlcnNpb24pKTtcbiAgICAgICAgfVxuICAgICAgICBPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIuaXMgPSBpcztcbiAgICB9KShPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIgfHwgKGV4cG9ydHMuT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyID0gT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyID0ge30pKTtcbiAgICAvKipcbiAgICAgKiBUaGUgVGV4dERvY3VtZW50SXRlbSBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAgICAgKiB7QGxpbmsgVGV4dERvY3VtZW50SXRlbX0gbGl0ZXJhbHMuXG4gICAgICovXG4gICAgdmFyIFRleHREb2N1bWVudEl0ZW07XG4gICAgKGZ1bmN0aW9uIChUZXh0RG9jdW1lbnRJdGVtKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IFRleHREb2N1bWVudEl0ZW0gbGl0ZXJhbC5cbiAgICAgICAgICogQHBhcmFtIHVyaSBUaGUgZG9jdW1lbnQncyB1cmkuXG4gICAgICAgICAqIEBwYXJhbSBsYW5ndWFnZUlkIFRoZSBkb2N1bWVudCdzIGxhbmd1YWdlIGlkZW50aWZpZXIuXG4gICAgICAgICAqIEBwYXJhbSB2ZXJzaW9uIFRoZSBkb2N1bWVudCdzIHZlcnNpb24gbnVtYmVyLlxuICAgICAgICAgKiBAcGFyYW0gdGV4dCBUaGUgZG9jdW1lbnQncyB0ZXh0LlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlKHVyaSwgbGFuZ3VhZ2VJZCwgdmVyc2lvbiwgdGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdXJpOiB1cmksIGxhbmd1YWdlSWQ6IGxhbmd1YWdlSWQsIHZlcnNpb246IHZlcnNpb24sIHRleHQ6IHRleHQgfTtcbiAgICAgICAgfVxuICAgICAgICBUZXh0RG9jdW1lbnRJdGVtLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgVGV4dERvY3VtZW50SXRlbX0gaW50ZXJmYWNlLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS51cmkpICYmIElzLnN0cmluZyhjYW5kaWRhdGUubGFuZ3VhZ2VJZCkgJiYgSXMuaW50ZWdlcihjYW5kaWRhdGUudmVyc2lvbikgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS50ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBUZXh0RG9jdW1lbnRJdGVtLmlzID0gaXM7XG4gICAgfSkoVGV4dERvY3VtZW50SXRlbSB8fCAoZXhwb3J0cy5UZXh0RG9jdW1lbnRJdGVtID0gVGV4dERvY3VtZW50SXRlbSA9IHt9KSk7XG4gICAgLyoqXG4gICAgICogRGVzY3JpYmVzIHRoZSBjb250ZW50IHR5cGUgdGhhdCBhIGNsaWVudCBzdXBwb3J0cyBpbiB2YXJpb3VzXG4gICAgICogcmVzdWx0IGxpdGVyYWxzIGxpa2UgYEhvdmVyYCwgYFBhcmFtZXRlckluZm9gIG9yIGBDb21wbGV0aW9uSXRlbWAuXG4gICAgICpcbiAgICAgKiBQbGVhc2Ugbm90ZSB0aGF0IGBNYXJrdXBLaW5kc2AgbXVzdCBub3Qgc3RhcnQgd2l0aCBhIGAkYC4gVGhpcyBraW5kc1xuICAgICAqIGFyZSByZXNlcnZlZCBmb3IgaW50ZXJuYWwgdXNhZ2UuXG4gICAgICovXG4gICAgdmFyIE1hcmt1cEtpbmQ7XG4gICAgKGZ1bmN0aW9uIChNYXJrdXBLaW5kKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQbGFpbiB0ZXh0IGlzIHN1cHBvcnRlZCBhcyBhIGNvbnRlbnQgZm9ybWF0XG4gICAgICAgICAqL1xuICAgICAgICBNYXJrdXBLaW5kLlBsYWluVGV4dCA9ICdwbGFpbnRleHQnO1xuICAgICAgICAvKipcbiAgICAgICAgICogTWFya2Rvd24gaXMgc3VwcG9ydGVkIGFzIGEgY29udGVudCBmb3JtYXRcbiAgICAgICAgICovXG4gICAgICAgIE1hcmt1cEtpbmQuTWFya2Rvd24gPSAnbWFya2Rvd24nO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsdWUgb2YgdGhlIHtAbGluayBNYXJrdXBLaW5kfSB0eXBlLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBjYW5kaWRhdGUgPT09IE1hcmt1cEtpbmQuUGxhaW5UZXh0IHx8IGNhbmRpZGF0ZSA9PT0gTWFya3VwS2luZC5NYXJrZG93bjtcbiAgICAgICAgfVxuICAgICAgICBNYXJrdXBLaW5kLmlzID0gaXM7XG4gICAgfSkoTWFya3VwS2luZCB8fCAoZXhwb3J0cy5NYXJrdXBLaW5kID0gTWFya3VwS2luZCA9IHt9KSk7XG4gICAgdmFyIE1hcmt1cENvbnRlbnQ7XG4gICAgKGZ1bmN0aW9uIChNYXJrdXBDb250ZW50KSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgY29uZm9ybXMgdG8gdGhlIHtAbGluayBNYXJrdXBDb250ZW50fSBpbnRlcmZhY2UuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwodmFsdWUpICYmIE1hcmt1cEtpbmQuaXMoY2FuZGlkYXRlLmtpbmQpICYmIElzLnN0cmluZyhjYW5kaWRhdGUudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIE1hcmt1cENvbnRlbnQuaXMgPSBpcztcbiAgICB9KShNYXJrdXBDb250ZW50IHx8IChleHBvcnRzLk1hcmt1cENvbnRlbnQgPSBNYXJrdXBDb250ZW50ID0ge30pKTtcbiAgICAvKipcbiAgICAgKiBUaGUga2luZCBvZiBhIGNvbXBsZXRpb24gZW50cnkuXG4gICAgICovXG4gICAgdmFyIENvbXBsZXRpb25JdGVtS2luZDtcbiAgICAoZnVuY3Rpb24gKENvbXBsZXRpb25JdGVtS2luZCkge1xuICAgICAgICBDb21wbGV0aW9uSXRlbUtpbmQuVGV4dCA9IDE7XG4gICAgICAgIENvbXBsZXRpb25JdGVtS2luZC5NZXRob2QgPSAyO1xuICAgICAgICBDb21wbGV0aW9uSXRlbUtpbmQuRnVuY3Rpb24gPSAzO1xuICAgICAgICBDb21wbGV0aW9uSXRlbUtpbmQuQ29uc3RydWN0b3IgPSA0O1xuICAgICAgICBDb21wbGV0aW9uSXRlbUtpbmQuRmllbGQgPSA1O1xuICAgICAgICBDb21wbGV0aW9uSXRlbUtpbmQuVmFyaWFibGUgPSA2O1xuICAgICAgICBDb21wbGV0aW9uSXRlbUtpbmQuQ2xhc3MgPSA3O1xuICAgICAgICBDb21wbGV0aW9uSXRlbUtpbmQuSW50ZXJmYWNlID0gODtcbiAgICAgICAgQ29tcGxldGlvbkl0ZW1LaW5kLk1vZHVsZSA9IDk7XG4gICAgICAgIENvbXBsZXRpb25JdGVtS2luZC5Qcm9wZXJ0eSA9IDEwO1xuICAgICAgICBDb21wbGV0aW9uSXRlbUtpbmQuVW5pdCA9IDExO1xuICAgICAgICBDb21wbGV0aW9uSXRlbUtpbmQuVmFsdWUgPSAxMjtcbiAgICAgICAgQ29tcGxldGlvbkl0ZW1LaW5kLkVudW0gPSAxMztcbiAgICAgICAgQ29tcGxldGlvbkl0ZW1LaW5kLktleXdvcmQgPSAxNDtcbiAgICAgICAgQ29tcGxldGlvbkl0ZW1LaW5kLlNuaXBwZXQgPSAxNTtcbiAgICAgICAgQ29tcGxldGlvbkl0ZW1LaW5kLkNvbG9yID0gMTY7XG4gICAgICAgIENvbXBsZXRpb25JdGVtS2luZC5GaWxlID0gMTc7XG4gICAgICAgIENvbXBsZXRpb25JdGVtS2luZC5SZWZlcmVuY2UgPSAxODtcbiAgICAgICAgQ29tcGxldGlvbkl0ZW1LaW5kLkZvbGRlciA9IDE5O1xuICAgICAgICBDb21wbGV0aW9uSXRlbUtpbmQuRW51bU1lbWJlciA9IDIwO1xuICAgICAgICBDb21wbGV0aW9uSXRlbUtpbmQuQ29uc3RhbnQgPSAyMTtcbiAgICAgICAgQ29tcGxldGlvbkl0ZW1LaW5kLlN0cnVjdCA9IDIyO1xuICAgICAgICBDb21wbGV0aW9uSXRlbUtpbmQuRXZlbnQgPSAyMztcbiAgICAgICAgQ29tcGxldGlvbkl0ZW1LaW5kLk9wZXJhdG9yID0gMjQ7XG4gICAgICAgIENvbXBsZXRpb25JdGVtS2luZC5UeXBlUGFyYW1ldGVyID0gMjU7XG4gICAgfSkoQ29tcGxldGlvbkl0ZW1LaW5kIHx8IChleHBvcnRzLkNvbXBsZXRpb25JdGVtS2luZCA9IENvbXBsZXRpb25JdGVtS2luZCA9IHt9KSk7XG4gICAgLyoqXG4gICAgICogRGVmaW5lcyB3aGV0aGVyIHRoZSBpbnNlcnQgdGV4dCBpbiBhIGNvbXBsZXRpb24gaXRlbSBzaG91bGQgYmUgaW50ZXJwcmV0ZWQgYXNcbiAgICAgKiBwbGFpbiB0ZXh0IG9yIGEgc25pcHBldC5cbiAgICAgKi9cbiAgICB2YXIgSW5zZXJ0VGV4dEZvcm1hdDtcbiAgICAoZnVuY3Rpb24gKEluc2VydFRleHRGb3JtYXQpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBwcmltYXJ5IHRleHQgdG8gYmUgaW5zZXJ0ZWQgaXMgdHJlYXRlZCBhcyBhIHBsYWluIHN0cmluZy5cbiAgICAgICAgICovXG4gICAgICAgIEluc2VydFRleHRGb3JtYXQuUGxhaW5UZXh0ID0gMTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBwcmltYXJ5IHRleHQgdG8gYmUgaW5zZXJ0ZWQgaXMgdHJlYXRlZCBhcyBhIHNuaXBwZXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEEgc25pcHBldCBjYW4gZGVmaW5lIHRhYiBzdG9wcyBhbmQgcGxhY2Vob2xkZXJzIHdpdGggYCQxYCwgYCQyYFxuICAgICAgICAgKiBhbmQgYCR7Mzpmb299YC4gYCQwYCBkZWZpbmVzIHRoZSBmaW5hbCB0YWIgc3RvcCwgaXQgZGVmYXVsdHMgdG9cbiAgICAgICAgICogdGhlIGVuZCBvZiB0aGUgc25pcHBldC4gUGxhY2Vob2xkZXJzIHdpdGggZXF1YWwgaWRlbnRpZmllcnMgYXJlIGxpbmtlZCxcbiAgICAgICAgICogdGhhdCBpcyB0eXBpbmcgaW4gb25lIHdpbGwgdXBkYXRlIG90aGVycyB0b28uXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSBhbHNvOiBodHRwczovL21pY3Jvc29mdC5naXRodWIuaW8vbGFuZ3VhZ2Utc2VydmVyLXByb3RvY29sL3NwZWNpZmljYXRpb25zL3NwZWNpZmljYXRpb24tY3VycmVudC8jc25pcHBldF9zeW50YXhcbiAgICAgICAgICovXG4gICAgICAgIEluc2VydFRleHRGb3JtYXQuU25pcHBldCA9IDI7XG4gICAgfSkoSW5zZXJ0VGV4dEZvcm1hdCB8fCAoZXhwb3J0cy5JbnNlcnRUZXh0Rm9ybWF0ID0gSW5zZXJ0VGV4dEZvcm1hdCA9IHt9KSk7XG4gICAgLyoqXG4gICAgICogQ29tcGxldGlvbiBpdGVtIHRhZ3MgYXJlIGV4dHJhIGFubm90YXRpb25zIHRoYXQgdHdlYWsgdGhlIHJlbmRlcmluZyBvZiBhIGNvbXBsZXRpb25cbiAgICAgKiBpdGVtLlxuICAgICAqXG4gICAgICogQHNpbmNlIDMuMTUuMFxuICAgICAqL1xuICAgIHZhciBDb21wbGV0aW9uSXRlbVRhZztcbiAgICAoZnVuY3Rpb24gKENvbXBsZXRpb25JdGVtVGFnKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW5kZXIgYSBjb21wbGV0aW9uIGFzIG9ic29sZXRlLCB1c3VhbGx5IHVzaW5nIGEgc3RyaWtlLW91dC5cbiAgICAgICAgICovXG4gICAgICAgIENvbXBsZXRpb25JdGVtVGFnLkRlcHJlY2F0ZWQgPSAxO1xuICAgIH0pKENvbXBsZXRpb25JdGVtVGFnIHx8IChleHBvcnRzLkNvbXBsZXRpb25JdGVtVGFnID0gQ29tcGxldGlvbkl0ZW1UYWcgPSB7fSkpO1xuICAgIC8qKlxuICAgICAqIFRoZSBJbnNlcnRSZXBsYWNlRWRpdCBuYW1lc3BhY2UgcHJvdmlkZXMgZnVuY3Rpb25zIHRvIGRlYWwgd2l0aCBpbnNlcnQgLyByZXBsYWNlIGVkaXRzLlxuICAgICAqXG4gICAgICogQHNpbmNlIDMuMTYuMFxuICAgICAqL1xuICAgIHZhciBJbnNlcnRSZXBsYWNlRWRpdDtcbiAgICAoZnVuY3Rpb24gKEluc2VydFJlcGxhY2VFZGl0KSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IGluc2VydCAvIHJlcGxhY2UgZWRpdFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlKG5ld1RleHQsIGluc2VydCwgcmVwbGFjZSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgbmV3VGV4dDogbmV3VGV4dCwgaW5zZXJ0OiBpbnNlcnQsIHJlcGxhY2U6IHJlcGxhY2UgfTtcbiAgICAgICAgfVxuICAgICAgICBJbnNlcnRSZXBsYWNlRWRpdC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIEluc2VydFJlcGxhY2VFZGl0fSBpbnRlcmZhY2UuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLm5ld1RleHQpICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5pbnNlcnQpICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5yZXBsYWNlKTtcbiAgICAgICAgfVxuICAgICAgICBJbnNlcnRSZXBsYWNlRWRpdC5pcyA9IGlzO1xuICAgIH0pKEluc2VydFJlcGxhY2VFZGl0IHx8IChleHBvcnRzLkluc2VydFJlcGxhY2VFZGl0ID0gSW5zZXJ0UmVwbGFjZUVkaXQgPSB7fSkpO1xuICAgIC8qKlxuICAgICAqIEhvdyB3aGl0ZXNwYWNlIGFuZCBpbmRlbnRhdGlvbiBpcyBoYW5kbGVkIGR1cmluZyBjb21wbGV0aW9uXG4gICAgICogaXRlbSBpbnNlcnRpb24uXG4gICAgICpcbiAgICAgKiBAc2luY2UgMy4xNi4wXG4gICAgICovXG4gICAgdmFyIEluc2VydFRleHRNb2RlO1xuICAgIChmdW5jdGlvbiAoSW5zZXJ0VGV4dE1vZGUpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBpbnNlcnRpb24gb3IgcmVwbGFjZSBzdHJpbmdzIGlzIHRha2VuIGFzIGl0IGlzLiBJZiB0aGVcbiAgICAgICAgICogdmFsdWUgaXMgbXVsdGkgbGluZSB0aGUgbGluZXMgYmVsb3cgdGhlIGN1cnNvciB3aWxsIGJlXG4gICAgICAgICAqIGluc2VydGVkIHVzaW5nIHRoZSBpbmRlbnRhdGlvbiBkZWZpbmVkIGluIHRoZSBzdHJpbmcgdmFsdWUuXG4gICAgICAgICAqIFRoZSBjbGllbnQgd2lsbCBub3QgYXBwbHkgYW55IGtpbmQgb2YgYWRqdXN0bWVudHMgdG8gdGhlXG4gICAgICAgICAqIHN0cmluZy5cbiAgICAgICAgICovXG4gICAgICAgIEluc2VydFRleHRNb2RlLmFzSXMgPSAxO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGVkaXRvciBhZGp1c3RzIGxlYWRpbmcgd2hpdGVzcGFjZSBvZiBuZXcgbGluZXMgc28gdGhhdFxuICAgICAgICAgKiB0aGV5IG1hdGNoIHRoZSBpbmRlbnRhdGlvbiB1cCB0byB0aGUgY3Vyc29yIG9mIHRoZSBsaW5lIGZvclxuICAgICAgICAgKiB3aGljaCB0aGUgaXRlbSBpcyBhY2NlcHRlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQ29uc2lkZXIgYSBsaW5lIGxpa2UgdGhpczogPDJ0YWJzPjxjdXJzb3I+PDN0YWJzPmZvby4gQWNjZXB0aW5nIGFcbiAgICAgICAgICogbXVsdGkgbGluZSBjb21wbGV0aW9uIGl0ZW0gaXMgaW5kZW50ZWQgdXNpbmcgMiB0YWJzIGFuZCBhbGxcbiAgICAgICAgICogZm9sbG93aW5nIGxpbmVzIGluc2VydGVkIHdpbGwgYmUgaW5kZW50ZWQgdXNpbmcgMiB0YWJzIGFzIHdlbGwuXG4gICAgICAgICAqL1xuICAgICAgICBJbnNlcnRUZXh0TW9kZS5hZGp1c3RJbmRlbnRhdGlvbiA9IDI7XG4gICAgfSkoSW5zZXJ0VGV4dE1vZGUgfHwgKGV4cG9ydHMuSW5zZXJ0VGV4dE1vZGUgPSBJbnNlcnRUZXh0TW9kZSA9IHt9KSk7XG4gICAgdmFyIENvbXBsZXRpb25JdGVtTGFiZWxEZXRhaWxzO1xuICAgIChmdW5jdGlvbiAoQ29tcGxldGlvbkl0ZW1MYWJlbERldGFpbHMpIHtcbiAgICAgICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgKElzLnN0cmluZyhjYW5kaWRhdGUuZGV0YWlsKSB8fCBjYW5kaWRhdGUuZGV0YWlsID09PSB1bmRlZmluZWQpICYmXG4gICAgICAgICAgICAgICAgKElzLnN0cmluZyhjYW5kaWRhdGUuZGVzY3JpcHRpb24pIHx8IGNhbmRpZGF0ZS5kZXNjcmlwdGlvbiA9PT0gdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBDb21wbGV0aW9uSXRlbUxhYmVsRGV0YWlscy5pcyA9IGlzO1xuICAgIH0pKENvbXBsZXRpb25JdGVtTGFiZWxEZXRhaWxzIHx8IChleHBvcnRzLkNvbXBsZXRpb25JdGVtTGFiZWxEZXRhaWxzID0gQ29tcGxldGlvbkl0ZW1MYWJlbERldGFpbHMgPSB7fSkpO1xuICAgIC8qKlxuICAgICAqIFRoZSBDb21wbGV0aW9uSXRlbSBuYW1lc3BhY2UgcHJvdmlkZXMgZnVuY3Rpb25zIHRvIGRlYWwgd2l0aFxuICAgICAqIGNvbXBsZXRpb24gaXRlbXMuXG4gICAgICovXG4gICAgdmFyIENvbXBsZXRpb25JdGVtO1xuICAgIChmdW5jdGlvbiAoQ29tcGxldGlvbkl0ZW0pIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIGNvbXBsZXRpb24gaXRlbSBhbmQgc2VlZCBpdCB3aXRoIGEgbGFiZWwuXG4gICAgICAgICAqIEBwYXJhbSBsYWJlbCBUaGUgY29tcGxldGlvbiBpdGVtJ3MgbGFiZWxcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZShsYWJlbCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgbGFiZWw6IGxhYmVsIH07XG4gICAgICAgIH1cbiAgICAgICAgQ29tcGxldGlvbkl0ZW0uY3JlYXRlID0gY3JlYXRlO1xuICAgIH0pKENvbXBsZXRpb25JdGVtIHx8IChleHBvcnRzLkNvbXBsZXRpb25JdGVtID0gQ29tcGxldGlvbkl0ZW0gPSB7fSkpO1xuICAgIC8qKlxuICAgICAqIFRoZSBDb21wbGV0aW9uTGlzdCBuYW1lc3BhY2UgcHJvdmlkZXMgZnVuY3Rpb25zIHRvIGRlYWwgd2l0aFxuICAgICAqIGNvbXBsZXRpb24gbGlzdHMuXG4gICAgICovXG4gICAgdmFyIENvbXBsZXRpb25MaXN0O1xuICAgIChmdW5jdGlvbiAoQ29tcGxldGlvbkxpc3QpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgY29tcGxldGlvbiBsaXN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gaXRlbXMgVGhlIGNvbXBsZXRpb24gaXRlbXMuXG4gICAgICAgICAqIEBwYXJhbSBpc0luY29tcGxldGUgVGhlIGxpc3QgaXMgbm90IGNvbXBsZXRlLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlKGl0ZW1zLCBpc0luY29tcGxldGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGl0ZW1zOiBpdGVtcyA/IGl0ZW1zIDogW10sIGlzSW5jb21wbGV0ZTogISFpc0luY29tcGxldGUgfTtcbiAgICAgICAgfVxuICAgICAgICBDb21wbGV0aW9uTGlzdC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgfSkoQ29tcGxldGlvbkxpc3QgfHwgKGV4cG9ydHMuQ29tcGxldGlvbkxpc3QgPSBDb21wbGV0aW9uTGlzdCA9IHt9KSk7XG4gICAgdmFyIE1hcmtlZFN0cmluZztcbiAgICAoZnVuY3Rpb24gKE1hcmtlZFN0cmluZykge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIG1hcmtlZCBzdHJpbmcgZnJvbSBwbGFpbiB0ZXh0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcGxhaW5UZXh0IFRoZSBwbGFpbiB0ZXh0LlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gZnJvbVBsYWluVGV4dChwbGFpblRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBwbGFpblRleHQucmVwbGFjZSgvW1xcXFxgKl97fVtcXF0oKSMrXFwtLiFdL2csICdcXFxcJCYnKTsgLy8gZXNjYXBlIG1hcmtkb3duIHN5bnRheCB0b2tlbnM6IGh0dHA6Ly9kYXJpbmdmaXJlYmFsbC5uZXQvcHJvamVjdHMvbWFya2Rvd24vc3ludGF4I2JhY2tzbGFzaFxuICAgICAgICB9XG4gICAgICAgIE1hcmtlZFN0cmluZy5mcm9tUGxhaW5UZXh0ID0gZnJvbVBsYWluVGV4dDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBjb25mb3JtcyB0byB0aGUge0BsaW5rIE1hcmtlZFN0cmluZ30gdHlwZS5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gSXMuc3RyaW5nKGNhbmRpZGF0ZSkgfHwgKElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLmxhbmd1YWdlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgTWFya2VkU3RyaW5nLmlzID0gaXM7XG4gICAgfSkoTWFya2VkU3RyaW5nIHx8IChleHBvcnRzLk1hcmtlZFN0cmluZyA9IE1hcmtlZFN0cmluZyA9IHt9KSk7XG4gICAgdmFyIEhvdmVyO1xuICAgIChmdW5jdGlvbiAoSG92ZXIpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBjb25mb3JtcyB0byB0aGUge0BsaW5rIEhvdmVyfSBpbnRlcmZhY2UuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuICEhY2FuZGlkYXRlICYmIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiAoTWFya3VwQ29udGVudC5pcyhjYW5kaWRhdGUuY29udGVudHMpIHx8XG4gICAgICAgICAgICAgICAgTWFya2VkU3RyaW5nLmlzKGNhbmRpZGF0ZS5jb250ZW50cykgfHxcbiAgICAgICAgICAgICAgICBJcy50eXBlZEFycmF5KGNhbmRpZGF0ZS5jb250ZW50cywgTWFya2VkU3RyaW5nLmlzKSkgJiYgKHZhbHVlLnJhbmdlID09PSB1bmRlZmluZWQgfHwgUmFuZ2UuaXModmFsdWUucmFuZ2UpKTtcbiAgICAgICAgfVxuICAgICAgICBIb3Zlci5pcyA9IGlzO1xuICAgIH0pKEhvdmVyIHx8IChleHBvcnRzLkhvdmVyID0gSG92ZXIgPSB7fSkpO1xuICAgIC8qKlxuICAgICAqIFRoZSBQYXJhbWV0ZXJJbmZvcm1hdGlvbiBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAgICAgKiB7QGxpbmsgUGFyYW1ldGVySW5mb3JtYXRpb259IGxpdGVyYWxzLlxuICAgICAqL1xuICAgIHZhciBQYXJhbWV0ZXJJbmZvcm1hdGlvbjtcbiAgICAoZnVuY3Rpb24gKFBhcmFtZXRlckluZm9ybWF0aW9uKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IHBhcmFtZXRlciBpbmZvcm1hdGlvbiBsaXRlcmFsLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbGFiZWwgQSBsYWJlbCBzdHJpbmcuXG4gICAgICAgICAqIEBwYXJhbSBkb2N1bWVudGF0aW9uIEEgZG9jIHN0cmluZy5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZShsYWJlbCwgZG9jdW1lbnRhdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50YXRpb24gPyB7IGxhYmVsOiBsYWJlbCwgZG9jdW1lbnRhdGlvbjogZG9jdW1lbnRhdGlvbiB9IDogeyBsYWJlbDogbGFiZWwgfTtcbiAgICAgICAgfVxuICAgICAgICBQYXJhbWV0ZXJJbmZvcm1hdGlvbi5jcmVhdGUgPSBjcmVhdGU7XG4gICAgfSkoUGFyYW1ldGVySW5mb3JtYXRpb24gfHwgKGV4cG9ydHMuUGFyYW1ldGVySW5mb3JtYXRpb24gPSBQYXJhbWV0ZXJJbmZvcm1hdGlvbiA9IHt9KSk7XG4gICAgLyoqXG4gICAgICogVGhlIFNpZ25hdHVyZUluZm9ybWF0aW9uIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICAgICAqIHtAbGluayBTaWduYXR1cmVJbmZvcm1hdGlvbn0gbGl0ZXJhbHMuXG4gICAgICovXG4gICAgdmFyIFNpZ25hdHVyZUluZm9ybWF0aW9uO1xuICAgIChmdW5jdGlvbiAoU2lnbmF0dXJlSW5mb3JtYXRpb24pIHtcbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlKGxhYmVsLCBkb2N1bWVudGF0aW9uKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1ldGVycyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAyOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzW19pIC0gMl0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHsgbGFiZWw6IGxhYmVsIH07XG4gICAgICAgICAgICBpZiAoSXMuZGVmaW5lZChkb2N1bWVudGF0aW9uKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5kb2N1bWVudGF0aW9uID0gZG9jdW1lbnRhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChJcy5kZWZpbmVkKHBhcmFtZXRlcnMpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnBhcmFtZXRlcnMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgU2lnbmF0dXJlSW5mb3JtYXRpb24uY3JlYXRlID0gY3JlYXRlO1xuICAgIH0pKFNpZ25hdHVyZUluZm9ybWF0aW9uIHx8IChleHBvcnRzLlNpZ25hdHVyZUluZm9ybWF0aW9uID0gU2lnbmF0dXJlSW5mb3JtYXRpb24gPSB7fSkpO1xuICAgIC8qKlxuICAgICAqIEEgZG9jdW1lbnQgaGlnaGxpZ2h0IGtpbmQuXG4gICAgICovXG4gICAgdmFyIERvY3VtZW50SGlnaGxpZ2h0S2luZDtcbiAgICAoZnVuY3Rpb24gKERvY3VtZW50SGlnaGxpZ2h0S2luZCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQSB0ZXh0dWFsIG9jY3VycmVuY2UuXG4gICAgICAgICAqL1xuICAgICAgICBEb2N1bWVudEhpZ2hsaWdodEtpbmQuVGV4dCA9IDE7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWFkLWFjY2VzcyBvZiBhIHN5bWJvbCwgbGlrZSByZWFkaW5nIGEgdmFyaWFibGUuXG4gICAgICAgICAqL1xuICAgICAgICBEb2N1bWVudEhpZ2hsaWdodEtpbmQuUmVhZCA9IDI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXcml0ZS1hY2Nlc3Mgb2YgYSBzeW1ib2wsIGxpa2Ugd3JpdGluZyB0byBhIHZhcmlhYmxlLlxuICAgICAgICAgKi9cbiAgICAgICAgRG9jdW1lbnRIaWdobGlnaHRLaW5kLldyaXRlID0gMztcbiAgICB9KShEb2N1bWVudEhpZ2hsaWdodEtpbmQgfHwgKGV4cG9ydHMuRG9jdW1lbnRIaWdobGlnaHRLaW5kID0gRG9jdW1lbnRIaWdobGlnaHRLaW5kID0ge30pKTtcbiAgICAvKipcbiAgICAgKiBEb2N1bWVudEhpZ2hsaWdodCBuYW1lc3BhY2UgdG8gcHJvdmlkZSBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICAgICAqIHtAbGluayBEb2N1bWVudEhpZ2hsaWdodH0gbGl0ZXJhbHMuXG4gICAgICovXG4gICAgdmFyIERvY3VtZW50SGlnaGxpZ2h0O1xuICAgIChmdW5jdGlvbiAoRG9jdW1lbnRIaWdobGlnaHQpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIERvY3VtZW50SGlnaGxpZ2h0IG9iamVjdC5cbiAgICAgICAgICogQHBhcmFtIHJhbmdlIFRoZSByYW5nZSB0aGUgaGlnaGxpZ2h0IGFwcGxpZXMgdG8uXG4gICAgICAgICAqIEBwYXJhbSBraW5kIFRoZSBoaWdobGlnaHQga2luZFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlKHJhbmdlLCBraW5kKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0geyByYW5nZTogcmFuZ2UgfTtcbiAgICAgICAgICAgIGlmIChJcy5udW1iZXIoa2luZCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQua2luZCA9IGtpbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIERvY3VtZW50SGlnaGxpZ2h0LmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICB9KShEb2N1bWVudEhpZ2hsaWdodCB8fCAoZXhwb3J0cy5Eb2N1bWVudEhpZ2hsaWdodCA9IERvY3VtZW50SGlnaGxpZ2h0ID0ge30pKTtcbiAgICAvKipcbiAgICAgKiBBIHN5bWJvbCBraW5kLlxuICAgICAqL1xuICAgIHZhciBTeW1ib2xLaW5kO1xuICAgIChmdW5jdGlvbiAoU3ltYm9sS2luZCkge1xuICAgICAgICBTeW1ib2xLaW5kLkZpbGUgPSAxO1xuICAgICAgICBTeW1ib2xLaW5kLk1vZHVsZSA9IDI7XG4gICAgICAgIFN5bWJvbEtpbmQuTmFtZXNwYWNlID0gMztcbiAgICAgICAgU3ltYm9sS2luZC5QYWNrYWdlID0gNDtcbiAgICAgICAgU3ltYm9sS2luZC5DbGFzcyA9IDU7XG4gICAgICAgIFN5bWJvbEtpbmQuTWV0aG9kID0gNjtcbiAgICAgICAgU3ltYm9sS2luZC5Qcm9wZXJ0eSA9IDc7XG4gICAgICAgIFN5bWJvbEtpbmQuRmllbGQgPSA4O1xuICAgICAgICBTeW1ib2xLaW5kLkNvbnN0cnVjdG9yID0gOTtcbiAgICAgICAgU3ltYm9sS2luZC5FbnVtID0gMTA7XG4gICAgICAgIFN5bWJvbEtpbmQuSW50ZXJmYWNlID0gMTE7XG4gICAgICAgIFN5bWJvbEtpbmQuRnVuY3Rpb24gPSAxMjtcbiAgICAgICAgU3ltYm9sS2luZC5WYXJpYWJsZSA9IDEzO1xuICAgICAgICBTeW1ib2xLaW5kLkNvbnN0YW50ID0gMTQ7XG4gICAgICAgIFN5bWJvbEtpbmQuU3RyaW5nID0gMTU7XG4gICAgICAgIFN5bWJvbEtpbmQuTnVtYmVyID0gMTY7XG4gICAgICAgIFN5bWJvbEtpbmQuQm9vbGVhbiA9IDE3O1xuICAgICAgICBTeW1ib2xLaW5kLkFycmF5ID0gMTg7XG4gICAgICAgIFN5bWJvbEtpbmQuT2JqZWN0ID0gMTk7XG4gICAgICAgIFN5bWJvbEtpbmQuS2V5ID0gMjA7XG4gICAgICAgIFN5bWJvbEtpbmQuTnVsbCA9IDIxO1xuICAgICAgICBTeW1ib2xLaW5kLkVudW1NZW1iZXIgPSAyMjtcbiAgICAgICAgU3ltYm9sS2luZC5TdHJ1Y3QgPSAyMztcbiAgICAgICAgU3ltYm9sS2luZC5FdmVudCA9IDI0O1xuICAgICAgICBTeW1ib2xLaW5kLk9wZXJhdG9yID0gMjU7XG4gICAgICAgIFN5bWJvbEtpbmQuVHlwZVBhcmFtZXRlciA9IDI2O1xuICAgIH0pKFN5bWJvbEtpbmQgfHwgKGV4cG9ydHMuU3ltYm9sS2luZCA9IFN5bWJvbEtpbmQgPSB7fSkpO1xuICAgIC8qKlxuICAgICAqIFN5bWJvbCB0YWdzIGFyZSBleHRyYSBhbm5vdGF0aW9ucyB0aGF0IHR3ZWFrIHRoZSByZW5kZXJpbmcgb2YgYSBzeW1ib2wuXG4gICAgICpcbiAgICAgKiBAc2luY2UgMy4xNlxuICAgICAqL1xuICAgIHZhciBTeW1ib2xUYWc7XG4gICAgKGZ1bmN0aW9uIChTeW1ib2xUYWcpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbmRlciBhIHN5bWJvbCBhcyBvYnNvbGV0ZSwgdXN1YWxseSB1c2luZyBhIHN0cmlrZS1vdXQuXG4gICAgICAgICAqL1xuICAgICAgICBTeW1ib2xUYWcuRGVwcmVjYXRlZCA9IDE7XG4gICAgfSkoU3ltYm9sVGFnIHx8IChleHBvcnRzLlN5bWJvbFRhZyA9IFN5bWJvbFRhZyA9IHt9KSk7XG4gICAgdmFyIFN5bWJvbEluZm9ybWF0aW9uO1xuICAgIChmdW5jdGlvbiAoU3ltYm9sSW5mb3JtYXRpb24pIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgc3ltYm9sIGluZm9ybWF0aW9uIGxpdGVyYWwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBzeW1ib2wuXG4gICAgICAgICAqIEBwYXJhbSBraW5kIFRoZSBraW5kIG9mIHRoZSBzeW1ib2wuXG4gICAgICAgICAqIEBwYXJhbSByYW5nZSBUaGUgcmFuZ2Ugb2YgdGhlIGxvY2F0aW9uIG9mIHRoZSBzeW1ib2wuXG4gICAgICAgICAqIEBwYXJhbSB1cmkgVGhlIHJlc291cmNlIG9mIHRoZSBsb2NhdGlvbiBvZiBzeW1ib2wuXG4gICAgICAgICAqIEBwYXJhbSBjb250YWluZXJOYW1lIFRoZSBuYW1lIG9mIHRoZSBzeW1ib2wgY29udGFpbmluZyB0aGUgc3ltYm9sLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlKG5hbWUsIGtpbmQsIHJhbmdlLCB1cmksIGNvbnRhaW5lck5hbWUpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICBraW5kOiBraW5kLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB7IHVyaTogdXJpLCByYW5nZTogcmFuZ2UgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChjb250YWluZXJOYW1lKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmNvbnRhaW5lck5hbWUgPSBjb250YWluZXJOYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBTeW1ib2xJbmZvcm1hdGlvbi5jcmVhdGUgPSBjcmVhdGU7XG4gICAgfSkoU3ltYm9sSW5mb3JtYXRpb24gfHwgKGV4cG9ydHMuU3ltYm9sSW5mb3JtYXRpb24gPSBTeW1ib2xJbmZvcm1hdGlvbiA9IHt9KSk7XG4gICAgdmFyIFdvcmtzcGFjZVN5bWJvbDtcbiAgICAoZnVuY3Rpb24gKFdvcmtzcGFjZVN5bWJvbCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgbmV3IHdvcmtzcGFjZSBzeW1ib2wuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBzeW1ib2wuXG4gICAgICAgICAqIEBwYXJhbSBraW5kIFRoZSBraW5kIG9mIHRoZSBzeW1ib2wuXG4gICAgICAgICAqIEBwYXJhbSB1cmkgVGhlIHJlc291cmNlIG9mIHRoZSBsb2NhdGlvbiBvZiB0aGUgc3ltYm9sLlxuICAgICAgICAgKiBAcGFyYW0gcmFuZ2UgQW4gb3B0aW9ucyByYW5nZSBvZiB0aGUgbG9jYXRpb24uXG4gICAgICAgICAqIEByZXR1cm5zIEEgV29ya3NwYWNlU3ltYm9sLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlKG5hbWUsIGtpbmQsIHVyaSwgcmFuZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiByYW5nZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyB7IG5hbWU6IG5hbWUsIGtpbmQ6IGtpbmQsIGxvY2F0aW9uOiB7IHVyaTogdXJpLCByYW5nZTogcmFuZ2UgfSB9XG4gICAgICAgICAgICAgICAgOiB7IG5hbWU6IG5hbWUsIGtpbmQ6IGtpbmQsIGxvY2F0aW9uOiB7IHVyaTogdXJpIH0gfTtcbiAgICAgICAgfVxuICAgICAgICBXb3Jrc3BhY2VTeW1ib2wuY3JlYXRlID0gY3JlYXRlO1xuICAgIH0pKFdvcmtzcGFjZVN5bWJvbCB8fCAoZXhwb3J0cy5Xb3Jrc3BhY2VTeW1ib2wgPSBXb3Jrc3BhY2VTeW1ib2wgPSB7fSkpO1xuICAgIHZhciBEb2N1bWVudFN5bWJvbDtcbiAgICAoZnVuY3Rpb24gKERvY3VtZW50U3ltYm9sKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IHN5bWJvbCBpbmZvcm1hdGlvbiBsaXRlcmFsLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgc3ltYm9sLlxuICAgICAgICAgKiBAcGFyYW0gZGV0YWlsIFRoZSBkZXRhaWwgb2YgdGhlIHN5bWJvbC5cbiAgICAgICAgICogQHBhcmFtIGtpbmQgVGhlIGtpbmQgb2YgdGhlIHN5bWJvbC5cbiAgICAgICAgICogQHBhcmFtIHJhbmdlIFRoZSByYW5nZSBvZiB0aGUgc3ltYm9sLlxuICAgICAgICAgKiBAcGFyYW0gc2VsZWN0aW9uUmFuZ2UgVGhlIHNlbGVjdGlvblJhbmdlIG9mIHRoZSBzeW1ib2wuXG4gICAgICAgICAqIEBwYXJhbSBjaGlsZHJlbiBDaGlsZHJlbiBvZiB0aGUgc3ltYm9sLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlKG5hbWUsIGRldGFpbCwga2luZCwgcmFuZ2UsIHNlbGVjdGlvblJhbmdlLCBjaGlsZHJlbikge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgIGRldGFpbDogZGV0YWlsLFxuICAgICAgICAgICAgICAgIGtpbmQ6IGtpbmQsXG4gICAgICAgICAgICAgICAgcmFuZ2U6IHJhbmdlLFxuICAgICAgICAgICAgICAgIHNlbGVjdGlvblJhbmdlOiBzZWxlY3Rpb25SYW5nZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIERvY3VtZW50U3ltYm9sLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgRG9jdW1lbnRTeW1ib2x9IGludGVyZmFjZS5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmXG4gICAgICAgICAgICAgICAgSXMuc3RyaW5nKGNhbmRpZGF0ZS5uYW1lKSAmJiBJcy5udW1iZXIoY2FuZGlkYXRlLmtpbmQpICYmXG4gICAgICAgICAgICAgICAgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKSAmJiBSYW5nZS5pcyhjYW5kaWRhdGUuc2VsZWN0aW9uUmFuZ2UpICYmXG4gICAgICAgICAgICAgICAgKGNhbmRpZGF0ZS5kZXRhaWwgPT09IHVuZGVmaW5lZCB8fCBJcy5zdHJpbmcoY2FuZGlkYXRlLmRldGFpbCkpICYmXG4gICAgICAgICAgICAgICAgKGNhbmRpZGF0ZS5kZXByZWNhdGVkID09PSB1bmRlZmluZWQgfHwgSXMuYm9vbGVhbihjYW5kaWRhdGUuZGVwcmVjYXRlZCkpICYmXG4gICAgICAgICAgICAgICAgKGNhbmRpZGF0ZS5jaGlsZHJlbiA9PT0gdW5kZWZpbmVkIHx8IEFycmF5LmlzQXJyYXkoY2FuZGlkYXRlLmNoaWxkcmVuKSkgJiZcbiAgICAgICAgICAgICAgICAoY2FuZGlkYXRlLnRhZ3MgPT09IHVuZGVmaW5lZCB8fCBBcnJheS5pc0FycmF5KGNhbmRpZGF0ZS50YWdzKSk7XG4gICAgICAgIH1cbiAgICAgICAgRG9jdW1lbnRTeW1ib2wuaXMgPSBpcztcbiAgICB9KShEb2N1bWVudFN5bWJvbCB8fCAoZXhwb3J0cy5Eb2N1bWVudFN5bWJvbCA9IERvY3VtZW50U3ltYm9sID0ge30pKTtcbiAgICAvKipcbiAgICAgKiBBIHNldCBvZiBwcmVkZWZpbmVkIGNvZGUgYWN0aW9uIGtpbmRzXG4gICAgICovXG4gICAgdmFyIENvZGVBY3Rpb25LaW5kO1xuICAgIChmdW5jdGlvbiAoQ29kZUFjdGlvbktpbmQpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVtcHR5IGtpbmQuXG4gICAgICAgICAqL1xuICAgICAgICBDb2RlQWN0aW9uS2luZC5FbXB0eSA9ICcnO1xuICAgICAgICAvKipcbiAgICAgICAgICogQmFzZSBraW5kIGZvciBxdWlja2ZpeCBhY3Rpb25zOiAncXVpY2tmaXgnXG4gICAgICAgICAqL1xuICAgICAgICBDb2RlQWN0aW9uS2luZC5RdWlja0ZpeCA9ICdxdWlja2ZpeCc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCYXNlIGtpbmQgZm9yIHJlZmFjdG9yaW5nIGFjdGlvbnM6ICdyZWZhY3RvcidcbiAgICAgICAgICovXG4gICAgICAgIENvZGVBY3Rpb25LaW5kLlJlZmFjdG9yID0gJ3JlZmFjdG9yJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJhc2Uga2luZCBmb3IgcmVmYWN0b3JpbmcgZXh0cmFjdGlvbiBhY3Rpb25zOiAncmVmYWN0b3IuZXh0cmFjdCdcbiAgICAgICAgICpcbiAgICAgICAgICogRXhhbXBsZSBleHRyYWN0IGFjdGlvbnM6XG4gICAgICAgICAqXG4gICAgICAgICAqIC0gRXh0cmFjdCBtZXRob2RcbiAgICAgICAgICogLSBFeHRyYWN0IGZ1bmN0aW9uXG4gICAgICAgICAqIC0gRXh0cmFjdCB2YXJpYWJsZVxuICAgICAgICAgKiAtIEV4dHJhY3QgaW50ZXJmYWNlIGZyb20gY2xhc3NcbiAgICAgICAgICogLSAuLi5cbiAgICAgICAgICovXG4gICAgICAgIENvZGVBY3Rpb25LaW5kLlJlZmFjdG9yRXh0cmFjdCA9ICdyZWZhY3Rvci5leHRyYWN0JztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJhc2Uga2luZCBmb3IgcmVmYWN0b3JpbmcgaW5saW5lIGFjdGlvbnM6ICdyZWZhY3Rvci5pbmxpbmUnXG4gICAgICAgICAqXG4gICAgICAgICAqIEV4YW1wbGUgaW5saW5lIGFjdGlvbnM6XG4gICAgICAgICAqXG4gICAgICAgICAqIC0gSW5saW5lIGZ1bmN0aW9uXG4gICAgICAgICAqIC0gSW5saW5lIHZhcmlhYmxlXG4gICAgICAgICAqIC0gSW5saW5lIGNvbnN0YW50XG4gICAgICAgICAqIC0gLi4uXG4gICAgICAgICAqL1xuICAgICAgICBDb2RlQWN0aW9uS2luZC5SZWZhY3RvcklubGluZSA9ICdyZWZhY3Rvci5pbmxpbmUnO1xuICAgICAgICAvKipcbiAgICAgICAgICogQmFzZSBraW5kIGZvciByZWZhY3RvcmluZyByZXdyaXRlIGFjdGlvbnM6ICdyZWZhY3Rvci5yZXdyaXRlJ1xuICAgICAgICAgKlxuICAgICAgICAgKiBFeGFtcGxlIHJld3JpdGUgYWN0aW9uczpcbiAgICAgICAgICpcbiAgICAgICAgICogLSBDb252ZXJ0IEphdmFTY3JpcHQgZnVuY3Rpb24gdG8gY2xhc3NcbiAgICAgICAgICogLSBBZGQgb3IgcmVtb3ZlIHBhcmFtZXRlclxuICAgICAgICAgKiAtIEVuY2Fwc3VsYXRlIGZpZWxkXG4gICAgICAgICAqIC0gTWFrZSBtZXRob2Qgc3RhdGljXG4gICAgICAgICAqIC0gTW92ZSBtZXRob2QgdG8gYmFzZSBjbGFzc1xuICAgICAgICAgKiAtIC4uLlxuICAgICAgICAgKi9cbiAgICAgICAgQ29kZUFjdGlvbktpbmQuUmVmYWN0b3JSZXdyaXRlID0gJ3JlZmFjdG9yLnJld3JpdGUnO1xuICAgICAgICAvKipcbiAgICAgICAgICogQmFzZSBraW5kIGZvciBzb3VyY2UgYWN0aW9uczogYHNvdXJjZWBcbiAgICAgICAgICpcbiAgICAgICAgICogU291cmNlIGNvZGUgYWN0aW9ucyBhcHBseSB0byB0aGUgZW50aXJlIGZpbGUuXG4gICAgICAgICAqL1xuICAgICAgICBDb2RlQWN0aW9uS2luZC5Tb3VyY2UgPSAnc291cmNlJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJhc2Uga2luZCBmb3IgYW4gb3JnYW5pemUgaW1wb3J0cyBzb3VyY2UgYWN0aW9uOiBgc291cmNlLm9yZ2FuaXplSW1wb3J0c2BcbiAgICAgICAgICovXG4gICAgICAgIENvZGVBY3Rpb25LaW5kLlNvdXJjZU9yZ2FuaXplSW1wb3J0cyA9ICdzb3VyY2Uub3JnYW5pemVJbXBvcnRzJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJhc2Uga2luZCBmb3IgYXV0by1maXggc291cmNlIGFjdGlvbnM6IGBzb3VyY2UuZml4QWxsYC5cbiAgICAgICAgICpcbiAgICAgICAgICogRml4IGFsbCBhY3Rpb25zIGF1dG9tYXRpY2FsbHkgZml4IGVycm9ycyB0aGF0IGhhdmUgYSBjbGVhciBmaXggdGhhdCBkbyBub3QgcmVxdWlyZSB1c2VyIGlucHV0LlxuICAgICAgICAgKiBUaGV5IHNob3VsZCBub3Qgc3VwcHJlc3MgZXJyb3JzIG9yIHBlcmZvcm0gdW5zYWZlIGZpeGVzIHN1Y2ggYXMgZ2VuZXJhdGluZyBuZXcgdHlwZXMgb3IgY2xhc3Nlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHNpbmNlIDMuMTUuMFxuICAgICAgICAgKi9cbiAgICAgICAgQ29kZUFjdGlvbktpbmQuU291cmNlRml4QWxsID0gJ3NvdXJjZS5maXhBbGwnO1xuICAgIH0pKENvZGVBY3Rpb25LaW5kIHx8IChleHBvcnRzLkNvZGVBY3Rpb25LaW5kID0gQ29kZUFjdGlvbktpbmQgPSB7fSkpO1xuICAgIC8qKlxuICAgICAqIFRoZSByZWFzb24gd2h5IGNvZGUgYWN0aW9ucyB3ZXJlIHJlcXVlc3RlZC5cbiAgICAgKlxuICAgICAqIEBzaW5jZSAzLjE3LjBcbiAgICAgKi9cbiAgICB2YXIgQ29kZUFjdGlvblRyaWdnZXJLaW5kO1xuICAgIChmdW5jdGlvbiAoQ29kZUFjdGlvblRyaWdnZXJLaW5kKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb2RlIGFjdGlvbnMgd2VyZSBleHBsaWNpdGx5IHJlcXVlc3RlZCBieSB0aGUgdXNlciBvciBieSBhbiBleHRlbnNpb24uXG4gICAgICAgICAqL1xuICAgICAgICBDb2RlQWN0aW9uVHJpZ2dlcktpbmQuSW52b2tlZCA9IDE7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb2RlIGFjdGlvbnMgd2VyZSByZXF1ZXN0ZWQgYXV0b21hdGljYWxseS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyB0eXBpY2FsbHkgaGFwcGVucyB3aGVuIGN1cnJlbnQgc2VsZWN0aW9uIGluIGEgZmlsZSBjaGFuZ2VzLCBidXQgY2FuXG4gICAgICAgICAqIGFsc28gYmUgdHJpZ2dlcmVkIHdoZW4gZmlsZSBjb250ZW50IGNoYW5nZXMuXG4gICAgICAgICAqL1xuICAgICAgICBDb2RlQWN0aW9uVHJpZ2dlcktpbmQuQXV0b21hdGljID0gMjtcbiAgICB9KShDb2RlQWN0aW9uVHJpZ2dlcktpbmQgfHwgKGV4cG9ydHMuQ29kZUFjdGlvblRyaWdnZXJLaW5kID0gQ29kZUFjdGlvblRyaWdnZXJLaW5kID0ge30pKTtcbiAgICAvKipcbiAgICAgKiBUaGUgQ29kZUFjdGlvbkNvbnRleHQgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gICAgICoge0BsaW5rIENvZGVBY3Rpb25Db250ZXh0fSBsaXRlcmFscy5cbiAgICAgKi9cbiAgICB2YXIgQ29kZUFjdGlvbkNvbnRleHQ7XG4gICAgKGZ1bmN0aW9uIChDb2RlQWN0aW9uQ29udGV4dCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBDb2RlQWN0aW9uQ29udGV4dCBsaXRlcmFsLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlKGRpYWdub3N0aWNzLCBvbmx5LCB0cmlnZ2VyS2luZCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHsgZGlhZ25vc3RpY3M6IGRpYWdub3N0aWNzIH07XG4gICAgICAgICAgICBpZiAob25seSAhPT0gdW5kZWZpbmVkICYmIG9ubHkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQub25seSA9IG9ubHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHJpZ2dlcktpbmQgIT09IHVuZGVmaW5lZCAmJiB0cmlnZ2VyS2luZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC50cmlnZ2VyS2luZCA9IHRyaWdnZXJLaW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBDb2RlQWN0aW9uQ29udGV4dC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIENvZGVBY3Rpb25Db250ZXh0fSBpbnRlcmZhY2UuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBJcy50eXBlZEFycmF5KGNhbmRpZGF0ZS5kaWFnbm9zdGljcywgRGlhZ25vc3RpYy5pcylcbiAgICAgICAgICAgICAgICAmJiAoY2FuZGlkYXRlLm9ubHkgPT09IHVuZGVmaW5lZCB8fCBJcy50eXBlZEFycmF5KGNhbmRpZGF0ZS5vbmx5LCBJcy5zdHJpbmcpKVxuICAgICAgICAgICAgICAgICYmIChjYW5kaWRhdGUudHJpZ2dlcktpbmQgPT09IHVuZGVmaW5lZCB8fCBjYW5kaWRhdGUudHJpZ2dlcktpbmQgPT09IENvZGVBY3Rpb25UcmlnZ2VyS2luZC5JbnZva2VkIHx8IGNhbmRpZGF0ZS50cmlnZ2VyS2luZCA9PT0gQ29kZUFjdGlvblRyaWdnZXJLaW5kLkF1dG9tYXRpYyk7XG4gICAgICAgIH1cbiAgICAgICAgQ29kZUFjdGlvbkNvbnRleHQuaXMgPSBpcztcbiAgICB9KShDb2RlQWN0aW9uQ29udGV4dCB8fCAoZXhwb3J0cy5Db2RlQWN0aW9uQ29udGV4dCA9IENvZGVBY3Rpb25Db250ZXh0ID0ge30pKTtcbiAgICB2YXIgQ29kZUFjdGlvbjtcbiAgICAoZnVuY3Rpb24gKENvZGVBY3Rpb24pIHtcbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlKHRpdGxlLCBraW5kT3JDb21tYW5kT3JFZGl0LCBraW5kKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0geyB0aXRsZTogdGl0bGUgfTtcbiAgICAgICAgICAgIHZhciBjaGVja0tpbmQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBraW5kT3JDb21tYW5kT3JFZGl0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNoZWNrS2luZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5raW5kID0ga2luZE9yQ29tbWFuZE9yRWRpdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKENvbW1hbmQuaXMoa2luZE9yQ29tbWFuZE9yRWRpdCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuY29tbWFuZCA9IGtpbmRPckNvbW1hbmRPckVkaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuZWRpdCA9IGtpbmRPckNvbW1hbmRPckVkaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hlY2tLaW5kICYmIGtpbmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5raW5kID0ga2luZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgQ29kZUFjdGlvbi5jcmVhdGUgPSBjcmVhdGU7XG4gICAgICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIElzLnN0cmluZyhjYW5kaWRhdGUudGl0bGUpICYmXG4gICAgICAgICAgICAgICAgKGNhbmRpZGF0ZS5kaWFnbm9zdGljcyA9PT0gdW5kZWZpbmVkIHx8IElzLnR5cGVkQXJyYXkoY2FuZGlkYXRlLmRpYWdub3N0aWNzLCBEaWFnbm9zdGljLmlzKSkgJiZcbiAgICAgICAgICAgICAgICAoY2FuZGlkYXRlLmtpbmQgPT09IHVuZGVmaW5lZCB8fCBJcy5zdHJpbmcoY2FuZGlkYXRlLmtpbmQpKSAmJlxuICAgICAgICAgICAgICAgIChjYW5kaWRhdGUuZWRpdCAhPT0gdW5kZWZpbmVkIHx8IGNhbmRpZGF0ZS5jb21tYW5kICE9PSB1bmRlZmluZWQpICYmXG4gICAgICAgICAgICAgICAgKGNhbmRpZGF0ZS5jb21tYW5kID09PSB1bmRlZmluZWQgfHwgQ29tbWFuZC5pcyhjYW5kaWRhdGUuY29tbWFuZCkpICYmXG4gICAgICAgICAgICAgICAgKGNhbmRpZGF0ZS5pc1ByZWZlcnJlZCA9PT0gdW5kZWZpbmVkIHx8IElzLmJvb2xlYW4oY2FuZGlkYXRlLmlzUHJlZmVycmVkKSkgJiZcbiAgICAgICAgICAgICAgICAoY2FuZGlkYXRlLmVkaXQgPT09IHVuZGVmaW5lZCB8fCBXb3Jrc3BhY2VFZGl0LmlzKGNhbmRpZGF0ZS5lZGl0KSk7XG4gICAgICAgIH1cbiAgICAgICAgQ29kZUFjdGlvbi5pcyA9IGlzO1xuICAgIH0pKENvZGVBY3Rpb24gfHwgKGV4cG9ydHMuQ29kZUFjdGlvbiA9IENvZGVBY3Rpb24gPSB7fSkpO1xuICAgIC8qKlxuICAgICAqIFRoZSBDb2RlTGVucyBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAgICAgKiB7QGxpbmsgQ29kZUxlbnN9IGxpdGVyYWxzLlxuICAgICAqL1xuICAgIHZhciBDb2RlTGVucztcbiAgICAoZnVuY3Rpb24gKENvZGVMZW5zKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IENvZGVMZW5zIGxpdGVyYWwuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBjcmVhdGUocmFuZ2UsIGRhdGEpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7IHJhbmdlOiByYW5nZSB9O1xuICAgICAgICAgICAgaWYgKElzLmRlZmluZWQoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuZGF0YSA9IGRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIENvZGVMZW5zLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgQ29kZUxlbnN9IGludGVyZmFjZS5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5yYW5nZSkgJiYgKElzLnVuZGVmaW5lZChjYW5kaWRhdGUuY29tbWFuZCkgfHwgQ29tbWFuZC5pcyhjYW5kaWRhdGUuY29tbWFuZCkpO1xuICAgICAgICB9XG4gICAgICAgIENvZGVMZW5zLmlzID0gaXM7XG4gICAgfSkoQ29kZUxlbnMgfHwgKGV4cG9ydHMuQ29kZUxlbnMgPSBDb2RlTGVucyA9IHt9KSk7XG4gICAgLyoqXG4gICAgICogVGhlIEZvcm1hdHRpbmdPcHRpb25zIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICAgICAqIHtAbGluayBGb3JtYXR0aW5nT3B0aW9uc30gbGl0ZXJhbHMuXG4gICAgICovXG4gICAgdmFyIEZvcm1hdHRpbmdPcHRpb25zO1xuICAgIChmdW5jdGlvbiAoRm9ybWF0dGluZ09wdGlvbnMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgRm9ybWF0dGluZ09wdGlvbnMgbGl0ZXJhbC5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZSh0YWJTaXplLCBpbnNlcnRTcGFjZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHRhYlNpemU6IHRhYlNpemUsIGluc2VydFNwYWNlczogaW5zZXJ0U3BhY2VzIH07XG4gICAgICAgIH1cbiAgICAgICAgRm9ybWF0dGluZ09wdGlvbnMuY3JlYXRlID0gY3JlYXRlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBGb3JtYXR0aW5nT3B0aW9uc30gaW50ZXJmYWNlLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgSXMudWludGVnZXIoY2FuZGlkYXRlLnRhYlNpemUpICYmIElzLmJvb2xlYW4oY2FuZGlkYXRlLmluc2VydFNwYWNlcyk7XG4gICAgICAgIH1cbiAgICAgICAgRm9ybWF0dGluZ09wdGlvbnMuaXMgPSBpcztcbiAgICB9KShGb3JtYXR0aW5nT3B0aW9ucyB8fCAoZXhwb3J0cy5Gb3JtYXR0aW5nT3B0aW9ucyA9IEZvcm1hdHRpbmdPcHRpb25zID0ge30pKTtcbiAgICAvKipcbiAgICAgKiBUaGUgRG9jdW1lbnRMaW5rIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICAgICAqIHtAbGluayBEb2N1bWVudExpbmt9IGxpdGVyYWxzLlxuICAgICAqL1xuICAgIHZhciBEb2N1bWVudExpbms7XG4gICAgKGZ1bmN0aW9uIChEb2N1bWVudExpbmspIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgRG9jdW1lbnRMaW5rIGxpdGVyYWwuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBjcmVhdGUocmFuZ2UsIHRhcmdldCwgZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IHJhbmdlLCB0YXJnZXQ6IHRhcmdldCwgZGF0YTogZGF0YSB9O1xuICAgICAgICB9XG4gICAgICAgIERvY3VtZW50TGluay5jcmVhdGUgPSBjcmVhdGU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIERvY3VtZW50TGlua30gaW50ZXJmYWNlLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKSAmJiAoSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS50YXJnZXQpIHx8IElzLnN0cmluZyhjYW5kaWRhdGUudGFyZ2V0KSk7XG4gICAgICAgIH1cbiAgICAgICAgRG9jdW1lbnRMaW5rLmlzID0gaXM7XG4gICAgfSkoRG9jdW1lbnRMaW5rIHx8IChleHBvcnRzLkRvY3VtZW50TGluayA9IERvY3VtZW50TGluayA9IHt9KSk7XG4gICAgLyoqXG4gICAgICogVGhlIFNlbGVjdGlvblJhbmdlIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb24gdG8gd29yayB3aXRoXG4gICAgICogU2VsZWN0aW9uUmFuZ2UgbGl0ZXJhbHMuXG4gICAgICovXG4gICAgdmFyIFNlbGVjdGlvblJhbmdlO1xuICAgIChmdW5jdGlvbiAoU2VsZWN0aW9uUmFuZ2UpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgU2VsZWN0aW9uUmFuZ2VcbiAgICAgICAgICogQHBhcmFtIHJhbmdlIHRoZSByYW5nZS5cbiAgICAgICAgICogQHBhcmFtIHBhcmVudCBhbiBvcHRpb25hbCBwYXJlbnQuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBjcmVhdGUocmFuZ2UsIHBhcmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IHJhbmdlLCBwYXJlbnQ6IHBhcmVudCB9O1xuICAgICAgICB9XG4gICAgICAgIFNlbGVjdGlvblJhbmdlLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAgICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKSAmJiAoY2FuZGlkYXRlLnBhcmVudCA9PT0gdW5kZWZpbmVkIHx8IFNlbGVjdGlvblJhbmdlLmlzKGNhbmRpZGF0ZS5wYXJlbnQpKTtcbiAgICAgICAgfVxuICAgICAgICBTZWxlY3Rpb25SYW5nZS5pcyA9IGlzO1xuICAgIH0pKFNlbGVjdGlvblJhbmdlIHx8IChleHBvcnRzLlNlbGVjdGlvblJhbmdlID0gU2VsZWN0aW9uUmFuZ2UgPSB7fSkpO1xuICAgIC8qKlxuICAgICAqIEEgc2V0IG9mIHByZWRlZmluZWQgdG9rZW4gdHlwZXMuIFRoaXMgc2V0IGlzIG5vdCBmaXhlZFxuICAgICAqIGFuIGNsaWVudHMgY2FuIHNwZWNpZnkgYWRkaXRpb25hbCB0b2tlbiB0eXBlcyB2aWEgdGhlXG4gICAgICogY29ycmVzcG9uZGluZyBjbGllbnQgY2FwYWJpbGl0aWVzLlxuICAgICAqXG4gICAgICogQHNpbmNlIDMuMTYuMFxuICAgICAqL1xuICAgIHZhciBTZW1hbnRpY1Rva2VuVHlwZXM7XG4gICAgKGZ1bmN0aW9uIChTZW1hbnRpY1Rva2VuVHlwZXMpIHtcbiAgICAgICAgU2VtYW50aWNUb2tlblR5cGVzW1wibmFtZXNwYWNlXCJdID0gXCJuYW1lc3BhY2VcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlcHJlc2VudHMgYSBnZW5lcmljIHR5cGUuIEFjdHMgYXMgYSBmYWxsYmFjayBmb3IgdHlwZXMgd2hpY2ggY2FuJ3QgYmUgbWFwcGVkIHRvXG4gICAgICAgICAqIGEgc3BlY2lmaWMgdHlwZSBsaWtlIGNsYXNzIG9yIGVudW0uXG4gICAgICAgICAqL1xuICAgICAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJ0eXBlXCJdID0gXCJ0eXBlXCI7XG4gICAgICAgIFNlbWFudGljVG9rZW5UeXBlc1tcImNsYXNzXCJdID0gXCJjbGFzc1wiO1xuICAgICAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJlbnVtXCJdID0gXCJlbnVtXCI7XG4gICAgICAgIFNlbWFudGljVG9rZW5UeXBlc1tcImludGVyZmFjZVwiXSA9IFwiaW50ZXJmYWNlXCI7XG4gICAgICAgIFNlbWFudGljVG9rZW5UeXBlc1tcInN0cnVjdFwiXSA9IFwic3RydWN0XCI7XG4gICAgICAgIFNlbWFudGljVG9rZW5UeXBlc1tcInR5cGVQYXJhbWV0ZXJcIl0gPSBcInR5cGVQYXJhbWV0ZXJcIjtcbiAgICAgICAgU2VtYW50aWNUb2tlblR5cGVzW1wicGFyYW1ldGVyXCJdID0gXCJwYXJhbWV0ZXJcIjtcbiAgICAgICAgU2VtYW50aWNUb2tlblR5cGVzW1widmFyaWFibGVcIl0gPSBcInZhcmlhYmxlXCI7XG4gICAgICAgIFNlbWFudGljVG9rZW5UeXBlc1tcInByb3BlcnR5XCJdID0gXCJwcm9wZXJ0eVwiO1xuICAgICAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJlbnVtTWVtYmVyXCJdID0gXCJlbnVtTWVtYmVyXCI7XG4gICAgICAgIFNlbWFudGljVG9rZW5UeXBlc1tcImV2ZW50XCJdID0gXCJldmVudFwiO1xuICAgICAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJmdW5jdGlvblwiXSA9IFwiZnVuY3Rpb25cIjtcbiAgICAgICAgU2VtYW50aWNUb2tlblR5cGVzW1wibWV0aG9kXCJdID0gXCJtZXRob2RcIjtcbiAgICAgICAgU2VtYW50aWNUb2tlblR5cGVzW1wibWFjcm9cIl0gPSBcIm1hY3JvXCI7XG4gICAgICAgIFNlbWFudGljVG9rZW5UeXBlc1tcImtleXdvcmRcIl0gPSBcImtleXdvcmRcIjtcbiAgICAgICAgU2VtYW50aWNUb2tlblR5cGVzW1wibW9kaWZpZXJcIl0gPSBcIm1vZGlmaWVyXCI7XG4gICAgICAgIFNlbWFudGljVG9rZW5UeXBlc1tcImNvbW1lbnRcIl0gPSBcImNvbW1lbnRcIjtcbiAgICAgICAgU2VtYW50aWNUb2tlblR5cGVzW1wic3RyaW5nXCJdID0gXCJzdHJpbmdcIjtcbiAgICAgICAgU2VtYW50aWNUb2tlblR5cGVzW1wibnVtYmVyXCJdID0gXCJudW1iZXJcIjtcbiAgICAgICAgU2VtYW50aWNUb2tlblR5cGVzW1wicmVnZXhwXCJdID0gXCJyZWdleHBcIjtcbiAgICAgICAgU2VtYW50aWNUb2tlblR5cGVzW1wib3BlcmF0b3JcIl0gPSBcIm9wZXJhdG9yXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAc2luY2UgMy4xNy4wXG4gICAgICAgICAqL1xuICAgICAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJkZWNvcmF0b3JcIl0gPSBcImRlY29yYXRvclwiO1xuICAgIH0pKFNlbWFudGljVG9rZW5UeXBlcyB8fCAoZXhwb3J0cy5TZW1hbnRpY1Rva2VuVHlwZXMgPSBTZW1hbnRpY1Rva2VuVHlwZXMgPSB7fSkpO1xuICAgIC8qKlxuICAgICAqIEEgc2V0IG9mIHByZWRlZmluZWQgdG9rZW4gbW9kaWZpZXJzLiBUaGlzIHNldCBpcyBub3QgZml4ZWRcbiAgICAgKiBhbiBjbGllbnRzIGNhbiBzcGVjaWZ5IGFkZGl0aW9uYWwgdG9rZW4gdHlwZXMgdmlhIHRoZVxuICAgICAqIGNvcnJlc3BvbmRpbmcgY2xpZW50IGNhcGFiaWxpdGllcy5cbiAgICAgKlxuICAgICAqIEBzaW5jZSAzLjE2LjBcbiAgICAgKi9cbiAgICB2YXIgU2VtYW50aWNUb2tlbk1vZGlmaWVycztcbiAgICAoZnVuY3Rpb24gKFNlbWFudGljVG9rZW5Nb2RpZmllcnMpIHtcbiAgICAgICAgU2VtYW50aWNUb2tlbk1vZGlmaWVyc1tcImRlY2xhcmF0aW9uXCJdID0gXCJkZWNsYXJhdGlvblwiO1xuICAgICAgICBTZW1hbnRpY1Rva2VuTW9kaWZpZXJzW1wiZGVmaW5pdGlvblwiXSA9IFwiZGVmaW5pdGlvblwiO1xuICAgICAgICBTZW1hbnRpY1Rva2VuTW9kaWZpZXJzW1wicmVhZG9ubHlcIl0gPSBcInJlYWRvbmx5XCI7XG4gICAgICAgIFNlbWFudGljVG9rZW5Nb2RpZmllcnNbXCJzdGF0aWNcIl0gPSBcInN0YXRpY1wiO1xuICAgICAgICBTZW1hbnRpY1Rva2VuTW9kaWZpZXJzW1wiZGVwcmVjYXRlZFwiXSA9IFwiZGVwcmVjYXRlZFwiO1xuICAgICAgICBTZW1hbnRpY1Rva2VuTW9kaWZpZXJzW1wiYWJzdHJhY3RcIl0gPSBcImFic3RyYWN0XCI7XG4gICAgICAgIFNlbWFudGljVG9rZW5Nb2RpZmllcnNbXCJhc3luY1wiXSA9IFwiYXN5bmNcIjtcbiAgICAgICAgU2VtYW50aWNUb2tlbk1vZGlmaWVyc1tcIm1vZGlmaWNhdGlvblwiXSA9IFwibW9kaWZpY2F0aW9uXCI7XG4gICAgICAgIFNlbWFudGljVG9rZW5Nb2RpZmllcnNbXCJkb2N1bWVudGF0aW9uXCJdID0gXCJkb2N1bWVudGF0aW9uXCI7XG4gICAgICAgIFNlbWFudGljVG9rZW5Nb2RpZmllcnNbXCJkZWZhdWx0TGlicmFyeVwiXSA9IFwiZGVmYXVsdExpYnJhcnlcIjtcbiAgICB9KShTZW1hbnRpY1Rva2VuTW9kaWZpZXJzIHx8IChleHBvcnRzLlNlbWFudGljVG9rZW5Nb2RpZmllcnMgPSBTZW1hbnRpY1Rva2VuTW9kaWZpZXJzID0ge30pKTtcbiAgICAvKipcbiAgICAgKiBAc2luY2UgMy4xNi4wXG4gICAgICovXG4gICAgdmFyIFNlbWFudGljVG9rZW5zO1xuICAgIChmdW5jdGlvbiAoU2VtYW50aWNUb2tlbnMpIHtcbiAgICAgICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgKGNhbmRpZGF0ZS5yZXN1bHRJZCA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBjYW5kaWRhdGUucmVzdWx0SWQgPT09ICdzdHJpbmcnKSAmJlxuICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkoY2FuZGlkYXRlLmRhdGEpICYmIChjYW5kaWRhdGUuZGF0YS5sZW5ndGggPT09IDAgfHwgdHlwZW9mIGNhbmRpZGF0ZS5kYXRhWzBdID09PSAnbnVtYmVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgU2VtYW50aWNUb2tlbnMuaXMgPSBpcztcbiAgICB9KShTZW1hbnRpY1Rva2VucyB8fCAoZXhwb3J0cy5TZW1hbnRpY1Rva2VucyA9IFNlbWFudGljVG9rZW5zID0ge30pKTtcbiAgICAvKipcbiAgICAgKiBUaGUgSW5saW5lVmFsdWVUZXh0IG5hbWVzcGFjZSBwcm92aWRlcyBmdW5jdGlvbnMgdG8gZGVhbCB3aXRoIElubGluZVZhbHVlVGV4dHMuXG4gICAgICpcbiAgICAgKiBAc2luY2UgMy4xNy4wXG4gICAgICovXG4gICAgdmFyIElubGluZVZhbHVlVGV4dDtcbiAgICAoZnVuY3Rpb24gKElubGluZVZhbHVlVGV4dCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBJbmxpbmVWYWx1ZVRleHQgbGl0ZXJhbC5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZShyYW5nZSwgdGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IHJhbmdlLCB0ZXh0OiB0ZXh0IH07XG4gICAgICAgIH1cbiAgICAgICAgSW5saW5lVmFsdWVUZXh0LmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAgICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBjYW5kaWRhdGUgIT09IHVuZGVmaW5lZCAmJiBjYW5kaWRhdGUgIT09IG51bGwgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIElubGluZVZhbHVlVGV4dC5pcyA9IGlzO1xuICAgIH0pKElubGluZVZhbHVlVGV4dCB8fCAoZXhwb3J0cy5JbmxpbmVWYWx1ZVRleHQgPSBJbmxpbmVWYWx1ZVRleHQgPSB7fSkpO1xuICAgIC8qKlxuICAgICAqIFRoZSBJbmxpbmVWYWx1ZVZhcmlhYmxlTG9va3VwIG5hbWVzcGFjZSBwcm92aWRlcyBmdW5jdGlvbnMgdG8gZGVhbCB3aXRoIElubGluZVZhbHVlVmFyaWFibGVMb29rdXBzLlxuICAgICAqXG4gICAgICogQHNpbmNlIDMuMTcuMFxuICAgICAqL1xuICAgIHZhciBJbmxpbmVWYWx1ZVZhcmlhYmxlTG9va3VwO1xuICAgIChmdW5jdGlvbiAoSW5saW5lVmFsdWVWYXJpYWJsZUxvb2t1cCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBJbmxpbmVWYWx1ZVRleHQgbGl0ZXJhbC5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZShyYW5nZSwgdmFyaWFibGVOYW1lLCBjYXNlU2Vuc2l0aXZlTG9va3VwKSB7XG4gICAgICAgICAgICByZXR1cm4geyByYW5nZTogcmFuZ2UsIHZhcmlhYmxlTmFtZTogdmFyaWFibGVOYW1lLCBjYXNlU2Vuc2l0aXZlTG9va3VwOiBjYXNlU2Vuc2l0aXZlTG9va3VwIH07XG4gICAgICAgIH1cbiAgICAgICAgSW5saW5lVmFsdWVWYXJpYWJsZUxvb2t1cC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gY2FuZGlkYXRlICE9PSB1bmRlZmluZWQgJiYgY2FuZGlkYXRlICE9PSBudWxsICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5yYW5nZSkgJiYgSXMuYm9vbGVhbihjYW5kaWRhdGUuY2FzZVNlbnNpdGl2ZUxvb2t1cClcbiAgICAgICAgICAgICAgICAmJiAoSXMuc3RyaW5nKGNhbmRpZGF0ZS52YXJpYWJsZU5hbWUpIHx8IGNhbmRpZGF0ZS52YXJpYWJsZU5hbWUgPT09IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgSW5saW5lVmFsdWVWYXJpYWJsZUxvb2t1cC5pcyA9IGlzO1xuICAgIH0pKElubGluZVZhbHVlVmFyaWFibGVMb29rdXAgfHwgKGV4cG9ydHMuSW5saW5lVmFsdWVWYXJpYWJsZUxvb2t1cCA9IElubGluZVZhbHVlVmFyaWFibGVMb29rdXAgPSB7fSkpO1xuICAgIC8qKlxuICAgICAqIFRoZSBJbmxpbmVWYWx1ZUV2YWx1YXRhYmxlRXhwcmVzc2lvbiBuYW1lc3BhY2UgcHJvdmlkZXMgZnVuY3Rpb25zIHRvIGRlYWwgd2l0aCBJbmxpbmVWYWx1ZUV2YWx1YXRhYmxlRXhwcmVzc2lvbi5cbiAgICAgKlxuICAgICAqIEBzaW5jZSAzLjE3LjBcbiAgICAgKi9cbiAgICB2YXIgSW5saW5lVmFsdWVFdmFsdWF0YWJsZUV4cHJlc3Npb247XG4gICAgKGZ1bmN0aW9uIChJbmxpbmVWYWx1ZUV2YWx1YXRhYmxlRXhwcmVzc2lvbikge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBJbmxpbmVWYWx1ZUV2YWx1YXRhYmxlRXhwcmVzc2lvbiBsaXRlcmFsLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlKHJhbmdlLCBleHByZXNzaW9uKSB7XG4gICAgICAgICAgICByZXR1cm4geyByYW5nZTogcmFuZ2UsIGV4cHJlc3Npb246IGV4cHJlc3Npb24gfTtcbiAgICAgICAgfVxuICAgICAgICBJbmxpbmVWYWx1ZUV2YWx1YXRhYmxlRXhwcmVzc2lvbi5jcmVhdGUgPSBjcmVhdGU7XG4gICAgICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gY2FuZGlkYXRlICE9PSB1bmRlZmluZWQgJiYgY2FuZGlkYXRlICE9PSBudWxsICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5yYW5nZSlcbiAgICAgICAgICAgICAgICAmJiAoSXMuc3RyaW5nKGNhbmRpZGF0ZS5leHByZXNzaW9uKSB8fCBjYW5kaWRhdGUuZXhwcmVzc2lvbiA9PT0gdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBJbmxpbmVWYWx1ZUV2YWx1YXRhYmxlRXhwcmVzc2lvbi5pcyA9IGlzO1xuICAgIH0pKElubGluZVZhbHVlRXZhbHVhdGFibGVFeHByZXNzaW9uIHx8IChleHBvcnRzLklubGluZVZhbHVlRXZhbHVhdGFibGVFeHByZXNzaW9uID0gSW5saW5lVmFsdWVFdmFsdWF0YWJsZUV4cHJlc3Npb24gPSB7fSkpO1xuICAgIC8qKlxuICAgICAqIFRoZSBJbmxpbmVWYWx1ZUNvbnRleHQgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gICAgICoge0BsaW5rIElubGluZVZhbHVlQ29udGV4dH0gbGl0ZXJhbHMuXG4gICAgICpcbiAgICAgKiBAc2luY2UgMy4xNy4wXG4gICAgICovXG4gICAgdmFyIElubGluZVZhbHVlQ29udGV4dDtcbiAgICAoZnVuY3Rpb24gKElubGluZVZhbHVlQ29udGV4dCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBJbmxpbmVWYWx1ZUNvbnRleHQgbGl0ZXJhbC5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZShmcmFtZUlkLCBzdG9wcGVkTG9jYXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB7IGZyYW1lSWQ6IGZyYW1lSWQsIHN0b3BwZWRMb2NhdGlvbjogc3RvcHBlZExvY2F0aW9uIH07XG4gICAgICAgIH1cbiAgICAgICAgSW5saW5lVmFsdWVDb250ZXh0LmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgSW5saW5lVmFsdWVDb250ZXh0fSBpbnRlcmZhY2UuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBSYW5nZS5pcyh2YWx1ZS5zdG9wcGVkTG9jYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIElubGluZVZhbHVlQ29udGV4dC5pcyA9IGlzO1xuICAgIH0pKElubGluZVZhbHVlQ29udGV4dCB8fCAoZXhwb3J0cy5JbmxpbmVWYWx1ZUNvbnRleHQgPSBJbmxpbmVWYWx1ZUNvbnRleHQgPSB7fSkpO1xuICAgIC8qKlxuICAgICAqIElubGF5IGhpbnQga2luZHMuXG4gICAgICpcbiAgICAgKiBAc2luY2UgMy4xNy4wXG4gICAgICovXG4gICAgdmFyIElubGF5SGludEtpbmQ7XG4gICAgKGZ1bmN0aW9uIChJbmxheUhpbnRLaW5kKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBpbmxheSBoaW50IHRoYXQgZm9yIGEgdHlwZSBhbm5vdGF0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgSW5sYXlIaW50S2luZC5UeXBlID0gMTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGlubGF5IGhpbnQgdGhhdCBpcyBmb3IgYSBwYXJhbWV0ZXIuXG4gICAgICAgICAqL1xuICAgICAgICBJbmxheUhpbnRLaW5kLlBhcmFtZXRlciA9IDI7XG4gICAgICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IDEgfHwgdmFsdWUgPT09IDI7XG4gICAgICAgIH1cbiAgICAgICAgSW5sYXlIaW50S2luZC5pcyA9IGlzO1xuICAgIH0pKElubGF5SGludEtpbmQgfHwgKGV4cG9ydHMuSW5sYXlIaW50S2luZCA9IElubGF5SGludEtpbmQgPSB7fSkpO1xuICAgIHZhciBJbmxheUhpbnRMYWJlbFBhcnQ7XG4gICAgKGZ1bmN0aW9uIChJbmxheUhpbnRMYWJlbFBhcnQpIHtcbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdmFsdWUgfTtcbiAgICAgICAgfVxuICAgICAgICBJbmxheUhpbnRMYWJlbFBhcnQuY3JlYXRlID0gY3JlYXRlO1xuICAgICAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKVxuICAgICAgICAgICAgICAgICYmIChjYW5kaWRhdGUudG9vbHRpcCA9PT0gdW5kZWZpbmVkIHx8IElzLnN0cmluZyhjYW5kaWRhdGUudG9vbHRpcCkgfHwgTWFya3VwQ29udGVudC5pcyhjYW5kaWRhdGUudG9vbHRpcCkpXG4gICAgICAgICAgICAgICAgJiYgKGNhbmRpZGF0ZS5sb2NhdGlvbiA9PT0gdW5kZWZpbmVkIHx8IExvY2F0aW9uLmlzKGNhbmRpZGF0ZS5sb2NhdGlvbikpXG4gICAgICAgICAgICAgICAgJiYgKGNhbmRpZGF0ZS5jb21tYW5kID09PSB1bmRlZmluZWQgfHwgQ29tbWFuZC5pcyhjYW5kaWRhdGUuY29tbWFuZCkpO1xuICAgICAgICB9XG4gICAgICAgIElubGF5SGludExhYmVsUGFydC5pcyA9IGlzO1xuICAgIH0pKElubGF5SGludExhYmVsUGFydCB8fCAoZXhwb3J0cy5JbmxheUhpbnRMYWJlbFBhcnQgPSBJbmxheUhpbnRMYWJlbFBhcnQgPSB7fSkpO1xuICAgIHZhciBJbmxheUhpbnQ7XG4gICAgKGZ1bmN0aW9uIChJbmxheUhpbnQpIHtcbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlKHBvc2l0aW9uLCBsYWJlbCwga2luZCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHsgcG9zaXRpb246IHBvc2l0aW9uLCBsYWJlbDogbGFiZWwgfTtcbiAgICAgICAgICAgIGlmIChraW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQua2luZCA9IGtpbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIElubGF5SGludC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIFBvc2l0aW9uLmlzKGNhbmRpZGF0ZS5wb3NpdGlvbilcbiAgICAgICAgICAgICAgICAmJiAoSXMuc3RyaW5nKGNhbmRpZGF0ZS5sYWJlbCkgfHwgSXMudHlwZWRBcnJheShjYW5kaWRhdGUubGFiZWwsIElubGF5SGludExhYmVsUGFydC5pcykpXG4gICAgICAgICAgICAgICAgJiYgKGNhbmRpZGF0ZS5raW5kID09PSB1bmRlZmluZWQgfHwgSW5sYXlIaW50S2luZC5pcyhjYW5kaWRhdGUua2luZCkpXG4gICAgICAgICAgICAgICAgJiYgKGNhbmRpZGF0ZS50ZXh0RWRpdHMgPT09IHVuZGVmaW5lZCkgfHwgSXMudHlwZWRBcnJheShjYW5kaWRhdGUudGV4dEVkaXRzLCBUZXh0RWRpdC5pcylcbiAgICAgICAgICAgICAgICAmJiAoY2FuZGlkYXRlLnRvb2x0aXAgPT09IHVuZGVmaW5lZCB8fCBJcy5zdHJpbmcoY2FuZGlkYXRlLnRvb2x0aXApIHx8IE1hcmt1cENvbnRlbnQuaXMoY2FuZGlkYXRlLnRvb2x0aXApKVxuICAgICAgICAgICAgICAgICYmIChjYW5kaWRhdGUucGFkZGluZ0xlZnQgPT09IHVuZGVmaW5lZCB8fCBJcy5ib29sZWFuKGNhbmRpZGF0ZS5wYWRkaW5nTGVmdCkpXG4gICAgICAgICAgICAgICAgJiYgKGNhbmRpZGF0ZS5wYWRkaW5nUmlnaHQgPT09IHVuZGVmaW5lZCB8fCBJcy5ib29sZWFuKGNhbmRpZGF0ZS5wYWRkaW5nUmlnaHQpKTtcbiAgICAgICAgfVxuICAgICAgICBJbmxheUhpbnQuaXMgPSBpcztcbiAgICB9KShJbmxheUhpbnQgfHwgKGV4cG9ydHMuSW5sYXlIaW50ID0gSW5sYXlIaW50ID0ge30pKTtcbiAgICB2YXIgU3RyaW5nVmFsdWU7XG4gICAgKGZ1bmN0aW9uIChTdHJpbmdWYWx1ZSkge1xuICAgICAgICBmdW5jdGlvbiBjcmVhdGVTbmlwcGV0KHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4geyBraW5kOiAnc25pcHBldCcsIHZhbHVlOiB2YWx1ZSB9O1xuICAgICAgICB9XG4gICAgICAgIFN0cmluZ1ZhbHVlLmNyZWF0ZVNuaXBwZXQgPSBjcmVhdGVTbmlwcGV0O1xuICAgIH0pKFN0cmluZ1ZhbHVlIHx8IChleHBvcnRzLlN0cmluZ1ZhbHVlID0gU3RyaW5nVmFsdWUgPSB7fSkpO1xuICAgIHZhciBJbmxpbmVDb21wbGV0aW9uSXRlbTtcbiAgICAoZnVuY3Rpb24gKElubGluZUNvbXBsZXRpb25JdGVtKSB7XG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZShpbnNlcnRUZXh0LCBmaWx0ZXJUZXh0LCByYW5nZSwgY29tbWFuZCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgaW5zZXJ0VGV4dDogaW5zZXJ0VGV4dCwgZmlsdGVyVGV4dDogZmlsdGVyVGV4dCwgcmFuZ2U6IHJhbmdlLCBjb21tYW5kOiBjb21tYW5kIH07XG4gICAgICAgIH1cbiAgICAgICAgSW5saW5lQ29tcGxldGlvbkl0ZW0uY3JlYXRlID0gY3JlYXRlO1xuICAgIH0pKElubGluZUNvbXBsZXRpb25JdGVtIHx8IChleHBvcnRzLklubGluZUNvbXBsZXRpb25JdGVtID0gSW5saW5lQ29tcGxldGlvbkl0ZW0gPSB7fSkpO1xuICAgIHZhciBJbmxpbmVDb21wbGV0aW9uTGlzdDtcbiAgICAoZnVuY3Rpb24gKElubGluZUNvbXBsZXRpb25MaXN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZShpdGVtcykge1xuICAgICAgICAgICAgcmV0dXJuIHsgaXRlbXM6IGl0ZW1zIH07XG4gICAgICAgIH1cbiAgICAgICAgSW5saW5lQ29tcGxldGlvbkxpc3QuY3JlYXRlID0gY3JlYXRlO1xuICAgIH0pKElubGluZUNvbXBsZXRpb25MaXN0IHx8IChleHBvcnRzLklubGluZUNvbXBsZXRpb25MaXN0ID0gSW5saW5lQ29tcGxldGlvbkxpc3QgPSB7fSkpO1xuICAgIC8qKlxuICAgICAqIERlc2NyaWJlcyBob3cgYW4ge0BsaW5rIElubGluZUNvbXBsZXRpb25JdGVtUHJvdmlkZXIgaW5saW5lIGNvbXBsZXRpb24gcHJvdmlkZXJ9IHdhcyB0cmlnZ2VyZWQuXG4gICAgICpcbiAgICAgKiBAc2luY2UgMy4xOC4wXG4gICAgICogQHByb3Bvc2VkXG4gICAgICovXG4gICAgdmFyIElubGluZUNvbXBsZXRpb25UcmlnZ2VyS2luZDtcbiAgICAoZnVuY3Rpb24gKElubGluZUNvbXBsZXRpb25UcmlnZ2VyS2luZCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29tcGxldGlvbiB3YXMgdHJpZ2dlcmVkIGV4cGxpY2l0bHkgYnkgYSB1c2VyIGdlc3R1cmUuXG4gICAgICAgICAqL1xuICAgICAgICBJbmxpbmVDb21wbGV0aW9uVHJpZ2dlcktpbmQuSW52b2tlZCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21wbGV0aW9uIHdhcyB0cmlnZ2VyZWQgYXV0b21hdGljYWxseSB3aGlsZSBlZGl0aW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgSW5saW5lQ29tcGxldGlvblRyaWdnZXJLaW5kLkF1dG9tYXRpYyA9IDE7XG4gICAgfSkoSW5saW5lQ29tcGxldGlvblRyaWdnZXJLaW5kIHx8IChleHBvcnRzLklubGluZUNvbXBsZXRpb25UcmlnZ2VyS2luZCA9IElubGluZUNvbXBsZXRpb25UcmlnZ2VyS2luZCA9IHt9KSk7XG4gICAgdmFyIFNlbGVjdGVkQ29tcGxldGlvbkluZm87XG4gICAgKGZ1bmN0aW9uIChTZWxlY3RlZENvbXBsZXRpb25JbmZvKSB7XG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZShyYW5nZSwgdGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IHJhbmdlLCB0ZXh0OiB0ZXh0IH07XG4gICAgICAgIH1cbiAgICAgICAgU2VsZWN0ZWRDb21wbGV0aW9uSW5mby5jcmVhdGUgPSBjcmVhdGU7XG4gICAgfSkoU2VsZWN0ZWRDb21wbGV0aW9uSW5mbyB8fCAoZXhwb3J0cy5TZWxlY3RlZENvbXBsZXRpb25JbmZvID0gU2VsZWN0ZWRDb21wbGV0aW9uSW5mbyA9IHt9KSk7XG4gICAgdmFyIElubGluZUNvbXBsZXRpb25Db250ZXh0O1xuICAgIChmdW5jdGlvbiAoSW5saW5lQ29tcGxldGlvbkNvbnRleHQpIHtcbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlKHRyaWdnZXJLaW5kLCBzZWxlY3RlZENvbXBsZXRpb25JbmZvKSB7XG4gICAgICAgICAgICByZXR1cm4geyB0cmlnZ2VyS2luZDogdHJpZ2dlcktpbmQsIHNlbGVjdGVkQ29tcGxldGlvbkluZm86IHNlbGVjdGVkQ29tcGxldGlvbkluZm8gfTtcbiAgICAgICAgfVxuICAgICAgICBJbmxpbmVDb21wbGV0aW9uQ29udGV4dC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgfSkoSW5saW5lQ29tcGxldGlvbkNvbnRleHQgfHwgKGV4cG9ydHMuSW5saW5lQ29tcGxldGlvbkNvbnRleHQgPSBJbmxpbmVDb21wbGV0aW9uQ29udGV4dCA9IHt9KSk7XG4gICAgdmFyIFdvcmtzcGFjZUZvbGRlcjtcbiAgICAoZnVuY3Rpb24gKFdvcmtzcGFjZUZvbGRlcikge1xuICAgICAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBVUkkuaXMoY2FuZGlkYXRlLnVyaSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBXb3Jrc3BhY2VGb2xkZXIuaXMgPSBpcztcbiAgICB9KShXb3Jrc3BhY2VGb2xkZXIgfHwgKGV4cG9ydHMuV29ya3NwYWNlRm9sZGVyID0gV29ya3NwYWNlRm9sZGVyID0ge30pKTtcbiAgICBleHBvcnRzLkVPTCA9IFsnXFxuJywgJ1xcclxcbicsICdcXHInXTtcbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgdGhlIHRleHQgZG9jdW1lbnQgZnJvbSB0aGUgbmV3IHZzY29kZS1sYW5ndWFnZXNlcnZlci10ZXh0ZG9jdW1lbnQgcGFja2FnZS5cbiAgICAgKi9cbiAgICB2YXIgVGV4dERvY3VtZW50O1xuICAgIChmdW5jdGlvbiAoVGV4dERvY3VtZW50KSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IElUZXh0RG9jdW1lbnQgbGl0ZXJhbCBmcm9tIHRoZSBnaXZlbiB1cmkgYW5kIGNvbnRlbnQuXG4gICAgICAgICAqIEBwYXJhbSB1cmkgVGhlIGRvY3VtZW50J3MgdXJpLlxuICAgICAgICAgKiBAcGFyYW0gbGFuZ3VhZ2VJZCBUaGUgZG9jdW1lbnQncyBsYW5ndWFnZSBJZC5cbiAgICAgICAgICogQHBhcmFtIHZlcnNpb24gVGhlIGRvY3VtZW50J3MgdmVyc2lvbi5cbiAgICAgICAgICogQHBhcmFtIGNvbnRlbnQgVGhlIGRvY3VtZW50J3MgY29udGVudC5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZSh1cmksIGxhbmd1YWdlSWQsIHZlcnNpb24sIGNvbnRlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRnVsbFRleHREb2N1bWVudCh1cmksIGxhbmd1YWdlSWQsIHZlcnNpb24sIGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICAgIFRleHREb2N1bWVudC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIElUZXh0RG9jdW1lbnR9IGludGVyZmFjZS5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUudXJpKSAmJiAoSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5sYW5ndWFnZUlkKSB8fCBJcy5zdHJpbmcoY2FuZGlkYXRlLmxhbmd1YWdlSWQpKSAmJiBJcy51aW50ZWdlcihjYW5kaWRhdGUubGluZUNvdW50KVxuICAgICAgICAgICAgICAgICYmIElzLmZ1bmMoY2FuZGlkYXRlLmdldFRleHQpICYmIElzLmZ1bmMoY2FuZGlkYXRlLnBvc2l0aW9uQXQpICYmIElzLmZ1bmMoY2FuZGlkYXRlLm9mZnNldEF0KSA/IHRydWUgOiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBUZXh0RG9jdW1lbnQuaXMgPSBpcztcbiAgICAgICAgZnVuY3Rpb24gYXBwbHlFZGl0cyhkb2N1bWVudCwgZWRpdHMpIHtcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gZG9jdW1lbnQuZ2V0VGV4dCgpO1xuICAgICAgICAgICAgdmFyIHNvcnRlZEVkaXRzID0gbWVyZ2VTb3J0KGVkaXRzLCBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIHZhciBkaWZmID0gYS5yYW5nZS5zdGFydC5saW5lIC0gYi5yYW5nZS5zdGFydC5saW5lO1xuICAgICAgICAgICAgICAgIGlmIChkaWZmID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhLnJhbmdlLnN0YXJ0LmNoYXJhY3RlciAtIGIucmFuZ2Uuc3RhcnQuY2hhcmFjdGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZGlmZjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGxhc3RNb2RpZmllZE9mZnNldCA9IHRleHQubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHNvcnRlZEVkaXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgdmFyIGUgPSBzb3J0ZWRFZGl0c1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRPZmZzZXQgPSBkb2N1bWVudC5vZmZzZXRBdChlLnJhbmdlLnN0YXJ0KTtcbiAgICAgICAgICAgICAgICB2YXIgZW5kT2Zmc2V0ID0gZG9jdW1lbnQub2Zmc2V0QXQoZS5yYW5nZS5lbmQpO1xuICAgICAgICAgICAgICAgIGlmIChlbmRPZmZzZXQgPD0gbGFzdE1vZGlmaWVkT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCBzdGFydE9mZnNldCkgKyBlLm5ld1RleHQgKyB0ZXh0LnN1YnN0cmluZyhlbmRPZmZzZXQsIHRleHQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT3ZlcmxhcHBpbmcgZWRpdCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsYXN0TW9kaWZpZWRPZmZzZXQgPSBzdGFydE9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgICB9XG4gICAgICAgIFRleHREb2N1bWVudC5hcHBseUVkaXRzID0gYXBwbHlFZGl0cztcbiAgICAgICAgZnVuY3Rpb24gbWVyZ2VTb3J0KGRhdGEsIGNvbXBhcmUpIHtcbiAgICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICAgICAgLy8gc29ydGVkXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcCA9IChkYXRhLmxlbmd0aCAvIDIpIHwgMDtcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gZGF0YS5zbGljZSgwLCBwKTtcbiAgICAgICAgICAgIHZhciByaWdodCA9IGRhdGEuc2xpY2UocCk7XG4gICAgICAgICAgICBtZXJnZVNvcnQobGVmdCwgY29tcGFyZSk7XG4gICAgICAgICAgICBtZXJnZVNvcnQocmlnaHQsIGNvbXBhcmUpO1xuICAgICAgICAgICAgdmFyIGxlZnRJZHggPSAwO1xuICAgICAgICAgICAgdmFyIHJpZ2h0SWR4ID0gMDtcbiAgICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChsZWZ0SWR4IDwgbGVmdC5sZW5ndGggJiYgcmlnaHRJZHggPCByaWdodC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmV0ID0gY29tcGFyZShsZWZ0W2xlZnRJZHhdLCByaWdodFtyaWdodElkeF0pO1xuICAgICAgICAgICAgICAgIGlmIChyZXQgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBzbWFsbGVyX2VxdWFsIC0+IHRha2UgbGVmdCB0byBwcmVzZXJ2ZSBvcmRlclxuICAgICAgICAgICAgICAgICAgICBkYXRhW2krK10gPSBsZWZ0W2xlZnRJZHgrK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBncmVhdGVyIC0+IHRha2UgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtpKytdID0gcmlnaHRbcmlnaHRJZHgrK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGxlZnRJZHggPCBsZWZ0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGRhdGFbaSsrXSA9IGxlZnRbbGVmdElkeCsrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChyaWdodElkeCA8IHJpZ2h0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGRhdGFbaSsrXSA9IHJpZ2h0W3JpZ2h0SWR4KytdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cbiAgICB9KShUZXh0RG9jdW1lbnQgfHwgKGV4cG9ydHMuVGV4dERvY3VtZW50ID0gVGV4dERvY3VtZW50ID0ge30pKTtcbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgdGhlIHRleHQgZG9jdW1lbnQgZnJvbSB0aGUgbmV3IHZzY29kZS1sYW5ndWFnZXNlcnZlci10ZXh0ZG9jdW1lbnQgcGFja2FnZS5cbiAgICAgKi9cbiAgICB2YXIgRnVsbFRleHREb2N1bWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gRnVsbFRleHREb2N1bWVudCh1cmksIGxhbmd1YWdlSWQsIHZlcnNpb24sIGNvbnRlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3VyaSA9IHVyaTtcbiAgICAgICAgICAgIHRoaXMuX2xhbmd1YWdlSWQgPSBsYW5ndWFnZUlkO1xuICAgICAgICAgICAgdGhpcy5fdmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgICAgICB0aGlzLl9jb250ZW50ID0gY29udGVudDtcbiAgICAgICAgICAgIHRoaXMuX2xpbmVPZmZzZXRzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGdWxsVGV4dERvY3VtZW50LnByb3RvdHlwZSwgXCJ1cmlcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3VyaTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZ1bGxUZXh0RG9jdW1lbnQucHJvdG90eXBlLCBcImxhbmd1YWdlSWRcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xhbmd1YWdlSWQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGdWxsVGV4dERvY3VtZW50LnByb3RvdHlwZSwgXCJ2ZXJzaW9uXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92ZXJzaW9uO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBGdWxsVGV4dERvY3VtZW50LnByb3RvdHlwZS5nZXRUZXh0ID0gZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLm9mZnNldEF0KHJhbmdlLnN0YXJ0KTtcbiAgICAgICAgICAgICAgICB2YXIgZW5kID0gdGhpcy5vZmZzZXRBdChyYW5nZS5lbmQpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250ZW50LnN1YnN0cmluZyhzdGFydCwgZW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250ZW50O1xuICAgICAgICB9O1xuICAgICAgICBGdWxsVGV4dERvY3VtZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZXZlbnQsIHZlcnNpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRlbnQgPSBldmVudC50ZXh0O1xuICAgICAgICAgICAgdGhpcy5fdmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgICAgICB0aGlzLl9saW5lT2Zmc2V0cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfTtcbiAgICAgICAgRnVsbFRleHREb2N1bWVudC5wcm90b3R5cGUuZ2V0TGluZU9mZnNldHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbGluZU9mZnNldHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhciBsaW5lT2Zmc2V0cyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciB0ZXh0ID0gdGhpcy5fY29udGVudDtcbiAgICAgICAgICAgICAgICB2YXIgaXNMaW5lU3RhcnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNMaW5lU3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVPZmZzZXRzLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0xpbmVTdGFydCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaCA9IHRleHQuY2hhckF0KGkpO1xuICAgICAgICAgICAgICAgICAgICBpc0xpbmVTdGFydCA9IChjaCA9PT0gJ1xccicgfHwgY2ggPT09ICdcXG4nKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXFxyJyAmJiBpICsgMSA8IHRleHQubGVuZ3RoICYmIHRleHQuY2hhckF0KGkgKyAxKSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNMaW5lU3RhcnQgJiYgdGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVPZmZzZXRzLnB1c2godGV4dC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9saW5lT2Zmc2V0cyA9IGxpbmVPZmZzZXRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVPZmZzZXRzO1xuICAgICAgICB9O1xuICAgICAgICBGdWxsVGV4dERvY3VtZW50LnByb3RvdHlwZS5wb3NpdGlvbkF0ID0gZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gTWF0aC5tYXgoTWF0aC5taW4ob2Zmc2V0LCB0aGlzLl9jb250ZW50Lmxlbmd0aCksIDApO1xuICAgICAgICAgICAgdmFyIGxpbmVPZmZzZXRzID0gdGhpcy5nZXRMaW5lT2Zmc2V0cygpO1xuICAgICAgICAgICAgdmFyIGxvdyA9IDAsIGhpZ2ggPSBsaW5lT2Zmc2V0cy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoaGlnaCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQb3NpdGlvbi5jcmVhdGUoMCwgb2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1pZCA9IE1hdGguZmxvb3IoKGxvdyArIGhpZ2gpIC8gMik7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmVPZmZzZXRzW21pZF0gPiBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaGlnaCA9IG1pZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbG93IGlzIHRoZSBsZWFzdCB4IGZvciB3aGljaCB0aGUgbGluZSBvZmZzZXQgaXMgbGFyZ2VyIHRoYW4gdGhlIGN1cnJlbnQgb2Zmc2V0XG4gICAgICAgICAgICAvLyBvciBhcnJheS5sZW5ndGggaWYgbm8gbGluZSBvZmZzZXQgaXMgbGFyZ2VyIHRoYW4gdGhlIGN1cnJlbnQgb2Zmc2V0XG4gICAgICAgICAgICB2YXIgbGluZSA9IGxvdyAtIDE7XG4gICAgICAgICAgICByZXR1cm4gUG9zaXRpb24uY3JlYXRlKGxpbmUsIG9mZnNldCAtIGxpbmVPZmZzZXRzW2xpbmVdKTtcbiAgICAgICAgfTtcbiAgICAgICAgRnVsbFRleHREb2N1bWVudC5wcm90b3R5cGUub2Zmc2V0QXQgPSBmdW5jdGlvbiAocG9zaXRpb24pIHtcbiAgICAgICAgICAgIHZhciBsaW5lT2Zmc2V0cyA9IHRoaXMuZ2V0TGluZU9mZnNldHMoKTtcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbi5saW5lID49IGxpbmVPZmZzZXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250ZW50Lmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBvc2l0aW9uLmxpbmUgPCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbGluZU9mZnNldCA9IGxpbmVPZmZzZXRzW3Bvc2l0aW9uLmxpbmVdO1xuICAgICAgICAgICAgdmFyIG5leHRMaW5lT2Zmc2V0ID0gKHBvc2l0aW9uLmxpbmUgKyAxIDwgbGluZU9mZnNldHMubGVuZ3RoKSA/IGxpbmVPZmZzZXRzW3Bvc2l0aW9uLmxpbmUgKyAxXSA6IHRoaXMuX2NvbnRlbnQubGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KE1hdGgubWluKGxpbmVPZmZzZXQgKyBwb3NpdGlvbi5jaGFyYWN0ZXIsIG5leHRMaW5lT2Zmc2V0KSwgbGluZU9mZnNldCk7XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGdWxsVGV4dERvY3VtZW50LnByb3RvdHlwZSwgXCJsaW5lQ291bnRcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TGluZU9mZnNldHMoKS5sZW5ndGg7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBGdWxsVGV4dERvY3VtZW50O1xuICAgIH0oKSk7XG4gICAgdmFyIElzO1xuICAgIChmdW5jdGlvbiAoSXMpIHtcbiAgICAgICAgdmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbiAgICAgICAgZnVuY3Rpb24gZGVmaW5lZCh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIH1cbiAgICAgICAgSXMuZGVmaW5lZCA9IGRlZmluZWQ7XG4gICAgICAgIGZ1bmN0aW9uIHVuZGVmaW5lZCh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIH1cbiAgICAgICAgSXMudW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgICAgICBmdW5jdGlvbiBib29sZWFuKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IHRydWUgfHwgdmFsdWUgPT09IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIElzLmJvb2xlYW4gPSBib29sZWFuO1xuICAgICAgICBmdW5jdGlvbiBzdHJpbmcodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7XG4gICAgICAgIH1cbiAgICAgICAgSXMuc3RyaW5nID0gc3RyaW5nO1xuICAgICAgICBmdW5jdGlvbiBudW1iZXIodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgTnVtYmVyXSc7XG4gICAgICAgIH1cbiAgICAgICAgSXMubnVtYmVyID0gbnVtYmVyO1xuICAgICAgICBmdW5jdGlvbiBudW1iZXJSYW5nZSh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgICAgICAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgTnVtYmVyXScgJiYgbWluIDw9IHZhbHVlICYmIHZhbHVlIDw9IG1heDtcbiAgICAgICAgfVxuICAgICAgICBJcy5udW1iZXJSYW5nZSA9IG51bWJlclJhbmdlO1xuICAgICAgICBmdW5jdGlvbiBpbnRlZ2VyKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IE51bWJlcl0nICYmIC0yMTQ3NDgzNjQ4IDw9IHZhbHVlICYmIHZhbHVlIDw9IDIxNDc0ODM2NDc7XG4gICAgICAgIH1cbiAgICAgICAgSXMuaW50ZWdlciA9IGludGVnZXI7XG4gICAgICAgIGZ1bmN0aW9uIHVpbnRlZ2VyKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IE51bWJlcl0nICYmIDAgPD0gdmFsdWUgJiYgdmFsdWUgPD0gMjE0NzQ4MzY0NztcbiAgICAgICAgfVxuICAgICAgICBJcy51aW50ZWdlciA9IHVpbnRlZ2VyO1xuICAgICAgICBmdW5jdGlvbiBmdW5jKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG4gICAgICAgIH1cbiAgICAgICAgSXMuZnVuYyA9IGZ1bmM7XG4gICAgICAgIGZ1bmN0aW9uIG9iamVjdExpdGVyYWwodmFsdWUpIHtcbiAgICAgICAgICAgIC8vIFN0cmljdGx5IHNwZWFraW5nIGNsYXNzIGluc3RhbmNlcyBwYXNzIHRoaXMgY2hlY2sgYXMgd2VsbC4gU2luY2UgdGhlIExTUFxuICAgICAgICAgICAgLy8gZG9lc24ndCB1c2UgY2xhc3NlcyB3ZSBpZ25vcmUgdGhpcyBmb3Igbm93LiBJZiB3ZSBkbyB3ZSBuZWVkIHRvIGFkZCBzb21ldGhpbmdcbiAgICAgICAgICAgIC8vIGxpa2UgdGhpczogYE9iamVjdC5nZXRQcm90b3R5cGVPZihPYmplY3QuZ2V0UHJvdG90eXBlT2YoeCkpID09PSBudWxsYFxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCc7XG4gICAgICAgIH1cbiAgICAgICAgSXMub2JqZWN0TGl0ZXJhbCA9IG9iamVjdExpdGVyYWw7XG4gICAgICAgIGZ1bmN0aW9uIHR5cGVkQXJyYXkodmFsdWUsIGNoZWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUuZXZlcnkoY2hlY2spO1xuICAgICAgICB9XG4gICAgICAgIElzLnR5cGVkQXJyYXkgPSB0eXBlZEFycmF5O1xuICAgIH0pKElzIHx8IChJcyA9IHt9KSk7XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/vscode-languageserver-types/lib/umd/main.js\n");

/***/ })

};
;