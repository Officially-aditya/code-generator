"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/e2b";
exports.ids = ["vendor-chunks/e2b"];
exports.modules = {

/***/ "(rsc)/./node_modules/e2b/dist/index.mjs":
/*!*****************************************!*\
  !*** ./node_modules/e2b/dist/index.mjs ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ApiClient: () => (/* binding */ ApiClient),\n/* harmony export */   AuthenticationError: () => (/* binding */ AuthenticationError),\n/* harmony export */   BuildError: () => (/* binding */ BuildError),\n/* harmony export */   CommandExitError: () => (/* binding */ CommandExitError),\n/* harmony export */   ConnectionConfig: () => (/* binding */ ConnectionConfig),\n/* harmony export */   FileType: () => (/* binding */ FileType2),\n/* harmony export */   FileUploadError: () => (/* binding */ FileUploadError),\n/* harmony export */   FilesystemEventType: () => (/* binding */ FilesystemEventType),\n/* harmony export */   InvalidArgumentError: () => (/* binding */ InvalidArgumentError),\n/* harmony export */   NotEnoughSpaceError: () => (/* binding */ NotEnoughSpaceError),\n/* harmony export */   NotFoundError: () => (/* binding */ NotFoundError),\n/* harmony export */   RateLimitError: () => (/* binding */ RateLimitError),\n/* harmony export */   Sandbox: () => (/* binding */ Sandbox),\n/* harmony export */   SandboxError: () => (/* binding */ SandboxError),\n/* harmony export */   Template: () => (/* binding */ Template),\n/* harmony export */   TemplateError: () => (/* binding */ TemplateError),\n/* harmony export */   TimeoutError: () => (/* binding */ TimeoutError),\n/* harmony export */   \"default\": () => (/* binding */ src_default),\n/* harmony export */   getSignature: () => (/* binding */ getSignature),\n/* harmony export */   waitForFile: () => (/* binding */ waitForFile),\n/* harmony export */   waitForPort: () => (/* binding */ waitForPort),\n/* harmony export */   waitForProcess: () => (/* binding */ waitForProcess),\n/* harmony export */   waitForTimeout: () => (/* binding */ waitForTimeout),\n/* harmony export */   waitForURL: () => (/* binding */ waitForURL)\n/* harmony export */ });\n/* harmony import */ var openapi_fetch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! openapi-fetch */ \"(rsc)/./node_modules/openapi-fetch/dist/index.js\");\n/* harmony import */ var platform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! platform */ \"(rsc)/./node_modules/platform/platform.js\");\n/* harmony import */ var _connectrpc_connect__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @connectrpc/connect */ \"(rsc)/./node_modules/@connectrpc/connect/dist/esm/promise-client.js\");\n/* harmony import */ var _connectrpc_connect__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @connectrpc/connect */ \"(rsc)/./node_modules/@connectrpc/connect/dist/esm/connect-error.js\");\n/* harmony import */ var _connectrpc_connect__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @connectrpc/connect */ \"(rsc)/./node_modules/@connectrpc/connect/dist/esm/code.js\");\n/* harmony import */ var _bufbuild_protobuf_codegenv2__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @bufbuild/protobuf/codegenv2 */ \"(rsc)/./node_modules/@bufbuild/protobuf/dist/esm/codegenv2/file.js\");\n/* harmony import */ var _bufbuild_protobuf_codegenv2__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @bufbuild/protobuf/codegenv2 */ \"(rsc)/./node_modules/@bufbuild/protobuf/dist/esm/codegenv2/service.js\");\n/* harmony import */ var _bufbuild_protobuf_wkt__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @bufbuild/protobuf/wkt */ \"(rsc)/./node_modules/@bufbuild/protobuf/dist/esm/wkt/gen/google/protobuf/timestamp_pb.js\");\n/* harmony import */ var compare_versions__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! compare-versions */ \"(rsc)/./node_modules/compare-versions/lib/esm/compareVersions.js\");\n/* harmony import */ var _connectrpc_connect_web__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @connectrpc/connect-web */ \"(rsc)/./node_modules/@connectrpc/connect-web/dist/esm/connect-transport.js\");\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n/* harmony import */ var node_fs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! node:fs */ \"node:fs\");\n/* harmony import */ var node_path__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! node:path */ \"node:path\");\n/* harmony import */ var dockerfile_ast__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! dockerfile-ast */ \"(rsc)/./node_modules/dockerfile-ast/lib/main.js\");\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for(\"Symbol.\" + name);\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __require = /* @__PURE__ */ ((x) => typeof require !== \"undefined\" ? require : typeof Proxy !== \"undefined\" ? new Proxy(x, {\n  get: (a, b) => (typeof require !== \"undefined\" ? require : a)[b]\n}) : x)(function(x) {\n  if (typeof require !== \"undefined\") return require.apply(this, arguments);\n  throw Error('Dynamic require of \"' + x + '\" is not supported');\n});\nvar __await = function(promise, isYieldStar) {\n  this[0] = promise;\n  this[1] = isYieldStar;\n};\nvar __asyncGenerator = (__this, __arguments, generator) => {\n  var resume = (k, v, yes, no) => {\n    try {\n      var x = generator[k](v), isAwait = (v = x.value) instanceof __await, done = x.done;\n      Promise.resolve(isAwait ? v[0] : v).then((y) => isAwait ? resume(k === \"return\" ? k : \"next\", v[1] ? { done: y.done, value: y.value } : y, yes, no) : yes({ value: y, done })).catch((e) => resume(\"throw\", e, yes, no));\n    } catch (e) {\n      no(e);\n    }\n  }, method = (k) => it[k] = (x) => new Promise((yes, no) => resume(k, x, yes, no)), it = {};\n  return generator = generator.apply(__this, __arguments), it[__knownSymbol(\"asyncIterator\")] = () => it, method(\"next\"), method(\"throw\"), method(\"return\"), it;\n};\nvar __forAwait = (obj, it, method) => (it = obj[__knownSymbol(\"asyncIterator\")]) ? it.call(obj) : (obj = obj[__knownSymbol(\"iterator\")](), it = {}, method = (key, fn) => (fn = obj[key]) && (it[key] = (arg) => new Promise((yes, no, done) => (arg = fn.call(obj, arg), done = arg.done, Promise.resolve(arg.value).then((value) => yes({ value, done }), no)))), method(\"next\"), method(\"return\"), it);\n\n// src/api/index.ts\n\n\n// src/api/metadata.ts\n\n\n// package.json\nvar version = \"2.1.2\";\n\n// src/utils.ts\n\nfunction getRuntime() {\n  var _a3, _b, _c;\n  if (globalThis.Bun) {\n    return { runtime: \"bun\", version: globalThis.Bun.version };\n  }\n  if (globalThis.Deno) {\n    return { runtime: \"deno\", version: globalThis.Deno.version.deno };\n  }\n  if (((_b = (_a3 = globalThis.process) == null ? void 0 : _a3.release) == null ? void 0 : _b.name) === \"node\") {\n    return { runtime: \"node\", version: platform__WEBPACK_IMPORTED_MODULE_1__.version || \"unknown\" };\n  }\n  if (typeof EdgeRuntime === \"string\") {\n    return { runtime: \"vercel-edge\", version: \"unknown\" };\n  }\n  if (((_c = globalThis.navigator) == null ? void 0 : _c.userAgent) === \"Cloudflare-Workers\") {\n    return { runtime: \"cloudflare-worker\", version: \"unknown\" };\n  }\n  if (typeof window !== \"undefined\") {\n    return { runtime: \"browser\", version: platform__WEBPACK_IMPORTED_MODULE_1__.version || \"unknown\" };\n  }\n  return { runtime: \"unknown\", version: \"unknown\" };\n}\nvar { runtime, version: runtimeVersion } = getRuntime();\nasync function sha256(data) {\n  if (typeof crypto !== \"undefined\") {\n    const encoder = new TextEncoder();\n    const dataBuffer = encoder.encode(data);\n    const hashBuffer = await crypto.subtle.digest(\"SHA-256\", dataBuffer);\n    const hashArray = new Uint8Array(hashBuffer);\n    return btoa(String.fromCharCode(...hashArray));\n  }\n  const { createHash } = __require(\"node:crypto\");\n  const hash = createHash(\"sha256\").update(data, \"utf8\").digest();\n  return hash.toString(\"base64\");\n}\nfunction timeoutToSeconds(timeout) {\n  return Math.ceil(timeout / 1e3);\n}\nasync function dynamicGlob() {\n  if (runtime === \"browser\") {\n    throw new Error(\"Browser runtime is not supported for glob\");\n  }\n  return await Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/e2b\"), __webpack_require__.e(\"vendor-chunks/minipass\"), __webpack_require__.e(\"vendor-chunks/@isaacs\")]).then(__webpack_require__.bind(__webpack_require__, /*! glob */ \"(rsc)/./node_modules/e2b/node_modules/glob/dist/esm/index.js\"));\n}\nasync function dynamicTar() {\n  if (runtime === \"browser\") {\n    throw new Error(\"Browser runtime is not supported for tar\");\n  }\n  return await Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/minipass\"), __webpack_require__.e(\"vendor-chunks/@isaacs\"), __webpack_require__.e(\"vendor-chunks/tar\"), __webpack_require__.e(\"vendor-chunks/mkdirp\"), __webpack_require__.e(\"vendor-chunks/minizlib\"), __webpack_require__.e(\"vendor-chunks/yallist\"), __webpack_require__.e(\"vendor-chunks/chownr\")]).then(__webpack_require__.bind(__webpack_require__, /*! tar */ \"(rsc)/./node_modules/tar/dist/esm/index.js\"));\n}\nfunction ansiRegex({ onlyFirst = false } = {}) {\n  const ST = \"(?:\\\\u0007|\\\\u001B\\\\u005C|\\\\u009C)\";\n  const osc = `(?:\\\\u001B\\\\][\\\\s\\\\S]*?${ST})`;\n  const csi = \"[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:\\\\d{1,4}(?:[;:]\\\\d{0,4})*)?[\\\\dA-PR-TZcf-nq-uy=><~]\";\n  const pattern = `${osc}|${csi}`;\n  return new RegExp(pattern, onlyFirst ? void 0 : \"g\");\n}\nfunction stripAnsi(text) {\n  return text.replace(ansiRegex(), \"\");\n}\n\n// src/api/metadata.ts\nvar _a;\nvar defaultHeaders = {\n  browser: typeof window !== \"undefined\" && platform__WEBPACK_IMPORTED_MODULE_1__.name || \"unknown\",\n  lang: \"js\",\n  lang_version: runtimeVersion,\n  package_version: version,\n  publisher: \"e2b\",\n  sdk_runtime: runtime,\n  system: ((_a = platform__WEBPACK_IMPORTED_MODULE_1__.os) == null ? void 0 : _a.family) || \"unknown\"\n};\nfunction getEnvVar(name) {\n  if (runtime === \"deno\") {\n    return Deno.env.get(name);\n  }\n  if (typeof process === \"undefined\") {\n    return \"\";\n  }\n  return process.env[name];\n}\n\n// src/errors.ts\nfunction formatSandboxTimeoutError(message) {\n  return new TimeoutError(\n    `${message}: This error is likely due to sandbox timeout. You can modify the sandbox timeout by passing 'timeoutMs' when starting the sandbox or calling '.setTimeout' on the sandbox with the desired timeout.`\n  );\n}\nvar SandboxError = class extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"SandboxError\";\n  }\n};\nvar TimeoutError = class extends SandboxError {\n  constructor(message) {\n    super(message);\n    this.name = \"TimeoutError\";\n  }\n};\nvar InvalidArgumentError = class extends SandboxError {\n  constructor(message) {\n    super(message);\n    this.name = \"InvalidArgumentError\";\n  }\n};\nvar NotEnoughSpaceError = class extends SandboxError {\n  constructor(message) {\n    super(message);\n    this.name = \"NotEnoughSpaceError\";\n  }\n};\nvar NotFoundError = class extends SandboxError {\n  constructor(message) {\n    super(message);\n    this.name = \"NotFoundError\";\n  }\n};\nvar AuthenticationError = class extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"AuthenticationError\";\n  }\n};\nvar TemplateError = class extends SandboxError {\n  constructor(message) {\n    super(message);\n    this.name = \"TemplateError\";\n  }\n};\nvar RateLimitError = class extends SandboxError {\n  constructor(message) {\n    super(message);\n    this.name = \"RateLimitError\";\n  }\n};\n\n// src/logs.ts\nfunction formatLog(log) {\n  return JSON.parse(JSON.stringify(log));\n}\nfunction createRpcLogger(logger) {\n  function logEach(stream) {\n    return __asyncGenerator(this, null, function* () {\n      var _a3;\n      try {\n        for (var iter = __forAwait(stream), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {\n          const m = temp.value;\n          (_a3 = logger.debug) == null ? void 0 : _a3.call(logger, \"Response stream:\", formatLog(m));\n          yield m;\n        }\n      } catch (temp) {\n        error = [temp];\n      } finally {\n        try {\n          more && (temp = iter.return) && (yield new __await(temp.call(iter)));\n        } finally {\n          if (error)\n            throw error[0];\n        }\n      }\n    });\n  }\n  return (next) => async (req) => {\n    var _a3, _b;\n    (_a3 = logger.info) == null ? void 0 : _a3.call(logger, `Request: POST ${req.url}`);\n    const res = await next(req);\n    if (res.stream) {\n      return __spreadProps(__spreadValues({}, res), {\n        message: logEach(res.message)\n      });\n    } else {\n      (_b = logger.info) == null ? void 0 : _b.call(logger, \"Response:\", formatLog(res.message));\n    }\n    return res;\n  };\n}\nfunction createApiLogger(logger) {\n  return {\n    async onRequest(req) {\n      var _a3;\n      (_a3 = logger.info) == null ? void 0 : _a3.call(logger, `Request ${req.method} ${req.url}`);\n      return req;\n    },\n    async onResponse(res) {\n      var _a3, _b;\n      if (res.status >= 400) {\n        (_a3 = logger.error) == null ? void 0 : _a3.call(logger, \"Response:\", res.status, res.statusText);\n      } else {\n        (_b = logger.info) == null ? void 0 : _b.call(logger, \"Response:\", res.status, res.statusText);\n      }\n      return res;\n    }\n  };\n}\n\n// src/api/index.ts\nfunction handleApiError(response, errorClass = SandboxError) {\n  var _a3, _b, _c, _d, _e, _f;\n  if (!response.error) {\n    return;\n  }\n  if (response.response.status === 401) {\n    const message2 = \"Unauthorized, please check your credentials.\";\n    const content = (_b = (_a3 = response.error) == null ? void 0 : _a3.message) != null ? _b : response.error;\n    if (content) {\n      return new AuthenticationError(`${message2} - ${content}`);\n    }\n    return new AuthenticationError(message2);\n  }\n  if (response.response.status === 429) {\n    const message2 = \"Rate limit exceeded, please try again later\";\n    const content = (_d = (_c = response.error) == null ? void 0 : _c.message) != null ? _d : response.error;\n    if (content) {\n      return new RateLimitError(`${message2} - ${content}`);\n    }\n    return new RateLimitError(message2);\n  }\n  const message = (_f = (_e = response.error) == null ? void 0 : _e.message) != null ? _f : response.error;\n  return new errorClass(`${response.response.status}: ${message}`);\n}\nvar ApiClient = class {\n  constructor(config, opts = { requireAccessToken: false, requireApiKey: false }) {\n    if ((opts == null ? void 0 : opts.requireApiKey) && !config.apiKey) {\n      throw new AuthenticationError(\n        \"API key is required, please visit the Team tab at https://e2b.dev/dashboard to get your API key. You can either set the environment variable `E2B_API_KEY` or you can pass it directly to the sandbox like Sandbox.create({ apiKey: 'e2b_...' })\"\n      );\n    }\n    if ((opts == null ? void 0 : opts.requireAccessToken) && !config.accessToken) {\n      throw new AuthenticationError(\n        \"Access token is required, please visit the Personal tab at https://e2b.dev/dashboard to get your access token. You can set the environment variable `E2B_ACCESS_TOKEN` or pass the `accessToken` in options.\"\n      );\n    }\n    this.api = (0,openapi_fetch__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n      baseUrl: config.apiUrl,\n      // keepalive: true, // TODO: Return keepalive\n      headers: __spreadValues(__spreadValues(__spreadValues(__spreadValues({}, defaultHeaders), config.apiKey && { \"X-API-KEY\": config.apiKey }), config.accessToken && {\n        Authorization: `Bearer ${config.accessToken}`\n      }), config.headers),\n      querySerializer: {\n        array: {\n          style: \"form\",\n          explode: false\n        }\n      }\n    });\n    if (config.logger) {\n      this.api.use(createApiLogger(config.logger));\n    }\n  }\n};\n\n// src/connectionConfig.ts\nvar REQUEST_TIMEOUT_MS = 6e4;\nvar DEFAULT_SANDBOX_TIMEOUT_MS = 3e5;\nvar KEEPALIVE_PING_INTERVAL_SEC = 50;\nvar KEEPALIVE_PING_HEADER = \"Keepalive-Ping-Interval\";\nvar ConnectionConfig = class _ConnectionConfig {\n  constructor(opts) {\n    var _a3;\n    this.apiKey = (opts == null ? void 0 : opts.apiKey) || _ConnectionConfig.apiKey;\n    this.debug = (opts == null ? void 0 : opts.debug) || _ConnectionConfig.debug;\n    this.domain = (opts == null ? void 0 : opts.domain) || _ConnectionConfig.domain;\n    this.accessToken = (opts == null ? void 0 : opts.accessToken) || _ConnectionConfig.accessToken;\n    this.requestTimeoutMs = (_a3 = opts == null ? void 0 : opts.requestTimeoutMs) != null ? _a3 : REQUEST_TIMEOUT_MS;\n    this.logger = opts == null ? void 0 : opts.logger;\n    this.headers = (opts == null ? void 0 : opts.headers) || {};\n    this.headers[\"User-Agent\"] = `e2b-js-sdk/${version}`;\n    this.apiUrl = this.debug ? \"http://localhost:3000\" : `https://api.${this.domain}`;\n  }\n  static get domain() {\n    return getEnvVar(\"E2B_DOMAIN\") || \"e2b.app\";\n  }\n  static get debug() {\n    return (getEnvVar(\"E2B_DEBUG\") || \"false\").toLowerCase() === \"true\";\n  }\n  static get apiKey() {\n    return getEnvVar(\"E2B_API_KEY\");\n  }\n  static get accessToken() {\n    return getEnvVar(\"E2B_ACCESS_TOKEN\");\n  }\n  getSignal(requestTimeoutMs) {\n    const timeout = requestTimeoutMs != null ? requestTimeoutMs : this.requestTimeoutMs;\n    return timeout ? AbortSignal.timeout(timeout) : void 0;\n  }\n};\nvar defaultUsername = \"user\";\n\n// src/sandbox/signature.ts\nasync function getSignature({\n  path: path2,\n  operation,\n  user,\n  expirationInSeconds,\n  envdAccessToken\n}) {\n  if (!envdAccessToken) {\n    throw new Error(\n      \"Access token is not set and signature cannot be generated!\"\n    );\n  }\n  const signatureExpiration = expirationInSeconds ? Math.floor(Date.now() / 1e3) + expirationInSeconds : null;\n  let signatureRaw;\n  if (signatureExpiration === null) {\n    signatureRaw = `${path2}:${operation}:${user}:${envdAccessToken}`;\n  } else {\n    signatureRaw = `${path2}:${operation}:${user}:${envdAccessToken}:${signatureExpiration.toString()}`;\n  }\n  const hashBase64 = await sha256(signatureRaw);\n  const signature = \"v1_\" + hashBase64.replace(/=+$/, \"\");\n  return {\n    signature,\n    expiration: signatureExpiration\n  };\n}\n\n// src/sandbox/filesystem/index.ts\n\n\n// src/envd/api.ts\n\n\nasync function handleEnvdApiError(res) {\n  var _a3;\n  if (!res.error) {\n    return;\n  }\n  const message = typeof res.error == \"string\" ? res.error : ((_a3 = res.error) == null ? void 0 : _a3.message) || await res.response.text();\n  switch (res.response.status) {\n    case 400:\n      return new InvalidArgumentError(message);\n    case 401:\n      return new AuthenticationError(message);\n    case 404:\n      return new NotFoundError(message);\n    case 429:\n      return new SandboxError(\n        `${res.response.status}: ${message}: The requests are being rate limited.`\n      );\n    case 502:\n      return formatSandboxTimeoutError(message);\n    case 507:\n      return new NotEnoughSpaceError(message);\n    default:\n      return new SandboxError(`${res.response.status}: ${message}`);\n  }\n}\nasync function handleProcessStartEvent(events) {\n  var _a3;\n  let startEvent;\n  try {\n    startEvent = (await events[Symbol.asyncIterator]().next()).value;\n  } catch (err) {\n    if (err instanceof _connectrpc_connect__WEBPACK_IMPORTED_MODULE_2__.ConnectError) {\n      if (err.code === _connectrpc_connect__WEBPACK_IMPORTED_MODULE_3__.Code.Unavailable) {\n        throw new NotFoundError(\"Sandbox is probably not running anymore\");\n      }\n    }\n    throw err;\n  }\n  if (((_a3 = startEvent.event) == null ? void 0 : _a3.event.case) !== \"start\") {\n    throw new Error(\"Expected start event\");\n  }\n  return startEvent.event.event.value.pid;\n}\nasync function handleWatchDirStartEvent(events) {\n  var _a3;\n  let startEvent;\n  try {\n    startEvent = (await events[Symbol.asyncIterator]().next()).value;\n  } catch (err) {\n    if (err instanceof _connectrpc_connect__WEBPACK_IMPORTED_MODULE_2__.ConnectError) {\n      if (err.code === _connectrpc_connect__WEBPACK_IMPORTED_MODULE_3__.Code.Unavailable) {\n        throw new NotFoundError(\"Sandbox is probably not running anymore\");\n      }\n    }\n    throw err;\n  }\n  if (((_a3 = startEvent.event) == null ? void 0 : _a3.case) !== \"start\") {\n    throw new Error(\"Expected start event\");\n  }\n  return startEvent.event.value;\n}\nvar EnvdApiClient = class {\n  constructor(config, metadata) {\n    this.api = (0,openapi_fetch__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n      baseUrl: config.apiUrl,\n      fetch: config == null ? void 0 : config.fetch,\n      headers: config == null ? void 0 : config.headers\n      // keepalive: true, // TODO: Return keepalive\n    });\n    this.version = metadata.version;\n    if (config.logger) {\n      this.api.use(createApiLogger(config.logger));\n    }\n  }\n};\n\n// src/envd/rpc.ts\n\nfunction handleRpcError(err) {\n  if (err instanceof _connectrpc_connect__WEBPACK_IMPORTED_MODULE_2__.ConnectError) {\n    switch (err.code) {\n      case _connectrpc_connect__WEBPACK_IMPORTED_MODULE_3__.Code.InvalidArgument:\n        return new InvalidArgumentError(err.message);\n      case _connectrpc_connect__WEBPACK_IMPORTED_MODULE_3__.Code.Unauthenticated:\n        return new AuthenticationError(err.message);\n      case _connectrpc_connect__WEBPACK_IMPORTED_MODULE_3__.Code.NotFound:\n        return new NotFoundError(err.message);\n      case _connectrpc_connect__WEBPACK_IMPORTED_MODULE_3__.Code.Unavailable:\n        return formatSandboxTimeoutError(err.message);\n      case _connectrpc_connect__WEBPACK_IMPORTED_MODULE_3__.Code.Canceled:\n        return new TimeoutError(\n          `${err.message}: This error is likely due to exceeding 'requestTimeoutMs'. You can pass the request timeout value as an option when making the request.`\n        );\n      case _connectrpc_connect__WEBPACK_IMPORTED_MODULE_3__.Code.DeadlineExceeded:\n        return new TimeoutError(\n          `${err.message}: This error is likely due to exceeding 'timeoutMs' \\u2014 the total time a long running request (like command execution or directory watch) can be active. It can be modified by passing 'timeoutMs' when making the request. Use '0' to disable the timeout.`\n        );\n      default:\n        return new SandboxError(`${err.code}: ${err.message}`);\n    }\n  }\n  return err;\n}\nfunction encode64(value) {\n  switch (runtime) {\n    case \"deno\":\n      return btoa(value);\n    case \"node\":\n      return Buffer.from(value).toString(\"base64\");\n    case \"bun\":\n      return Buffer.from(value).toString(\"base64\");\n    default:\n      return btoa(value);\n  }\n}\nfunction authenticationHeader(username) {\n  const value = `${username || defaultUsername}:`;\n  const encoded = encode64(value);\n  return { Authorization: `Basic ${encoded}` };\n}\n\n// src/envd/filesystem/filesystem_pb.ts\n\n\nvar file_filesystem_filesystem = /* @__PURE__ */ (0,_bufbuild_protobuf_codegenv2__WEBPACK_IMPORTED_MODULE_4__.fileDesc)(\n  \"ChtmaWxlc3lzdGVtL2ZpbGVzeXN0ZW0ucHJvdG8SCmZpbGVzeXN0ZW0iMgoLTW92ZVJlcXVlc3QSDgoGc291cmNlGAEgASgJEhMKC2Rlc3RpbmF0aW9uGAIgASgJIjQKDE1vdmVSZXNwb25zZRIkCgVlbnRyeRgBIAEoCzIVLmZpbGVzeXN0ZW0uRW50cnlJbmZvIh4KDk1ha2VEaXJSZXF1ZXN0EgwKBHBhdGgYASABKAkiNwoPTWFrZURpclJlc3BvbnNlEiQKBWVudHJ5GAEgASgLMhUuZmlsZXN5c3RlbS5FbnRyeUluZm8iHQoNUmVtb3ZlUmVxdWVzdBIMCgRwYXRoGAEgASgJIhAKDlJlbW92ZVJlc3BvbnNlIhsKC1N0YXRSZXF1ZXN0EgwKBHBhdGgYASABKAkiNAoMU3RhdFJlc3BvbnNlEiQKBWVudHJ5GAEgASgLMhUuZmlsZXN5c3RlbS5FbnRyeUluZm8i/QEKCUVudHJ5SW5mbxIMCgRuYW1lGAEgASgJEiIKBHR5cGUYAiABKA4yFC5maWxlc3lzdGVtLkZpbGVUeXBlEgwKBHBhdGgYAyABKAkSDAoEc2l6ZRgEIAEoAxIMCgRtb2RlGAUgASgNEhMKC3Blcm1pc3Npb25zGAYgASgJEg0KBW93bmVyGAcgASgJEg0KBWdyb3VwGAggASgJEjEKDW1vZGlmaWVkX3RpbWUYCSABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEhsKDnN5bWxpbmtfdGFyZ2V0GAogASgJSACIAQFCEQoPX3N5bWxpbmtfdGFyZ2V0Ii0KDkxpc3REaXJSZXF1ZXN0EgwKBHBhdGgYASABKAkSDQoFZGVwdGgYAiABKA0iOQoPTGlzdERpclJlc3BvbnNlEiYKB2VudHJpZXMYASADKAsyFS5maWxlc3lzdGVtLkVudHJ5SW5mbyIyCg9XYXRjaERpclJlcXVlc3QSDAoEcGF0aBgBIAEoCRIRCglyZWN1cnNpdmUYAiABKAgiRAoPRmlsZXN5c3RlbUV2ZW50EgwKBG5hbWUYASABKAkSIwoEdHlwZRgCIAEoDjIVLmZpbGVzeXN0ZW0uRXZlbnRUeXBlIuABChBXYXRjaERpclJlc3BvbnNlEjgKBXN0YXJ0GAEgASgLMicuZmlsZXN5c3RlbS5XYXRjaERpclJlc3BvbnNlLlN0YXJ0RXZlbnRIABIxCgpmaWxlc3lzdGVtGAIgASgLMhsuZmlsZXN5c3RlbS5GaWxlc3lzdGVtRXZlbnRIABI7CglrZWVwYWxpdmUYAyABKAsyJi5maWxlc3lzdGVtLldhdGNoRGlyUmVzcG9uc2UuS2VlcEFsaXZlSAAaDAoKU3RhcnRFdmVudBoLCglLZWVwQWxpdmVCBwoFZXZlbnQiNwoUQ3JlYXRlV2F0Y2hlclJlcXVlc3QSDAoEcGF0aBgBIAEoCRIRCglyZWN1cnNpdmUYAiABKAgiKwoVQ3JlYXRlV2F0Y2hlclJlc3BvbnNlEhIKCndhdGNoZXJfaWQYASABKAkiLQoXR2V0V2F0Y2hlckV2ZW50c1JlcXVlc3QSEgoKd2F0Y2hlcl9pZBgBIAEoCSJHChhHZXRXYXRjaGVyRXZlbnRzUmVzcG9uc2USKwoGZXZlbnRzGAEgAygLMhsuZmlsZXN5c3RlbS5GaWxlc3lzdGVtRXZlbnQiKgoUUmVtb3ZlV2F0Y2hlclJlcXVlc3QSEgoKd2F0Y2hlcl9pZBgBIAEoCSIXChVSZW1vdmVXYXRjaGVyUmVzcG9uc2UqUgoIRmlsZVR5cGUSGQoVRklMRV9UWVBFX1VOU1BFQ0lGSUVEEAASEgoORklMRV9UWVBFX0ZJTEUQARIXChNGSUxFX1RZUEVfRElSRUNUT1JZEAIqmAEKCUV2ZW50VHlwZRIaChZFVkVOVF9UWVBFX1VOU1BFQ0lGSUVEEAASFQoRRVZFTlRfVFlQRV9DUkVBVEUQARIUChBFVkVOVF9UWVBFX1dSSVRFEAISFQoRRVZFTlRfVFlQRV9SRU1PVkUQAxIVChFFVkVOVF9UWVBFX1JFTkFNRRAEEhQKEEVWRU5UX1RZUEVfQ0hNT0QQBTKfBQoKRmlsZXN5c3RlbRI5CgRTdGF0EhcuZmlsZXN5c3RlbS5TdGF0UmVxdWVzdBoYLmZpbGVzeXN0ZW0uU3RhdFJlc3BvbnNlEkIKB01ha2VEaXISGi5maWxlc3lzdGVtLk1ha2VEaXJSZXF1ZXN0GhsuZmlsZXN5c3RlbS5NYWtlRGlyUmVzcG9uc2USOQoETW92ZRIXLmZpbGVzeXN0ZW0uTW92ZVJlcXVlc3QaGC5maWxlc3lzdGVtLk1vdmVSZXNwb25zZRJCCgdMaXN0RGlyEhouZmlsZXN5c3RlbS5MaXN0RGlyUmVxdWVzdBobLmZpbGVzeXN0ZW0uTGlzdERpclJlc3BvbnNlEj8KBlJlbW92ZRIZLmZpbGVzeXN0ZW0uUmVtb3ZlUmVxdWVzdBoaLmZpbGVzeXN0ZW0uUmVtb3ZlUmVzcG9uc2USRwoIV2F0Y2hEaXISGy5maWxlc3lzdGVtLldhdGNoRGlyUmVxdWVzdBocLmZpbGVzeXN0ZW0uV2F0Y2hEaXJSZXNwb25zZTABElQKDUNyZWF0ZVdhdGNoZXISIC5maWxlc3lzdGVtLkNyZWF0ZVdhdGNoZXJSZXF1ZXN0GiEuZmlsZXN5c3RlbS5DcmVhdGVXYXRjaGVyUmVzcG9uc2USXQoQR2V0V2F0Y2hlckV2ZW50cxIjLmZpbGVzeXN0ZW0uR2V0V2F0Y2hlckV2ZW50c1JlcXVlc3QaJC5maWxlc3lzdGVtLkdldFdhdGNoZXJFdmVudHNSZXNwb25zZRJUCg1SZW1vdmVXYXRjaGVyEiAuZmlsZXN5c3RlbS5SZW1vdmVXYXRjaGVyUmVxdWVzdBohLmZpbGVzeXN0ZW0uUmVtb3ZlV2F0Y2hlclJlc3BvbnNlQmkKDmNvbS5maWxlc3lzdGVtQg9GaWxlc3lzdGVtUHJvdG9QAaICA0ZYWKoCCkZpbGVzeXN0ZW3KAgpGaWxlc3lzdGVt4gIWRmlsZXN5c3RlbVxHUEJNZXRhZGF0YeoCCkZpbGVzeXN0ZW1iBnByb3RvMw\",\n  [_bufbuild_protobuf_wkt__WEBPACK_IMPORTED_MODULE_5__.file_google_protobuf_timestamp]\n);\nvar Filesystem = /* @__PURE__ */ (0,_bufbuild_protobuf_codegenv2__WEBPACK_IMPORTED_MODULE_6__.serviceDesc)(file_filesystem_filesystem, 0);\n\n// src/sandbox/filesystem/watchHandle.ts\nvar FilesystemEventType = /* @__PURE__ */ ((FilesystemEventType2) => {\n  FilesystemEventType2[\"CHMOD\"] = \"chmod\";\n  FilesystemEventType2[\"CREATE\"] = \"create\";\n  FilesystemEventType2[\"REMOVE\"] = \"remove\";\n  FilesystemEventType2[\"RENAME\"] = \"rename\";\n  FilesystemEventType2[\"WRITE\"] = \"write\";\n  return FilesystemEventType2;\n})(FilesystemEventType || {});\nfunction mapEventType(type) {\n  switch (type) {\n    case 5 /* CHMOD */:\n      return \"chmod\" /* CHMOD */;\n    case 1 /* CREATE */:\n      return \"create\" /* CREATE */;\n    case 3 /* REMOVE */:\n      return \"remove\" /* REMOVE */;\n    case 4 /* RENAME */:\n      return \"rename\" /* RENAME */;\n    case 2 /* WRITE */:\n      return \"write\" /* WRITE */;\n  }\n}\nvar WatchHandle = class {\n  constructor(handleStop, events, onEvent, onExit) {\n    this.handleStop = handleStop;\n    this.events = events;\n    this.onEvent = onEvent;\n    this.onExit = onExit;\n    this.handleEvents();\n  }\n  /**\n   * Stop watching the directory.\n   */\n  async stop() {\n    this.handleStop();\n  }\n  iterateEvents() {\n    return __asyncGenerator(this, null, function* () {\n      try {\n        try {\n          for (var iter = __forAwait(this.events), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {\n            const event = temp.value;\n            switch (event.event.case) {\n              case \"filesystem\":\n                yield event.event;\n                break;\n            }\n          }\n        } catch (temp) {\n          error = [temp];\n        } finally {\n          try {\n            more && (temp = iter.return) && (yield new __await(temp.call(iter)));\n          } finally {\n            if (error)\n              throw error[0];\n          }\n        }\n      } catch (err) {\n        throw handleRpcError(err);\n      }\n    });\n  }\n  async handleEvents() {\n    var _a3, _b, _c;\n    try {\n      try {\n        for (var iter = __forAwait(this.iterateEvents()), more, temp, error; more = !(temp = await iter.next()).done; more = false) {\n          const event = temp.value;\n          const eventType = mapEventType(event.value.type);\n          if (eventType === void 0) {\n            continue;\n          }\n          (_a3 = this.onEvent) == null ? void 0 : _a3.call(this, {\n            name: event.value.name,\n            type: eventType\n          });\n        }\n      } catch (temp) {\n        error = [temp];\n      } finally {\n        try {\n          more && (temp = iter.return) && await temp.call(iter);\n        } finally {\n          if (error)\n            throw error[0];\n        }\n      }\n      (_b = this.onExit) == null ? void 0 : _b.call(this);\n    } catch (err) {\n      (_c = this.onExit) == null ? void 0 : _c.call(this, err);\n    }\n  }\n};\n\n// src/sandbox/filesystem/index.ts\n\n\n// src/envd/versions.ts\nvar ENVD_VERSION_RECURSIVE_WATCH = \"0.1.4\";\n\n// src/sandbox/filesystem/index.ts\nvar FileType2 = /* @__PURE__ */ ((FileType3) => {\n  FileType3[\"FILE\"] = \"file\";\n  FileType3[\"DIR\"] = \"dir\";\n  return FileType3;\n})(FileType2 || {});\nfunction mapFileType(fileType) {\n  switch (fileType) {\n    case 2 /* DIRECTORY */:\n      return \"dir\" /* DIR */;\n    case 1 /* FILE */:\n      return \"file\" /* FILE */;\n  }\n}\nfunction mapModifiedTime(modifiedTime) {\n  if (!modifiedTime) return void 0;\n  return new Date(\n    Number(modifiedTime.seconds) * 1e3 + Math.floor(modifiedTime.nanos / 1e6)\n  );\n}\nvar Filesystem2 = class {\n  constructor(transport, envdApi, connectionConfig) {\n    this.envdApi = envdApi;\n    this.connectionConfig = connectionConfig;\n    this.defaultWatchTimeout = 6e4;\n    // 60 seconds\n    this.defaultWatchRecursive = false;\n    this.rpc = (0,_connectrpc_connect__WEBPACK_IMPORTED_MODULE_7__.createClient)(Filesystem, transport);\n  }\n  async read(path2, opts) {\n    var _a3;\n    const format = (_a3 = opts == null ? void 0 : opts.format) != null ? _a3 : \"text\";\n    const res = await this.envdApi.api.GET(\"/files\", {\n      params: {\n        query: {\n          path: path2,\n          username: (opts == null ? void 0 : opts.user) || defaultUsername\n        }\n      },\n      parseAs: format === \"bytes\" ? \"arrayBuffer\" : format,\n      signal: this.connectionConfig.getSignal(opts == null ? void 0 : opts.requestTimeoutMs)\n    });\n    const err = await handleEnvdApiError(res);\n    if (err) {\n      throw err;\n    }\n    if (format === \"bytes\") {\n      return new Uint8Array(res.data);\n    }\n    if (res.response.headers.get(\"content-length\") === \"0\") {\n      return \"\";\n    }\n    return res.data;\n  }\n  async write(pathOrFiles, dataOrOpts, opts) {\n    if (typeof pathOrFiles !== \"string\" && !Array.isArray(pathOrFiles)) {\n      throw new Error(\"Path or files are required\");\n    }\n    if (typeof pathOrFiles === \"string\" && Array.isArray(dataOrOpts)) {\n      throw new Error(\n        \"Cannot specify both path and array of files. You have to specify either path and data for a single file or an array for multiple files.\"\n      );\n    }\n    const { path: path2, writeOpts, writeFiles } = typeof pathOrFiles === \"string\" ? {\n      path: pathOrFiles,\n      writeOpts: opts,\n      writeFiles: [\n        {\n          data: dataOrOpts\n        }\n      ]\n    } : {\n      path: void 0,\n      writeOpts: dataOrOpts,\n      writeFiles: pathOrFiles\n    };\n    if (writeFiles.length === 0) return [];\n    const blobs = await Promise.all(\n      writeFiles.map((f) => new Response(f.data).blob())\n    );\n    const res = await this.envdApi.api.POST(\"/files\", {\n      params: {\n        query: {\n          path: path2,\n          username: (writeOpts == null ? void 0 : writeOpts.user) || defaultUsername\n        }\n      },\n      bodySerializer() {\n        return blobs.reduce((fd, blob, i) => {\n          fd.append(\"file\", blob, writeFiles[i].path);\n          return fd;\n        }, new FormData());\n      },\n      body: {},\n      headers: {\n        \"Content-Type\": \"multipart/form-data\",\n        \"Bun-Content-Type\": \"temporary-fix\"\n        // https://github.com/oven-sh/bun/issues/14988\n      }\n    });\n    const err = await handleEnvdApiError(res);\n    if (err) {\n      throw err;\n    }\n    const files = res.data;\n    if (!files) {\n      throw new Error(\"Expected to receive information about written file\");\n    }\n    return files.length === 1 && path2 ? files[0] : files;\n  }\n  /**\n   * List entries in a directory.\n   *\n   * @param path path to the directory.\n   * @param opts connection options.\n   *\n   * @returns list of entries in the sandbox filesystem directory.\n   */\n  async list(path2, opts) {\n    var _a3;\n    if (typeof (opts == null ? void 0 : opts.depth) === \"number\" && opts.depth < 1) {\n      throw new InvalidArgumentError(\"depth should be at least one\");\n    }\n    try {\n      const res = await this.rpc.listDir(\n        {\n          path: path2,\n          depth: (_a3 = opts == null ? void 0 : opts.depth) != null ? _a3 : 1\n        },\n        {\n          headers: authenticationHeader(opts == null ? void 0 : opts.user),\n          signal: this.connectionConfig.getSignal(opts == null ? void 0 : opts.requestTimeoutMs)\n        }\n      );\n      const entries = [];\n      for (const e of res.entries) {\n        const type = mapFileType(e.type);\n        if (type) {\n          entries.push({\n            name: e.name,\n            type,\n            path: e.path,\n            size: Number(e.size),\n            mode: e.mode,\n            permissions: e.permissions,\n            owner: e.owner,\n            group: e.group,\n            modifiedTime: mapModifiedTime(e.modifiedTime),\n            symlinkTarget: e.symlinkTarget\n          });\n        }\n      }\n      return entries;\n    } catch (err) {\n      throw handleRpcError(err);\n    }\n  }\n  /**\n   * Create a new directory and all directories along the way if needed on the specified path.\n   *\n   * @param path path to a new directory. For example '/dirA/dirB' when creating 'dirB'.\n   * @param opts connection options.\n   *\n   * @returns `true` if the directory was created, `false` if it already exists.\n   */\n  async makeDir(path2, opts) {\n    try {\n      await this.rpc.makeDir(\n        { path: path2 },\n        {\n          headers: authenticationHeader(opts == null ? void 0 : opts.user),\n          signal: this.connectionConfig.getSignal(opts == null ? void 0 : opts.requestTimeoutMs)\n        }\n      );\n      return true;\n    } catch (err) {\n      if (err instanceof _connectrpc_connect__WEBPACK_IMPORTED_MODULE_2__.ConnectError) {\n        if (err.code === _connectrpc_connect__WEBPACK_IMPORTED_MODULE_3__.Code.AlreadyExists) {\n          return false;\n        }\n      }\n      throw handleRpcError(err);\n    }\n  }\n  /**\n   * Rename a file or directory.\n   *\n   * @param oldPath path to the file or directory to rename.\n   * @param newPath new path for the file or directory.\n   * @param opts connection options.\n   *\n   * @returns information about renamed file or directory.\n   */\n  async rename(oldPath, newPath, opts) {\n    try {\n      const res = await this.rpc.move(\n        {\n          source: oldPath,\n          destination: newPath\n        },\n        {\n          headers: authenticationHeader(opts == null ? void 0 : opts.user),\n          signal: this.connectionConfig.getSignal(opts == null ? void 0 : opts.requestTimeoutMs)\n        }\n      );\n      const entry = res.entry;\n      if (!entry) {\n        throw new Error(\"Expected to receive information about moved object\");\n      }\n      return {\n        name: entry.name,\n        type: mapFileType(entry.type),\n        path: entry.path,\n        size: Number(entry.size),\n        mode: entry.mode,\n        permissions: entry.permissions,\n        owner: entry.owner,\n        group: entry.group,\n        modifiedTime: mapModifiedTime(entry.modifiedTime),\n        symlinkTarget: entry.symlinkTarget\n      };\n    } catch (err) {\n      throw handleRpcError(err);\n    }\n  }\n  /**\n   * Remove a file or directory.\n   *\n   * @param path path to a file or directory.\n   * @param opts connection options.\n   */\n  async remove(path2, opts) {\n    try {\n      await this.rpc.remove(\n        { path: path2 },\n        {\n          headers: authenticationHeader(opts == null ? void 0 : opts.user),\n          signal: this.connectionConfig.getSignal(opts == null ? void 0 : opts.requestTimeoutMs)\n        }\n      );\n    } catch (err) {\n      throw handleRpcError(err);\n    }\n  }\n  /**\n   * Check if a file or a directory exists.\n   *\n   * @param path path to a file or a directory\n   * @param opts connection options.\n   *\n   * @returns `true` if the file or directory exists, `false` otherwise\n   */\n  async exists(path2, opts) {\n    try {\n      await this.rpc.stat(\n        { path: path2 },\n        {\n          headers: authenticationHeader(opts == null ? void 0 : opts.user),\n          signal: this.connectionConfig.getSignal(opts == null ? void 0 : opts.requestTimeoutMs)\n        }\n      );\n      return true;\n    } catch (err) {\n      if (err instanceof _connectrpc_connect__WEBPACK_IMPORTED_MODULE_2__.ConnectError) {\n        if (err.code === _connectrpc_connect__WEBPACK_IMPORTED_MODULE_3__.Code.NotFound) {\n          return false;\n        }\n      }\n      throw handleRpcError(err);\n    }\n  }\n  /**\n   * Get information about a file or directory.\n   *\n   * @param path path to a file or directory.\n   * @param opts connection options.\n   *\n   * @returns information about the file or directory like name, type, and path.\n   */\n  async getInfo(path2, opts) {\n    try {\n      const res = await this.rpc.stat(\n        { path: path2 },\n        { headers: authenticationHeader(opts == null ? void 0 : opts.user) }\n      );\n      if (!res.entry) {\n        throw new Error(\n          \"Expected to receive information about the file or directory\"\n        );\n      }\n      return {\n        name: res.entry.name,\n        type: mapFileType(res.entry.type),\n        path: res.entry.path,\n        size: Number(res.entry.size),\n        mode: res.entry.mode,\n        permissions: res.entry.permissions,\n        owner: res.entry.owner,\n        group: res.entry.group,\n        modifiedTime: mapModifiedTime(res.entry.modifiedTime),\n        symlinkTarget: res.entry.symlinkTarget\n      };\n    } catch (err) {\n      throw handleRpcError(err);\n    }\n  }\n  /**\n   * Start watching a directory for filesystem events.\n   *\n   * @param path path to directory to watch.\n   * @param onEvent callback to call when an event in the directory occurs.\n   * @param opts connection options.\n   *\n   * @returns `WatchHandle` object for stopping watching directory.\n   */\n  async watchDir(path2, onEvent, opts) {\n    var _a3, _b, _c;\n    if ((opts == null ? void 0 : opts.recursive) && this.envdApi.version && (0,compare_versions__WEBPACK_IMPORTED_MODULE_8__.compareVersions)(this.envdApi.version, ENVD_VERSION_RECURSIVE_WATCH) < 0) {\n      throw new TemplateError(\n        \"You need to update the template to use recursive watching. You can do this by running `e2b template build` in the directory with the template.\"\n      );\n    }\n    const requestTimeoutMs = (_a3 = opts == null ? void 0 : opts.requestTimeoutMs) != null ? _a3 : this.connectionConfig.requestTimeoutMs;\n    const controller = new AbortController();\n    const reqTimeout = requestTimeoutMs ? setTimeout(() => {\n      controller.abort();\n    }, requestTimeoutMs) : void 0;\n    const events = this.rpc.watchDir(\n      {\n        path: path2,\n        recursive: (_b = opts == null ? void 0 : opts.recursive) != null ? _b : this.defaultWatchRecursive\n      },\n      {\n        headers: __spreadProps(__spreadValues({}, authenticationHeader(opts == null ? void 0 : opts.user)), {\n          [KEEPALIVE_PING_HEADER]: KEEPALIVE_PING_INTERVAL_SEC.toString()\n        }),\n        signal: controller.signal,\n        timeoutMs: (_c = opts == null ? void 0 : opts.timeoutMs) != null ? _c : this.defaultWatchTimeout\n      }\n    );\n    try {\n      await handleWatchDirStartEvent(events);\n      clearTimeout(reqTimeout);\n      return new WatchHandle(\n        () => controller.abort(),\n        events,\n        onEvent,\n        opts == null ? void 0 : opts.onExit\n      );\n    } catch (err) {\n      throw handleRpcError(err);\n    }\n  }\n};\n\n// src/sandbox/commands/commandHandle.ts\nvar CommandExitError = class extends SandboxError {\n  constructor(result) {\n    super(result.error);\n    this.result = result;\n    this.name = \"CommandExitError\";\n  }\n  /**\n   * Command execution exit code.\n   * `0` if the command finished successfully.\n   */\n  get exitCode() {\n    return this.result.exitCode;\n  }\n  /**\n   * Error message from command execution.\n   */\n  get error() {\n    return this.result.error;\n  }\n  /**\n   * Command execution stdout output.\n   */\n  get stdout() {\n    return this.result.stdout;\n  }\n  /**\n   * Command execution stderr output.\n   */\n  get stderr() {\n    return this.result.stderr;\n  }\n};\nvar CommandHandle = class {\n  /**\n   * @hidden\n   * @internal\n   * @access protected\n   */\n  constructor(pid, handleDisconnect, handleKill, events, onStdout, onStderr, onPty) {\n    this.pid = pid;\n    this.handleDisconnect = handleDisconnect;\n    this.handleKill = handleKill;\n    this.events = events;\n    this.onStdout = onStdout;\n    this.onStderr = onStderr;\n    this.onPty = onPty;\n    this._stdout = \"\";\n    this._stderr = \"\";\n    this._wait = this.handleEvents();\n  }\n  /**\n   * Command execution exit code.\n   * `0` if the command finished successfully.\n   *\n   * It is `undefined` if the command is still running.\n   */\n  get exitCode() {\n    var _a3;\n    return (_a3 = this.result) == null ? void 0 : _a3.exitCode;\n  }\n  /**\n   * Error message from command execution.\n   */\n  get error() {\n    var _a3;\n    return (_a3 = this.result) == null ? void 0 : _a3.error;\n  }\n  /**\n   * Command execution stderr output.\n   */\n  get stderr() {\n    return this._stderr;\n  }\n  /**\n   * Command execution stdout output.\n   */\n  get stdout() {\n    return this._stdout;\n  }\n  /**\n   * Wait for the command to finish and return the result.\n   * If the command exits with a non-zero exit code, it throws a `CommandExitError`.\n   *\n   * @returns `CommandResult` result of command execution.\n   */\n  async wait() {\n    await this._wait;\n    if (this.iterationError) {\n      throw this.iterationError;\n    }\n    if (!this.result) {\n      throw new SandboxError(\"Process exited without a result\");\n    }\n    if (this.result.exitCode !== 0) {\n      throw new CommandExitError(this.result);\n    }\n    return this.result;\n  }\n  /**\n   * Disconnect from the command.\n   *\n   * The command is not killed, but SDK stops receiving events from the command.\n   * You can reconnect to the command using {@link Commands.connect}.\n   */\n  async disconnect() {\n    this.handleDisconnect();\n  }\n  /**\n   * Kill the command.\n   * It uses `SIGKILL` signal to kill the command.\n   *\n   * @returns `true` if the command was killed successfully, `false` if the command was not found.\n   */\n  async kill() {\n    return await this.handleKill();\n  }\n  iterateEvents() {\n    return __asyncGenerator(this, null, function* () {\n      var _a3;\n      try {\n        for (var iter = __forAwait(this.events), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {\n          const event = temp.value;\n          const e = (_a3 = event == null ? void 0 : event.event) == null ? void 0 : _a3.event;\n          let out;\n          switch (e == null ? void 0 : e.case) {\n            case \"data\":\n              switch (e.value.output.case) {\n                case \"stdout\":\n                  out = new TextDecoder().decode(e.value.output.value);\n                  this._stdout += out;\n                  yield [out, null, null];\n                  break;\n                case \"stderr\":\n                  out = new TextDecoder().decode(e.value.output.value);\n                  this._stderr += out;\n                  yield [null, out, null];\n                  break;\n                case \"pty\":\n                  yield [null, null, e.value.output.value];\n                  break;\n              }\n              break;\n            case \"end\":\n              this.result = {\n                exitCode: e.value.exitCode,\n                error: e.value.error,\n                stdout: this.stdout,\n                stderr: this.stderr\n              };\n              break;\n          }\n        }\n      } catch (temp) {\n        error = [temp];\n      } finally {\n        try {\n          more && (temp = iter.return) && (yield new __await(temp.call(iter)));\n        } finally {\n          if (error)\n            throw error[0];\n        }\n      }\n    });\n  }\n  async handleEvents() {\n    var _a3, _b, _c;\n    try {\n      try {\n        for (var iter = __forAwait(this.iterateEvents()), more, temp, error; more = !(temp = await iter.next()).done; more = false) {\n          const [stdout, stderr, pty] = temp.value;\n          if (stdout !== null) {\n            (_a3 = this.onStdout) == null ? void 0 : _a3.call(this, stdout);\n          } else if (stderr !== null) {\n            (_b = this.onStderr) == null ? void 0 : _b.call(this, stderr);\n          } else if (pty) {\n            (_c = this.onPty) == null ? void 0 : _c.call(this, pty);\n          }\n        }\n      } catch (temp) {\n        error = [temp];\n      } finally {\n        try {\n          more && (temp = iter.return) && await temp.call(iter);\n        } finally {\n          if (error)\n            throw error[0];\n        }\n      }\n    } catch (e) {\n      this.iterationError = handleRpcError(e);\n    }\n  }\n};\n\n// src/sandbox/index.ts\n\n\n// src/sandbox/commands/index.ts\n\n\n// src/envd/process/process_pb.ts\n\nvar file_process_process = /* @__PURE__ */ (0,_bufbuild_protobuf_codegenv2__WEBPACK_IMPORTED_MODULE_4__.fileDesc)(\n  \"ChVwcm9jZXNzL3Byb2Nlc3MucHJvdG8SB3Byb2Nlc3MiSgoDUFRZEh8KBHNpemUYASABKAsyES5wcm9jZXNzLlBUWS5TaXplGiIKBFNpemUSDAoEY29scxgBIAEoDRIMCgRyb3dzGAIgASgNIqEBCg1Qcm9jZXNzQ29uZmlnEgsKA2NtZBgBIAEoCRIMCgRhcmdzGAIgAygJEi4KBGVudnMYAyADKAsyIC5wcm9jZXNzLlByb2Nlc3NDb25maWcuRW52c0VudHJ5EhAKA2N3ZBgEIAEoCUgAiAEBGisKCUVudnNFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBQgYKBF9jd2QiDQoLTGlzdFJlcXVlc3QiXAoLUHJvY2Vzc0luZm8SJgoGY29uZmlnGAEgASgLMhYucHJvY2Vzcy5Qcm9jZXNzQ29uZmlnEgsKA3BpZBgCIAEoDRIQCgN0YWcYAyABKAlIAIgBAUIGCgRfdGFnIjcKDExpc3RSZXNwb25zZRInCglwcm9jZXNzZXMYASADKAsyFC5wcm9jZXNzLlByb2Nlc3NJbmZvInkKDFN0YXJ0UmVxdWVzdBInCgdwcm9jZXNzGAEgASgLMhYucHJvY2Vzcy5Qcm9jZXNzQ29uZmlnEh4KA3B0eRgCIAEoCzIMLnByb2Nlc3MuUFRZSACIAQESEAoDdGFnGAMgASgJSAGIAQFCBgoEX3B0eUIGCgRfdGFnImIKDVVwZGF0ZVJlcXVlc3QSKQoHcHJvY2VzcxgBIAEoCzIYLnByb2Nlc3MuUHJvY2Vzc1NlbGVjdG9yEh4KA3B0eRgCIAEoCzIMLnByb2Nlc3MuUFRZSACIAQFCBgoEX3B0eSIQCg5VcGRhdGVSZXNwb25zZSKvAwoMUHJvY2Vzc0V2ZW50EjEKBXN0YXJ0GAEgASgLMiAucHJvY2Vzcy5Qcm9jZXNzRXZlbnQuU3RhcnRFdmVudEgAEi8KBGRhdGEYAiABKAsyHy5wcm9jZXNzLlByb2Nlc3NFdmVudC5EYXRhRXZlbnRIABItCgNlbmQYAyABKAsyHi5wcm9jZXNzLlByb2Nlc3NFdmVudC5FbmRFdmVudEgAEjQKCWtlZXBhbGl2ZRgEIAEoCzIfLnByb2Nlc3MuUHJvY2Vzc0V2ZW50LktlZXBBbGl2ZUgAGhkKClN0YXJ0RXZlbnQSCwoDcGlkGAEgASgNGkgKCURhdGFFdmVudBIQCgZzdGRvdXQYASABKAxIABIQCgZzdGRlcnIYAiABKAxIABINCgNwdHkYAyABKAxIAEIICgZvdXRwdXQaWwoIRW5kRXZlbnQSEQoJZXhpdF9jb2RlGAEgASgREg4KBmV4aXRlZBgCIAEoCBIOCgZzdGF0dXMYAyABKAkSEgoFZXJyb3IYBCABKAlIAIgBAUIICgZfZXJyb3IaCwoJS2VlcEFsaXZlQgcKBWV2ZW50IjUKDVN0YXJ0UmVzcG9uc2USJAoFZXZlbnQYASABKAsyFS5wcm9jZXNzLlByb2Nlc3NFdmVudCI3Cg9Db25uZWN0UmVzcG9uc2USJAoFZXZlbnQYASABKAsyFS5wcm9jZXNzLlByb2Nlc3NFdmVudCJjChBTZW5kSW5wdXRSZXF1ZXN0EikKB3Byb2Nlc3MYASABKAsyGC5wcm9jZXNzLlByb2Nlc3NTZWxlY3RvchIkCgVpbnB1dBgCIAEoCzIVLnByb2Nlc3MuUHJvY2Vzc0lucHV0IhMKEVNlbmRJbnB1dFJlc3BvbnNlIjcKDFByb2Nlc3NJbnB1dBIPCgVzdGRpbhgBIAEoDEgAEg0KA3B0eRgCIAEoDEgAQgcKBWlucHV0IsICChJTdHJlYW1JbnB1dFJlcXVlc3QSNwoFc3RhcnQYASABKAsyJi5wcm9jZXNzLlN0cmVhbUlucHV0UmVxdWVzdC5TdGFydEV2ZW50SAASNQoEZGF0YRgCIAEoCzIlLnByb2Nlc3MuU3RyZWFtSW5wdXRSZXF1ZXN0LkRhdGFFdmVudEgAEjoKCWtlZXBhbGl2ZRgDIAEoCzIlLnByb2Nlc3MuU3RyZWFtSW5wdXRSZXF1ZXN0LktlZXBBbGl2ZUgAGjcKClN0YXJ0RXZlbnQSKQoHcHJvY2VzcxgBIAEoCzIYLnByb2Nlc3MuUHJvY2Vzc1NlbGVjdG9yGjEKCURhdGFFdmVudBIkCgVpbnB1dBgCIAEoCzIVLnByb2Nlc3MuUHJvY2Vzc0lucHV0GgsKCUtlZXBBbGl2ZUIHCgVldmVudCIVChNTdHJlYW1JbnB1dFJlc3BvbnNlIl8KEVNlbmRTaWduYWxSZXF1ZXN0EikKB3Byb2Nlc3MYASABKAsyGC5wcm9jZXNzLlByb2Nlc3NTZWxlY3RvchIfCgZzaWduYWwYAiABKA4yDy5wcm9jZXNzLlNpZ25hbCIUChJTZW5kU2lnbmFsUmVzcG9uc2UiOwoOQ29ubmVjdFJlcXVlc3QSKQoHcHJvY2VzcxgBIAEoCzIYLnByb2Nlc3MuUHJvY2Vzc1NlbGVjdG9yIjsKD1Byb2Nlc3NTZWxlY3RvchINCgNwaWQYASABKA1IABINCgN0YWcYAiABKAlIAEIKCghzZWxlY3RvcipICgZTaWduYWwSFgoSU0lHTkFMX1VOU1BFQ0lGSUVEEAASEgoOU0lHTkFMX1NJR1RFUk0QDxISCg5TSUdOQUxfU0lHS0lMTBAJMsoDCgdQcm9jZXNzEjMKBExpc3QSFC5wcm9jZXNzLkxpc3RSZXF1ZXN0GhUucHJvY2Vzcy5MaXN0UmVzcG9uc2USPgoHQ29ubmVjdBIXLnByb2Nlc3MuQ29ubmVjdFJlcXVlc3QaGC5wcm9jZXNzLkNvbm5lY3RSZXNwb25zZTABEjgKBVN0YXJ0EhUucHJvY2Vzcy5TdGFydFJlcXVlc3QaFi5wcm9jZXNzLlN0YXJ0UmVzcG9uc2UwARI5CgZVcGRhdGUSFi5wcm9jZXNzLlVwZGF0ZVJlcXVlc3QaFy5wcm9jZXNzLlVwZGF0ZVJlc3BvbnNlEkoKC1N0cmVhbUlucHV0EhsucHJvY2Vzcy5TdHJlYW1JbnB1dFJlcXVlc3QaHC5wcm9jZXNzLlN0cmVhbUlucHV0UmVzcG9uc2UoARJCCglTZW5kSW5wdXQSGS5wcm9jZXNzLlNlbmRJbnB1dFJlcXVlc3QaGi5wcm9jZXNzLlNlbmRJbnB1dFJlc3BvbnNlEkUKClNlbmRTaWduYWwSGi5wcm9jZXNzLlNlbmRTaWduYWxSZXF1ZXN0GhsucHJvY2Vzcy5TZW5kU2lnbmFsUmVzcG9uc2VCVwoLY29tLnByb2Nlc3NCDFByb2Nlc3NQcm90b1ABogIDUFhYqgIHUHJvY2Vzc8oCB1Byb2Nlc3PiAhNQcm9jZXNzXEdQQk1ldGFkYXRh6gIHUHJvY2Vzc2IGcHJvdG8z\"\n);\nvar Process = /* @__PURE__ */ (0,_bufbuild_protobuf_codegenv2__WEBPACK_IMPORTED_MODULE_6__.serviceDesc)(file_process_process, 0);\n\n// src/sandbox/commands/pty.ts\n\nvar Pty = class {\n  constructor(transport, connectionConfig) {\n    this.transport = transport;\n    this.connectionConfig = connectionConfig;\n    this.rpc = (0,_connectrpc_connect__WEBPACK_IMPORTED_MODULE_7__.createClient)(Process, this.transport);\n  }\n  /**\n   * Create a new PTY (pseudo-terminal).\n   *\n   * @param opts options for creating the PTY.\n   *\n   * @returns handle to interact with the PTY.\n   */\n  async create(opts) {\n    var _a3, _b, _c;\n    const requestTimeoutMs = (_a3 = opts == null ? void 0 : opts.requestTimeoutMs) != null ? _a3 : this.connectionConfig.requestTimeoutMs;\n    const envs = (_b = opts == null ? void 0 : opts.envs) != null ? _b : {};\n    envs.TERM = \"xterm-256color\";\n    const controller = new AbortController();\n    const reqTimeout = setTimeout(() => {\n      controller.abort();\n    }, requestTimeoutMs);\n    const events = this.rpc.start(\n      {\n        process: {\n          cmd: \"/bin/bash\",\n          args: [\"-i\", \"-l\"],\n          envs,\n          cwd: opts == null ? void 0 : opts.cwd\n        },\n        pty: {\n          size: {\n            cols: opts.cols,\n            rows: opts.rows\n          }\n        }\n      },\n      {\n        headers: __spreadProps(__spreadValues({}, authenticationHeader(opts == null ? void 0 : opts.user)), {\n          [KEEPALIVE_PING_HEADER]: KEEPALIVE_PING_INTERVAL_SEC.toString()\n        }),\n        signal: controller.signal,\n        timeoutMs: (_c = opts == null ? void 0 : opts.timeoutMs) != null ? _c : 6e4\n      }\n    );\n    try {\n      const pid = await handleProcessStartEvent(events);\n      clearTimeout(reqTimeout);\n      return new CommandHandle(\n        pid,\n        () => controller.abort(),\n        () => this.kill(pid),\n        events,\n        void 0,\n        void 0,\n        opts.onData\n      );\n    } catch (err) {\n      throw handleRpcError(err);\n    }\n  }\n  /**\n   * Send input to a PTY.\n   *\n   * @param pid process ID of the PTY.\n   * @param data input data to send to the PTY.\n   * @param opts connection options.\n   */\n  async sendInput(pid, data, opts) {\n    try {\n      await this.rpc.sendInput(\n        {\n          input: {\n            input: {\n              case: \"pty\",\n              value: data\n            }\n          },\n          process: {\n            selector: {\n              case: \"pid\",\n              value: pid\n            }\n          }\n        },\n        {\n          signal: this.connectionConfig.getSignal(opts == null ? void 0 : opts.requestTimeoutMs)\n        }\n      );\n    } catch (err) {\n      throw handleRpcError(err);\n    }\n  }\n  /**\n   * Resize PTY.\n   * Call this when the terminal window is resized and the number of columns and rows has changed.\n   *\n   * @param pid process ID of the PTY.\n   * @param size new size of the PTY.\n   * @param opts connection options.\n   */\n  async resize(pid, size, opts) {\n    try {\n      await this.rpc.update(\n        {\n          process: {\n            selector: {\n              case: \"pid\",\n              value: pid\n            }\n          },\n          pty: {\n            size\n          }\n        },\n        {\n          signal: this.connectionConfig.getSignal(opts == null ? void 0 : opts.requestTimeoutMs)\n        }\n      );\n    } catch (err) {\n      throw handleRpcError(err);\n    }\n  }\n  /**\n   * Kill a running PTY specified by process ID.\n   * It uses `SIGKILL` signal to kill the PTY.\n   *\n   * @param pid process ID of the PTY.\n   * @param opts connection options.\n   *\n   * @returns `true` if the PTY was killed, `false` if the PTY was not found.\n   */\n  async kill(pid, opts) {\n    try {\n      await this.rpc.sendSignal(\n        {\n          process: {\n            selector: {\n              case: \"pid\",\n              value: pid\n            }\n          },\n          signal: 9 /* SIGKILL */\n        },\n        {\n          signal: this.connectionConfig.getSignal(opts == null ? void 0 : opts.requestTimeoutMs)\n        }\n      );\n      return true;\n    } catch (err) {\n      if (err instanceof _connectrpc_connect__WEBPACK_IMPORTED_MODULE_2__.ConnectError) {\n        if (err.code === _connectrpc_connect__WEBPACK_IMPORTED_MODULE_3__.Code.NotFound) {\n          return false;\n        }\n      }\n      throw handleRpcError(err);\n    }\n  }\n};\n\n// src/sandbox/commands/index.ts\nvar Commands = class {\n  // 60 seconds\n  constructor(transport, connectionConfig) {\n    this.connectionConfig = connectionConfig;\n    this.defaultProcessConnectionTimeout = 6e4;\n    this.rpc = (0,_connectrpc_connect__WEBPACK_IMPORTED_MODULE_7__.createClient)(Process, transport);\n  }\n  /**\n   * List all running commands and PTY sessions.\n   *\n   * @param opts connection options.\n   *\n   * @returns list of running commands and PTY sessions.\n   */\n  async list(opts) {\n    try {\n      const res = await this.rpc.list(\n        {},\n        {\n          signal: this.connectionConfig.getSignal(opts == null ? void 0 : opts.requestTimeoutMs)\n        }\n      );\n      return res.processes.map((p) => __spreadValues(__spreadProps(__spreadValues({\n        pid: p.pid\n      }, p.tag && { tag: p.tag }), {\n        args: p.config.args,\n        envs: p.config.envs,\n        cmd: p.config.cmd\n      }), p.config.cwd && { cwd: p.config.cwd }));\n    } catch (err) {\n      throw handleRpcError(err);\n    }\n  }\n  /**\n   * Send data to command stdin.\n   *\n   * @param pid process ID of the command. You can get the list of running commands using {@link Commands.list}.\n   * @param data data to send to the command.\n   * @param opts connection options.\n   */\n  async sendStdin(pid, data, opts) {\n    try {\n      await this.rpc.sendInput(\n        {\n          process: {\n            selector: {\n              case: \"pid\",\n              value: pid\n            }\n          },\n          input: {\n            input: {\n              case: \"stdin\",\n              value: new TextEncoder().encode(data)\n            }\n          }\n        },\n        {\n          signal: this.connectionConfig.getSignal(opts == null ? void 0 : opts.requestTimeoutMs)\n        }\n      );\n    } catch (err) {\n      throw handleRpcError(err);\n    }\n  }\n  /**\n   * Kill a running command specified by its process ID.\n   * It uses `SIGKILL` signal to kill the command.\n   *\n   * @param pid process ID of the command. You can get the list of running commands using {@link Commands.list}.\n   * @param opts connection options.\n   *\n   * @returns `true` if the command was killed, `false` if the command was not found.\n   */\n  async kill(pid, opts) {\n    try {\n      await this.rpc.sendSignal(\n        {\n          process: {\n            selector: {\n              case: \"pid\",\n              value: pid\n            }\n          },\n          signal: 9 /* SIGKILL */\n        },\n        {\n          signal: this.connectionConfig.getSignal(opts == null ? void 0 : opts.requestTimeoutMs)\n        }\n      );\n      return true;\n    } catch (err) {\n      if (err instanceof _connectrpc_connect__WEBPACK_IMPORTED_MODULE_2__.ConnectError) {\n        if (err.code === _connectrpc_connect__WEBPACK_IMPORTED_MODULE_3__.Code.NotFound) {\n          return false;\n        }\n      }\n      throw handleRpcError(err);\n    }\n  }\n  /**\n   * Connect to a running command.\n   * You can use {@link CommandHandle.wait} to wait for the command to finish and get execution results.\n   *\n   * @param pid process ID of the command to connect to. You can get the list of running commands using {@link Commands.list}.\n   * @param opts connection options.\n   *\n   * @returns `CommandHandle` handle to interact with the running command.\n   */\n  async connect(pid, opts) {\n    var _a3, _b;\n    const requestTimeoutMs = (_a3 = opts == null ? void 0 : opts.requestTimeoutMs) != null ? _a3 : this.connectionConfig.requestTimeoutMs;\n    const controller = new AbortController();\n    const reqTimeout = requestTimeoutMs ? setTimeout(() => {\n      controller.abort();\n    }, requestTimeoutMs) : void 0;\n    const events = this.rpc.connect(\n      {\n        process: {\n          selector: {\n            case: \"pid\",\n            value: pid\n          }\n        }\n      },\n      {\n        signal: controller.signal,\n        headers: {\n          [KEEPALIVE_PING_HEADER]: KEEPALIVE_PING_INTERVAL_SEC.toString()\n        },\n        timeoutMs: (_b = opts == null ? void 0 : opts.timeoutMs) != null ? _b : this.defaultProcessConnectionTimeout\n      }\n    );\n    try {\n      const pid2 = await handleProcessStartEvent(events);\n      clearTimeout(reqTimeout);\n      return new CommandHandle(\n        pid2,\n        () => controller.abort(),\n        () => this.kill(pid2),\n        events,\n        opts == null ? void 0 : opts.onStdout,\n        opts == null ? void 0 : opts.onStderr,\n        void 0\n      );\n    } catch (err) {\n      throw handleRpcError(err);\n    }\n  }\n  async run(cmd, opts) {\n    const proc = await this.start(cmd, opts);\n    return (opts == null ? void 0 : opts.background) ? proc : proc.wait();\n  }\n  async start(cmd, opts) {\n    var _a3, _b;\n    const requestTimeoutMs = (_a3 = opts == null ? void 0 : opts.requestTimeoutMs) != null ? _a3 : this.connectionConfig.requestTimeoutMs;\n    const controller = new AbortController();\n    const reqTimeout = requestTimeoutMs ? setTimeout(() => {\n      controller.abort();\n    }, requestTimeoutMs) : void 0;\n    const events = this.rpc.start(\n      {\n        process: {\n          cmd: \"/bin/bash\",\n          cwd: opts == null ? void 0 : opts.cwd,\n          envs: opts == null ? void 0 : opts.envs,\n          args: [\"-l\", \"-c\", cmd]\n        }\n      },\n      {\n        headers: __spreadProps(__spreadValues({}, authenticationHeader(opts == null ? void 0 : opts.user)), {\n          [KEEPALIVE_PING_HEADER]: KEEPALIVE_PING_INTERVAL_SEC.toString()\n        }),\n        signal: controller.signal,\n        timeoutMs: (_b = opts == null ? void 0 : opts.timeoutMs) != null ? _b : this.defaultProcessConnectionTimeout\n      }\n    );\n    try {\n      const pid = await handleProcessStartEvent(events);\n      clearTimeout(reqTimeout);\n      return new CommandHandle(\n        pid,\n        () => controller.abort(),\n        () => this.kill(pid),\n        events,\n        opts == null ? void 0 : opts.onStdout,\n        opts == null ? void 0 : opts.onStderr,\n        void 0\n      );\n    } catch (err) {\n      throw handleRpcError(err);\n    }\n  }\n};\n\n// src/sandbox/sandboxApi.ts\n\nvar SandboxApi = class {\n  constructor() {\n  }\n  /**\n   * Kill the sandbox specified by sandbox ID.\n   *\n   * @param sandboxId sandbox ID.\n   * @param opts connection options.\n   *\n   * @returns `true` if the sandbox was found and killed, `false` otherwise.\n   */\n  static async kill(sandboxId, opts) {\n    var _a3;\n    const config = new ConnectionConfig(opts);\n    const client = new ApiClient(config);\n    const res = await client.api.DELETE(\"/sandboxes/{sandboxID}\", {\n      params: {\n        path: {\n          sandboxID: sandboxId\n        }\n      },\n      signal: config.getSignal(opts == null ? void 0 : opts.requestTimeoutMs)\n    });\n    if (((_a3 = res.error) == null ? void 0 : _a3.code) === 404) {\n      return false;\n    }\n    const err = handleApiError(res);\n    if (err) {\n      throw err;\n    }\n    return true;\n  }\n  /**\n   * Get sandbox information like sandbox ID, template, metadata, started at/end at date.\n   *\n   * @param sandboxId sandbox ID.\n   * @param opts connection options.\n   *\n   * @returns sandbox information.\n   */\n  static async getInfo(sandboxId, opts) {\n    const fullInfo = await this.getFullInfo(sandboxId, opts);\n    delete fullInfo.envdAccessToken;\n    delete fullInfo.sandboxDomain;\n    return fullInfo;\n  }\n  /**\n   * Get the metrics of the sandbox.\n   *\n   * @param sandboxId sandbox ID.\n   * @param opts sandbox metrics options.\n   *\n   * @returns  List of sandbox metrics containing CPU, memory and disk usage information.\n   */\n  static async getMetrics(sandboxId, opts) {\n    var _a3, _b;\n    const config = new ConnectionConfig(opts);\n    const client = new ApiClient(config);\n    const res = await client.api.GET(\"/sandboxes/{sandboxID}/metrics\", {\n      params: {\n        path: {\n          sandboxID: sandboxId,\n          start: opts == null ? void 0 : opts.start,\n          end: opts == null ? void 0 : opts.end\n        }\n      },\n      signal: config.getSignal(opts == null ? void 0 : opts.requestTimeoutMs)\n    });\n    const err = handleApiError(res);\n    if (err) {\n      throw err;\n    }\n    return (_b = (_a3 = res.data) == null ? void 0 : _a3.map((metric) => ({\n      timestamp: new Date(metric.timestamp),\n      cpuUsedPct: metric.cpuUsedPct,\n      cpuCount: metric.cpuCount,\n      memUsed: metric.memUsed,\n      memTotal: metric.memTotal,\n      diskUsed: metric.diskUsed,\n      diskTotal: metric.diskTotal\n    }))) != null ? _b : [];\n  }\n  /**\n   * Set the timeout of the specified sandbox.\n   * After the timeout expires the sandbox will be automatically killed.\n   *\n   * This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to {@link Sandbox.setTimeout}.\n   *\n   * Maximum time a sandbox can be kept alive is 24 hours (86_400_000 milliseconds) for Pro users and 1 hour (3_600_000 milliseconds) for Hobby users.\n   *\n   * @param sandboxId sandbox ID.\n   * @param timeoutMs timeout in **milliseconds**.\n   * @param opts connection options.\n   */\n  static async setTimeout(sandboxId, timeoutMs, opts) {\n    const config = new ConnectionConfig(opts);\n    const client = new ApiClient(config);\n    const res = await client.api.POST(\"/sandboxes/{sandboxID}/timeout\", {\n      params: {\n        path: {\n          sandboxID: sandboxId\n        }\n      },\n      body: {\n        timeout: timeoutToSeconds(timeoutMs)\n      },\n      signal: config.getSignal(opts == null ? void 0 : opts.requestTimeoutMs)\n    });\n    const err = handleApiError(res);\n    if (err) {\n      throw err;\n    }\n  }\n  static async getFullInfo(sandboxId, opts) {\n    var _a3;\n    const config = new ConnectionConfig(opts);\n    const client = new ApiClient(config);\n    const res = await client.api.GET(\"/sandboxes/{sandboxID}\", {\n      params: {\n        path: {\n          sandboxID: sandboxId\n        }\n      },\n      signal: config.getSignal(opts == null ? void 0 : opts.requestTimeoutMs)\n    });\n    const err = handleApiError(res);\n    if (err) {\n      throw err;\n    }\n    if (!res.data) {\n      throw new Error(\"Sandbox not found\");\n    }\n    return __spreadProps(__spreadValues({\n      sandboxId: res.data.sandboxID,\n      templateId: res.data.templateID\n    }, res.data.alias && { name: res.data.alias }), {\n      metadata: (_a3 = res.data.metadata) != null ? _a3 : {},\n      envdVersion: res.data.envdVersion,\n      envdAccessToken: res.data.envdAccessToken,\n      startedAt: new Date(res.data.startedAt),\n      endAt: new Date(res.data.endAt),\n      state: res.data.state,\n      cpuCount: res.data.cpuCount,\n      memoryMB: res.data.memoryMB,\n      sandboxDomain: res.data.domain || void 0\n    });\n  }\n  /**\n   * Pause the sandbox specified by sandbox ID.\n   *\n   * @param sandboxId sandbox ID.\n   * @param opts connection options.\n   *\n   * @returns `true` if the sandbox got paused, `false` if the sandbox was already paused.\n   */\n  static async betaPause(sandboxId, opts) {\n    var _a3, _b;\n    const config = new ConnectionConfig(opts);\n    const client = new ApiClient(config);\n    const res = await client.api.POST(\"/sandboxes/{sandboxID}/pause\", {\n      params: {\n        path: {\n          sandboxID: sandboxId\n        }\n      },\n      signal: config.getSignal(opts == null ? void 0 : opts.requestTimeoutMs)\n    });\n    if (((_a3 = res.error) == null ? void 0 : _a3.code) === 404) {\n      throw new NotFoundError(`Sandbox ${sandboxId} not found`);\n    }\n    if (((_b = res.error) == null ? void 0 : _b.code) === 409) {\n      return false;\n    }\n    const err = handleApiError(res);\n    if (err) {\n      throw err;\n    }\n    return true;\n  }\n  static async createSandbox(template, timeoutMs, opts) {\n    var _a3, _b, _c;\n    const config = new ConnectionConfig(opts);\n    const client = new ApiClient(config);\n    const res = await client.api.POST(\"/sandboxes\", {\n      body: {\n        autoPause: (_a3 = opts == null ? void 0 : opts.autoPause) != null ? _a3 : false,\n        templateID: template,\n        metadata: opts == null ? void 0 : opts.metadata,\n        envVars: opts == null ? void 0 : opts.envs,\n        timeout: timeoutToSeconds(timeoutMs),\n        secure: (_b = opts == null ? void 0 : opts.secure) != null ? _b : true,\n        allow_internet_access: (_c = opts == null ? void 0 : opts.allowInternetAccess) != null ? _c : true\n      },\n      signal: config.getSignal(opts == null ? void 0 : opts.requestTimeoutMs)\n    });\n    const err = handleApiError(res);\n    if (err) {\n      throw err;\n    }\n    if ((0,compare_versions__WEBPACK_IMPORTED_MODULE_8__.compareVersions)(res.data.envdVersion, \"0.1.0\") < 0) {\n      await this.kill(res.data.sandboxID, opts);\n      throw new TemplateError(\n        \"You need to update the template to use the new SDK. You can do this by running `e2b template build` in the directory with the template.\"\n      );\n    }\n    return {\n      sandboxId: res.data.sandboxID,\n      sandboxDomain: res.data.domain || void 0,\n      envdVersion: res.data.envdVersion,\n      envdAccessToken: res.data.envdAccessToken\n    };\n  }\n  static async resumeSandbox(sandboxId, opts) {\n    var _a3, _b, _c;\n    const timeoutMs = (_a3 = opts == null ? void 0 : opts.timeoutMs) != null ? _a3 : DEFAULT_SANDBOX_TIMEOUT_MS;\n    const config = new ConnectionConfig(opts);\n    const client = new ApiClient(config);\n    const res = await client.api.POST(\"/sandboxes/{sandboxID}/resume\", {\n      params: {\n        path: {\n          sandboxID: sandboxId\n        }\n      },\n      body: {\n        timeout: timeoutToSeconds(timeoutMs)\n      },\n      signal: config.getSignal(opts == null ? void 0 : opts.requestTimeoutMs)\n    });\n    if (((_b = res.error) == null ? void 0 : _b.code) === 404) {\n      throw new NotFoundError(`Paused sandbox ${sandboxId} not found`);\n    }\n    if (((_c = res.error) == null ? void 0 : _c.code) === 409) {\n      return false;\n    }\n    const err = handleApiError(res);\n    if (err) {\n      throw err;\n    }\n    return true;\n  }\n};\nvar SandboxPaginator = class {\n  constructor(opts) {\n    this.config = new ConnectionConfig(opts);\n    this.client = new ApiClient(this.config);\n    this._hasNext = true;\n    this._nextToken = opts == null ? void 0 : opts.nextToken;\n    this.query = opts == null ? void 0 : opts.query;\n    this.limit = opts == null ? void 0 : opts.limit;\n  }\n  /**\n   * Returns True if there are more items to fetch.\n   */\n  get hasNext() {\n    return this._hasNext;\n  }\n  /**\n   * Returns the next token to use for pagination.\n   */\n  get nextToken() {\n    return this._nextToken;\n  }\n  /**\n   * Get the next page of sandboxes.\n   *\n   * @throws Error if there are no more items to fetch. Call this method only if `hasNext` is `true`.\n   *\n   * @returns List of sandboxes\n   */\n  async nextItems() {\n    var _a3, _b, _c;\n    if (!this.hasNext) {\n      throw new Error(\"No more items to fetch\");\n    }\n    let metadata = void 0;\n    if ((_a3 = this.query) == null ? void 0 : _a3.metadata) {\n      const encodedPairs = Object.fromEntries(\n        Object.entries(this.query.metadata).map(([key, value]) => [\n          encodeURIComponent(key),\n          encodeURIComponent(value)\n        ])\n      );\n      metadata = new URLSearchParams(encodedPairs).toString();\n    }\n    const res = await this.client.api.GET(\"/v2/sandboxes\", {\n      params: {\n        query: {\n          metadata,\n          state: (_b = this.query) == null ? void 0 : _b.state,\n          limit: this.limit,\n          nextToken: this.nextToken\n        }\n      },\n      // requestTimeoutMs is already passed here via the connectionConfig.\n      signal: this.config.getSignal()\n    });\n    const err = handleApiError(res);\n    if (err) {\n      throw err;\n    }\n    this._nextToken = res.response.headers.get(\"x-next-token\") || void 0;\n    this._hasNext = !!this._nextToken;\n    return ((_c = res.data) != null ? _c : []).map(\n      (sandbox) => {\n        var _a4;\n        return __spreadProps(__spreadValues({\n          sandboxId: sandbox.sandboxID,\n          templateId: sandbox.templateID\n        }, sandbox.alias && { name: sandbox.alias }), {\n          metadata: (_a4 = sandbox.metadata) != null ? _a4 : {},\n          startedAt: new Date(sandbox.startedAt),\n          endAt: new Date(sandbox.endAt),\n          state: sandbox.state,\n          cpuCount: sandbox.cpuCount,\n          memoryMB: sandbox.memoryMB,\n          envdVersion: sandbox.envdVersion\n        });\n      }\n    );\n  }\n};\n\n// src/sandbox/index.ts\n\nvar Sandbox = class extends SandboxApi {\n  /**\n   * Use {@link Sandbox.create} to create a new Sandbox instead.\n   *\n   * @hidden\n   * @hide\n   * @internal\n   * @access protected\n   */\n  constructor(opts) {\n    var _a3;\n    super();\n    this.envdPort = 49983;\n    this.connectionConfig = new ConnectionConfig(opts);\n    this.sandboxId = opts.sandboxId;\n    this.sandboxDomain = (_a3 = opts.sandboxDomain) != null ? _a3 : this.connectionConfig.domain;\n    this.envdAccessToken = opts.envdAccessToken;\n    this.envdApiUrl = `${this.connectionConfig.debug ? \"http\" : \"https\"}://${this.getHost(this.envdPort)}`;\n    const rpcTransport = (0,_connectrpc_connect_web__WEBPACK_IMPORTED_MODULE_9__.createConnectTransport)({\n      baseUrl: this.envdApiUrl,\n      useBinaryFormat: false,\n      interceptors: (opts == null ? void 0 : opts.logger) ? [createRpcLogger(opts.logger)] : void 0,\n      fetch: (url, options) => {\n        const headers = new Headers(this.connectionConfig.headers);\n        new Headers(options == null ? void 0 : options.headers).forEach(\n          (value, key) => headers.append(key, value)\n        );\n        if (this.envdAccessToken) {\n          headers.append(\"X-Access-Token\", this.envdAccessToken);\n        }\n        options = __spreadProps(__spreadValues({}, options != null ? options : {}), {\n          headers,\n          redirect: \"follow\"\n        });\n        return fetch(url, options);\n      }\n    });\n    this.envdApi = new EnvdApiClient(\n      {\n        apiUrl: this.envdApiUrl,\n        logger: opts == null ? void 0 : opts.logger,\n        accessToken: this.envdAccessToken,\n        headers: this.envdAccessToken ? { \"X-Access-Token\": this.envdAccessToken } : {}\n      },\n      {\n        version: opts == null ? void 0 : opts.envdVersion\n      }\n    );\n    this.files = new Filesystem2(\n      rpcTransport,\n      this.envdApi,\n      this.connectionConfig\n    );\n    this.commands = new Commands(rpcTransport, this.connectionConfig);\n    this.pty = new Pty(rpcTransport, this.connectionConfig);\n  }\n  /**\n   * List all sandboxes.\n   *\n   * @param opts connection options.\n   *\n   * @returns paginator for listing sandboxes.\n   */\n  static list(opts) {\n    return new SandboxPaginator(opts);\n  }\n  static async create(templateOrOpts, opts) {\n    var _a3;\n    const { template, sandboxOpts } = typeof templateOrOpts === \"string\" ? { template: templateOrOpts, sandboxOpts: opts } : { template: this.defaultTemplate, sandboxOpts: templateOrOpts };\n    const config = new ConnectionConfig(sandboxOpts);\n    if (config.debug) {\n      return new this(__spreadValues({\n        sandboxId: \"debug_sandbox_id\"\n      }, config));\n    }\n    const sandbox = await SandboxApi.createSandbox(\n      template,\n      (_a3 = sandboxOpts == null ? void 0 : sandboxOpts.timeoutMs) != null ? _a3 : this.defaultSandboxTimeoutMs,\n      sandboxOpts\n    );\n    return new this(__spreadValues(__spreadValues({}, sandbox), config));\n  }\n  static async betaCreate(templateOrOpts, opts) {\n    var _a3;\n    const { template, sandboxOpts } = typeof templateOrOpts === \"string\" ? { template: templateOrOpts, sandboxOpts: opts } : { template: this.defaultTemplate, sandboxOpts: templateOrOpts };\n    const config = new ConnectionConfig(sandboxOpts);\n    if (config.debug) {\n      return new this(__spreadValues({\n        sandboxId: \"debug_sandbox_id\"\n      }, config));\n    }\n    const sandbox = await SandboxApi.createSandbox(\n      template,\n      (_a3 = sandboxOpts == null ? void 0 : sandboxOpts.timeoutMs) != null ? _a3 : this.defaultSandboxTimeoutMs,\n      sandboxOpts\n    );\n    return new this(__spreadValues(__spreadValues({}, sandbox), config));\n  }\n  /**\n   * Connect to a sandbox. If the sandbox is paused, it will be automatically resumed.\n   * Sandbox must be either running or be paused.\n   *\n   * With sandbox ID you can connect to the same sandbox from different places or environments (serverless functions, etc).\n   *\n   * @param sandboxId sandbox ID.\n   * @param opts connection options.\n   *\n   * @returns A running sandbox instance\n   *\n   * @example\n   * ```ts\n   * const sandbox = await Sandbox.create()\n   * const sandboxId = sandbox.sandboxId\n   *\n   * // Connect to the same sandbox.\n   * const sameSandbox = await Sandbox.connect(sandboxId)\n   * ```\n   */\n  static async connect(sandboxId, opts) {\n    try {\n      await SandboxApi.setTimeout(\n        sandboxId,\n        (opts == null ? void 0 : opts.timeoutMs) || DEFAULT_SANDBOX_TIMEOUT_MS,\n        opts\n      );\n    } catch (e) {\n      if (e instanceof SandboxError) {\n        await SandboxApi.resumeSandbox(sandboxId, opts);\n      } else {\n        throw e;\n      }\n    }\n    const info = await SandboxApi.getFullInfo(sandboxId, opts);\n    const config = new ConnectionConfig(opts);\n    return new this(__spreadValues({\n      sandboxId,\n      sandboxDomain: info.sandboxDomain,\n      envdAccessToken: info.envdAccessToken,\n      envdVersion: info.envdVersion\n    }, config));\n  }\n  /**\n   * Connect to a sandbox. If the sandbox is paused, it will be automatically resumed.\n   * Sandbox must be either running or be paused.\n   *\n   * With sandbox ID you can connect to the same sandbox from different places or environments (serverless functions, etc).\n   *\n   * @param opts connection options.\n   *\n   * @returns A running sandbox instance\n   *\n   * @example\n   * ```ts\n   * const sandbox = await Sandbox.create()\n   * await sandbox.betaPause()\n   *\n   * // Connect to the same sandbox.\n   * const sameSandbox = await sandbox.connect()\n   * ```\n   */\n  async connect(opts) {\n    try {\n      await SandboxApi.setTimeout(\n        this.sandboxId,\n        (opts == null ? void 0 : opts.timeoutMs) || DEFAULT_SANDBOX_TIMEOUT_MS,\n        opts\n      );\n    } catch (e) {\n      await SandboxApi.resumeSandbox(this.sandboxId, opts);\n    }\n    return this;\n  }\n  /**\n   * Get the host address for the specified sandbox port.\n   * You can then use this address to connect to the sandbox port from outside the sandbox via HTTP or WebSocket.\n   *\n   * @param port number of the port in the sandbox.\n   *\n   * @returns host address of the sandbox port.\n   *\n   * @example\n   * ```ts\n   * const sandbox = await Sandbox.create()\n   * // Start an HTTP server\n   * await sandbox.commands.exec('python3 -m http.server 3000')\n   * // Get the hostname of the HTTP server\n   * const serverURL = sandbox.getHost(3000)\n   * ```\n   */\n  getHost(port) {\n    if (this.connectionConfig.debug) {\n      return `localhost:${port}`;\n    }\n    return `${port}-${this.sandboxId}.${this.sandboxDomain}`;\n  }\n  /**\n   * Check if the sandbox is running.\n   *\n   * @returns `true` if the sandbox is running, `false` otherwise.\n   *\n   * @example\n   * ```ts\n   * const sandbox = await Sandbox.create()\n   * await sandbox.isRunning() // Returns true\n   *\n   * await sandbox.kill()\n   * await sandbox.isRunning() // Returns false\n   * ```\n   */\n  async isRunning(opts) {\n    const signal = this.connectionConfig.getSignal(opts == null ? void 0 : opts.requestTimeoutMs);\n    const res = await this.envdApi.api.GET(\"/health\", {\n      signal\n    });\n    if (res.response.status == 502) {\n      return false;\n    }\n    const err = await handleEnvdApiError(res);\n    if (err) {\n      throw err;\n    }\n    return true;\n  }\n  /**\n   * Set the timeout of the sandbox.\n   * After the timeout expires the sandbox will be automatically killed.\n   *\n   * This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to `.setTimeout`.\n   * Maximum time a sandbox can be kept alive is 24 hours (86_400_000 milliseconds) for Pro users and 1 hour (3_600_000 milliseconds) for Hobby users.\n   *\n   * @param timeoutMs timeout in **milliseconds**.\n   * @param opts connection options.\n   */\n  async setTimeout(timeoutMs, opts) {\n    if (this.connectionConfig.debug) {\n      return;\n    }\n    await SandboxApi.setTimeout(this.sandboxId, timeoutMs, __spreadValues(__spreadValues({}, this.connectionConfig), opts));\n  }\n  /**\n   * Kill the sandbox.\n   *\n   * @param opts connection options.\n   */\n  async kill(opts) {\n    if (this.connectionConfig.debug) {\n      return;\n    }\n    await SandboxApi.kill(this.sandboxId, __spreadValues(__spreadValues({}, this.connectionConfig), opts));\n  }\n  /**\n   * @beta This feature is in beta and may change in the future.\n   *\n   * Pause a sandbox by its ID.\n   *\n   * @param opts connection options.\n   *\n   * @returns sandbox ID that can be used to resume the sandbox.\n   */\n  async betaPause(opts) {\n    return await SandboxApi.betaPause(this.sandboxId, opts);\n  }\n  /**\n   * Get the URL to upload a file to the sandbox.\n   *\n   * You have to send a POST request to this URL with the file as multipart/form-data.\n   *\n   * @param path path to the file in the sandbox.\n   *\n   * @param opts download url options.\n   *\n   * @returns URL for uploading file.\n   */\n  async uploadUrl(path2, opts) {\n    var _a3;\n    opts = opts != null ? opts : {};\n    const useSignature = !!this.envdAccessToken;\n    if (!useSignature && opts.useSignatureExpiration != void 0) {\n      throw new Error(\n        \"Signature expiration can be used only when sandbox is created as secured.\"\n      );\n    }\n    const username = (_a3 = opts.user) != null ? _a3 : defaultUsername;\n    const filePath = path2 != null ? path2 : \"\";\n    const fileUrl = this.fileUrl(filePath, username);\n    if (useSignature) {\n      const url = new URL(fileUrl);\n      const sig = await getSignature({\n        path: filePath,\n        operation: \"write\",\n        user: username,\n        expirationInSeconds: opts.useSignatureExpiration,\n        envdAccessToken: this.envdAccessToken\n      });\n      url.searchParams.set(\"signature\", sig.signature);\n      if (sig.expiration) {\n        url.searchParams.set(\"signature_expiration\", sig.expiration.toString());\n      }\n      return url.toString();\n    }\n    return fileUrl;\n  }\n  /**\n   * Get the URL to download a file from the sandbox.\n   *\n   * @param path path to the file in the sandbox.\n   *\n   * @param opts download url options.\n   *\n   * @returns URL for downloading file.\n   */\n  async downloadUrl(path2, opts) {\n    var _a3;\n    opts = opts != null ? opts : {};\n    const useSignature = !!this.envdAccessToken;\n    if (!useSignature && opts.useSignatureExpiration != void 0) {\n      throw new Error(\n        \"Signature expiration can be used only when sandbox is created as secured.\"\n      );\n    }\n    const username = (_a3 = opts.user) != null ? _a3 : defaultUsername;\n    const fileUrl = this.fileUrl(path2, username);\n    if (useSignature) {\n      const url = new URL(fileUrl);\n      const sig = await getSignature({\n        path: path2,\n        operation: \"read\",\n        user: username,\n        expirationInSeconds: opts.useSignatureExpiration,\n        envdAccessToken: this.envdAccessToken\n      });\n      url.searchParams.set(\"signature\", sig.signature);\n      if (sig.expiration) {\n        url.searchParams.set(\"signature_expiration\", sig.expiration.toString());\n      }\n      return url.toString();\n    }\n    return fileUrl;\n  }\n  /**\n   * Get sandbox information like sandbox ID, template, metadata, started at/end at date.\n   *\n   * @param opts connection options.\n   *\n   * @returns information about the sandbox\n   */\n  async getInfo(opts) {\n    return await SandboxApi.getInfo(this.sandboxId, __spreadValues(__spreadValues({}, this.connectionConfig), opts));\n  }\n  /**\n   * Get the metrics of the sandbox.\n   *\n   * @param opts connection options.\n   *\n   * @returns  List of sandbox metrics containing CPU, memory and disk usage information.\n   */\n  async getMetrics(opts) {\n    var _a3, _b;\n    if (this.envdApi.version) {\n      if ((0,compare_versions__WEBPACK_IMPORTED_MODULE_8__.compareVersions)(this.envdApi.version, \"0.1.5\") < 0) {\n        throw new SandboxError(\n          \"You need to update the template to use the new SDK. You can do this by running `e2b template build` in the directory with the template.\"\n        );\n      }\n      if ((0,compare_versions__WEBPACK_IMPORTED_MODULE_8__.compareVersions)(this.envdApi.version, \"0.2.4\") < 0) {\n        (_b = (_a3 = this.connectionConfig.logger) == null ? void 0 : _a3.warn) == null ? void 0 : _b.call(\n          _a3,\n          \"Disk metrics are not supported in this version of the sandbox, please rebuild the template to get disk metrics.\"\n        );\n      }\n    }\n    return await SandboxApi.getMetrics(this.sandboxId, __spreadValues(__spreadValues({}, this.connectionConfig), opts));\n  }\n  fileUrl(path2, username) {\n    const url = new URL(\"/files\", this.envdApiUrl);\n    url.searchParams.set(\"username\", username != null ? username : defaultUsername);\n    if (path2) {\n      url.searchParams.set(\"path\", path2);\n    }\n    return url.toString();\n  }\n};\nSandbox.defaultTemplate = \"base\";\nSandbox.defaultSandboxTimeoutMs = DEFAULT_SANDBOX_TIMEOUT_MS;\n\n// src/template/errors.ts\nvar BuildError = class extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"BuildError\";\n  }\n};\nvar FileUploadError = class extends BuildError {\n  constructor(message) {\n    super(message);\n    this.name = \"FileUploadError\";\n  }\n};\n\n// src/template/types.ts\nvar LogEntry = class {\n  constructor(timestamp, level, message) {\n    this.timestamp = timestamp;\n    this.level = level;\n    this.message = message;\n  }\n  toString() {\n    return `[${this.timestamp.toISOString()}] [${this.level}] ${stripAnsi(\n      this.message\n    )}`;\n  }\n};\n\n// src/template/utils.ts\n\n\n\nfunction readDockerignore(contextPath) {\n  const dockerignorePath = node_path__WEBPACK_IMPORTED_MODULE_12__.join(contextPath, \".dockerignore\");\n  if (!node_fs__WEBPACK_IMPORTED_MODULE_11__.existsSync(dockerignorePath)) {\n    return [];\n  }\n  const content = node_fs__WEBPACK_IMPORTED_MODULE_11__.readFileSync(dockerignorePath, \"utf-8\");\n  return content.split(\"\\n\").map((line) => line.trim()).filter((line) => line && !line.startsWith(\"#\"));\n}\nasync function calculateFilesHash(src, dest, contextPath, ignorePatterns) {\n  const { globSync } = await dynamicGlob();\n  const srcPath = node_path__WEBPACK_IMPORTED_MODULE_12__.join(contextPath, src);\n  const hash = node_crypto__WEBPACK_IMPORTED_MODULE_10__.createHash(\"sha256\");\n  const content = `COPY ${src} ${dest}`;\n  hash.update(content);\n  const files = globSync(srcPath, {\n    ignore: ignorePatterns\n  });\n  if (files.length === 0) {\n    throw new Error(`No files found in ${srcPath}`);\n  }\n  for (const file of files) {\n    const content2 = node_fs__WEBPACK_IMPORTED_MODULE_11__.readFileSync(file);\n    hash.update(new Uint8Array(content2));\n  }\n  return hash.digest(\"hex\");\n}\nfunction getCallerDirectory() {\n  const stackTrace = new Error().stack;\n  if (!stackTrace) {\n    return;\n  }\n  const lines = stackTrace.split(\"\\n\");\n  const caller = lines[4];\n  const match = caller.match(/at ([^:]+):\\d+:\\d+/);\n  if (match) {\n    const filePath = match[1];\n    return node_path__WEBPACK_IMPORTED_MODULE_12__.dirname(filePath);\n  }\n  return;\n}\nfunction padOctal(mode) {\n  return mode.toString(8).padStart(4, \"0\");\n}\nasync function tarFileStream(fileName, fileContextPath) {\n  const { globSync } = await dynamicGlob();\n  const { create } = await dynamicTar();\n  const files = globSync(fileName, { cwd: fileContextPath, nodir: false });\n  return create(\n    {\n      gzip: true,\n      cwd: fileContextPath\n    },\n    files\n  );\n}\nasync function tarFileStreamUpload(fileName, fileContextPath) {\n  const sizeCalculationStream = await tarFileStream(fileName, fileContextPath);\n  let contentLength = 0;\n  try {\n    for (var iter = __forAwait(sizeCalculationStream), more, temp, error; more = !(temp = await iter.next()).done; more = false) {\n      const chunk = temp.value;\n      contentLength += chunk.length;\n    }\n  } catch (temp) {\n    error = [temp];\n  } finally {\n    try {\n      more && (temp = iter.return) && await temp.call(iter);\n    } finally {\n      if (error)\n        throw error[0];\n    }\n  }\n  return {\n    contentLength,\n    uploadStream: await tarFileStream(fileName, fileContextPath)\n  };\n}\n\n// src/template/buildApi.ts\nasync function requestBuild(client, { alias, cpuCount, memoryMB }) {\n  const requestBuildRes = await client.api.POST(\"/v2/templates\", {\n    body: {\n      alias,\n      cpuCount,\n      memoryMB\n    }\n  });\n  const error = handleApiError(requestBuildRes, BuildError);\n  if (error) {\n    throw error;\n  }\n  if (!requestBuildRes.data) {\n    throw new BuildError(\"Failed to request build\");\n  }\n  return requestBuildRes.data;\n}\nasync function getFileUploadLink(client, { templateID, filesHash }) {\n  const fileUploadLinkRes = await client.api.GET(\n    \"/templates/{templateID}/files/{hash}\",\n    {\n      params: {\n        path: {\n          templateID,\n          hash: filesHash\n        }\n      }\n    }\n  );\n  const error = handleApiError(fileUploadLinkRes, FileUploadError);\n  if (error) {\n    throw error;\n  }\n  if (!fileUploadLinkRes.data) {\n    throw new FileUploadError(\"Failed to get file upload link\");\n  }\n  return fileUploadLinkRes.data;\n}\nasync function uploadFile(options) {\n  const { fileName, url, fileContextPath } = options;\n  const { contentLength, uploadStream } = await tarFileStreamUpload(\n    fileName,\n    fileContextPath\n  );\n  const res = await fetch(url, {\n    method: \"PUT\",\n    // @ts-expect-error\n    body: uploadStream,\n    headers: {\n      \"Content-Length\": contentLength.toString()\n    },\n    duplex: \"half\"\n  });\n  if (!res.ok) {\n    throw new FileUploadError(\n      `Failed to upload file: ${res.statusText} ${res.status}`\n    );\n  }\n}\nasync function triggerBuild(client, { templateID, buildID, template }) {\n  const triggerBuildRes = await client.api.POST(\n    \"/v2/templates/{templateID}/builds/{buildID}\",\n    {\n      params: {\n        path: {\n          templateID,\n          buildID\n        }\n      },\n      body: template\n    }\n  );\n  const error = handleApiError(triggerBuildRes, BuildError);\n  if (error) {\n    throw error;\n  }\n}\nasync function getBuildStatus(client, { templateID, buildID, logsOffset }) {\n  const buildStatusRes = await client.api.GET(\n    \"/templates/{templateID}/builds/{buildID}/status\",\n    {\n      params: {\n        path: {\n          templateID,\n          buildID\n        },\n        query: {\n          logsOffset\n        }\n      }\n    }\n  );\n  const error = handleApiError(buildStatusRes, BuildError);\n  if (error) {\n    throw error;\n  }\n  if (!buildStatusRes.data) {\n    throw new BuildError(\"Failed to get build status\");\n  }\n  return buildStatusRes.data;\n}\nasync function waitForBuildFinish(client, {\n  templateID,\n  buildID,\n  onBuildLogs,\n  logsRefreshFrequency\n}) {\n  var _a3, _b;\n  let logsOffset = 0;\n  let status = \"building\";\n  while (status === \"building\" || status === \"waiting\") {\n    const buildStatus = await getBuildStatus(client, {\n      templateID,\n      buildID,\n      logsOffset\n    });\n    logsOffset += buildStatus.logEntries.length;\n    buildStatus.logEntries.forEach(\n      (logEntry) => onBuildLogs == null ? void 0 : onBuildLogs(\n        new LogEntry(\n          new Date(logEntry.timestamp),\n          logEntry.level,\n          stripAnsi(logEntry.message)\n        )\n      )\n    );\n    status = buildStatus.status;\n    switch (status) {\n      case \"ready\": {\n        return;\n      }\n      case \"waiting\": {\n        break;\n      }\n      case \"error\": {\n        throw new BuildError((_b = (_a3 = buildStatus == null ? void 0 : buildStatus.reason) == null ? void 0 : _a3.message) != null ? _b : \"Unknown error\");\n      }\n    }\n    await new Promise((resolve) => setTimeout(resolve, logsRefreshFrequency));\n  }\n  throw new BuildError(\"Unknown build error occurred.\");\n}\n\n// src/template/dockerfileParser.ts\n\n\nfunction parseDockerfile(dockerfileContentOrPath, templateBuilder) {\n  let dockerfileContent;\n  try {\n    if (node_fs__WEBPACK_IMPORTED_MODULE_11__.existsSync(dockerfileContentOrPath) && node_fs__WEBPACK_IMPORTED_MODULE_11__.statSync(dockerfileContentOrPath).isFile()) {\n      dockerfileContent = node_fs__WEBPACK_IMPORTED_MODULE_11__.readFileSync(dockerfileContentOrPath, \"utf-8\");\n    } else {\n      dockerfileContent = dockerfileContentOrPath;\n    }\n  } catch (e) {\n    dockerfileContent = dockerfileContentOrPath;\n  }\n  const dockerfile = dockerfile_ast__WEBPACK_IMPORTED_MODULE_13__.DockerfileParser.parse(dockerfileContent);\n  const instructions = dockerfile.getInstructions();\n  const fromInstructions = instructions.filter(\n    (instruction) => instruction.getKeyword() === \"FROM\"\n  );\n  if (fromInstructions.length > 1) {\n    throw new Error(\"Multi-stage Dockerfiles are not supported\");\n  }\n  if (fromInstructions.length === 0) {\n    throw new Error(\"Dockerfile must contain a FROM instruction\");\n  }\n  const fromInstruction = fromInstructions[0];\n  const argumentsData = fromInstruction.getArguments();\n  let baseImage = \"e2bdev/base\";\n  if (argumentsData && argumentsData.length > 0) {\n    baseImage = argumentsData[0].getValue();\n  }\n  const resultInstructions = [];\n  for (const instruction of instructions) {\n    const keyword = instruction.getKeyword();\n    switch (keyword) {\n      case \"FROM\":\n        break;\n      case \"RUN\":\n        handleRunInstruction(instruction, templateBuilder);\n        break;\n      case \"COPY\":\n      case \"ADD\":\n        handleCopyInstruction(instruction, templateBuilder);\n        break;\n      case \"WORKDIR\":\n        handleWorkdirInstruction(instruction, templateBuilder);\n        break;\n      case \"USER\":\n        handleUserInstruction(instruction, templateBuilder);\n        break;\n      case \"ENV\":\n      case \"ARG\":\n        handleEnvInstruction(instruction, templateBuilder);\n        break;\n      case \"EXPOSE\":\n        break;\n      case \"VOLUME\":\n        break;\n      case \"CMD\":\n      case \"ENTRYPOINT\":\n        handleCmdEntrypointInstruction(instruction, templateBuilder);\n        break;\n      default:\n        console.warn(`Unsupported instruction: ${keyword}`);\n        break;\n    }\n  }\n  return {\n    baseImage,\n    instructions: resultInstructions\n  };\n}\nfunction handleRunInstruction(instruction, templateBuilder) {\n  const argumentsData = instruction.getArguments();\n  if (argumentsData && argumentsData.length > 0) {\n    const command = argumentsData.map((arg) => arg.getValue()).join(\" \");\n    templateBuilder.runCmd(command);\n  }\n}\nfunction handleCopyInstruction(instruction, templateBuilder) {\n  const argumentsData = instruction.getArguments();\n  if (argumentsData && argumentsData.length >= 2) {\n    const src = argumentsData[0].getValue();\n    const dest = argumentsData[argumentsData.length - 1].getValue();\n    templateBuilder.copy(src, dest);\n  }\n}\nfunction handleWorkdirInstruction(instruction, templateBuilder) {\n  const argumentsData = instruction.getArguments();\n  if (argumentsData && argumentsData.length > 0) {\n    const workdir = argumentsData[0].getValue();\n    templateBuilder.setWorkdir(workdir);\n  }\n}\nfunction handleUserInstruction(instruction, templateBuilder) {\n  const argumentsData = instruction.getArguments();\n  if (argumentsData && argumentsData.length > 0) {\n    const user = argumentsData[0].getValue();\n    templateBuilder.setUser(user);\n  }\n}\nfunction handleEnvInstruction(instruction, templateBuilder) {\n  const argumentsData = instruction.getArguments();\n  const keyword = instruction.getKeyword();\n  if (argumentsData && argumentsData.length >= 1) {\n    if (argumentsData.length === 2) {\n      const firstArg = argumentsData[0].getValue();\n      const secondArg = argumentsData[1].getValue();\n      if (firstArg.includes(\"=\") && secondArg.includes(\"=\")) {\n        for (const arg of argumentsData) {\n          const envString = arg.getValue();\n          const equalIndex = envString.indexOf(\"=\");\n          if (equalIndex > 0) {\n            const key = envString.substring(0, equalIndex);\n            const value = envString.substring(equalIndex + 1);\n            templateBuilder.setEnvs({ [key]: value });\n          }\n        }\n      } else {\n        templateBuilder.setEnvs({ [firstArg]: secondArg });\n      }\n    } else if (argumentsData.length === 1) {\n      const envString = argumentsData[0].getValue();\n      const equalIndex = envString.indexOf(\"=\");\n      if (equalIndex > 0) {\n        const key = envString.substring(0, equalIndex);\n        const value = envString.substring(equalIndex + 1);\n        templateBuilder.setEnvs({ [key]: value });\n      } else if (keyword === \"ARG\" && envString.trim()) {\n        const key = envString.trim();\n        templateBuilder.setEnvs({ [key]: \"\" });\n      }\n    } else {\n      for (const arg of argumentsData) {\n        const envString = arg.getValue();\n        const equalIndex = envString.indexOf(\"=\");\n        if (equalIndex > 0) {\n          const key = envString.substring(0, equalIndex);\n          const value = envString.substring(equalIndex + 1);\n          templateBuilder.setEnvs({ [key]: value });\n        } else if (keyword === \"ARG\") {\n          const key = envString;\n          templateBuilder.setEnvs({ [key]: \"\" });\n        }\n      }\n    }\n  }\n}\nfunction handleCmdEntrypointInstruction(instruction, templateBuilder) {\n  const argumentsData = instruction.getArguments();\n  if (argumentsData && argumentsData.length > 0) {\n    const command = argumentsData.map((arg) => arg.getValue()).join(\" \");\n    const waitForTimeout2 = (timeout) => {\n      const seconds = Math.max(1, Math.floor(timeout / 1e3));\n      return `sleep ${seconds}`;\n    };\n    templateBuilder.setStartCmd(command, waitForTimeout2(2e4));\n  }\n}\n\n// src/template/readycmd.ts\nvar ReadyCmd = class {\n  constructor(cmd) {\n    this.cmd = cmd;\n  }\n  getCmd() {\n    return this.cmd;\n  }\n};\nfunction waitForPort(port) {\n  const cmd = `ss -tuln | grep :${port}`;\n  return new ReadyCmd(cmd);\n}\nfunction waitForURL(url, statusCode = 200) {\n  const cmd = `curl -s -o /dev/null -w \"%{http_code}\" ${url} | grep -q \"${statusCode}\"`;\n  return new ReadyCmd(cmd);\n}\nfunction waitForProcess(processName) {\n  const cmd = `pgrep ${processName} > /dev/null`;\n  return new ReadyCmd(cmd);\n}\nfunction waitForFile(filename) {\n  const cmd = `[ -f ${filename} ]`;\n  return new ReadyCmd(cmd);\n}\nfunction waitForTimeout(timeout) {\n  const seconds = Math.max(1, Math.floor(timeout / 1e3));\n  const cmd = `sleep ${seconds}`;\n  return new ReadyCmd(cmd);\n}\n\n// src/template/index.ts\nvar _a2;\nvar TemplateBase = class {\n  constructor(options) {\n    this.defaultBaseImage = \"e2bdev/base\";\n    this.baseImage = this.defaultBaseImage;\n    this.baseTemplate = void 0;\n    this.startCmd = void 0;\n    this.readyCmd = void 0;\n    // Force the whole template to be rebuilt\n    this.force = false;\n    // Force the next layer to be rebuilt\n    this.forceNextLayer = false;\n    this.instructions = [];\n    this.fileContextPath = runtime === \"browser\" ? \".\" : (_a2 = getCallerDirectory()) != null ? _a2 : \".\";\n    this.ignoreFilePaths = [];\n    this.logsRefreshFrequency = 200;\n    var _a3, _b;\n    this.fileContextPath = (_a3 = options == null ? void 0 : options.fileContextPath) != null ? _a3 : this.fileContextPath;\n    this.ignoreFilePaths = (_b = options == null ? void 0 : options.ignoreFilePaths) != null ? _b : this.ignoreFilePaths;\n  }\n  static toJSON(template) {\n    return template.toJSON();\n  }\n  static toDockerfile(template) {\n    return template.toDockerfile();\n  }\n  static build(template, options) {\n    return template.build(options);\n  }\n  // Built-in image mixins\n  fromDebianImage(variant = \"slim\") {\n    return this.fromImage(`debian:${variant}`);\n  }\n  fromUbuntuImage(variant = \"lts\") {\n    return this.fromImage(`ubuntu:${variant}`);\n  }\n  fromPythonImage(version2 = \"3.13\") {\n    return this.fromImage(`python:${version2}`);\n  }\n  fromNodeImage(variant = \"lts\") {\n    return this.fromImage(`node:${variant}`);\n  }\n  fromBaseImage() {\n    return this.fromImage(this.defaultBaseImage);\n  }\n  fromImage(baseImage) {\n    this.baseImage = baseImage;\n    this.baseTemplate = void 0;\n    if (this.forceNextLayer) {\n      this.force = true;\n    }\n    return this;\n  }\n  fromTemplate(template) {\n    this.baseTemplate = template;\n    this.baseImage = void 0;\n    if (this.forceNextLayer) {\n      this.force = true;\n    }\n    return this;\n  }\n  /**\n   * Parse a Dockerfile and convert it to Template SDK format\n   *\n   * @param dockerfileContentOrPath Either the Dockerfile content as a string,\n   *                                or a path to a Dockerfile file\n   * @returns TemplateBuilder instance for method chaining\n   */\n  fromDockerfile(dockerfileContentOrPath) {\n    const { baseImage } = parseDockerfile(dockerfileContentOrPath, this);\n    this.baseImage = baseImage;\n    this.baseTemplate = void 0;\n    if (this.forceNextLayer) {\n      this.force = true;\n    }\n    return this;\n  }\n  copy(srcOrItems, destOrOptions, options) {\n    var _a3, _b;\n    if (runtime === \"browser\") {\n      throw new Error(\"Browser runtime is not supported for copy\");\n    }\n    const items = Array.isArray(srcOrItems) ? srcOrItems : [\n      {\n        src: srcOrItems,\n        dest: destOrOptions,\n        mode: options == null ? void 0 : options.mode,\n        user: options == null ? void 0 : options.user,\n        forceUpload: options == null ? void 0 : options.forceUpload\n      }\n    ];\n    for (const item of items) {\n      const args = [\n        item.src,\n        item.dest,\n        (_a3 = item.user) != null ? _a3 : \"\",\n        item.mode ? padOctal(item.mode) : \"\"\n      ];\n      this.instructions.push({\n        type: \"COPY\",\n        args,\n        force: (_b = item.forceUpload) != null ? _b : this.forceNextLayer,\n        forceUpload: item.forceUpload\n      });\n    }\n    return this;\n  }\n  remove(path2, options) {\n    const args = [\"rm\", path2];\n    if (options == null ? void 0 : options.recursive) {\n      args.push(\"-r\");\n    }\n    if (options == null ? void 0 : options.force) {\n      args.push(\"-f\");\n    }\n    this.runCmd(args.join(\" \"));\n    return this;\n  }\n  rename(src, dest, options) {\n    const args = [\"mv\", src, dest];\n    if (options == null ? void 0 : options.force) {\n      args.push(\"-f\");\n    }\n    this.runCmd(args.join(\" \"));\n    return this;\n  }\n  makeDir(paths2, options) {\n    const args = [\"mkdir\", \"-p\", ...Array.isArray(paths2) ? paths2 : [paths2]];\n    if (options == null ? void 0 : options.mode) {\n      args.push(`-m ${padOctal(options.mode)}`);\n    }\n    this.runCmd(args.join(\" \"));\n    return this;\n  }\n  makeSymlink(src, dest) {\n    const args = [\"ln\", \"-s\", src, dest];\n    this.runCmd(args.join(\" \"));\n    return this;\n  }\n  runCmd(commandOrCommands, options) {\n    const cmds = Array.isArray(commandOrCommands) ? commandOrCommands : [commandOrCommands];\n    const args = [cmds.join(\" && \")];\n    if (options == null ? void 0 : options.user) {\n      args.push(options.user);\n    }\n    this.instructions.push({\n      type: \"RUN\",\n      args,\n      force: this.forceNextLayer\n    });\n    return this;\n  }\n  setWorkdir(workdir) {\n    this.instructions.push({\n      type: \"WORKDIR\",\n      args: [workdir],\n      force: this.forceNextLayer\n    });\n    return this;\n  }\n  setUser(user) {\n    this.instructions.push({\n      type: \"USER\",\n      args: [user],\n      force: this.forceNextLayer\n    });\n    return this;\n  }\n  pipInstall(packages) {\n    const args = [\"pip\", \"install\"];\n    const packageList = packages ? Array.isArray(packages) ? packages : [packages] : void 0;\n    if (packageList) {\n      args.push(...packageList);\n    } else {\n      args.push(\".\");\n    }\n    return this.runCmd(args);\n  }\n  npmInstall(packages, g) {\n    const args = [\"npm\", \"install\"];\n    const packageList = packages ? Array.isArray(packages) ? packages : [packages] : void 0;\n    if (packageList) {\n      args.push(...packageList);\n    }\n    if (g) {\n      args.push(\"-g\");\n    }\n    return this.runCmd(args);\n  }\n  aptInstall(packages) {\n    const packageList = Array.isArray(packages) ? packages : [packages];\n    return this.runCmd(\n      [\n        \"apt-get update\",\n        `DEBIAN_FRONTEND=noninteractive DEBCONF_NOWARNINGS=yes apt-get install -y --no-install-recommends ${packageList.join(\n          \" \"\n        )}`\n      ],\n      { user: \"root\" }\n    );\n  }\n  gitClone(url, path2, options) {\n    const args = [\"git\", \"clone\", url, path2];\n    if (options == null ? void 0 : options.branch) {\n      args.push(`--branch ${options.branch}`);\n      args.push(\"--single-branch\");\n    }\n    if (options == null ? void 0 : options.depth) {\n      args.push(`--depth ${options.depth}`);\n    }\n    this.runCmd(args.join(\" \"));\n    return this;\n  }\n  setStartCmd(startCommand, readyCommand) {\n    this.startCmd = startCommand;\n    if (readyCommand instanceof ReadyCmd) {\n      this.readyCmd = readyCommand.getCmd();\n    } else {\n      this.readyCmd = readyCommand;\n    }\n    return this;\n  }\n  setReadyCmd(readyCommand) {\n    if (readyCommand instanceof ReadyCmd) {\n      this.readyCmd = readyCommand.getCmd();\n    } else {\n      this.readyCmd = readyCommand;\n    }\n    return this;\n  }\n  setEnvs(envs) {\n    if (Object.keys(envs).length === 0) {\n      return this;\n    }\n    this.instructions.push({\n      type: \"ENV\",\n      args: Object.entries(envs).flatMap(([key, value]) => [key, value]),\n      force: this.forceNextLayer\n    });\n    return this;\n  }\n  skipCache() {\n    this.forceNextLayer = true;\n    return this;\n  }\n  async toJSON() {\n    return JSON.stringify(\n      this.serialize(await this.calculateFilesHashes()),\n      void 0,\n      2\n    );\n  }\n  toDockerfile() {\n    if (this.baseTemplate !== void 0) {\n      throw new Error(\n        \"Cannot convert template built from another template to Dockerfile. Templates based on other templates can only be built using the E2B API.\"\n      );\n    }\n    if (this.baseImage === void 0) {\n      throw new Error(\"No base image specified for template\");\n    }\n    let dockerfile = `FROM ${this.baseImage}\n`;\n    for (const instruction of this.instructions) {\n      dockerfile += `${instruction.type} ${instruction.args.join(\" \")}\n`;\n    }\n    if (this.startCmd) {\n      dockerfile += `ENTRYPOINT ${this.startCmd}\n`;\n    }\n    return dockerfile;\n  }\n  async build(options) {\n    var _a3, _b, _c, _d, _e, _f, _g;\n    const config = new ConnectionConfig({\n      domain: options.domain,\n      apiKey: options.apiKey\n    });\n    const client = new ApiClient(config);\n    if (options.skipCache) {\n      this.force = true;\n    }\n    (_a3 = options.onBuildLogs) == null ? void 0 : _a3.call(\n      options,\n      new LogEntry(\n        /* @__PURE__ */ new Date(),\n        \"info\",\n        `Requesting build for template: ${options.alias}`\n      )\n    );\n    const { templateID, buildID } = await requestBuild(client, {\n      alias: options.alias,\n      cpuCount: (_b = options.cpuCount) != null ? _b : 1,\n      memoryMB: (_c = options.memoryMB) != null ? _c : 1024\n    });\n    (_d = options.onBuildLogs) == null ? void 0 : _d.call(\n      options,\n      new LogEntry(\n        /* @__PURE__ */ new Date(),\n        \"info\",\n        `Template created with ID: ${templateID}, Build ID: ${buildID}`\n      )\n    );\n    const instructionsWithHashes = await this.calculateFilesHashes();\n    const fileUploads = instructionsWithHashes.filter((instruction) => instruction.type === \"COPY\").map((instruction) => ({\n      src: instruction.args[0],\n      dest: instruction.args[1],\n      filesHash: instruction.filesHash,\n      forceUpload: instruction.forceUpload\n    }));\n    const uploadPromises = fileUploads.map(async (file) => {\n      var _a4, _b2;\n      const { present, url } = await getFileUploadLink(client, {\n        templateID,\n        filesHash: file.filesHash\n      });\n      if (file.forceUpload && url != null || present === false && url != null) {\n        await uploadFile({\n          fileName: file.src,\n          fileContextPath: this.fileContextPath,\n          url\n        });\n        (_a4 = options.onBuildLogs) == null ? void 0 : _a4.call(\n          options,\n          new LogEntry(/* @__PURE__ */ new Date(), \"info\", `Uploaded '${file.src}'`)\n        );\n      } else {\n        (_b2 = options.onBuildLogs) == null ? void 0 : _b2.call(\n          options,\n          new LogEntry(\n            /* @__PURE__ */ new Date(),\n            \"info\",\n            `Skipping upload of '${file.src}', already cached`\n          )\n        );\n      }\n    });\n    await Promise.all(uploadPromises);\n    (_e = options.onBuildLogs) == null ? void 0 : _e.call(\n      options,\n      new LogEntry(/* @__PURE__ */ new Date(), \"info\", \"All file uploads completed\")\n    );\n    (_f = options.onBuildLogs) == null ? void 0 : _f.call(\n      options,\n      new LogEntry(/* @__PURE__ */ new Date(), \"info\", \"Starting building...\")\n    );\n    await triggerBuild(client, {\n      templateID,\n      buildID,\n      template: this.serialize(instructionsWithHashes)\n    });\n    (_g = options.onBuildLogs) == null ? void 0 : _g.call(\n      options,\n      new LogEntry(/* @__PURE__ */ new Date(), \"info\", \"Waiting for logs...\")\n    );\n    await waitForBuildFinish(client, {\n      templateID,\n      buildID,\n      onBuildLogs: options.onBuildLogs,\n      logsRefreshFrequency: this.logsRefreshFrequency\n    });\n  }\n  // We might no longer need this as we move the logic server-side\n  async calculateFilesHashes() {\n    const steps = [];\n    for (const instruction of this.instructions) {\n      if (instruction.type === \"COPY\") {\n        instruction.filesHash = await calculateFilesHash(\n          instruction.args[0],\n          instruction.args[1],\n          this.fileContextPath,\n          [\n            ...this.ignoreFilePaths,\n            ...runtime === \"browser\" ? [] : readDockerignore(this.fileContextPath)\n          ]\n        );\n      }\n      steps.push(instruction);\n    }\n    return steps;\n  }\n  serialize(steps) {\n    const baseData = {\n      startCmd: this.startCmd,\n      readyCmd: this.readyCmd,\n      steps,\n      force: this.force\n    };\n    if (this.baseImage !== void 0) {\n      return __spreadProps(__spreadValues({}, baseData), {\n        fromImage: this.baseImage\n      });\n    } else if (this.baseTemplate !== void 0) {\n      return __spreadProps(__spreadValues({}, baseData), {\n        fromTemplate: this.baseTemplate\n      });\n    } else {\n      throw new BuildError(\n        \"Template must specify either fromImage or fromTemplate\"\n      );\n    }\n  }\n};\nfunction Template(options) {\n  return new TemplateBase(options);\n}\nTemplate.build = TemplateBase.build;\nTemplate.toJSON = TemplateBase.toJSON;\nTemplate.toDockerfile = TemplateBase.toDockerfile;\n\n// src/index.ts\nvar src_default = Sandbox;\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZTJiL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2R0FBNkcsK0JBQStCLHNCQUFzQixnQkFBZ0I7QUFDbEwsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGtKQUFrSiwwTEFBMEwsYUFBYTs7QUFFelY7QUFDeUM7O0FBRXpDO0FBQ2lDOztBQUVqQztBQUNBOztBQUVBO0FBQ2dDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhLDBCQUEwQiw2Q0FBZ0I7QUFDdkQ7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhLDZCQUE2Qiw2Q0FBZ0I7QUFDMUQ7QUFDQSxXQUFXO0FBQ1g7QUFDQSxNQUFNLG1DQUFtQztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxhQUFhO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx5U0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxZEFBYTtBQUM1QjtBQUNBLHFCQUFxQixvQkFBb0IsSUFBSTtBQUM3QztBQUNBLHdDQUF3QyxHQUFHO0FBQzNDLHdDQUF3QyxVQUFVLElBQUksS0FBSyxNQUFNLElBQUk7QUFDckUscUJBQXFCLElBQUksR0FBRyxJQUFJO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLDBDQUFjO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0NBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTyxRQUFRO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Qsc0RBQXNEO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLFFBQVE7QUFDckY7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLFlBQVksRUFBRSxRQUFRO0FBQy9GO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxVQUFVLElBQUksUUFBUTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxVQUFVLElBQUksUUFBUTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix5QkFBeUIsSUFBSSxRQUFRO0FBQ2hFO0FBQ0E7QUFDQSwrQkFBK0IsaURBQWlEO0FBQ2hGO0FBQ0E7QUFDQSxxT0FBcU8sbUJBQW1CO0FBQ3hQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx5REFBWTtBQUMzQjtBQUNBO0FBQ0EsNkVBQTZFLHNDQUFzQyw0QkFBNEI7QUFDL0ksaUNBQWlDLG1CQUFtQjtBQUNwRCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFFBQVE7QUFDdkQsd0VBQXdFLFlBQVk7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixNQUFNLEdBQUcsVUFBVSxHQUFHLEtBQUssR0FBRyxnQkFBZ0I7QUFDcEUsSUFBSTtBQUNKLHNCQUFzQixNQUFNLEdBQUcsVUFBVSxHQUFHLEtBQUssR0FBRyxnQkFBZ0IsR0FBRywrQkFBK0I7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUs2Qjs7QUFFN0I7QUFDMEM7QUFDZTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG9CQUFvQixJQUFJLFFBQVE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLG9CQUFvQixJQUFJLFFBQVE7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osdUJBQXVCLDZEQUFZO0FBQ25DLHVCQUF1QixxREFBSTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osdUJBQXVCLDZEQUFZO0FBQ25DLHVCQUF1QixxREFBSTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHlEQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNtRjtBQUNuRjtBQUNBLHFCQUFxQiw2REFBYTtBQUNsQztBQUNBLFdBQVcscURBQUs7QUFDaEI7QUFDQSxXQUFXLHFEQUFLO0FBQ2hCO0FBQ0EsV0FBVyxxREFBSztBQUNoQjtBQUNBLFdBQVcscURBQUs7QUFDaEI7QUFDQSxXQUFXLHFEQUFLO0FBQ2hCO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCO0FBQ0EsV0FBVyxxREFBSztBQUNoQjtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0EsbUNBQW1DLFNBQVMsSUFBSSxZQUFZO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNEJBQTRCO0FBQy9DO0FBQ0EsV0FBVyx3QkFBd0IsUUFBUTtBQUMzQzs7QUFFQTtBQU1zQztBQUNrQztBQUN4RSxpREFBaUQsc0VBQVE7QUFDekQ7QUFDQSxHQUFHLGtGQUE4QjtBQUNqQztBQUNBLGlDQUFpQyx5RUFBVzs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0Usc0RBQXNEO0FBQzVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLHlDQUF5QztBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNtRDs7QUFFbkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxpQkFBaUI7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpRUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUNBQXFDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGFBQWE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHlCQUF5Qiw2REFBYTtBQUN0Qyx5QkFBeUIscURBQUs7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGFBQWE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxhQUFhO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTix5QkFBeUIsNkRBQWE7QUFDdEMseUJBQXlCLHFEQUFLO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGFBQWE7QUFDdkIsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLGlFQUFlO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsdUJBQXVCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0Usc0RBQXNEO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSx5Q0FBeUM7QUFDdEg7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ2lFOztBQUVqRTtBQUs2Qjs7QUFFN0I7QUFNc0M7QUFDdEMsMkNBQTJDLHNFQUFTO0FBQ3BEO0FBQ0E7QUFDQSw4QkFBOEIseUVBQVk7O0FBRTFDO0FBSzZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpRUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHlCQUF5Qiw2REFBYTtBQUN0Qyx5QkFBeUIscURBQUs7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpRUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sYUFBYSxZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLE9BQU8scUJBQXFCLG1CQUFtQjtBQUMvQyxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkZBQTJGLG9CQUFvQjtBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkZBQTJGLG9CQUFvQjtBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHlCQUF5Qiw2REFBYTtBQUN0Qyx5QkFBeUIscURBQUs7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwwQkFBMEI7QUFDNUM7QUFDQSx5R0FBeUcsb0JBQW9CO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDdUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFVBQVU7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxVQUFVO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtIQUFrSCx5QkFBeUI7QUFDM0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsVUFBVTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxVQUFVO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxzQkFBc0Isc0JBQXNCO0FBQ2pELDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFVBQVU7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQSx5Q0FBeUMsV0FBVztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpRUFBZ0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxVQUFVO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnREFBZ0QsV0FBVztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxxQkFBcUIscUJBQXFCO0FBQ25ELCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDdUU7QUFDdkU7QUFDQTtBQUNBLFVBQVUsc0JBQXNCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsK0NBQStDLEtBQUssNEJBQTRCO0FBQ3pHLHlCQUF5QiwrRUFBc0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxnQ0FBZ0M7QUFDakY7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMseUNBQXlDO0FBQ25GLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHdCQUF3Qix5Q0FBeUMsOENBQThDLElBQUk7QUFDL0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLFlBQVksd0JBQXdCLHlDQUF5Qyw4Q0FBOEMsSUFBSTtBQUMvSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixLQUFLO0FBQy9CO0FBQ0EsY0FBYyxLQUFLLEdBQUcsZUFBZSxHQUFHLG1CQUFtQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkZBQTJGO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGlFQUFnQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsaUVBQWdCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNkJBQTZCLEtBQUssV0FBVyxJQUFJO0FBQ2hFO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDa0M7QUFDVDtBQUNJO0FBQzdCO0FBQ0EsMkJBQTJCLDRDQUFTO0FBQ3BDLE9BQU8sZ0RBQWE7QUFDcEI7QUFDQTtBQUNBLGtCQUFrQixrREFBZTtBQUNqQztBQUNBO0FBQ0E7QUFDQSxVQUFVLFdBQVc7QUFDckIsa0JBQWtCLDRDQUFTO0FBQzNCLGVBQWUsb0RBQWtCO0FBQ2pDLDBCQUEwQixLQUFLLEVBQUUsS0FBSztBQUN0QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSx5Q0FBeUMsUUFBUTtBQUNqRDtBQUNBO0FBQ0EscUJBQXFCLGtEQUFlO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLCtDQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxXQUFXO0FBQ3JCLFVBQVUsU0FBUztBQUNuQixxQ0FBcUMsb0NBQW9DO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLHlDQUF5QztBQUNuSDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0MsMkJBQTJCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsdUJBQXVCO0FBQ2xFO0FBQ0EsaUJBQWlCLFdBQVcsUUFBUSxLQUFLO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxpQ0FBaUM7QUFDM0MsVUFBVSw4QkFBOEI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0JBQWdCLEVBQUUsV0FBVztBQUM3RDtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsK0JBQStCO0FBQ3JFO0FBQ0Esb0JBQW9CLFdBQVcsU0FBUyxRQUFRO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGlDQUFpQztBQUN6RTtBQUNBLGlCQUFpQixXQUFXLFNBQVMsUUFBUTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBR3dCO0FBQ0U7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnREFBYyw2QkFBNkIsOENBQVk7QUFDL0QsMEJBQTBCLGtEQUFnQjtBQUMxQyxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EscUJBQXFCLDZEQUFnQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsUUFBUTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsY0FBYztBQUNwRDtBQUNBO0FBQ0EsUUFBUTtBQUNSLGtDQUFrQyx1QkFBdUI7QUFDekQ7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxjQUFjO0FBQ2hELFFBQVE7QUFDUjtBQUNBLGtDQUFrQyxXQUFXO0FBQzdDO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xELFVBQVU7QUFDVjtBQUNBLG9DQUFvQyxXQUFXO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxLQUFLO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxVQUFVLElBQUksS0FBSyxhQUFhLFdBQVc7QUFDckY7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGFBQWE7QUFDcEM7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFVBQVU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsUUFBUTtBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBO0FBQ0Esb0NBQW9DLFFBQVE7QUFDNUM7QUFDQTtBQUNBLG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsdUJBQXVCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0R0FBNEc7QUFDNUc7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixjQUFjO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSx1QkFBdUIsa0JBQWtCLEVBQUU7QUFDM0M7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsY0FBYztBQUN4RDtBQUNBO0FBQ0EsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsV0FBVyxjQUFjLFFBQVE7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsY0FBYyxlQUFlO0FBQzdCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esd0VBQXdFLFNBQVM7QUFDakY7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxTQUFTO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOLDRDQUE0QztBQUM1QztBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUEwQkU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpdmUtdmliZS1haS1uZXh0Ly4vbm9kZV9tb2R1bGVzL2UyYi9kaXN0L2luZGV4Lm1qcz8zMDBjIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZQcm9wcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzO1xudmFyIF9fZ2V0T3duUHJvcERlc2NzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM7XG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIF9fa25vd25TeW1ib2wgPSAobmFtZSwgc3ltYm9sKSA9PiAoc3ltYm9sID0gU3ltYm9sW25hbWVdKSA/IHN5bWJvbCA6IFN5bWJvbC5mb3IoXCJTeW1ib2wuXCIgKyBuYW1lKTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG52YXIgX19zcHJlYWRQcm9wcyA9IChhLCBiKSA9PiBfX2RlZlByb3BzKGEsIF9fZ2V0T3duUHJvcERlc2NzKGIpKTtcbnZhciBfX3JlcXVpcmUgPSAvKiBAX19QVVJFX18gKi8gKCh4KSA9PiB0eXBlb2YgcmVxdWlyZSAhPT0gXCJ1bmRlZmluZWRcIiA/IHJlcXVpcmUgOiB0eXBlb2YgUHJveHkgIT09IFwidW5kZWZpbmVkXCIgPyBuZXcgUHJveHkoeCwge1xuICBnZXQ6IChhLCBiKSA9PiAodHlwZW9mIHJlcXVpcmUgIT09IFwidW5kZWZpbmVkXCIgPyByZXF1aXJlIDogYSlbYl1cbn0pIDogeCkoZnVuY3Rpb24oeCkge1xuICBpZiAodHlwZW9mIHJlcXVpcmUgIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiByZXF1aXJlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIHRocm93IEVycm9yKCdEeW5hbWljIHJlcXVpcmUgb2YgXCInICsgeCArICdcIiBpcyBub3Qgc3VwcG9ydGVkJyk7XG59KTtcbnZhciBfX2F3YWl0ID0gZnVuY3Rpb24ocHJvbWlzZSwgaXNZaWVsZFN0YXIpIHtcbiAgdGhpc1swXSA9IHByb21pc2U7XG4gIHRoaXNbMV0gPSBpc1lpZWxkU3Rhcjtcbn07XG52YXIgX19hc3luY0dlbmVyYXRvciA9IChfX3RoaXMsIF9fYXJndW1lbnRzLCBnZW5lcmF0b3IpID0+IHtcbiAgdmFyIHJlc3VtZSA9IChrLCB2LCB5ZXMsIG5vKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciB4ID0gZ2VuZXJhdG9yW2tdKHYpLCBpc0F3YWl0ID0gKHYgPSB4LnZhbHVlKSBpbnN0YW5jZW9mIF9fYXdhaXQsIGRvbmUgPSB4LmRvbmU7XG4gICAgICBQcm9taXNlLnJlc29sdmUoaXNBd2FpdCA/IHZbMF0gOiB2KS50aGVuKCh5KSA9PiBpc0F3YWl0ID8gcmVzdW1lKGsgPT09IFwicmV0dXJuXCIgPyBrIDogXCJuZXh0XCIsIHZbMV0gPyB7IGRvbmU6IHkuZG9uZSwgdmFsdWU6IHkudmFsdWUgfSA6IHksIHllcywgbm8pIDogeWVzKHsgdmFsdWU6IHksIGRvbmUgfSkpLmNhdGNoKChlKSA9PiByZXN1bWUoXCJ0aHJvd1wiLCBlLCB5ZXMsIG5vKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbm8oZSk7XG4gICAgfVxuICB9LCBtZXRob2QgPSAoaykgPT4gaXRba10gPSAoeCkgPT4gbmV3IFByb21pc2UoKHllcywgbm8pID0+IHJlc3VtZShrLCB4LCB5ZXMsIG5vKSksIGl0ID0ge307XG4gIHJldHVybiBnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkoX190aGlzLCBfX2FyZ3VtZW50cyksIGl0W19fa25vd25TeW1ib2woXCJhc3luY0l0ZXJhdG9yXCIpXSA9ICgpID0+IGl0LCBtZXRob2QoXCJuZXh0XCIpLCBtZXRob2QoXCJ0aHJvd1wiKSwgbWV0aG9kKFwicmV0dXJuXCIpLCBpdDtcbn07XG52YXIgX19mb3JBd2FpdCA9IChvYmosIGl0LCBtZXRob2QpID0+IChpdCA9IG9ialtfX2tub3duU3ltYm9sKFwiYXN5bmNJdGVyYXRvclwiKV0pID8gaXQuY2FsbChvYmopIDogKG9iaiA9IG9ialtfX2tub3duU3ltYm9sKFwiaXRlcmF0b3JcIildKCksIGl0ID0ge30sIG1ldGhvZCA9IChrZXksIGZuKSA9PiAoZm4gPSBvYmpba2V5XSkgJiYgKGl0W2tleV0gPSAoYXJnKSA9PiBuZXcgUHJvbWlzZSgoeWVzLCBubywgZG9uZSkgPT4gKGFyZyA9IGZuLmNhbGwob2JqLCBhcmcpLCBkb25lID0gYXJnLmRvbmUsIFByb21pc2UucmVzb2x2ZShhcmcudmFsdWUpLnRoZW4oKHZhbHVlKSA9PiB5ZXMoeyB2YWx1ZSwgZG9uZSB9KSwgbm8pKSkpLCBtZXRob2QoXCJuZXh0XCIpLCBtZXRob2QoXCJyZXR1cm5cIiksIGl0KTtcblxuLy8gc3JjL2FwaS9pbmRleC50c1xuaW1wb3J0IGNyZWF0ZUNsaWVudCBmcm9tIFwib3BlbmFwaS1mZXRjaFwiO1xuXG4vLyBzcmMvYXBpL21ldGFkYXRhLnRzXG5pbXBvcnQgcGxhdGZvcm0yIGZyb20gXCJwbGF0Zm9ybVwiO1xuXG4vLyBwYWNrYWdlLmpzb25cbnZhciB2ZXJzaW9uID0gXCIyLjEuMlwiO1xuXG4vLyBzcmMvdXRpbHMudHNcbmltcG9ydCBwbGF0Zm9ybSBmcm9tIFwicGxhdGZvcm1cIjtcbmZ1bmN0aW9uIGdldFJ1bnRpbWUoKSB7XG4gIHZhciBfYTMsIF9iLCBfYztcbiAgaWYgKGdsb2JhbFRoaXMuQnVuKSB7XG4gICAgcmV0dXJuIHsgcnVudGltZTogXCJidW5cIiwgdmVyc2lvbjogZ2xvYmFsVGhpcy5CdW4udmVyc2lvbiB9O1xuICB9XG4gIGlmIChnbG9iYWxUaGlzLkRlbm8pIHtcbiAgICByZXR1cm4geyBydW50aW1lOiBcImRlbm9cIiwgdmVyc2lvbjogZ2xvYmFsVGhpcy5EZW5vLnZlcnNpb24uZGVubyB9O1xuICB9XG4gIGlmICgoKF9iID0gKF9hMyA9IGdsb2JhbFRoaXMucHJvY2VzcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5yZWxlYXNlKSA9PSBudWxsID8gdm9pZCAwIDogX2IubmFtZSkgPT09IFwibm9kZVwiKSB7XG4gICAgcmV0dXJuIHsgcnVudGltZTogXCJub2RlXCIsIHZlcnNpb246IHBsYXRmb3JtLnZlcnNpb24gfHwgXCJ1bmtub3duXCIgfTtcbiAgfVxuICBpZiAodHlwZW9mIEVkZ2VSdW50aW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHsgcnVudGltZTogXCJ2ZXJjZWwtZWRnZVwiLCB2ZXJzaW9uOiBcInVua25vd25cIiB9O1xuICB9XG4gIGlmICgoKF9jID0gZ2xvYmFsVGhpcy5uYXZpZ2F0b3IpID09IG51bGwgPyB2b2lkIDAgOiBfYy51c2VyQWdlbnQpID09PSBcIkNsb3VkZmxhcmUtV29ya2Vyc1wiKSB7XG4gICAgcmV0dXJuIHsgcnVudGltZTogXCJjbG91ZGZsYXJlLXdvcmtlclwiLCB2ZXJzaW9uOiBcInVua25vd25cIiB9O1xuICB9XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIHsgcnVudGltZTogXCJicm93c2VyXCIsIHZlcnNpb246IHBsYXRmb3JtLnZlcnNpb24gfHwgXCJ1bmtub3duXCIgfTtcbiAgfVxuICByZXR1cm4geyBydW50aW1lOiBcInVua25vd25cIiwgdmVyc2lvbjogXCJ1bmtub3duXCIgfTtcbn1cbnZhciB7IHJ1bnRpbWUsIHZlcnNpb246IHJ1bnRpbWVWZXJzaW9uIH0gPSBnZXRSdW50aW1lKCk7XG5hc3luYyBmdW5jdGlvbiBzaGEyNTYoZGF0YSkge1xuICBpZiAodHlwZW9mIGNyeXB0byAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICBjb25zdCBkYXRhQnVmZmVyID0gZW5jb2Rlci5lbmNvZGUoZGF0YSk7XG4gICAgY29uc3QgaGFzaEJ1ZmZlciA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuZGlnZXN0KFwiU0hBLTI1NlwiLCBkYXRhQnVmZmVyKTtcbiAgICBjb25zdCBoYXNoQXJyYXkgPSBuZXcgVWludDhBcnJheShoYXNoQnVmZmVyKTtcbiAgICByZXR1cm4gYnRvYShTdHJpbmcuZnJvbUNoYXJDb2RlKC4uLmhhc2hBcnJheSkpO1xuICB9XG4gIGNvbnN0IHsgY3JlYXRlSGFzaCB9ID0gX19yZXF1aXJlKFwibm9kZTpjcnlwdG9cIik7XG4gIGNvbnN0IGhhc2ggPSBjcmVhdGVIYXNoKFwic2hhMjU2XCIpLnVwZGF0ZShkYXRhLCBcInV0ZjhcIikuZGlnZXN0KCk7XG4gIHJldHVybiBoYXNoLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xufVxuZnVuY3Rpb24gdGltZW91dFRvU2Vjb25kcyh0aW1lb3V0KSB7XG4gIHJldHVybiBNYXRoLmNlaWwodGltZW91dCAvIDFlMyk7XG59XG5hc3luYyBmdW5jdGlvbiBkeW5hbWljR2xvYigpIHtcbiAgaWYgKHJ1bnRpbWUgPT09IFwiYnJvd3NlclwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQnJvd3NlciBydW50aW1lIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIGdsb2JcIik7XG4gIH1cbiAgcmV0dXJuIGF3YWl0IGltcG9ydChcImdsb2JcIik7XG59XG5hc3luYyBmdW5jdGlvbiBkeW5hbWljVGFyKCkge1xuICBpZiAocnVudGltZSA9PT0gXCJicm93c2VyXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJCcm93c2VyIHJ1bnRpbWUgaXMgbm90IHN1cHBvcnRlZCBmb3IgdGFyXCIpO1xuICB9XG4gIHJldHVybiBhd2FpdCBpbXBvcnQoXCJ0YXJcIik7XG59XG5mdW5jdGlvbiBhbnNpUmVnZXgoeyBvbmx5Rmlyc3QgPSBmYWxzZSB9ID0ge30pIHtcbiAgY29uc3QgU1QgPSBcIig/OlxcXFx1MDAwN3xcXFxcdTAwMUJcXFxcdTAwNUN8XFxcXHUwMDlDKVwiO1xuICBjb25zdCBvc2MgPSBgKD86XFxcXHUwMDFCXFxcXF1bXFxcXHNcXFxcU10qPyR7U1R9KWA7XG4gIGNvbnN0IGNzaSA9IFwiW1xcXFx1MDAxQlxcXFx1MDA5Ql1bW1xcXFxdKCkjOz9dKig/OlxcXFxkezEsNH0oPzpbOzpdXFxcXGR7MCw0fSkqKT9bXFxcXGRBLVBSLVRaY2YtbnEtdXk9Pjx+XVwiO1xuICBjb25zdCBwYXR0ZXJuID0gYCR7b3NjfXwke2NzaX1gO1xuICByZXR1cm4gbmV3IFJlZ0V4cChwYXR0ZXJuLCBvbmx5Rmlyc3QgPyB2b2lkIDAgOiBcImdcIik7XG59XG5mdW5jdGlvbiBzdHJpcEFuc2kodGV4dCkge1xuICByZXR1cm4gdGV4dC5yZXBsYWNlKGFuc2lSZWdleCgpLCBcIlwiKTtcbn1cblxuLy8gc3JjL2FwaS9tZXRhZGF0YS50c1xudmFyIF9hO1xudmFyIGRlZmF1bHRIZWFkZXJzID0ge1xuICBicm93c2VyOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHBsYXRmb3JtMi5uYW1lIHx8IFwidW5rbm93blwiLFxuICBsYW5nOiBcImpzXCIsXG4gIGxhbmdfdmVyc2lvbjogcnVudGltZVZlcnNpb24sXG4gIHBhY2thZ2VfdmVyc2lvbjogdmVyc2lvbixcbiAgcHVibGlzaGVyOiBcImUyYlwiLFxuICBzZGtfcnVudGltZTogcnVudGltZSxcbiAgc3lzdGVtOiAoKF9hID0gcGxhdGZvcm0yLm9zKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZmFtaWx5KSB8fCBcInVua25vd25cIlxufTtcbmZ1bmN0aW9uIGdldEVudlZhcihuYW1lKSB7XG4gIGlmIChydW50aW1lID09PSBcImRlbm9cIikge1xuICAgIHJldHVybiBEZW5vLmVudi5nZXQobmFtZSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgcmV0dXJuIHByb2Nlc3MuZW52W25hbWVdO1xufVxuXG4vLyBzcmMvZXJyb3JzLnRzXG5mdW5jdGlvbiBmb3JtYXRTYW5kYm94VGltZW91dEVycm9yKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0RXJyb3IoXG4gICAgYCR7bWVzc2FnZX06IFRoaXMgZXJyb3IgaXMgbGlrZWx5IGR1ZSB0byBzYW5kYm94IHRpbWVvdXQuIFlvdSBjYW4gbW9kaWZ5IHRoZSBzYW5kYm94IHRpbWVvdXQgYnkgcGFzc2luZyAndGltZW91dE1zJyB3aGVuIHN0YXJ0aW5nIHRoZSBzYW5kYm94IG9yIGNhbGxpbmcgJy5zZXRUaW1lb3V0JyBvbiB0aGUgc2FuZGJveCB3aXRoIHRoZSBkZXNpcmVkIHRpbWVvdXQuYFxuICApO1xufVxudmFyIFNhbmRib3hFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gXCJTYW5kYm94RXJyb3JcIjtcbiAgfVxufTtcbnZhciBUaW1lb3V0RXJyb3IgPSBjbGFzcyBleHRlbmRzIFNhbmRib3hFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSBcIlRpbWVvdXRFcnJvclwiO1xuICB9XG59O1xudmFyIEludmFsaWRBcmd1bWVudEVycm9yID0gY2xhc3MgZXh0ZW5kcyBTYW5kYm94RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gXCJJbnZhbGlkQXJndW1lbnRFcnJvclwiO1xuICB9XG59O1xudmFyIE5vdEVub3VnaFNwYWNlRXJyb3IgPSBjbGFzcyBleHRlbmRzIFNhbmRib3hFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSBcIk5vdEVub3VnaFNwYWNlRXJyb3JcIjtcbiAgfVxufTtcbnZhciBOb3RGb3VuZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBTYW5kYm94RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gXCJOb3RGb3VuZEVycm9yXCI7XG4gIH1cbn07XG52YXIgQXV0aGVudGljYXRpb25FcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gXCJBdXRoZW50aWNhdGlvbkVycm9yXCI7XG4gIH1cbn07XG52YXIgVGVtcGxhdGVFcnJvciA9IGNsYXNzIGV4dGVuZHMgU2FuZGJveEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9IFwiVGVtcGxhdGVFcnJvclwiO1xuICB9XG59O1xudmFyIFJhdGVMaW1pdEVycm9yID0gY2xhc3MgZXh0ZW5kcyBTYW5kYm94RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gXCJSYXRlTGltaXRFcnJvclwiO1xuICB9XG59O1xuXG4vLyBzcmMvbG9ncy50c1xuZnVuY3Rpb24gZm9ybWF0TG9nKGxvZykge1xuICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShsb2cpKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJwY0xvZ2dlcihsb2dnZXIpIHtcbiAgZnVuY3Rpb24gbG9nRWFjaChzdHJlYW0pIHtcbiAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hMztcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIGl0ZXIgPSBfX2ZvckF3YWl0KHN0cmVhbSksIG1vcmUsIHRlbXAsIGVycm9yOyBtb3JlID0gISh0ZW1wID0geWllbGQgbmV3IF9fYXdhaXQoaXRlci5uZXh0KCkpKS5kb25lOyBtb3JlID0gZmFsc2UpIHtcbiAgICAgICAgICBjb25zdCBtID0gdGVtcC52YWx1ZTtcbiAgICAgICAgICAoX2EzID0gbG9nZ2VyLmRlYnVnKSA9PSBudWxsID8gdm9pZCAwIDogX2EzLmNhbGwobG9nZ2VyLCBcIlJlc3BvbnNlIHN0cmVhbTpcIiwgZm9ybWF0TG9nKG0pKTtcbiAgICAgICAgICB5aWVsZCBtO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoICh0ZW1wKSB7XG4gICAgICAgIGVycm9yID0gW3RlbXBdO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBtb3JlICYmICh0ZW1wID0gaXRlci5yZXR1cm4pICYmICh5aWVsZCBuZXcgX19hd2FpdCh0ZW1wLmNhbGwoaXRlcikpKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICB0aHJvdyBlcnJvclswXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiAobmV4dCkgPT4gYXN5bmMgKHJlcSkgPT4ge1xuICAgIHZhciBfYTMsIF9iO1xuICAgIChfYTMgPSBsb2dnZXIuaW5mbykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5jYWxsKGxvZ2dlciwgYFJlcXVlc3Q6IFBPU1QgJHtyZXEudXJsfWApO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IG5leHQocmVxKTtcbiAgICBpZiAocmVzLnN0cmVhbSkge1xuICAgICAgcmV0dXJuIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIHJlcyksIHtcbiAgICAgICAgbWVzc2FnZTogbG9nRWFjaChyZXMubWVzc2FnZSlcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAoX2IgPSBsb2dnZXIuaW5mbykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwobG9nZ2VyLCBcIlJlc3BvbnNlOlwiLCBmb3JtYXRMb2cocmVzLm1lc3NhZ2UpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUFwaUxvZ2dlcihsb2dnZXIpIHtcbiAgcmV0dXJuIHtcbiAgICBhc3luYyBvblJlcXVlc3QocmVxKSB7XG4gICAgICB2YXIgX2EzO1xuICAgICAgKF9hMyA9IGxvZ2dlci5pbmZvKSA9PSBudWxsID8gdm9pZCAwIDogX2EzLmNhbGwobG9nZ2VyLCBgUmVxdWVzdCAke3JlcS5tZXRob2R9ICR7cmVxLnVybH1gKTtcbiAgICAgIHJldHVybiByZXE7XG4gICAgfSxcbiAgICBhc3luYyBvblJlc3BvbnNlKHJlcykge1xuICAgICAgdmFyIF9hMywgX2I7XG4gICAgICBpZiAocmVzLnN0YXR1cyA+PSA0MDApIHtcbiAgICAgICAgKF9hMyA9IGxvZ2dlci5lcnJvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5jYWxsKGxvZ2dlciwgXCJSZXNwb25zZTpcIiwgcmVzLnN0YXR1cywgcmVzLnN0YXR1c1RleHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKF9iID0gbG9nZ2VyLmluZm8pID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKGxvZ2dlciwgXCJSZXNwb25zZTpcIiwgcmVzLnN0YXR1cywgcmVzLnN0YXR1c1RleHQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hcGkvaW5kZXgudHNcbmZ1bmN0aW9uIGhhbmRsZUFwaUVycm9yKHJlc3BvbnNlLCBlcnJvckNsYXNzID0gU2FuZGJveEVycm9yKSB7XG4gIHZhciBfYTMsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgaWYgKCFyZXNwb25zZS5lcnJvcikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocmVzcG9uc2UucmVzcG9uc2Uuc3RhdHVzID09PSA0MDEpIHtcbiAgICBjb25zdCBtZXNzYWdlMiA9IFwiVW5hdXRob3JpemVkLCBwbGVhc2UgY2hlY2sgeW91ciBjcmVkZW50aWFscy5cIjtcbiAgICBjb25zdCBjb250ZW50ID0gKF9iID0gKF9hMyA9IHJlc3BvbnNlLmVycm9yKSA9PSBudWxsID8gdm9pZCAwIDogX2EzLm1lc3NhZ2UpICE9IG51bGwgPyBfYiA6IHJlc3BvbnNlLmVycm9yO1xuICAgIGlmIChjb250ZW50KSB7XG4gICAgICByZXR1cm4gbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IoYCR7bWVzc2FnZTJ9IC0gJHtjb250ZW50fWApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IobWVzc2FnZTIpO1xuICB9XG4gIGlmIChyZXNwb25zZS5yZXNwb25zZS5zdGF0dXMgPT09IDQyOSkge1xuICAgIGNvbnN0IG1lc3NhZ2UyID0gXCJSYXRlIGxpbWl0IGV4Y2VlZGVkLCBwbGVhc2UgdHJ5IGFnYWluIGxhdGVyXCI7XG4gICAgY29uc3QgY29udGVudCA9IChfZCA9IChfYyA9IHJlc3BvbnNlLmVycm9yKSA9PSBudWxsID8gdm9pZCAwIDogX2MubWVzc2FnZSkgIT0gbnVsbCA/IF9kIDogcmVzcG9uc2UuZXJyb3I7XG4gICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgIHJldHVybiBuZXcgUmF0ZUxpbWl0RXJyb3IoYCR7bWVzc2FnZTJ9IC0gJHtjb250ZW50fWApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFJhdGVMaW1pdEVycm9yKG1lc3NhZ2UyKTtcbiAgfVxuICBjb25zdCBtZXNzYWdlID0gKF9mID0gKF9lID0gcmVzcG9uc2UuZXJyb3IpID09IG51bGwgPyB2b2lkIDAgOiBfZS5tZXNzYWdlKSAhPSBudWxsID8gX2YgOiByZXNwb25zZS5lcnJvcjtcbiAgcmV0dXJuIG5ldyBlcnJvckNsYXNzKGAke3Jlc3BvbnNlLnJlc3BvbnNlLnN0YXR1c306ICR7bWVzc2FnZX1gKTtcbn1cbnZhciBBcGlDbGllbnQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZywgb3B0cyA9IHsgcmVxdWlyZUFjY2Vzc1Rva2VuOiBmYWxzZSwgcmVxdWlyZUFwaUtleTogZmFsc2UgfSkge1xuICAgIGlmICgob3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5yZXF1aXJlQXBpS2V5KSAmJiAhY29uZmlnLmFwaUtleSkge1xuICAgICAgdGhyb3cgbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IoXG4gICAgICAgIFwiQVBJIGtleSBpcyByZXF1aXJlZCwgcGxlYXNlIHZpc2l0IHRoZSBUZWFtIHRhYiBhdCBodHRwczovL2UyYi5kZXYvZGFzaGJvYXJkIHRvIGdldCB5b3VyIEFQSSBrZXkuIFlvdSBjYW4gZWl0aGVyIHNldCB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGUgYEUyQl9BUElfS0VZYCBvciB5b3UgY2FuIHBhc3MgaXQgZGlyZWN0bHkgdG8gdGhlIHNhbmRib3ggbGlrZSBTYW5kYm94LmNyZWF0ZSh7IGFwaUtleTogJ2UyYl8uLi4nIH0pXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICgob3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5yZXF1aXJlQWNjZXNzVG9rZW4pICYmICFjb25maWcuYWNjZXNzVG9rZW4pIHtcbiAgICAgIHRocm93IG5ldyBBdXRoZW50aWNhdGlvbkVycm9yKFxuICAgICAgICBcIkFjY2VzcyB0b2tlbiBpcyByZXF1aXJlZCwgcGxlYXNlIHZpc2l0IHRoZSBQZXJzb25hbCB0YWIgYXQgaHR0cHM6Ly9lMmIuZGV2L2Rhc2hib2FyZCB0byBnZXQgeW91ciBhY2Nlc3MgdG9rZW4uIFlvdSBjYW4gc2V0IHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZSBgRTJCX0FDQ0VTU19UT0tFTmAgb3IgcGFzcyB0aGUgYGFjY2Vzc1Rva2VuYCBpbiBvcHRpb25zLlwiXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLmFwaSA9IGNyZWF0ZUNsaWVudCh7XG4gICAgICBiYXNlVXJsOiBjb25maWcuYXBpVXJsLFxuICAgICAgLy8ga2VlcGFsaXZlOiB0cnVlLCAvLyBUT0RPOiBSZXR1cm4ga2VlcGFsaXZlXG4gICAgICBoZWFkZXJzOiBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgZGVmYXVsdEhlYWRlcnMpLCBjb25maWcuYXBpS2V5ICYmIHsgXCJYLUFQSS1LRVlcIjogY29uZmlnLmFwaUtleSB9KSwgY29uZmlnLmFjY2Vzc1Rva2VuICYmIHtcbiAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke2NvbmZpZy5hY2Nlc3NUb2tlbn1gXG4gICAgICB9KSwgY29uZmlnLmhlYWRlcnMpLFxuICAgICAgcXVlcnlTZXJpYWxpemVyOiB7XG4gICAgICAgIGFycmF5OiB7XG4gICAgICAgICAgc3R5bGU6IFwiZm9ybVwiLFxuICAgICAgICAgIGV4cGxvZGU6IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoY29uZmlnLmxvZ2dlcikge1xuICAgICAgdGhpcy5hcGkudXNlKGNyZWF0ZUFwaUxvZ2dlcihjb25maWcubG9nZ2VyKSk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvY29ubmVjdGlvbkNvbmZpZy50c1xudmFyIFJFUVVFU1RfVElNRU9VVF9NUyA9IDZlNDtcbnZhciBERUZBVUxUX1NBTkRCT1hfVElNRU9VVF9NUyA9IDNlNTtcbnZhciBLRUVQQUxJVkVfUElOR19JTlRFUlZBTF9TRUMgPSA1MDtcbnZhciBLRUVQQUxJVkVfUElOR19IRUFERVIgPSBcIktlZXBhbGl2ZS1QaW5nLUludGVydmFsXCI7XG52YXIgQ29ubmVjdGlvbkNvbmZpZyA9IGNsYXNzIF9Db25uZWN0aW9uQ29uZmlnIHtcbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHZhciBfYTM7XG4gICAgdGhpcy5hcGlLZXkgPSAob3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5hcGlLZXkpIHx8IF9Db25uZWN0aW9uQ29uZmlnLmFwaUtleTtcbiAgICB0aGlzLmRlYnVnID0gKG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuZGVidWcpIHx8IF9Db25uZWN0aW9uQ29uZmlnLmRlYnVnO1xuICAgIHRoaXMuZG9tYWluID0gKG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuZG9tYWluKSB8fCBfQ29ubmVjdGlvbkNvbmZpZy5kb21haW47XG4gICAgdGhpcy5hY2Nlc3NUb2tlbiA9IChvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLmFjY2Vzc1Rva2VuKSB8fCBfQ29ubmVjdGlvbkNvbmZpZy5hY2Nlc3NUb2tlbjtcbiAgICB0aGlzLnJlcXVlc3RUaW1lb3V0TXMgPSAoX2EzID0gb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5yZXF1ZXN0VGltZW91dE1zKSAhPSBudWxsID8gX2EzIDogUkVRVUVTVF9USU1FT1VUX01TO1xuICAgIHRoaXMubG9nZ2VyID0gb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5sb2dnZXI7XG4gICAgdGhpcy5oZWFkZXJzID0gKG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuaGVhZGVycykgfHwge307XG4gICAgdGhpcy5oZWFkZXJzW1wiVXNlci1BZ2VudFwiXSA9IGBlMmItanMtc2RrLyR7dmVyc2lvbn1gO1xuICAgIHRoaXMuYXBpVXJsID0gdGhpcy5kZWJ1ZyA/IFwiaHR0cDovL2xvY2FsaG9zdDozMDAwXCIgOiBgaHR0cHM6Ly9hcGkuJHt0aGlzLmRvbWFpbn1gO1xuICB9XG4gIHN0YXRpYyBnZXQgZG9tYWluKCkge1xuICAgIHJldHVybiBnZXRFbnZWYXIoXCJFMkJfRE9NQUlOXCIpIHx8IFwiZTJiLmFwcFwiO1xuICB9XG4gIHN0YXRpYyBnZXQgZGVidWcoKSB7XG4gICAgcmV0dXJuIChnZXRFbnZWYXIoXCJFMkJfREVCVUdcIikgfHwgXCJmYWxzZVwiKS50b0xvd2VyQ2FzZSgpID09PSBcInRydWVcIjtcbiAgfVxuICBzdGF0aWMgZ2V0IGFwaUtleSgpIHtcbiAgICByZXR1cm4gZ2V0RW52VmFyKFwiRTJCX0FQSV9LRVlcIik7XG4gIH1cbiAgc3RhdGljIGdldCBhY2Nlc3NUb2tlbigpIHtcbiAgICByZXR1cm4gZ2V0RW52VmFyKFwiRTJCX0FDQ0VTU19UT0tFTlwiKTtcbiAgfVxuICBnZXRTaWduYWwocmVxdWVzdFRpbWVvdXRNcykge1xuICAgIGNvbnN0IHRpbWVvdXQgPSByZXF1ZXN0VGltZW91dE1zICE9IG51bGwgPyByZXF1ZXN0VGltZW91dE1zIDogdGhpcy5yZXF1ZXN0VGltZW91dE1zO1xuICAgIHJldHVybiB0aW1lb3V0ID8gQWJvcnRTaWduYWwudGltZW91dCh0aW1lb3V0KSA6IHZvaWQgMDtcbiAgfVxufTtcbnZhciBkZWZhdWx0VXNlcm5hbWUgPSBcInVzZXJcIjtcblxuLy8gc3JjL3NhbmRib3gvc2lnbmF0dXJlLnRzXG5hc3luYyBmdW5jdGlvbiBnZXRTaWduYXR1cmUoe1xuICBwYXRoOiBwYXRoMixcbiAgb3BlcmF0aW9uLFxuICB1c2VyLFxuICBleHBpcmF0aW9uSW5TZWNvbmRzLFxuICBlbnZkQWNjZXNzVG9rZW5cbn0pIHtcbiAgaWYgKCFlbnZkQWNjZXNzVG9rZW4pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIkFjY2VzcyB0b2tlbiBpcyBub3Qgc2V0IGFuZCBzaWduYXR1cmUgY2Fubm90IGJlIGdlbmVyYXRlZCFcIlxuICAgICk7XG4gIH1cbiAgY29uc3Qgc2lnbmF0dXJlRXhwaXJhdGlvbiA9IGV4cGlyYXRpb25JblNlY29uZHMgPyBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxZTMpICsgZXhwaXJhdGlvbkluU2Vjb25kcyA6IG51bGw7XG4gIGxldCBzaWduYXR1cmVSYXc7XG4gIGlmIChzaWduYXR1cmVFeHBpcmF0aW9uID09PSBudWxsKSB7XG4gICAgc2lnbmF0dXJlUmF3ID0gYCR7cGF0aDJ9OiR7b3BlcmF0aW9ufToke3VzZXJ9OiR7ZW52ZEFjY2Vzc1Rva2VufWA7XG4gIH0gZWxzZSB7XG4gICAgc2lnbmF0dXJlUmF3ID0gYCR7cGF0aDJ9OiR7b3BlcmF0aW9ufToke3VzZXJ9OiR7ZW52ZEFjY2Vzc1Rva2VufToke3NpZ25hdHVyZUV4cGlyYXRpb24udG9TdHJpbmcoKX1gO1xuICB9XG4gIGNvbnN0IGhhc2hCYXNlNjQgPSBhd2FpdCBzaGEyNTYoc2lnbmF0dXJlUmF3KTtcbiAgY29uc3Qgc2lnbmF0dXJlID0gXCJ2MV9cIiArIGhhc2hCYXNlNjQucmVwbGFjZSgvPSskLywgXCJcIik7XG4gIHJldHVybiB7XG4gICAgc2lnbmF0dXJlLFxuICAgIGV4cGlyYXRpb246IHNpZ25hdHVyZUV4cGlyYXRpb25cbiAgfTtcbn1cblxuLy8gc3JjL3NhbmRib3gvZmlsZXN5c3RlbS9pbmRleC50c1xuaW1wb3J0IHtcbiAgY3JlYXRlQ2xpZW50IGFzIGNyZWF0ZUNsaWVudDMsXG4gIENvbm5lY3RFcnJvciBhcyBDb25uZWN0RXJyb3IzLFxuICBDb2RlIGFzIENvZGUzXG59IGZyb20gXCJAY29ubmVjdHJwYy9jb25uZWN0XCI7XG5cbi8vIHNyYy9lbnZkL2FwaS50c1xuaW1wb3J0IGNyZWF0ZUNsaWVudDIgZnJvbSBcIm9wZW5hcGktZmV0Y2hcIjtcbmltcG9ydCB7IENvZGUsIENvbm5lY3RFcnJvciB9IGZyb20gXCJAY29ubmVjdHJwYy9jb25uZWN0XCI7XG5hc3luYyBmdW5jdGlvbiBoYW5kbGVFbnZkQXBpRXJyb3IocmVzKSB7XG4gIHZhciBfYTM7XG4gIGlmICghcmVzLmVycm9yKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG1lc3NhZ2UgPSB0eXBlb2YgcmVzLmVycm9yID09IFwic3RyaW5nXCIgPyByZXMuZXJyb3IgOiAoKF9hMyA9IHJlcy5lcnJvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5tZXNzYWdlKSB8fCBhd2FpdCByZXMucmVzcG9uc2UudGV4dCgpO1xuICBzd2l0Y2ggKHJlcy5yZXNwb25zZS5zdGF0dXMpIHtcbiAgICBjYXNlIDQwMDpcbiAgICAgIHJldHVybiBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IobWVzc2FnZSk7XG4gICAgY2FzZSA0MDE6XG4gICAgICByZXR1cm4gbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IobWVzc2FnZSk7XG4gICAgY2FzZSA0MDQ6XG4gICAgICByZXR1cm4gbmV3IE5vdEZvdW5kRXJyb3IobWVzc2FnZSk7XG4gICAgY2FzZSA0Mjk6XG4gICAgICByZXR1cm4gbmV3IFNhbmRib3hFcnJvcihcbiAgICAgICAgYCR7cmVzLnJlc3BvbnNlLnN0YXR1c306ICR7bWVzc2FnZX06IFRoZSByZXF1ZXN0cyBhcmUgYmVpbmcgcmF0ZSBsaW1pdGVkLmBcbiAgICAgICk7XG4gICAgY2FzZSA1MDI6XG4gICAgICByZXR1cm4gZm9ybWF0U2FuZGJveFRpbWVvdXRFcnJvcihtZXNzYWdlKTtcbiAgICBjYXNlIDUwNzpcbiAgICAgIHJldHVybiBuZXcgTm90RW5vdWdoU3BhY2VFcnJvcihtZXNzYWdlKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG5ldyBTYW5kYm94RXJyb3IoYCR7cmVzLnJlc3BvbnNlLnN0YXR1c306ICR7bWVzc2FnZX1gKTtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gaGFuZGxlUHJvY2Vzc1N0YXJ0RXZlbnQoZXZlbnRzKSB7XG4gIHZhciBfYTM7XG4gIGxldCBzdGFydEV2ZW50O1xuICB0cnkge1xuICAgIHN0YXJ0RXZlbnQgPSAoYXdhaXQgZXZlbnRzW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpLm5leHQoKSkudmFsdWU7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnIgaW5zdGFuY2VvZiBDb25uZWN0RXJyb3IpIHtcbiAgICAgIGlmIChlcnIuY29kZSA9PT0gQ29kZS5VbmF2YWlsYWJsZSkge1xuICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFcnJvcihcIlNhbmRib3ggaXMgcHJvYmFibHkgbm90IHJ1bm5pbmcgYW55bW9yZVwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgZXJyO1xuICB9XG4gIGlmICgoKF9hMyA9IHN0YXJ0RXZlbnQuZXZlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYTMuZXZlbnQuY2FzZSkgIT09IFwic3RhcnRcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIHN0YXJ0IGV2ZW50XCIpO1xuICB9XG4gIHJldHVybiBzdGFydEV2ZW50LmV2ZW50LmV2ZW50LnZhbHVlLnBpZDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZVdhdGNoRGlyU3RhcnRFdmVudChldmVudHMpIHtcbiAgdmFyIF9hMztcbiAgbGV0IHN0YXJ0RXZlbnQ7XG4gIHRyeSB7XG4gICAgc3RhcnRFdmVudCA9IChhd2FpdCBldmVudHNbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkubmV4dCgpKS52YWx1ZTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGVyciBpbnN0YW5jZW9mIENvbm5lY3RFcnJvcikge1xuICAgICAgaWYgKGVyci5jb2RlID09PSBDb2RlLlVuYXZhaWxhYmxlKSB7XG4gICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEVycm9yKFwiU2FuZGJveCBpcyBwcm9iYWJseSBub3QgcnVubmluZyBhbnltb3JlXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBlcnI7XG4gIH1cbiAgaWYgKCgoX2EzID0gc3RhcnRFdmVudC5ldmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5jYXNlKSAhPT0gXCJzdGFydFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgc3RhcnQgZXZlbnRcIik7XG4gIH1cbiAgcmV0dXJuIHN0YXJ0RXZlbnQuZXZlbnQudmFsdWU7XG59XG52YXIgRW52ZEFwaUNsaWVudCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY29uZmlnLCBtZXRhZGF0YSkge1xuICAgIHRoaXMuYXBpID0gY3JlYXRlQ2xpZW50Mih7XG4gICAgICBiYXNlVXJsOiBjb25maWcuYXBpVXJsLFxuICAgICAgZmV0Y2g6IGNvbmZpZyA9PSBudWxsID8gdm9pZCAwIDogY29uZmlnLmZldGNoLFxuICAgICAgaGVhZGVyczogY29uZmlnID09IG51bGwgPyB2b2lkIDAgOiBjb25maWcuaGVhZGVyc1xuICAgICAgLy8ga2VlcGFsaXZlOiB0cnVlLCAvLyBUT0RPOiBSZXR1cm4ga2VlcGFsaXZlXG4gICAgfSk7XG4gICAgdGhpcy52ZXJzaW9uID0gbWV0YWRhdGEudmVyc2lvbjtcbiAgICBpZiAoY29uZmlnLmxvZ2dlcikge1xuICAgICAgdGhpcy5hcGkudXNlKGNyZWF0ZUFwaUxvZ2dlcihjb25maWcubG9nZ2VyKSk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvZW52ZC9ycGMudHNcbmltcG9ydCB7IENvZGUgYXMgQ29kZTIsIENvbm5lY3RFcnJvciBhcyBDb25uZWN0RXJyb3IyIH0gZnJvbSBcIkBjb25uZWN0cnBjL2Nvbm5lY3RcIjtcbmZ1bmN0aW9uIGhhbmRsZVJwY0Vycm9yKGVycikge1xuICBpZiAoZXJyIGluc3RhbmNlb2YgQ29ubmVjdEVycm9yMikge1xuICAgIHN3aXRjaCAoZXJyLmNvZGUpIHtcbiAgICAgIGNhc2UgQ29kZTIuSW52YWxpZEFyZ3VtZW50OlxuICAgICAgICByZXR1cm4gbmV3IEludmFsaWRBcmd1bWVudEVycm9yKGVyci5tZXNzYWdlKTtcbiAgICAgIGNhc2UgQ29kZTIuVW5hdXRoZW50aWNhdGVkOlxuICAgICAgICByZXR1cm4gbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IoZXJyLm1lc3NhZ2UpO1xuICAgICAgY2FzZSBDb2RlMi5Ob3RGb3VuZDpcbiAgICAgICAgcmV0dXJuIG5ldyBOb3RGb3VuZEVycm9yKGVyci5tZXNzYWdlKTtcbiAgICAgIGNhc2UgQ29kZTIuVW5hdmFpbGFibGU6XG4gICAgICAgIHJldHVybiBmb3JtYXRTYW5kYm94VGltZW91dEVycm9yKGVyci5tZXNzYWdlKTtcbiAgICAgIGNhc2UgQ29kZTIuQ2FuY2VsZWQ6XG4gICAgICAgIHJldHVybiBuZXcgVGltZW91dEVycm9yKFxuICAgICAgICAgIGAke2Vyci5tZXNzYWdlfTogVGhpcyBlcnJvciBpcyBsaWtlbHkgZHVlIHRvIGV4Y2VlZGluZyAncmVxdWVzdFRpbWVvdXRNcycuIFlvdSBjYW4gcGFzcyB0aGUgcmVxdWVzdCB0aW1lb3V0IHZhbHVlIGFzIGFuIG9wdGlvbiB3aGVuIG1ha2luZyB0aGUgcmVxdWVzdC5gXG4gICAgICAgICk7XG4gICAgICBjYXNlIENvZGUyLkRlYWRsaW5lRXhjZWVkZWQ6XG4gICAgICAgIHJldHVybiBuZXcgVGltZW91dEVycm9yKFxuICAgICAgICAgIGAke2Vyci5tZXNzYWdlfTogVGhpcyBlcnJvciBpcyBsaWtlbHkgZHVlIHRvIGV4Y2VlZGluZyAndGltZW91dE1zJyBcXHUyMDE0IHRoZSB0b3RhbCB0aW1lIGEgbG9uZyBydW5uaW5nIHJlcXVlc3QgKGxpa2UgY29tbWFuZCBleGVjdXRpb24gb3IgZGlyZWN0b3J5IHdhdGNoKSBjYW4gYmUgYWN0aXZlLiBJdCBjYW4gYmUgbW9kaWZpZWQgYnkgcGFzc2luZyAndGltZW91dE1zJyB3aGVuIG1ha2luZyB0aGUgcmVxdWVzdC4gVXNlICcwJyB0byBkaXNhYmxlIHRoZSB0aW1lb3V0LmBcbiAgICAgICAgKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBuZXcgU2FuZGJveEVycm9yKGAke2Vyci5jb2RlfTogJHtlcnIubWVzc2FnZX1gKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVycjtcbn1cbmZ1bmN0aW9uIGVuY29kZTY0KHZhbHVlKSB7XG4gIHN3aXRjaCAocnVudGltZSkge1xuICAgIGNhc2UgXCJkZW5vXCI6XG4gICAgICByZXR1cm4gYnRvYSh2YWx1ZSk7XG4gICAgY2FzZSBcIm5vZGVcIjpcbiAgICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZSkudG9TdHJpbmcoXCJiYXNlNjRcIik7XG4gICAgY2FzZSBcImJ1blwiOlxuICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlKS50b1N0cmluZyhcImJhc2U2NFwiKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGJ0b2EodmFsdWUpO1xuICB9XG59XG5mdW5jdGlvbiBhdXRoZW50aWNhdGlvbkhlYWRlcih1c2VybmFtZSkge1xuICBjb25zdCB2YWx1ZSA9IGAke3VzZXJuYW1lIHx8IGRlZmF1bHRVc2VybmFtZX06YDtcbiAgY29uc3QgZW5jb2RlZCA9IGVuY29kZTY0KHZhbHVlKTtcbiAgcmV0dXJuIHsgQXV0aG9yaXphdGlvbjogYEJhc2ljICR7ZW5jb2RlZH1gIH07XG59XG5cbi8vIHNyYy9lbnZkL2ZpbGVzeXN0ZW0vZmlsZXN5c3RlbV9wYi50c1xuaW1wb3J0IHtcbiAgZW51bURlc2MsXG4gIGZpbGVEZXNjLFxuICBtZXNzYWdlRGVzYyxcbiAgc2VydmljZURlc2Ncbn0gZnJvbSBcIkBidWZidWlsZC9wcm90b2J1Zi9jb2RlZ2VudjJcIjtcbmltcG9ydCB7IGZpbGVfZ29vZ2xlX3Byb3RvYnVmX3RpbWVzdGFtcCB9IGZyb20gXCJAYnVmYnVpbGQvcHJvdG9idWYvd2t0XCI7XG52YXIgZmlsZV9maWxlc3lzdGVtX2ZpbGVzeXN0ZW0gPSAvKiBAX19QVVJFX18gKi8gZmlsZURlc2MoXG4gIFwiQ2h0bWFXeGxjM2x6ZEdWdEwyWnBiR1Z6ZVhOMFpXMHVjSEp2ZEc4U0NtWnBiR1Z6ZVhOMFpXMGlNZ29MVFc5MlpWSmxjWFZsYzNRU0Rnb0djMjkxY21ObEdBRWdBU2dKRWhNS0MyUmxjM1JwYm1GMGFXOXVHQUlnQVNnSklqUUtERTF2ZG1WU1pYTndiMjV6WlJJa0NnVmxiblJ5ZVJnQklBRW9DeklWTG1acGJHVnplWE4wWlcwdVJXNTBjbmxKYm1adkloNEtEazFoYTJWRWFYSlNaWEYxWlhOMEVnd0tCSEJoZEdnWUFTQUJLQWtpTndvUFRXRnJaVVJwY2xKbGMzQnZibk5sRWlRS0JXVnVkSEo1R0FFZ0FTZ0xNaFV1Wm1sc1pYTjVjM1JsYlM1RmJuUnllVWx1Wm04aUhRb05VbVZ0YjNabFVtVnhkV1Z6ZEJJTUNnUndZWFJvR0FFZ0FTZ0pJaEFLRGxKbGJXOTJaVkpsYzNCdmJuTmxJaHNLQzFOMFlYUlNaWEYxWlhOMEVnd0tCSEJoZEdnWUFTQUJLQWtpTkFvTVUzUmhkRkpsYzNCdmJuTmxFaVFLQldWdWRISjVHQUVnQVNnTE1oVXVabWxzWlhONWMzUmxiUzVGYm5SeWVVbHVabThpL1FFS0NVVnVkSEo1U1c1bWJ4SU1DZ1J1WVcxbEdBRWdBU2dKRWlJS0JIUjVjR1VZQWlBQktBNHlGQzVtYVd4bGMzbHpkR1Z0TGtacGJHVlVlWEJsRWd3S0JIQmhkR2dZQXlBQktBa1NEQW9FYzJsNlpSZ0VJQUVvQXhJTUNnUnRiMlJsR0FVZ0FTZ05FaE1LQzNCbGNtMXBjM05wYjI1ekdBWWdBU2dKRWcwS0JXOTNibVZ5R0FjZ0FTZ0pFZzBLQldkeWIzVndHQWdnQVNnSkVqRUtEVzF2WkdsbWFXVmtYM1JwYldVWUNTQUJLQXN5R2k1bmIyOW5iR1V1Y0hKdmRHOWlkV1l1VkdsdFpYTjBZVzF3RWhzS0RuTjViV3hwYm10ZmRHRnlaMlYwR0FvZ0FTZ0pTQUNJQVFGQ0VRb1BYM041Yld4cGJtdGZkR0Z5WjJWMElpMEtEa3hwYzNSRWFYSlNaWEYxWlhOMEVnd0tCSEJoZEdnWUFTQUJLQWtTRFFvRlpHVndkR2dZQWlBQktBMGlPUW9QVEdsemRFUnBjbEpsYzNCdmJuTmxFaVlLQjJWdWRISnBaWE1ZQVNBREtBc3lGUzVtYVd4bGMzbHpkR1Z0TGtWdWRISjVTVzVtYnlJeUNnOVhZWFJqYUVScGNsSmxjWFZsYzNRU0RBb0VjR0YwYUJnQklBRW9DUklSQ2dseVpXTjFjbk5wZG1VWUFpQUJLQWdpUkFvUFJtbHNaWE41YzNSbGJVVjJaVzUwRWd3S0JHNWhiV1VZQVNBQktBa1NJd29FZEhsd1pSZ0NJQUVvRGpJVkxtWnBiR1Z6ZVhOMFpXMHVSWFpsYm5SVWVYQmxJdUFCQ2hCWFlYUmphRVJwY2xKbGMzQnZibk5sRWpnS0JYTjBZWEowR0FFZ0FTZ0xNaWN1Wm1sc1pYTjVjM1JsYlM1WFlYUmphRVJwY2xKbGMzQnZibk5sTGxOMFlYSjBSWFpsYm5SSUFCSXhDZ3BtYVd4bGMzbHpkR1Z0R0FJZ0FTZ0xNaHN1Wm1sc1pYTjVjM1JsYlM1R2FXeGxjM2x6ZEdWdFJYWmxiblJJQUJJN0NnbHJaV1Z3WVd4cGRtVVlBeUFCS0FzeUppNW1hV3hsYzNsemRHVnRMbGRoZEdOb1JHbHlVbVZ6Y0c5dWMyVXVTMlZsY0VGc2FYWmxTQUFhREFvS1UzUmhjblJGZG1WdWRCb0xDZ2xMWldWd1FXeHBkbVZDQndvRlpYWmxiblFpTndvVVEzSmxZWFJsVjJGMFkyaGxjbEpsY1hWbGMzUVNEQW9FY0dGMGFCZ0JJQUVvQ1JJUkNnbHlaV04xY25OcGRtVVlBaUFCS0FnaUt3b1ZRM0psWVhSbFYyRjBZMmhsY2xKbGMzQnZibk5sRWhJS0NuZGhkR05vWlhKZmFXUVlBU0FCS0FraUxRb1hSMlYwVjJGMFkyaGxja1YyWlc1MGMxSmxjWFZsYzNRU0Vnb0tkMkYwWTJobGNsOXBaQmdCSUFFb0NTSkhDaGhIWlhSWFlYUmphR1Z5UlhabGJuUnpVbVZ6Y0c5dWMyVVNLd29HWlhabGJuUnpHQUVnQXlnTE1oc3VabWxzWlhONWMzUmxiUzVHYVd4bGMzbHpkR1Z0UlhabGJuUWlLZ29VVW1WdGIzWmxWMkYwWTJobGNsSmxjWFZsYzNRU0Vnb0tkMkYwWTJobGNsOXBaQmdCSUFFb0NTSVhDaFZTWlcxdmRtVlhZWFJqYUdWeVVtVnpjRzl1YzJVcVVnb0lSbWxzWlZSNWNHVVNHUW9WUmtsTVJWOVVXVkJGWDFWT1UxQkZRMGxHU1VWRUVBQVNFZ29PUmtsTVJWOVVXVkJGWDBaSlRFVVFBUklYQ2hOR1NVeEZYMVJaVUVWZlJFbFNSVU5VVDFKWkVBSXFtQUVLQ1VWMlpXNTBWSGx3WlJJYUNoWkZWa1ZPVkY5VVdWQkZYMVZPVTFCRlEwbEdTVVZFRUFBU0ZRb1JSVlpGVGxSZlZGbFFSVjlEVWtWQlZFVVFBUklVQ2hCRlZrVk9WRjlVV1ZCRlgxZFNTVlJGRUFJU0ZRb1JSVlpGVGxSZlZGbFFSVjlTUlUxUFZrVVFBeElWQ2hGRlZrVk9WRjlVV1ZCRlgxSkZUa0ZOUlJBRUVoUUtFRVZXUlU1VVgxUlpVRVZmUTBoTlQwUVFCVEtmQlFvS1JtbHNaWE41YzNSbGJSSTVDZ1JUZEdGMEVoY3VabWxzWlhONWMzUmxiUzVUZEdGMFVtVnhkV1Z6ZEJvWUxtWnBiR1Z6ZVhOMFpXMHVVM1JoZEZKbGMzQnZibk5sRWtJS0IwMWhhMlZFYVhJU0dpNW1hV3hsYzNsemRHVnRMazFoYTJWRWFYSlNaWEYxWlhOMEdoc3VabWxzWlhONWMzUmxiUzVOWVd0bFJHbHlVbVZ6Y0c5dWMyVVNPUW9FVFc5MlpSSVhMbVpwYkdWemVYTjBaVzB1VFc5MlpWSmxjWFZsYzNRYUdDNW1hV3hsYzNsemRHVnRMazF2ZG1WU1pYTndiMjV6WlJKQ0NnZE1hWE4wUkdseUVob3VabWxzWlhONWMzUmxiUzVNYVhOMFJHbHlVbVZ4ZFdWemRCb2JMbVpwYkdWemVYTjBaVzB1VEdsemRFUnBjbEpsYzNCdmJuTmxFajhLQmxKbGJXOTJaUklaTG1acGJHVnplWE4wWlcwdVVtVnRiM1psVW1WeGRXVnpkQm9hTG1acGJHVnplWE4wWlcwdVVtVnRiM1psVW1WemNHOXVjMlVTUndvSVYyRjBZMmhFYVhJU0d5NW1hV3hsYzNsemRHVnRMbGRoZEdOb1JHbHlVbVZ4ZFdWemRCb2NMbVpwYkdWemVYTjBaVzB1VjJGMFkyaEVhWEpTWlhOd2IyNXpaVEFCRWxRS0RVTnlaV0YwWlZkaGRHTm9aWElTSUM1bWFXeGxjM2x6ZEdWdExrTnlaV0YwWlZkaGRHTm9aWEpTWlhGMVpYTjBHaUV1Wm1sc1pYTjVjM1JsYlM1RGNtVmhkR1ZYWVhSamFHVnlVbVZ6Y0c5dWMyVVNYUW9RUjJWMFYyRjBZMmhsY2tWMlpXNTBjeElqTG1acGJHVnplWE4wWlcwdVIyVjBWMkYwWTJobGNrVjJaVzUwYzFKbGNYVmxjM1FhSkM1bWFXeGxjM2x6ZEdWdExrZGxkRmRoZEdOb1pYSkZkbVZ1ZEhOU1pYTndiMjV6WlJKVUNnMVNaVzF2ZG1WWFlYUmphR1Z5RWlBdVptbHNaWE41YzNSbGJTNVNaVzF2ZG1WWFlYUmphR1Z5VW1WeGRXVnpkQm9oTG1acGJHVnplWE4wWlcwdVVtVnRiM1psVjJGMFkyaGxjbEpsYzNCdmJuTmxRbWtLRG1OdmJTNW1hV3hsYzNsemRHVnRRZzlHYVd4bGMzbHpkR1Z0VUhKdmRHOVFBYUlDQTBaWVdLb0NDa1pwYkdWemVYTjBaVzNLQWdwR2FXeGxjM2x6ZEdWdDRnSVdSbWxzWlhONWMzUmxiVnhIVUVKTlpYUmhaR0YwWWVvQ0NrWnBiR1Z6ZVhOMFpXMWlCbkJ5YjNSdk13XCIsXG4gIFtmaWxlX2dvb2dsZV9wcm90b2J1Zl90aW1lc3RhbXBdXG4pO1xudmFyIEZpbGVzeXN0ZW0gPSAvKiBAX19QVVJFX18gKi8gc2VydmljZURlc2MoZmlsZV9maWxlc3lzdGVtX2ZpbGVzeXN0ZW0sIDApO1xuXG4vLyBzcmMvc2FuZGJveC9maWxlc3lzdGVtL3dhdGNoSGFuZGxlLnRzXG52YXIgRmlsZXN5c3RlbUV2ZW50VHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAoKEZpbGVzeXN0ZW1FdmVudFR5cGUyKSA9PiB7XG4gIEZpbGVzeXN0ZW1FdmVudFR5cGUyW1wiQ0hNT0RcIl0gPSBcImNobW9kXCI7XG4gIEZpbGVzeXN0ZW1FdmVudFR5cGUyW1wiQ1JFQVRFXCJdID0gXCJjcmVhdGVcIjtcbiAgRmlsZXN5c3RlbUV2ZW50VHlwZTJbXCJSRU1PVkVcIl0gPSBcInJlbW92ZVwiO1xuICBGaWxlc3lzdGVtRXZlbnRUeXBlMltcIlJFTkFNRVwiXSA9IFwicmVuYW1lXCI7XG4gIEZpbGVzeXN0ZW1FdmVudFR5cGUyW1wiV1JJVEVcIl0gPSBcIndyaXRlXCI7XG4gIHJldHVybiBGaWxlc3lzdGVtRXZlbnRUeXBlMjtcbn0pKEZpbGVzeXN0ZW1FdmVudFR5cGUgfHwge30pO1xuZnVuY3Rpb24gbWFwRXZlbnRUeXBlKHR5cGUpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSA1IC8qIENITU9EICovOlxuICAgICAgcmV0dXJuIFwiY2htb2RcIiAvKiBDSE1PRCAqLztcbiAgICBjYXNlIDEgLyogQ1JFQVRFICovOlxuICAgICAgcmV0dXJuIFwiY3JlYXRlXCIgLyogQ1JFQVRFICovO1xuICAgIGNhc2UgMyAvKiBSRU1PVkUgKi86XG4gICAgICByZXR1cm4gXCJyZW1vdmVcIiAvKiBSRU1PVkUgKi87XG4gICAgY2FzZSA0IC8qIFJFTkFNRSAqLzpcbiAgICAgIHJldHVybiBcInJlbmFtZVwiIC8qIFJFTkFNRSAqLztcbiAgICBjYXNlIDIgLyogV1JJVEUgKi86XG4gICAgICByZXR1cm4gXCJ3cml0ZVwiIC8qIFdSSVRFICovO1xuICB9XG59XG52YXIgV2F0Y2hIYW5kbGUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGhhbmRsZVN0b3AsIGV2ZW50cywgb25FdmVudCwgb25FeGl0KSB7XG4gICAgdGhpcy5oYW5kbGVTdG9wID0gaGFuZGxlU3RvcDtcbiAgICB0aGlzLmV2ZW50cyA9IGV2ZW50cztcbiAgICB0aGlzLm9uRXZlbnQgPSBvbkV2ZW50O1xuICAgIHRoaXMub25FeGl0ID0gb25FeGl0O1xuICAgIHRoaXMuaGFuZGxlRXZlbnRzKCk7XG4gIH1cbiAgLyoqXG4gICAqIFN0b3Agd2F0Y2hpbmcgdGhlIGRpcmVjdG9yeS5cbiAgICovXG4gIGFzeW5jIHN0b3AoKSB7XG4gICAgdGhpcy5oYW5kbGVTdG9wKCk7XG4gIH1cbiAgaXRlcmF0ZUV2ZW50cygpIHtcbiAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKHZhciBpdGVyID0gX19mb3JBd2FpdCh0aGlzLmV2ZW50cyksIG1vcmUsIHRlbXAsIGVycm9yOyBtb3JlID0gISh0ZW1wID0geWllbGQgbmV3IF9fYXdhaXQoaXRlci5uZXh0KCkpKS5kb25lOyBtb3JlID0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gdGVtcC52YWx1ZTtcbiAgICAgICAgICAgIHN3aXRjaCAoZXZlbnQuZXZlbnQuY2FzZSkge1xuICAgICAgICAgICAgICBjYXNlIFwiZmlsZXN5c3RlbVwiOlxuICAgICAgICAgICAgICAgIHlpZWxkIGV2ZW50LmV2ZW50O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAodGVtcCkge1xuICAgICAgICAgIGVycm9yID0gW3RlbXBdO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBtb3JlICYmICh0ZW1wID0gaXRlci5yZXR1cm4pICYmICh5aWVsZCBuZXcgX19hd2FpdCh0ZW1wLmNhbGwoaXRlcikpKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICB0aHJvdyBlcnJvclswXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aHJvdyBoYW5kbGVScGNFcnJvcihlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGhhbmRsZUV2ZW50cygpIHtcbiAgICB2YXIgX2EzLCBfYiwgX2M7XG4gICAgdHJ5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIGl0ZXIgPSBfX2ZvckF3YWl0KHRoaXMuaXRlcmF0ZUV2ZW50cygpKSwgbW9yZSwgdGVtcCwgZXJyb3I7IG1vcmUgPSAhKHRlbXAgPSBhd2FpdCBpdGVyLm5leHQoKSkuZG9uZTsgbW9yZSA9IGZhbHNlKSB7XG4gICAgICAgICAgY29uc3QgZXZlbnQgPSB0ZW1wLnZhbHVlO1xuICAgICAgICAgIGNvbnN0IGV2ZW50VHlwZSA9IG1hcEV2ZW50VHlwZShldmVudC52YWx1ZS50eXBlKTtcbiAgICAgICAgICBpZiAoZXZlbnRUeXBlID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICAoX2EzID0gdGhpcy5vbkV2ZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EzLmNhbGwodGhpcywge1xuICAgICAgICAgICAgbmFtZTogZXZlbnQudmFsdWUubmFtZSxcbiAgICAgICAgICAgIHR5cGU6IGV2ZW50VHlwZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoICh0ZW1wKSB7XG4gICAgICAgIGVycm9yID0gW3RlbXBdO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBtb3JlICYmICh0ZW1wID0gaXRlci5yZXR1cm4pICYmIGF3YWl0IHRlbXAuY2FsbChpdGVyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICB0aHJvdyBlcnJvclswXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgKF9iID0gdGhpcy5vbkV4aXQpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKHRoaXMpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgKF9jID0gdGhpcy5vbkV4aXQpID09IG51bGwgPyB2b2lkIDAgOiBfYy5jYWxsKHRoaXMsIGVycik7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvc2FuZGJveC9maWxlc3lzdGVtL2luZGV4LnRzXG5pbXBvcnQgeyBjb21wYXJlVmVyc2lvbnMgfSBmcm9tIFwiY29tcGFyZS12ZXJzaW9uc1wiO1xuXG4vLyBzcmMvZW52ZC92ZXJzaW9ucy50c1xudmFyIEVOVkRfVkVSU0lPTl9SRUNVUlNJVkVfV0FUQ0ggPSBcIjAuMS40XCI7XG5cbi8vIHNyYy9zYW5kYm94L2ZpbGVzeXN0ZW0vaW5kZXgudHNcbnZhciBGaWxlVHlwZTIgPSAvKiBAX19QVVJFX18gKi8gKChGaWxlVHlwZTMpID0+IHtcbiAgRmlsZVR5cGUzW1wiRklMRVwiXSA9IFwiZmlsZVwiO1xuICBGaWxlVHlwZTNbXCJESVJcIl0gPSBcImRpclwiO1xuICByZXR1cm4gRmlsZVR5cGUzO1xufSkoRmlsZVR5cGUyIHx8IHt9KTtcbmZ1bmN0aW9uIG1hcEZpbGVUeXBlKGZpbGVUeXBlKSB7XG4gIHN3aXRjaCAoZmlsZVR5cGUpIHtcbiAgICBjYXNlIDIgLyogRElSRUNUT1JZICovOlxuICAgICAgcmV0dXJuIFwiZGlyXCIgLyogRElSICovO1xuICAgIGNhc2UgMSAvKiBGSUxFICovOlxuICAgICAgcmV0dXJuIFwiZmlsZVwiIC8qIEZJTEUgKi87XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcE1vZGlmaWVkVGltZShtb2RpZmllZFRpbWUpIHtcbiAgaWYgKCFtb2RpZmllZFRpbWUpIHJldHVybiB2b2lkIDA7XG4gIHJldHVybiBuZXcgRGF0ZShcbiAgICBOdW1iZXIobW9kaWZpZWRUaW1lLnNlY29uZHMpICogMWUzICsgTWF0aC5mbG9vcihtb2RpZmllZFRpbWUubmFub3MgLyAxZTYpXG4gICk7XG59XG52YXIgRmlsZXN5c3RlbTIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHRyYW5zcG9ydCwgZW52ZEFwaSwgY29ubmVjdGlvbkNvbmZpZykge1xuICAgIHRoaXMuZW52ZEFwaSA9IGVudmRBcGk7XG4gICAgdGhpcy5jb25uZWN0aW9uQ29uZmlnID0gY29ubmVjdGlvbkNvbmZpZztcbiAgICB0aGlzLmRlZmF1bHRXYXRjaFRpbWVvdXQgPSA2ZTQ7XG4gICAgLy8gNjAgc2Vjb25kc1xuICAgIHRoaXMuZGVmYXVsdFdhdGNoUmVjdXJzaXZlID0gZmFsc2U7XG4gICAgdGhpcy5ycGMgPSBjcmVhdGVDbGllbnQzKEZpbGVzeXN0ZW0sIHRyYW5zcG9ydCk7XG4gIH1cbiAgYXN5bmMgcmVhZChwYXRoMiwgb3B0cykge1xuICAgIHZhciBfYTM7XG4gICAgY29uc3QgZm9ybWF0ID0gKF9hMyA9IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuZm9ybWF0KSAhPSBudWxsID8gX2EzIDogXCJ0ZXh0XCI7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5lbnZkQXBpLmFwaS5HRVQoXCIvZmlsZXNcIiwge1xuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIHF1ZXJ5OiB7XG4gICAgICAgICAgcGF0aDogcGF0aDIsXG4gICAgICAgICAgdXNlcm5hbWU6IChvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLnVzZXIpIHx8IGRlZmF1bHRVc2VybmFtZVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcGFyc2VBczogZm9ybWF0ID09PSBcImJ5dGVzXCIgPyBcImFycmF5QnVmZmVyXCIgOiBmb3JtYXQsXG4gICAgICBzaWduYWw6IHRoaXMuY29ubmVjdGlvbkNvbmZpZy5nZXRTaWduYWwob3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5yZXF1ZXN0VGltZW91dE1zKVxuICAgIH0pO1xuICAgIGNvbnN0IGVyciA9IGF3YWl0IGhhbmRsZUVudmRBcGlFcnJvcihyZXMpO1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gICAgaWYgKGZvcm1hdCA9PT0gXCJieXRlc1wiKSB7XG4gICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkocmVzLmRhdGEpO1xuICAgIH1cbiAgICBpZiAocmVzLnJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiY29udGVudC1sZW5ndGhcIikgPT09IFwiMFwiKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5kYXRhO1xuICB9XG4gIGFzeW5jIHdyaXRlKHBhdGhPckZpbGVzLCBkYXRhT3JPcHRzLCBvcHRzKSB7XG4gICAgaWYgKHR5cGVvZiBwYXRoT3JGaWxlcyAhPT0gXCJzdHJpbmdcIiAmJiAhQXJyYXkuaXNBcnJheShwYXRoT3JGaWxlcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhdGggb3IgZmlsZXMgYXJlIHJlcXVpcmVkXCIpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHBhdGhPckZpbGVzID09PSBcInN0cmluZ1wiICYmIEFycmF5LmlzQXJyYXkoZGF0YU9yT3B0cykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJDYW5ub3Qgc3BlY2lmeSBib3RoIHBhdGggYW5kIGFycmF5IG9mIGZpbGVzLiBZb3UgaGF2ZSB0byBzcGVjaWZ5IGVpdGhlciBwYXRoIGFuZCBkYXRhIGZvciBhIHNpbmdsZSBmaWxlIG9yIGFuIGFycmF5IGZvciBtdWx0aXBsZSBmaWxlcy5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgeyBwYXRoOiBwYXRoMiwgd3JpdGVPcHRzLCB3cml0ZUZpbGVzIH0gPSB0eXBlb2YgcGF0aE9yRmlsZXMgPT09IFwic3RyaW5nXCIgPyB7XG4gICAgICBwYXRoOiBwYXRoT3JGaWxlcyxcbiAgICAgIHdyaXRlT3B0czogb3B0cyxcbiAgICAgIHdyaXRlRmlsZXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIGRhdGE6IGRhdGFPck9wdHNcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0gOiB7XG4gICAgICBwYXRoOiB2b2lkIDAsXG4gICAgICB3cml0ZU9wdHM6IGRhdGFPck9wdHMsXG4gICAgICB3cml0ZUZpbGVzOiBwYXRoT3JGaWxlc1xuICAgIH07XG4gICAgaWYgKHdyaXRlRmlsZXMubGVuZ3RoID09PSAwKSByZXR1cm4gW107XG4gICAgY29uc3QgYmxvYnMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIHdyaXRlRmlsZXMubWFwKChmKSA9PiBuZXcgUmVzcG9uc2UoZi5kYXRhKS5ibG9iKCkpXG4gICAgKTtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmVudmRBcGkuYXBpLlBPU1QoXCIvZmlsZXNcIiwge1xuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIHF1ZXJ5OiB7XG4gICAgICAgICAgcGF0aDogcGF0aDIsXG4gICAgICAgICAgdXNlcm5hbWU6ICh3cml0ZU9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IHdyaXRlT3B0cy51c2VyKSB8fCBkZWZhdWx0VXNlcm5hbWVcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGJvZHlTZXJpYWxpemVyKCkge1xuICAgICAgICByZXR1cm4gYmxvYnMucmVkdWNlKChmZCwgYmxvYiwgaSkgPT4ge1xuICAgICAgICAgIGZkLmFwcGVuZChcImZpbGVcIiwgYmxvYiwgd3JpdGVGaWxlc1tpXS5wYXRoKTtcbiAgICAgICAgICByZXR1cm4gZmQ7XG4gICAgICAgIH0sIG5ldyBGb3JtRGF0YSgpKTtcbiAgICAgIH0sXG4gICAgICBib2R5OiB7fSxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJtdWx0aXBhcnQvZm9ybS1kYXRhXCIsXG4gICAgICAgIFwiQnVuLUNvbnRlbnQtVHlwZVwiOiBcInRlbXBvcmFyeS1maXhcIlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vb3Zlbi1zaC9idW4vaXNzdWVzLzE0OTg4XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgZXJyID0gYXdhaXQgaGFuZGxlRW52ZEFwaUVycm9yKHJlcyk7XG4gICAgaWYgKGVycikge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgICBjb25zdCBmaWxlcyA9IHJlcy5kYXRhO1xuICAgIGlmICghZmlsZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIHRvIHJlY2VpdmUgaW5mb3JtYXRpb24gYWJvdXQgd3JpdHRlbiBmaWxlXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZmlsZXMubGVuZ3RoID09PSAxICYmIHBhdGgyID8gZmlsZXNbMF0gOiBmaWxlcztcbiAgfVxuICAvKipcbiAgICogTGlzdCBlbnRyaWVzIGluIGEgZGlyZWN0b3J5LlxuICAgKlxuICAgKiBAcGFyYW0gcGF0aCBwYXRoIHRvIHRoZSBkaXJlY3RvcnkuXG4gICAqIEBwYXJhbSBvcHRzIGNvbm5lY3Rpb24gb3B0aW9ucy5cbiAgICpcbiAgICogQHJldHVybnMgbGlzdCBvZiBlbnRyaWVzIGluIHRoZSBzYW5kYm94IGZpbGVzeXN0ZW0gZGlyZWN0b3J5LlxuICAgKi9cbiAgYXN5bmMgbGlzdChwYXRoMiwgb3B0cykge1xuICAgIHZhciBfYTM7XG4gICAgaWYgKHR5cGVvZiAob3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5kZXB0aCkgPT09IFwibnVtYmVyXCIgJiYgb3B0cy5kZXB0aCA8IDEpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcImRlcHRoIHNob3VsZCBiZSBhdCBsZWFzdCBvbmVcIik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLnJwYy5saXN0RGlyKFxuICAgICAgICB7XG4gICAgICAgICAgcGF0aDogcGF0aDIsXG4gICAgICAgICAgZGVwdGg6IChfYTMgPSBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLmRlcHRoKSAhPSBudWxsID8gX2EzIDogMVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgaGVhZGVyczogYXV0aGVudGljYXRpb25IZWFkZXIob3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy51c2VyKSxcbiAgICAgICAgICBzaWduYWw6IHRoaXMuY29ubmVjdGlvbkNvbmZpZy5nZXRTaWduYWwob3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5yZXF1ZXN0VGltZW91dE1zKVxuICAgICAgICB9XG4gICAgICApO1xuICAgICAgY29uc3QgZW50cmllcyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBlIG9mIHJlcy5lbnRyaWVzKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBtYXBGaWxlVHlwZShlLnR5cGUpO1xuICAgICAgICBpZiAodHlwZSkge1xuICAgICAgICAgIGVudHJpZXMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBlLm5hbWUsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgcGF0aDogZS5wYXRoLFxuICAgICAgICAgICAgc2l6ZTogTnVtYmVyKGUuc2l6ZSksXG4gICAgICAgICAgICBtb2RlOiBlLm1vZGUsXG4gICAgICAgICAgICBwZXJtaXNzaW9uczogZS5wZXJtaXNzaW9ucyxcbiAgICAgICAgICAgIG93bmVyOiBlLm93bmVyLFxuICAgICAgICAgICAgZ3JvdXA6IGUuZ3JvdXAsXG4gICAgICAgICAgICBtb2RpZmllZFRpbWU6IG1hcE1vZGlmaWVkVGltZShlLm1vZGlmaWVkVGltZSksXG4gICAgICAgICAgICBzeW1saW5rVGFyZ2V0OiBlLnN5bWxpbmtUYXJnZXRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGVudHJpZXM7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aHJvdyBoYW5kbGVScGNFcnJvcihlcnIpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGRpcmVjdG9yeSBhbmQgYWxsIGRpcmVjdG9yaWVzIGFsb25nIHRoZSB3YXkgaWYgbmVlZGVkIG9uIHRoZSBzcGVjaWZpZWQgcGF0aC5cbiAgICpcbiAgICogQHBhcmFtIHBhdGggcGF0aCB0byBhIG5ldyBkaXJlY3RvcnkuIEZvciBleGFtcGxlICcvZGlyQS9kaXJCJyB3aGVuIGNyZWF0aW5nICdkaXJCJy5cbiAgICogQHBhcmFtIG9wdHMgY29ubmVjdGlvbiBvcHRpb25zLlxuICAgKlxuICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGRpcmVjdG9yeSB3YXMgY3JlYXRlZCwgYGZhbHNlYCBpZiBpdCBhbHJlYWR5IGV4aXN0cy5cbiAgICovXG4gIGFzeW5jIG1ha2VEaXIocGF0aDIsIG9wdHMpIHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5ycGMubWFrZURpcihcbiAgICAgICAgeyBwYXRoOiBwYXRoMiB9LFxuICAgICAgICB7XG4gICAgICAgICAgaGVhZGVyczogYXV0aGVudGljYXRpb25IZWFkZXIob3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy51c2VyKSxcbiAgICAgICAgICBzaWduYWw6IHRoaXMuY29ubmVjdGlvbkNvbmZpZy5nZXRTaWduYWwob3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5yZXF1ZXN0VGltZW91dE1zKVxuICAgICAgICB9XG4gICAgICApO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgQ29ubmVjdEVycm9yMykge1xuICAgICAgICBpZiAoZXJyLmNvZGUgPT09IENvZGUzLkFscmVhZHlFeGlzdHMpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRocm93IGhhbmRsZVJwY0Vycm9yKGVycik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZW5hbWUgYSBmaWxlIG9yIGRpcmVjdG9yeS5cbiAgICpcbiAgICogQHBhcmFtIG9sZFBhdGggcGF0aCB0byB0aGUgZmlsZSBvciBkaXJlY3RvcnkgdG8gcmVuYW1lLlxuICAgKiBAcGFyYW0gbmV3UGF0aCBuZXcgcGF0aCBmb3IgdGhlIGZpbGUgb3IgZGlyZWN0b3J5LlxuICAgKiBAcGFyYW0gb3B0cyBjb25uZWN0aW9uIG9wdGlvbnMuXG4gICAqXG4gICAqIEByZXR1cm5zIGluZm9ybWF0aW9uIGFib3V0IHJlbmFtZWQgZmlsZSBvciBkaXJlY3RvcnkuXG4gICAqL1xuICBhc3luYyByZW5hbWUob2xkUGF0aCwgbmV3UGF0aCwgb3B0cykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLnJwYy5tb3ZlKFxuICAgICAgICB7XG4gICAgICAgICAgc291cmNlOiBvbGRQYXRoLFxuICAgICAgICAgIGRlc3RpbmF0aW9uOiBuZXdQYXRoXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBoZWFkZXJzOiBhdXRoZW50aWNhdGlvbkhlYWRlcihvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLnVzZXIpLFxuICAgICAgICAgIHNpZ25hbDogdGhpcy5jb25uZWN0aW9uQ29uZmlnLmdldFNpZ25hbChvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLnJlcXVlc3RUaW1lb3V0TXMpXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICBjb25zdCBlbnRyeSA9IHJlcy5lbnRyeTtcbiAgICAgIGlmICghZW50cnkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgdG8gcmVjZWl2ZSBpbmZvcm1hdGlvbiBhYm91dCBtb3ZlZCBvYmplY3RcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBlbnRyeS5uYW1lLFxuICAgICAgICB0eXBlOiBtYXBGaWxlVHlwZShlbnRyeS50eXBlKSxcbiAgICAgICAgcGF0aDogZW50cnkucGF0aCxcbiAgICAgICAgc2l6ZTogTnVtYmVyKGVudHJ5LnNpemUpLFxuICAgICAgICBtb2RlOiBlbnRyeS5tb2RlLFxuICAgICAgICBwZXJtaXNzaW9uczogZW50cnkucGVybWlzc2lvbnMsXG4gICAgICAgIG93bmVyOiBlbnRyeS5vd25lcixcbiAgICAgICAgZ3JvdXA6IGVudHJ5Lmdyb3VwLFxuICAgICAgICBtb2RpZmllZFRpbWU6IG1hcE1vZGlmaWVkVGltZShlbnRyeS5tb2RpZmllZFRpbWUpLFxuICAgICAgICBzeW1saW5rVGFyZ2V0OiBlbnRyeS5zeW1saW5rVGFyZ2V0XG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgaGFuZGxlUnBjRXJyb3IoZXJyKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSBhIGZpbGUgb3IgZGlyZWN0b3J5LlxuICAgKlxuICAgKiBAcGFyYW0gcGF0aCBwYXRoIHRvIGEgZmlsZSBvciBkaXJlY3RvcnkuXG4gICAqIEBwYXJhbSBvcHRzIGNvbm5lY3Rpb24gb3B0aW9ucy5cbiAgICovXG4gIGFzeW5jIHJlbW92ZShwYXRoMiwgb3B0cykge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLnJwYy5yZW1vdmUoXG4gICAgICAgIHsgcGF0aDogcGF0aDIgfSxcbiAgICAgICAge1xuICAgICAgICAgIGhlYWRlcnM6IGF1dGhlbnRpY2F0aW9uSGVhZGVyKG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMudXNlciksXG4gICAgICAgICAgc2lnbmFsOiB0aGlzLmNvbm5lY3Rpb25Db25maWcuZ2V0U2lnbmFsKG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMucmVxdWVzdFRpbWVvdXRNcylcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IGhhbmRsZVJwY0Vycm9yKGVycik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIGZpbGUgb3IgYSBkaXJlY3RvcnkgZXhpc3RzLlxuICAgKlxuICAgKiBAcGFyYW0gcGF0aCBwYXRoIHRvIGEgZmlsZSBvciBhIGRpcmVjdG9yeVxuICAgKiBAcGFyYW0gb3B0cyBjb25uZWN0aW9uIG9wdGlvbnMuXG4gICAqXG4gICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgZmlsZSBvciBkaXJlY3RvcnkgZXhpc3RzLCBgZmFsc2VgIG90aGVyd2lzZVxuICAgKi9cbiAgYXN5bmMgZXhpc3RzKHBhdGgyLCBvcHRzKSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMucnBjLnN0YXQoXG4gICAgICAgIHsgcGF0aDogcGF0aDIgfSxcbiAgICAgICAge1xuICAgICAgICAgIGhlYWRlcnM6IGF1dGhlbnRpY2F0aW9uSGVhZGVyKG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMudXNlciksXG4gICAgICAgICAgc2lnbmFsOiB0aGlzLmNvbm5lY3Rpb25Db25maWcuZ2V0U2lnbmFsKG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMucmVxdWVzdFRpbWVvdXRNcylcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIENvbm5lY3RFcnJvcjMpIHtcbiAgICAgICAgaWYgKGVyci5jb2RlID09PSBDb2RlMy5Ob3RGb3VuZCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhyb3cgaGFuZGxlUnBjRXJyb3IoZXJyKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEdldCBpbmZvcm1hdGlvbiBhYm91dCBhIGZpbGUgb3IgZGlyZWN0b3J5LlxuICAgKlxuICAgKiBAcGFyYW0gcGF0aCBwYXRoIHRvIGEgZmlsZSBvciBkaXJlY3RvcnkuXG4gICAqIEBwYXJhbSBvcHRzIGNvbm5lY3Rpb24gb3B0aW9ucy5cbiAgICpcbiAgICogQHJldHVybnMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGZpbGUgb3IgZGlyZWN0b3J5IGxpa2UgbmFtZSwgdHlwZSwgYW5kIHBhdGguXG4gICAqL1xuICBhc3luYyBnZXRJbmZvKHBhdGgyLCBvcHRzKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMucnBjLnN0YXQoXG4gICAgICAgIHsgcGF0aDogcGF0aDIgfSxcbiAgICAgICAgeyBoZWFkZXJzOiBhdXRoZW50aWNhdGlvbkhlYWRlcihvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLnVzZXIpIH1cbiAgICAgICk7XG4gICAgICBpZiAoIXJlcy5lbnRyeSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJFeHBlY3RlZCB0byByZWNlaXZlIGluZm9ybWF0aW9uIGFib3V0IHRoZSBmaWxlIG9yIGRpcmVjdG9yeVwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiByZXMuZW50cnkubmFtZSxcbiAgICAgICAgdHlwZTogbWFwRmlsZVR5cGUocmVzLmVudHJ5LnR5cGUpLFxuICAgICAgICBwYXRoOiByZXMuZW50cnkucGF0aCxcbiAgICAgICAgc2l6ZTogTnVtYmVyKHJlcy5lbnRyeS5zaXplKSxcbiAgICAgICAgbW9kZTogcmVzLmVudHJ5Lm1vZGUsXG4gICAgICAgIHBlcm1pc3Npb25zOiByZXMuZW50cnkucGVybWlzc2lvbnMsXG4gICAgICAgIG93bmVyOiByZXMuZW50cnkub3duZXIsXG4gICAgICAgIGdyb3VwOiByZXMuZW50cnkuZ3JvdXAsXG4gICAgICAgIG1vZGlmaWVkVGltZTogbWFwTW9kaWZpZWRUaW1lKHJlcy5lbnRyeS5tb2RpZmllZFRpbWUpLFxuICAgICAgICBzeW1saW5rVGFyZ2V0OiByZXMuZW50cnkuc3ltbGlua1RhcmdldFxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IGhhbmRsZVJwY0Vycm9yKGVycik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTdGFydCB3YXRjaGluZyBhIGRpcmVjdG9yeSBmb3IgZmlsZXN5c3RlbSBldmVudHMuXG4gICAqXG4gICAqIEBwYXJhbSBwYXRoIHBhdGggdG8gZGlyZWN0b3J5IHRvIHdhdGNoLlxuICAgKiBAcGFyYW0gb25FdmVudCBjYWxsYmFjayB0byBjYWxsIHdoZW4gYW4gZXZlbnQgaW4gdGhlIGRpcmVjdG9yeSBvY2N1cnMuXG4gICAqIEBwYXJhbSBvcHRzIGNvbm5lY3Rpb24gb3B0aW9ucy5cbiAgICpcbiAgICogQHJldHVybnMgYFdhdGNoSGFuZGxlYCBvYmplY3QgZm9yIHN0b3BwaW5nIHdhdGNoaW5nIGRpcmVjdG9yeS5cbiAgICovXG4gIGFzeW5jIHdhdGNoRGlyKHBhdGgyLCBvbkV2ZW50LCBvcHRzKSB7XG4gICAgdmFyIF9hMywgX2IsIF9jO1xuICAgIGlmICgob3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5yZWN1cnNpdmUpICYmIHRoaXMuZW52ZEFwaS52ZXJzaW9uICYmIGNvbXBhcmVWZXJzaW9ucyh0aGlzLmVudmRBcGkudmVyc2lvbiwgRU5WRF9WRVJTSU9OX1JFQ1VSU0lWRV9XQVRDSCkgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgVGVtcGxhdGVFcnJvcihcbiAgICAgICAgXCJZb3UgbmVlZCB0byB1cGRhdGUgdGhlIHRlbXBsYXRlIHRvIHVzZSByZWN1cnNpdmUgd2F0Y2hpbmcuIFlvdSBjYW4gZG8gdGhpcyBieSBydW5uaW5nIGBlMmIgdGVtcGxhdGUgYnVpbGRgIGluIHRoZSBkaXJlY3Rvcnkgd2l0aCB0aGUgdGVtcGxhdGUuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHJlcXVlc3RUaW1lb3V0TXMgPSAoX2EzID0gb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5yZXF1ZXN0VGltZW91dE1zKSAhPSBudWxsID8gX2EzIDogdGhpcy5jb25uZWN0aW9uQ29uZmlnLnJlcXVlc3RUaW1lb3V0TXM7XG4gICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCByZXFUaW1lb3V0ID0gcmVxdWVzdFRpbWVvdXRNcyA/IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgY29udHJvbGxlci5hYm9ydCgpO1xuICAgIH0sIHJlcXVlc3RUaW1lb3V0TXMpIDogdm9pZCAwO1xuICAgIGNvbnN0IGV2ZW50cyA9IHRoaXMucnBjLndhdGNoRGlyKFxuICAgICAge1xuICAgICAgICBwYXRoOiBwYXRoMixcbiAgICAgICAgcmVjdXJzaXZlOiAoX2IgPSBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLnJlY3Vyc2l2ZSkgIT0gbnVsbCA/IF9iIDogdGhpcy5kZWZhdWx0V2F0Y2hSZWN1cnNpdmVcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGhlYWRlcnM6IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIGF1dGhlbnRpY2F0aW9uSGVhZGVyKG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMudXNlcikpLCB7XG4gICAgICAgICAgW0tFRVBBTElWRV9QSU5HX0hFQURFUl06IEtFRVBBTElWRV9QSU5HX0lOVEVSVkFMX1NFQy50b1N0cmluZygpXG4gICAgICAgIH0pLFxuICAgICAgICBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgICB0aW1lb3V0TXM6IChfYyA9IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMudGltZW91dE1zKSAhPSBudWxsID8gX2MgOiB0aGlzLmRlZmF1bHRXYXRjaFRpbWVvdXRcbiAgICAgIH1cbiAgICApO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBoYW5kbGVXYXRjaERpclN0YXJ0RXZlbnQoZXZlbnRzKTtcbiAgICAgIGNsZWFyVGltZW91dChyZXFUaW1lb3V0KTtcbiAgICAgIHJldHVybiBuZXcgV2F0Y2hIYW5kbGUoXG4gICAgICAgICgpID0+IGNvbnRyb2xsZXIuYWJvcnQoKSxcbiAgICAgICAgZXZlbnRzLFxuICAgICAgICBvbkV2ZW50LFxuICAgICAgICBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLm9uRXhpdFxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IGhhbmRsZVJwY0Vycm9yKGVycik7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvc2FuZGJveC9jb21tYW5kcy9jb21tYW5kSGFuZGxlLnRzXG52YXIgQ29tbWFuZEV4aXRFcnJvciA9IGNsYXNzIGV4dGVuZHMgU2FuZGJveEVycm9yIHtcbiAgY29uc3RydWN0b3IocmVzdWx0KSB7XG4gICAgc3VwZXIocmVzdWx0LmVycm9yKTtcbiAgICB0aGlzLnJlc3VsdCA9IHJlc3VsdDtcbiAgICB0aGlzLm5hbWUgPSBcIkNvbW1hbmRFeGl0RXJyb3JcIjtcbiAgfVxuICAvKipcbiAgICogQ29tbWFuZCBleGVjdXRpb24gZXhpdCBjb2RlLlxuICAgKiBgMGAgaWYgdGhlIGNvbW1hbmQgZmluaXNoZWQgc3VjY2Vzc2Z1bGx5LlxuICAgKi9cbiAgZ2V0IGV4aXRDb2RlKCkge1xuICAgIHJldHVybiB0aGlzLnJlc3VsdC5leGl0Q29kZTtcbiAgfVxuICAvKipcbiAgICogRXJyb3IgbWVzc2FnZSBmcm9tIGNvbW1hbmQgZXhlY3V0aW9uLlxuICAgKi9cbiAgZ2V0IGVycm9yKCkge1xuICAgIHJldHVybiB0aGlzLnJlc3VsdC5lcnJvcjtcbiAgfVxuICAvKipcbiAgICogQ29tbWFuZCBleGVjdXRpb24gc3Rkb3V0IG91dHB1dC5cbiAgICovXG4gIGdldCBzdGRvdXQoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzdWx0LnN0ZG91dDtcbiAgfVxuICAvKipcbiAgICogQ29tbWFuZCBleGVjdXRpb24gc3RkZXJyIG91dHB1dC5cbiAgICovXG4gIGdldCBzdGRlcnIoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzdWx0LnN0ZGVycjtcbiAgfVxufTtcbnZhciBDb21tYW5kSGFuZGxlID0gY2xhc3Mge1xuICAvKipcbiAgICogQGhpZGRlblxuICAgKiBAaW50ZXJuYWxcbiAgICogQGFjY2VzcyBwcm90ZWN0ZWRcbiAgICovXG4gIGNvbnN0cnVjdG9yKHBpZCwgaGFuZGxlRGlzY29ubmVjdCwgaGFuZGxlS2lsbCwgZXZlbnRzLCBvblN0ZG91dCwgb25TdGRlcnIsIG9uUHR5KSB7XG4gICAgdGhpcy5waWQgPSBwaWQ7XG4gICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0ID0gaGFuZGxlRGlzY29ubmVjdDtcbiAgICB0aGlzLmhhbmRsZUtpbGwgPSBoYW5kbGVLaWxsO1xuICAgIHRoaXMuZXZlbnRzID0gZXZlbnRzO1xuICAgIHRoaXMub25TdGRvdXQgPSBvblN0ZG91dDtcbiAgICB0aGlzLm9uU3RkZXJyID0gb25TdGRlcnI7XG4gICAgdGhpcy5vblB0eSA9IG9uUHR5O1xuICAgIHRoaXMuX3N0ZG91dCA9IFwiXCI7XG4gICAgdGhpcy5fc3RkZXJyID0gXCJcIjtcbiAgICB0aGlzLl93YWl0ID0gdGhpcy5oYW5kbGVFdmVudHMoKTtcbiAgfVxuICAvKipcbiAgICogQ29tbWFuZCBleGVjdXRpb24gZXhpdCBjb2RlLlxuICAgKiBgMGAgaWYgdGhlIGNvbW1hbmQgZmluaXNoZWQgc3VjY2Vzc2Z1bGx5LlxuICAgKlxuICAgKiBJdCBpcyBgdW5kZWZpbmVkYCBpZiB0aGUgY29tbWFuZCBpcyBzdGlsbCBydW5uaW5nLlxuICAgKi9cbiAgZ2V0IGV4aXRDb2RlKCkge1xuICAgIHZhciBfYTM7XG4gICAgcmV0dXJuIChfYTMgPSB0aGlzLnJlc3VsdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5leGl0Q29kZTtcbiAgfVxuICAvKipcbiAgICogRXJyb3IgbWVzc2FnZSBmcm9tIGNvbW1hbmQgZXhlY3V0aW9uLlxuICAgKi9cbiAgZ2V0IGVycm9yKCkge1xuICAgIHZhciBfYTM7XG4gICAgcmV0dXJuIChfYTMgPSB0aGlzLnJlc3VsdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5lcnJvcjtcbiAgfVxuICAvKipcbiAgICogQ29tbWFuZCBleGVjdXRpb24gc3RkZXJyIG91dHB1dC5cbiAgICovXG4gIGdldCBzdGRlcnIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0ZGVycjtcbiAgfVxuICAvKipcbiAgICogQ29tbWFuZCBleGVjdXRpb24gc3Rkb3V0IG91dHB1dC5cbiAgICovXG4gIGdldCBzdGRvdXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0ZG91dDtcbiAgfVxuICAvKipcbiAgICogV2FpdCBmb3IgdGhlIGNvbW1hbmQgdG8gZmluaXNoIGFuZCByZXR1cm4gdGhlIHJlc3VsdC5cbiAgICogSWYgdGhlIGNvbW1hbmQgZXhpdHMgd2l0aCBhIG5vbi16ZXJvIGV4aXQgY29kZSwgaXQgdGhyb3dzIGEgYENvbW1hbmRFeGl0RXJyb3JgLlxuICAgKlxuICAgKiBAcmV0dXJucyBgQ29tbWFuZFJlc3VsdGAgcmVzdWx0IG9mIGNvbW1hbmQgZXhlY3V0aW9uLlxuICAgKi9cbiAgYXN5bmMgd2FpdCgpIHtcbiAgICBhd2FpdCB0aGlzLl93YWl0O1xuICAgIGlmICh0aGlzLml0ZXJhdGlvbkVycm9yKSB7XG4gICAgICB0aHJvdyB0aGlzLml0ZXJhdGlvbkVycm9yO1xuICAgIH1cbiAgICBpZiAoIXRoaXMucmVzdWx0KSB7XG4gICAgICB0aHJvdyBuZXcgU2FuZGJveEVycm9yKFwiUHJvY2VzcyBleGl0ZWQgd2l0aG91dCBhIHJlc3VsdFwiKTtcbiAgICB9XG4gICAgaWYgKHRoaXMucmVzdWx0LmV4aXRDb2RlICE9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgQ29tbWFuZEV4aXRFcnJvcih0aGlzLnJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJlc3VsdDtcbiAgfVxuICAvKipcbiAgICogRGlzY29ubmVjdCBmcm9tIHRoZSBjb21tYW5kLlxuICAgKlxuICAgKiBUaGUgY29tbWFuZCBpcyBub3Qga2lsbGVkLCBidXQgU0RLIHN0b3BzIHJlY2VpdmluZyBldmVudHMgZnJvbSB0aGUgY29tbWFuZC5cbiAgICogWW91IGNhbiByZWNvbm5lY3QgdG8gdGhlIGNvbW1hbmQgdXNpbmcge0BsaW5rIENvbW1hbmRzLmNvbm5lY3R9LlxuICAgKi9cbiAgYXN5bmMgZGlzY29ubmVjdCgpIHtcbiAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QoKTtcbiAgfVxuICAvKipcbiAgICogS2lsbCB0aGUgY29tbWFuZC5cbiAgICogSXQgdXNlcyBgU0lHS0lMTGAgc2lnbmFsIHRvIGtpbGwgdGhlIGNvbW1hbmQuXG4gICAqXG4gICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgY29tbWFuZCB3YXMga2lsbGVkIHN1Y2Nlc3NmdWxseSwgYGZhbHNlYCBpZiB0aGUgY29tbWFuZCB3YXMgbm90IGZvdW5kLlxuICAgKi9cbiAgYXN5bmMga2lsbCgpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5oYW5kbGVLaWxsKCk7XG4gIH1cbiAgaXRlcmF0ZUV2ZW50cygpIHtcbiAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hMztcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIGl0ZXIgPSBfX2ZvckF3YWl0KHRoaXMuZXZlbnRzKSwgbW9yZSwgdGVtcCwgZXJyb3I7IG1vcmUgPSAhKHRlbXAgPSB5aWVsZCBuZXcgX19hd2FpdChpdGVyLm5leHQoKSkpLmRvbmU7IG1vcmUgPSBmYWxzZSkge1xuICAgICAgICAgIGNvbnN0IGV2ZW50ID0gdGVtcC52YWx1ZTtcbiAgICAgICAgICBjb25zdCBlID0gKF9hMyA9IGV2ZW50ID09IG51bGwgPyB2b2lkIDAgOiBldmVudC5ldmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5ldmVudDtcbiAgICAgICAgICBsZXQgb3V0O1xuICAgICAgICAgIHN3aXRjaCAoZSA9PSBudWxsID8gdm9pZCAwIDogZS5jYXNlKSB7XG4gICAgICAgICAgICBjYXNlIFwiZGF0YVwiOlxuICAgICAgICAgICAgICBzd2l0Y2ggKGUudmFsdWUub3V0cHV0LmNhc2UpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwic3Rkb3V0XCI6XG4gICAgICAgICAgICAgICAgICBvdXQgPSBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoZS52YWx1ZS5vdXRwdXQudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5fc3Rkb3V0ICs9IG91dDtcbiAgICAgICAgICAgICAgICAgIHlpZWxkIFtvdXQsIG51bGwsIG51bGxdO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInN0ZGVyclwiOlxuICAgICAgICAgICAgICAgICAgb3V0ID0gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGUudmFsdWUub3V0cHV0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX3N0ZGVyciArPSBvdXQ7XG4gICAgICAgICAgICAgICAgICB5aWVsZCBbbnVsbCwgb3V0LCBudWxsXTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJwdHlcIjpcbiAgICAgICAgICAgICAgICAgIHlpZWxkIFtudWxsLCBudWxsLCBlLnZhbHVlLm91dHB1dC52YWx1ZV07XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgdGhpcy5yZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgZXhpdENvZGU6IGUudmFsdWUuZXhpdENvZGUsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGUudmFsdWUuZXJyb3IsXG4gICAgICAgICAgICAgICAgc3Rkb3V0OiB0aGlzLnN0ZG91dCxcbiAgICAgICAgICAgICAgICBzdGRlcnI6IHRoaXMuc3RkZXJyXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAodGVtcCkge1xuICAgICAgICBlcnJvciA9IFt0ZW1wXTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbW9yZSAmJiAodGVtcCA9IGl0ZXIucmV0dXJuKSAmJiAoeWllbGQgbmV3IF9fYXdhaXQodGVtcC5jYWxsKGl0ZXIpKSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgdGhyb3cgZXJyb3JbMF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBhc3luYyBoYW5kbGVFdmVudHMoKSB7XG4gICAgdmFyIF9hMywgX2IsIF9jO1xuICAgIHRyeSB7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBpdGVyID0gX19mb3JBd2FpdCh0aGlzLml0ZXJhdGVFdmVudHMoKSksIG1vcmUsIHRlbXAsIGVycm9yOyBtb3JlID0gISh0ZW1wID0gYXdhaXQgaXRlci5uZXh0KCkpLmRvbmU7IG1vcmUgPSBmYWxzZSkge1xuICAgICAgICAgIGNvbnN0IFtzdGRvdXQsIHN0ZGVyciwgcHR5XSA9IHRlbXAudmFsdWU7XG4gICAgICAgICAgaWYgKHN0ZG91dCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgKF9hMyA9IHRoaXMub25TdGRvdXQpID09IG51bGwgPyB2b2lkIDAgOiBfYTMuY2FsbCh0aGlzLCBzdGRvdXQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RkZXJyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAoX2IgPSB0aGlzLm9uU3RkZXJyKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbCh0aGlzLCBzdGRlcnIpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocHR5KSB7XG4gICAgICAgICAgICAoX2MgPSB0aGlzLm9uUHR5KSA9PSBudWxsID8gdm9pZCAwIDogX2MuY2FsbCh0aGlzLCBwdHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAodGVtcCkge1xuICAgICAgICBlcnJvciA9IFt0ZW1wXTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbW9yZSAmJiAodGVtcCA9IGl0ZXIucmV0dXJuKSAmJiBhd2FpdCB0ZW1wLmNhbGwoaXRlcik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgdGhyb3cgZXJyb3JbMF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aGlzLml0ZXJhdGlvbkVycm9yID0gaGFuZGxlUnBjRXJyb3IoZSk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvc2FuZGJveC9pbmRleC50c1xuaW1wb3J0IHsgY3JlYXRlQ29ubmVjdFRyYW5zcG9ydCB9IGZyb20gXCJAY29ubmVjdHJwYy9jb25uZWN0LXdlYlwiO1xuXG4vLyBzcmMvc2FuZGJveC9jb21tYW5kcy9pbmRleC50c1xuaW1wb3J0IHtcbiAgQ29kZSBhcyBDb2RlNSxcbiAgQ29ubmVjdEVycm9yIGFzIENvbm5lY3RFcnJvcjUsXG4gIGNyZWF0ZUNsaWVudCBhcyBjcmVhdGVDbGllbnQ1XG59IGZyb20gXCJAY29ubmVjdHJwYy9jb25uZWN0XCI7XG5cbi8vIHNyYy9lbnZkL3Byb2Nlc3MvcHJvY2Vzc19wYi50c1xuaW1wb3J0IHtcbiAgZW51bURlc2MgYXMgZW51bURlc2MyLFxuICBmaWxlRGVzYyBhcyBmaWxlRGVzYzIsXG4gIG1lc3NhZ2VEZXNjIGFzIG1lc3NhZ2VEZXNjMixcbiAgc2VydmljZURlc2MgYXMgc2VydmljZURlc2MyXG59IGZyb20gXCJAYnVmYnVpbGQvcHJvdG9idWYvY29kZWdlbnYyXCI7XG52YXIgZmlsZV9wcm9jZXNzX3Byb2Nlc3MgPSAvKiBAX19QVVJFX18gKi8gZmlsZURlc2MyKFxuICBcIkNoVndjbTlqWlhOekwzQnliMk5sYzNNdWNISnZkRzhTQjNCeWIyTmxjM01pU2dvRFVGUlpFaDhLQkhOcGVtVVlBU0FCS0FzeUVTNXdjbTlqWlhOekxsQlVXUzVUYVhwbEdpSUtCRk5wZW1VU0RBb0VZMjlzY3hnQklBRW9EUklNQ2dSeWIzZHpHQUlnQVNnTklxRUJDZzFRY205alpYTnpRMjl1Wm1sbkVnc0tBMk50WkJnQklBRW9DUklNQ2dSaGNtZHpHQUlnQXlnSkVpNEtCR1Z1ZG5NWUF5QURLQXN5SUM1d2NtOWpaWE56TGxCeWIyTmxjM05EYjI1bWFXY3VSVzUyYzBWdWRISjVFaEFLQTJOM1pCZ0VJQUVvQ1VnQWlBRUJHaXNLQ1VWdWRuTkZiblJ5ZVJJTENnTnJaWGtZQVNBQktBa1NEUW9GZG1Gc2RXVVlBaUFCS0FrNkFqZ0JRZ1lLQkY5amQyUWlEUW9MVEdsemRGSmxjWFZsYzNRaVhBb0xVSEp2WTJWemMwbHVabThTSmdvR1kyOXVabWxuR0FFZ0FTZ0xNaFl1Y0hKdlkyVnpjeTVRY205alpYTnpRMjl1Wm1sbkVnc0tBM0JwWkJnQ0lBRW9EUklRQ2dOMFlXY1lBeUFCS0FsSUFJZ0JBVUlHQ2dSZmRHRm5JamNLREV4cGMzUlNaWE53YjI1elpSSW5DZ2x3Y205alpYTnpaWE1ZQVNBREtBc3lGQzV3Y205alpYTnpMbEJ5YjJObGMzTkpibVp2SW5rS0RGTjBZWEowVW1WeGRXVnpkQkluQ2dkd2NtOWpaWE56R0FFZ0FTZ0xNaFl1Y0hKdlkyVnpjeTVRY205alpYTnpRMjl1Wm1sbkVoNEtBM0IwZVJnQ0lBRW9DeklNTG5CeWIyTmxjM011VUZSWlNBQ0lBUUVTRUFvRGRHRm5HQU1nQVNnSlNBR0lBUUZDQmdvRVgzQjBlVUlHQ2dSZmRHRm5JbUlLRFZWd1pHRjBaVkpsY1hWbGMzUVNLUW9IY0hKdlkyVnpjeGdCSUFFb0N6SVlMbkJ5YjJObGMzTXVVSEp2WTJWemMxTmxiR1ZqZEc5eUVoNEtBM0IwZVJnQ0lBRW9DeklNTG5CeWIyTmxjM011VUZSWlNBQ0lBUUZDQmdvRVgzQjBlU0lRQ2c1VmNHUmhkR1ZTWlhOd2IyNXpaU0t2QXdvTVVISnZZMlZ6YzBWMlpXNTBFakVLQlhOMFlYSjBHQUVnQVNnTE1pQXVjSEp2WTJWemN5NVFjbTlqWlhOelJYWmxiblF1VTNSaGNuUkZkbVZ1ZEVnQUVpOEtCR1JoZEdFWUFpQUJLQXN5SHk1d2NtOWpaWE56TGxCeWIyTmxjM05GZG1WdWRDNUVZWFJoUlhabGJuUklBQkl0Q2dObGJtUVlBeUFCS0FzeUhpNXdjbTlqWlhOekxsQnliMk5sYzNORmRtVnVkQzVGYm1SRmRtVnVkRWdBRWpRS0NXdGxaWEJoYkdsMlpSZ0VJQUVvQ3pJZkxuQnliMk5sYzNNdVVISnZZMlZ6YzBWMlpXNTBMa3RsWlhCQmJHbDJaVWdBR2hrS0NsTjBZWEowUlhabGJuUVNDd29EY0dsa0dBRWdBU2dOR2tnS0NVUmhkR0ZGZG1WdWRCSVFDZ1p6ZEdSdmRYUVlBU0FCS0F4SUFCSVFDZ1p6ZEdSbGNuSVlBaUFCS0F4SUFCSU5DZ053ZEhrWUF5QUJLQXhJQUVJSUNnWnZkWFJ3ZFhRYVd3b0lSVzVrUlhabGJuUVNFUW9KWlhocGRGOWpiMlJsR0FFZ0FTZ1JFZzRLQm1WNGFYUmxaQmdDSUFFb0NCSU9DZ1p6ZEdGMGRYTVlBeUFCS0FrU0Vnb0ZaWEp5YjNJWUJDQUJLQWxJQUlnQkFVSUlDZ1pmWlhKeWIzSWFDd29KUzJWbGNFRnNhWFpsUWdjS0JXVjJaVzUwSWpVS0RWTjBZWEowVW1WemNHOXVjMlVTSkFvRlpYWmxiblFZQVNBQktBc3lGUzV3Y205alpYTnpMbEJ5YjJObGMzTkZkbVZ1ZENJM0NnOURiMjV1WldOMFVtVnpjRzl1YzJVU0pBb0ZaWFpsYm5RWUFTQUJLQXN5RlM1d2NtOWpaWE56TGxCeWIyTmxjM05GZG1WdWRDSmpDaEJUWlc1a1NXNXdkWFJTWlhGMVpYTjBFaWtLQjNCeWIyTmxjM01ZQVNBQktBc3lHQzV3Y205alpYTnpMbEJ5YjJObGMzTlRaV3hsWTNSdmNoSWtDZ1ZwYm5CMWRCZ0NJQUVvQ3pJVkxuQnliMk5sYzNNdVVISnZZMlZ6YzBsdWNIVjBJaE1LRVZObGJtUkpibkIxZEZKbGMzQnZibk5sSWpjS0RGQnliMk5sYzNOSmJuQjFkQklQQ2dWemRHUnBiaGdCSUFFb0RFZ0FFZzBLQTNCMGVSZ0NJQUVvREVnQVFnY0tCV2x1Y0hWMElzSUNDaEpUZEhKbFlXMUpibkIxZEZKbGNYVmxjM1FTTndvRmMzUmhjblFZQVNBQktBc3lKaTV3Y205alpYTnpMbE4wY21WaGJVbHVjSFYwVW1WeGRXVnpkQzVUZEdGeWRFVjJaVzUwU0FBU05Rb0VaR0YwWVJnQ0lBRW9DeklsTG5CeWIyTmxjM011VTNSeVpXRnRTVzV3ZFhSU1pYRjFaWE4wTGtSaGRHRkZkbVZ1ZEVnQUVqb0tDV3RsWlhCaGJHbDJaUmdESUFFb0N6SWxMbkJ5YjJObGMzTXVVM1J5WldGdFNXNXdkWFJTWlhGMVpYTjBMa3RsWlhCQmJHbDJaVWdBR2pjS0NsTjBZWEowUlhabGJuUVNLUW9IY0hKdlkyVnpjeGdCSUFFb0N6SVlMbkJ5YjJObGMzTXVVSEp2WTJWemMxTmxiR1ZqZEc5eUdqRUtDVVJoZEdGRmRtVnVkQklrQ2dWcGJuQjFkQmdDSUFFb0N6SVZMbkJ5YjJObGMzTXVVSEp2WTJWemMwbHVjSFYwR2dzS0NVdGxaWEJCYkdsMlpVSUhDZ1ZsZG1WdWRDSVZDaE5UZEhKbFlXMUpibkIxZEZKbGMzQnZibk5sSWw4S0VWTmxibVJUYVdkdVlXeFNaWEYxWlhOMEVpa0tCM0J5YjJObGMzTVlBU0FCS0FzeUdDNXdjbTlqWlhOekxsQnliMk5sYzNOVFpXeGxZM1J2Y2hJZkNnWnphV2R1WVd3WUFpQUJLQTR5RHk1d2NtOWpaWE56TGxOcFoyNWhiQ0lVQ2hKVFpXNWtVMmxuYm1Gc1VtVnpjRzl1YzJVaU93b09RMjl1Ym1WamRGSmxjWFZsYzNRU0tRb0hjSEp2WTJWemN4Z0JJQUVvQ3pJWUxuQnliMk5sYzNNdVVISnZZMlZ6YzFObGJHVmpkRzl5SWpzS0QxQnliMk5sYzNOVFpXeGxZM1J2Y2hJTkNnTndhV1FZQVNBQktBMUlBQklOQ2dOMFlXY1lBaUFCS0FsSUFFSUtDZ2h6Wld4bFkzUnZjaXBJQ2daVGFXZHVZV3dTRmdvU1UwbEhUa0ZNWDFWT1UxQkZRMGxHU1VWRUVBQVNFZ29PVTBsSFRrRk1YMU5KUjFSRlVrMFFEeElTQ2c1VFNVZE9RVXhmVTBsSFMwbE1UQkFKTXNvRENnZFFjbTlqWlhOekVqTUtCRXhwYzNRU0ZDNXdjbTlqWlhOekxreHBjM1JTWlhGMVpYTjBHaFV1Y0hKdlkyVnpjeTVNYVhOMFVtVnpjRzl1YzJVU1Bnb0hRMjl1Ym1WamRCSVhMbkJ5YjJObGMzTXVRMjl1Ym1WamRGSmxjWFZsYzNRYUdDNXdjbTlqWlhOekxrTnZibTVsWTNSU1pYTndiMjV6WlRBQkVqZ0tCVk4wWVhKMEVoVXVjSEp2WTJWemN5NVRkR0Z5ZEZKbGNYVmxjM1FhRmk1d2NtOWpaWE56TGxOMFlYSjBVbVZ6Y0c5dWMyVXdBUkk1Q2daVmNHUmhkR1VTRmk1d2NtOWpaWE56TGxWd1pHRjBaVkpsY1hWbGMzUWFGeTV3Y205alpYTnpMbFZ3WkdGMFpWSmxjM0J2Ym5ObEVrb0tDMU4wY21WaGJVbHVjSFYwRWhzdWNISnZZMlZ6Y3k1VGRISmxZVzFKYm5CMWRGSmxjWFZsYzNRYUhDNXdjbTlqWlhOekxsTjBjbVZoYlVsdWNIVjBVbVZ6Y0c5dWMyVW9BUkpDQ2dsVFpXNWtTVzV3ZFhRU0dTNXdjbTlqWlhOekxsTmxibVJKYm5CMWRGSmxjWFZsYzNRYUdpNXdjbTlqWlhOekxsTmxibVJKYm5CMWRGSmxjM0J2Ym5ObEVrVUtDbE5sYm1SVGFXZHVZV3dTR2k1d2NtOWpaWE56TGxObGJtUlRhV2R1WVd4U1pYRjFaWE4wR2hzdWNISnZZMlZ6Y3k1VFpXNWtVMmxuYm1Gc1VtVnpjRzl1YzJWQ1Z3b0xZMjl0TG5CeWIyTmxjM05DREZCeWIyTmxjM05RY205MGIxQUJvZ0lEVUZoWXFnSUhVSEp2WTJWemM4b0NCMUJ5YjJObGMzUGlBaE5RY205alpYTnpYRWRRUWsxbGRHRmtZWFJoNmdJSFVISnZZMlZ6YzJJR2NISnZkRzh6XCJcbik7XG52YXIgUHJvY2VzcyA9IC8qIEBfX1BVUkVfXyAqLyBzZXJ2aWNlRGVzYzIoZmlsZV9wcm9jZXNzX3Byb2Nlc3MsIDApO1xuXG4vLyBzcmMvc2FuZGJveC9jb21tYW5kcy9wdHkudHNcbmltcG9ydCB7XG4gIENvZGUgYXMgQ29kZTQsXG4gIENvbm5lY3RFcnJvciBhcyBDb25uZWN0RXJyb3I0LFxuICBjcmVhdGVDbGllbnQgYXMgY3JlYXRlQ2xpZW50NFxufSBmcm9tIFwiQGNvbm5lY3RycGMvY29ubmVjdFwiO1xudmFyIFB0eSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IodHJhbnNwb3J0LCBjb25uZWN0aW9uQ29uZmlnKSB7XG4gICAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gICAgdGhpcy5jb25uZWN0aW9uQ29uZmlnID0gY29ubmVjdGlvbkNvbmZpZztcbiAgICB0aGlzLnJwYyA9IGNyZWF0ZUNsaWVudDQoUHJvY2VzcywgdGhpcy50cmFuc3BvcnQpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgUFRZIChwc2V1ZG8tdGVybWluYWwpLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0cyBvcHRpb25zIGZvciBjcmVhdGluZyB0aGUgUFRZLlxuICAgKlxuICAgKiBAcmV0dXJucyBoYW5kbGUgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgUFRZLlxuICAgKi9cbiAgYXN5bmMgY3JlYXRlKG9wdHMpIHtcbiAgICB2YXIgX2EzLCBfYiwgX2M7XG4gICAgY29uc3QgcmVxdWVzdFRpbWVvdXRNcyA9IChfYTMgPSBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLnJlcXVlc3RUaW1lb3V0TXMpICE9IG51bGwgPyBfYTMgOiB0aGlzLmNvbm5lY3Rpb25Db25maWcucmVxdWVzdFRpbWVvdXRNcztcbiAgICBjb25zdCBlbnZzID0gKF9iID0gb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5lbnZzKSAhPSBudWxsID8gX2IgOiB7fTtcbiAgICBlbnZzLlRFUk0gPSBcInh0ZXJtLTI1NmNvbG9yXCI7XG4gICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCByZXFUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBjb250cm9sbGVyLmFib3J0KCk7XG4gICAgfSwgcmVxdWVzdFRpbWVvdXRNcyk7XG4gICAgY29uc3QgZXZlbnRzID0gdGhpcy5ycGMuc3RhcnQoXG4gICAgICB7XG4gICAgICAgIHByb2Nlc3M6IHtcbiAgICAgICAgICBjbWQ6IFwiL2Jpbi9iYXNoXCIsXG4gICAgICAgICAgYXJnczogW1wiLWlcIiwgXCItbFwiXSxcbiAgICAgICAgICBlbnZzLFxuICAgICAgICAgIGN3ZDogb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5jd2RcbiAgICAgICAgfSxcbiAgICAgICAgcHR5OiB7XG4gICAgICAgICAgc2l6ZToge1xuICAgICAgICAgICAgY29sczogb3B0cy5jb2xzLFxuICAgICAgICAgICAgcm93czogb3B0cy5yb3dzXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBoZWFkZXJzOiBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBhdXRoZW50aWNhdGlvbkhlYWRlcihvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLnVzZXIpKSwge1xuICAgICAgICAgIFtLRUVQQUxJVkVfUElOR19IRUFERVJdOiBLRUVQQUxJVkVfUElOR19JTlRFUlZBTF9TRUMudG9TdHJpbmcoKVxuICAgICAgICB9KSxcbiAgICAgICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbCxcbiAgICAgICAgdGltZW91dE1zOiAoX2MgPSBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLnRpbWVvdXRNcykgIT0gbnVsbCA/IF9jIDogNmU0XG4gICAgICB9XG4gICAgKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcGlkID0gYXdhaXQgaGFuZGxlUHJvY2Vzc1N0YXJ0RXZlbnQoZXZlbnRzKTtcbiAgICAgIGNsZWFyVGltZW91dChyZXFUaW1lb3V0KTtcbiAgICAgIHJldHVybiBuZXcgQ29tbWFuZEhhbmRsZShcbiAgICAgICAgcGlkLFxuICAgICAgICAoKSA9PiBjb250cm9sbGVyLmFib3J0KCksXG4gICAgICAgICgpID0+IHRoaXMua2lsbChwaWQpLFxuICAgICAgICBldmVudHMsXG4gICAgICAgIHZvaWQgMCxcbiAgICAgICAgdm9pZCAwLFxuICAgICAgICBvcHRzLm9uRGF0YVxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IGhhbmRsZVJwY0Vycm9yKGVycik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTZW5kIGlucHV0IHRvIGEgUFRZLlxuICAgKlxuICAgKiBAcGFyYW0gcGlkIHByb2Nlc3MgSUQgb2YgdGhlIFBUWS5cbiAgICogQHBhcmFtIGRhdGEgaW5wdXQgZGF0YSB0byBzZW5kIHRvIHRoZSBQVFkuXG4gICAqIEBwYXJhbSBvcHRzIGNvbm5lY3Rpb24gb3B0aW9ucy5cbiAgICovXG4gIGFzeW5jIHNlbmRJbnB1dChwaWQsIGRhdGEsIG9wdHMpIHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5ycGMuc2VuZElucHV0KFxuICAgICAgICB7XG4gICAgICAgICAgaW5wdXQ6IHtcbiAgICAgICAgICAgIGlucHV0OiB7XG4gICAgICAgICAgICAgIGNhc2U6IFwicHR5XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBkYXRhXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBwcm9jZXNzOiB7XG4gICAgICAgICAgICBzZWxlY3Rvcjoge1xuICAgICAgICAgICAgICBjYXNlOiBcInBpZFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogcGlkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgc2lnbmFsOiB0aGlzLmNvbm5lY3Rpb25Db25maWcuZ2V0U2lnbmFsKG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMucmVxdWVzdFRpbWVvdXRNcylcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IGhhbmRsZVJwY0Vycm9yKGVycik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXNpemUgUFRZLlxuICAgKiBDYWxsIHRoaXMgd2hlbiB0aGUgdGVybWluYWwgd2luZG93IGlzIHJlc2l6ZWQgYW5kIHRoZSBudW1iZXIgb2YgY29sdW1ucyBhbmQgcm93cyBoYXMgY2hhbmdlZC5cbiAgICpcbiAgICogQHBhcmFtIHBpZCBwcm9jZXNzIElEIG9mIHRoZSBQVFkuXG4gICAqIEBwYXJhbSBzaXplIG5ldyBzaXplIG9mIHRoZSBQVFkuXG4gICAqIEBwYXJhbSBvcHRzIGNvbm5lY3Rpb24gb3B0aW9ucy5cbiAgICovXG4gIGFzeW5jIHJlc2l6ZShwaWQsIHNpemUsIG9wdHMpIHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5ycGMudXBkYXRlKFxuICAgICAgICB7XG4gICAgICAgICAgcHJvY2Vzczoge1xuICAgICAgICAgICAgc2VsZWN0b3I6IHtcbiAgICAgICAgICAgICAgY2FzZTogXCJwaWRcIixcbiAgICAgICAgICAgICAgdmFsdWU6IHBpZFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcHR5OiB7XG4gICAgICAgICAgICBzaXplXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgc2lnbmFsOiB0aGlzLmNvbm5lY3Rpb25Db25maWcuZ2V0U2lnbmFsKG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMucmVxdWVzdFRpbWVvdXRNcylcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IGhhbmRsZVJwY0Vycm9yKGVycik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBLaWxsIGEgcnVubmluZyBQVFkgc3BlY2lmaWVkIGJ5IHByb2Nlc3MgSUQuXG4gICAqIEl0IHVzZXMgYFNJR0tJTExgIHNpZ25hbCB0byBraWxsIHRoZSBQVFkuXG4gICAqXG4gICAqIEBwYXJhbSBwaWQgcHJvY2VzcyBJRCBvZiB0aGUgUFRZLlxuICAgKiBAcGFyYW0gb3B0cyBjb25uZWN0aW9uIG9wdGlvbnMuXG4gICAqXG4gICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgUFRZIHdhcyBraWxsZWQsIGBmYWxzZWAgaWYgdGhlIFBUWSB3YXMgbm90IGZvdW5kLlxuICAgKi9cbiAgYXN5bmMga2lsbChwaWQsIG9wdHMpIHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5ycGMuc2VuZFNpZ25hbChcbiAgICAgICAge1xuICAgICAgICAgIHByb2Nlc3M6IHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiB7XG4gICAgICAgICAgICAgIGNhc2U6IFwicGlkXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBwaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHNpZ25hbDogOSAvKiBTSUdLSUxMICovXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBzaWduYWw6IHRoaXMuY29ubmVjdGlvbkNvbmZpZy5nZXRTaWduYWwob3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5yZXF1ZXN0VGltZW91dE1zKVxuICAgICAgICB9XG4gICAgICApO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgQ29ubmVjdEVycm9yNCkge1xuICAgICAgICBpZiAoZXJyLmNvZGUgPT09IENvZGU0Lk5vdEZvdW5kKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aHJvdyBoYW5kbGVScGNFcnJvcihlcnIpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL3NhbmRib3gvY29tbWFuZHMvaW5kZXgudHNcbnZhciBDb21tYW5kcyA9IGNsYXNzIHtcbiAgLy8gNjAgc2Vjb25kc1xuICBjb25zdHJ1Y3Rvcih0cmFuc3BvcnQsIGNvbm5lY3Rpb25Db25maWcpIHtcbiAgICB0aGlzLmNvbm5lY3Rpb25Db25maWcgPSBjb25uZWN0aW9uQ29uZmlnO1xuICAgIHRoaXMuZGVmYXVsdFByb2Nlc3NDb25uZWN0aW9uVGltZW91dCA9IDZlNDtcbiAgICB0aGlzLnJwYyA9IGNyZWF0ZUNsaWVudDUoUHJvY2VzcywgdHJhbnNwb3J0KTtcbiAgfVxuICAvKipcbiAgICogTGlzdCBhbGwgcnVubmluZyBjb21tYW5kcyBhbmQgUFRZIHNlc3Npb25zLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0cyBjb25uZWN0aW9uIG9wdGlvbnMuXG4gICAqXG4gICAqIEByZXR1cm5zIGxpc3Qgb2YgcnVubmluZyBjb21tYW5kcyBhbmQgUFRZIHNlc3Npb25zLlxuICAgKi9cbiAgYXN5bmMgbGlzdChvcHRzKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMucnBjLmxpc3QoXG4gICAgICAgIHt9LFxuICAgICAgICB7XG4gICAgICAgICAgc2lnbmFsOiB0aGlzLmNvbm5lY3Rpb25Db25maWcuZ2V0U2lnbmFsKG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMucmVxdWVzdFRpbWVvdXRNcylcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIHJldHVybiByZXMucHJvY2Vzc2VzLm1hcCgocCkgPT4gX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7XG4gICAgICAgIHBpZDogcC5waWRcbiAgICAgIH0sIHAudGFnICYmIHsgdGFnOiBwLnRhZyB9KSwge1xuICAgICAgICBhcmdzOiBwLmNvbmZpZy5hcmdzLFxuICAgICAgICBlbnZzOiBwLmNvbmZpZy5lbnZzLFxuICAgICAgICBjbWQ6IHAuY29uZmlnLmNtZFxuICAgICAgfSksIHAuY29uZmlnLmN3ZCAmJiB7IGN3ZDogcC5jb25maWcuY3dkIH0pKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IGhhbmRsZVJwY0Vycm9yKGVycik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTZW5kIGRhdGEgdG8gY29tbWFuZCBzdGRpbi5cbiAgICpcbiAgICogQHBhcmFtIHBpZCBwcm9jZXNzIElEIG9mIHRoZSBjb21tYW5kLiBZb3UgY2FuIGdldCB0aGUgbGlzdCBvZiBydW5uaW5nIGNvbW1hbmRzIHVzaW5nIHtAbGluayBDb21tYW5kcy5saXN0fS5cbiAgICogQHBhcmFtIGRhdGEgZGF0YSB0byBzZW5kIHRvIHRoZSBjb21tYW5kLlxuICAgKiBAcGFyYW0gb3B0cyBjb25uZWN0aW9uIG9wdGlvbnMuXG4gICAqL1xuICBhc3luYyBzZW5kU3RkaW4ocGlkLCBkYXRhLCBvcHRzKSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMucnBjLnNlbmRJbnB1dChcbiAgICAgICAge1xuICAgICAgICAgIHByb2Nlc3M6IHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiB7XG4gICAgICAgICAgICAgIGNhc2U6IFwicGlkXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBwaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGlucHV0OiB7XG4gICAgICAgICAgICBpbnB1dDoge1xuICAgICAgICAgICAgICBjYXNlOiBcInN0ZGluXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoZGF0YSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBzaWduYWw6IHRoaXMuY29ubmVjdGlvbkNvbmZpZy5nZXRTaWduYWwob3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5yZXF1ZXN0VGltZW91dE1zKVxuICAgICAgICB9XG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgaGFuZGxlUnBjRXJyb3IoZXJyKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEtpbGwgYSBydW5uaW5nIGNvbW1hbmQgc3BlY2lmaWVkIGJ5IGl0cyBwcm9jZXNzIElELlxuICAgKiBJdCB1c2VzIGBTSUdLSUxMYCBzaWduYWwgdG8ga2lsbCB0aGUgY29tbWFuZC5cbiAgICpcbiAgICogQHBhcmFtIHBpZCBwcm9jZXNzIElEIG9mIHRoZSBjb21tYW5kLiBZb3UgY2FuIGdldCB0aGUgbGlzdCBvZiBydW5uaW5nIGNvbW1hbmRzIHVzaW5nIHtAbGluayBDb21tYW5kcy5saXN0fS5cbiAgICogQHBhcmFtIG9wdHMgY29ubmVjdGlvbiBvcHRpb25zLlxuICAgKlxuICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGNvbW1hbmQgd2FzIGtpbGxlZCwgYGZhbHNlYCBpZiB0aGUgY29tbWFuZCB3YXMgbm90IGZvdW5kLlxuICAgKi9cbiAgYXN5bmMga2lsbChwaWQsIG9wdHMpIHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5ycGMuc2VuZFNpZ25hbChcbiAgICAgICAge1xuICAgICAgICAgIHByb2Nlc3M6IHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiB7XG4gICAgICAgICAgICAgIGNhc2U6IFwicGlkXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBwaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHNpZ25hbDogOSAvKiBTSUdLSUxMICovXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBzaWduYWw6IHRoaXMuY29ubmVjdGlvbkNvbmZpZy5nZXRTaWduYWwob3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5yZXF1ZXN0VGltZW91dE1zKVxuICAgICAgICB9XG4gICAgICApO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgQ29ubmVjdEVycm9yNSkge1xuICAgICAgICBpZiAoZXJyLmNvZGUgPT09IENvZGU1Lk5vdEZvdW5kKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aHJvdyBoYW5kbGVScGNFcnJvcihlcnIpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ29ubmVjdCB0byBhIHJ1bm5pbmcgY29tbWFuZC5cbiAgICogWW91IGNhbiB1c2Uge0BsaW5rIENvbW1hbmRIYW5kbGUud2FpdH0gdG8gd2FpdCBmb3IgdGhlIGNvbW1hbmQgdG8gZmluaXNoIGFuZCBnZXQgZXhlY3V0aW9uIHJlc3VsdHMuXG4gICAqXG4gICAqIEBwYXJhbSBwaWQgcHJvY2VzcyBJRCBvZiB0aGUgY29tbWFuZCB0byBjb25uZWN0IHRvLiBZb3UgY2FuIGdldCB0aGUgbGlzdCBvZiBydW5uaW5nIGNvbW1hbmRzIHVzaW5nIHtAbGluayBDb21tYW5kcy5saXN0fS5cbiAgICogQHBhcmFtIG9wdHMgY29ubmVjdGlvbiBvcHRpb25zLlxuICAgKlxuICAgKiBAcmV0dXJucyBgQ29tbWFuZEhhbmRsZWAgaGFuZGxlIHRvIGludGVyYWN0IHdpdGggdGhlIHJ1bm5pbmcgY29tbWFuZC5cbiAgICovXG4gIGFzeW5jIGNvbm5lY3QocGlkLCBvcHRzKSB7XG4gICAgdmFyIF9hMywgX2I7XG4gICAgY29uc3QgcmVxdWVzdFRpbWVvdXRNcyA9IChfYTMgPSBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLnJlcXVlc3RUaW1lb3V0TXMpICE9IG51bGwgPyBfYTMgOiB0aGlzLmNvbm5lY3Rpb25Db25maWcucmVxdWVzdFRpbWVvdXRNcztcbiAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHJlcVRpbWVvdXQgPSByZXF1ZXN0VGltZW91dE1zID8gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBjb250cm9sbGVyLmFib3J0KCk7XG4gICAgfSwgcmVxdWVzdFRpbWVvdXRNcykgOiB2b2lkIDA7XG4gICAgY29uc3QgZXZlbnRzID0gdGhpcy5ycGMuY29ubmVjdChcbiAgICAgIHtcbiAgICAgICAgcHJvY2Vzczoge1xuICAgICAgICAgIHNlbGVjdG9yOiB7XG4gICAgICAgICAgICBjYXNlOiBcInBpZFwiLFxuICAgICAgICAgICAgdmFsdWU6IHBpZFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbCxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFtLRUVQQUxJVkVfUElOR19IRUFERVJdOiBLRUVQQUxJVkVfUElOR19JTlRFUlZBTF9TRUMudG9TdHJpbmcoKVxuICAgICAgICB9LFxuICAgICAgICB0aW1lb3V0TXM6IChfYiA9IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMudGltZW91dE1zKSAhPSBudWxsID8gX2IgOiB0aGlzLmRlZmF1bHRQcm9jZXNzQ29ubmVjdGlvblRpbWVvdXRcbiAgICAgIH1cbiAgICApO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwaWQyID0gYXdhaXQgaGFuZGxlUHJvY2Vzc1N0YXJ0RXZlbnQoZXZlbnRzKTtcbiAgICAgIGNsZWFyVGltZW91dChyZXFUaW1lb3V0KTtcbiAgICAgIHJldHVybiBuZXcgQ29tbWFuZEhhbmRsZShcbiAgICAgICAgcGlkMixcbiAgICAgICAgKCkgPT4gY29udHJvbGxlci5hYm9ydCgpLFxuICAgICAgICAoKSA9PiB0aGlzLmtpbGwocGlkMiksXG4gICAgICAgIGV2ZW50cyxcbiAgICAgICAgb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5vblN0ZG91dCxcbiAgICAgICAgb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5vblN0ZGVycixcbiAgICAgICAgdm9pZCAwXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgaGFuZGxlUnBjRXJyb3IoZXJyKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgcnVuKGNtZCwgb3B0cykge1xuICAgIGNvbnN0IHByb2MgPSBhd2FpdCB0aGlzLnN0YXJ0KGNtZCwgb3B0cyk7XG4gICAgcmV0dXJuIChvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLmJhY2tncm91bmQpID8gcHJvYyA6IHByb2Mud2FpdCgpO1xuICB9XG4gIGFzeW5jIHN0YXJ0KGNtZCwgb3B0cykge1xuICAgIHZhciBfYTMsIF9iO1xuICAgIGNvbnN0IHJlcXVlc3RUaW1lb3V0TXMgPSAoX2EzID0gb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5yZXF1ZXN0VGltZW91dE1zKSAhPSBudWxsID8gX2EzIDogdGhpcy5jb25uZWN0aW9uQ29uZmlnLnJlcXVlc3RUaW1lb3V0TXM7XG4gICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCByZXFUaW1lb3V0ID0gcmVxdWVzdFRpbWVvdXRNcyA/IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgY29udHJvbGxlci5hYm9ydCgpO1xuICAgIH0sIHJlcXVlc3RUaW1lb3V0TXMpIDogdm9pZCAwO1xuICAgIGNvbnN0IGV2ZW50cyA9IHRoaXMucnBjLnN0YXJ0KFxuICAgICAge1xuICAgICAgICBwcm9jZXNzOiB7XG4gICAgICAgICAgY21kOiBcIi9iaW4vYmFzaFwiLFxuICAgICAgICAgIGN3ZDogb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5jd2QsXG4gICAgICAgICAgZW52czogb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5lbnZzLFxuICAgICAgICAgIGFyZ3M6IFtcIi1sXCIsIFwiLWNcIiwgY21kXVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBoZWFkZXJzOiBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBhdXRoZW50aWNhdGlvbkhlYWRlcihvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLnVzZXIpKSwge1xuICAgICAgICAgIFtLRUVQQUxJVkVfUElOR19IRUFERVJdOiBLRUVQQUxJVkVfUElOR19JTlRFUlZBTF9TRUMudG9TdHJpbmcoKVxuICAgICAgICB9KSxcbiAgICAgICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbCxcbiAgICAgICAgdGltZW91dE1zOiAoX2IgPSBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLnRpbWVvdXRNcykgIT0gbnVsbCA/IF9iIDogdGhpcy5kZWZhdWx0UHJvY2Vzc0Nvbm5lY3Rpb25UaW1lb3V0XG4gICAgICB9XG4gICAgKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcGlkID0gYXdhaXQgaGFuZGxlUHJvY2Vzc1N0YXJ0RXZlbnQoZXZlbnRzKTtcbiAgICAgIGNsZWFyVGltZW91dChyZXFUaW1lb3V0KTtcbiAgICAgIHJldHVybiBuZXcgQ29tbWFuZEhhbmRsZShcbiAgICAgICAgcGlkLFxuICAgICAgICAoKSA9PiBjb250cm9sbGVyLmFib3J0KCksXG4gICAgICAgICgpID0+IHRoaXMua2lsbChwaWQpLFxuICAgICAgICBldmVudHMsXG4gICAgICAgIG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMub25TdGRvdXQsXG4gICAgICAgIG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMub25TdGRlcnIsXG4gICAgICAgIHZvaWQgMFxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IGhhbmRsZVJwY0Vycm9yKGVycik7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvc2FuZGJveC9zYW5kYm94QXBpLnRzXG5pbXBvcnQgeyBjb21wYXJlVmVyc2lvbnMgYXMgY29tcGFyZVZlcnNpb25zMiB9IGZyb20gXCJjb21wYXJlLXZlcnNpb25zXCI7XG52YXIgU2FuZGJveEFwaSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gIH1cbiAgLyoqXG4gICAqIEtpbGwgdGhlIHNhbmRib3ggc3BlY2lmaWVkIGJ5IHNhbmRib3ggSUQuXG4gICAqXG4gICAqIEBwYXJhbSBzYW5kYm94SWQgc2FuZGJveCBJRC5cbiAgICogQHBhcmFtIG9wdHMgY29ubmVjdGlvbiBvcHRpb25zLlxuICAgKlxuICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHNhbmRib3ggd2FzIGZvdW5kIGFuZCBraWxsZWQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGtpbGwoc2FuZGJveElkLCBvcHRzKSB7XG4gICAgdmFyIF9hMztcbiAgICBjb25zdCBjb25maWcgPSBuZXcgQ29ubmVjdGlvbkNvbmZpZyhvcHRzKTtcbiAgICBjb25zdCBjbGllbnQgPSBuZXcgQXBpQ2xpZW50KGNvbmZpZyk7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgY2xpZW50LmFwaS5ERUxFVEUoXCIvc2FuZGJveGVzL3tzYW5kYm94SUR9XCIsIHtcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgc2FuZGJveElEOiBzYW5kYm94SWRcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNpZ25hbDogY29uZmlnLmdldFNpZ25hbChvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLnJlcXVlc3RUaW1lb3V0TXMpXG4gICAgfSk7XG4gICAgaWYgKCgoX2EzID0gcmVzLmVycm9yKSA9PSBudWxsID8gdm9pZCAwIDogX2EzLmNvZGUpID09PSA0MDQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgZXJyID0gaGFuZGxlQXBpRXJyb3IocmVzKTtcbiAgICBpZiAoZXJyKSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgc2FuZGJveCBpbmZvcm1hdGlvbiBsaWtlIHNhbmRib3ggSUQsIHRlbXBsYXRlLCBtZXRhZGF0YSwgc3RhcnRlZCBhdC9lbmQgYXQgZGF0ZS5cbiAgICpcbiAgICogQHBhcmFtIHNhbmRib3hJZCBzYW5kYm94IElELlxuICAgKiBAcGFyYW0gb3B0cyBjb25uZWN0aW9uIG9wdGlvbnMuXG4gICAqXG4gICAqIEByZXR1cm5zIHNhbmRib3ggaW5mb3JtYXRpb24uXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgZ2V0SW5mbyhzYW5kYm94SWQsIG9wdHMpIHtcbiAgICBjb25zdCBmdWxsSW5mbyA9IGF3YWl0IHRoaXMuZ2V0RnVsbEluZm8oc2FuZGJveElkLCBvcHRzKTtcbiAgICBkZWxldGUgZnVsbEluZm8uZW52ZEFjY2Vzc1Rva2VuO1xuICAgIGRlbGV0ZSBmdWxsSW5mby5zYW5kYm94RG9tYWluO1xuICAgIHJldHVybiBmdWxsSW5mbztcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBtZXRyaWNzIG9mIHRoZSBzYW5kYm94LlxuICAgKlxuICAgKiBAcGFyYW0gc2FuZGJveElkIHNhbmRib3ggSUQuXG4gICAqIEBwYXJhbSBvcHRzIHNhbmRib3ggbWV0cmljcyBvcHRpb25zLlxuICAgKlxuICAgKiBAcmV0dXJucyAgTGlzdCBvZiBzYW5kYm94IG1ldHJpY3MgY29udGFpbmluZyBDUFUsIG1lbW9yeSBhbmQgZGlzayB1c2FnZSBpbmZvcm1hdGlvbi5cbiAgICovXG4gIHN0YXRpYyBhc3luYyBnZXRNZXRyaWNzKHNhbmRib3hJZCwgb3B0cykge1xuICAgIHZhciBfYTMsIF9iO1xuICAgIGNvbnN0IGNvbmZpZyA9IG5ldyBDb25uZWN0aW9uQ29uZmlnKG9wdHMpO1xuICAgIGNvbnN0IGNsaWVudCA9IG5ldyBBcGlDbGllbnQoY29uZmlnKTtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBjbGllbnQuYXBpLkdFVChcIi9zYW5kYm94ZXMve3NhbmRib3hJRH0vbWV0cmljc1wiLCB7XG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgcGF0aDoge1xuICAgICAgICAgIHNhbmRib3hJRDogc2FuZGJveElkLFxuICAgICAgICAgIHN0YXJ0OiBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLnN0YXJ0LFxuICAgICAgICAgIGVuZDogb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5lbmRcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNpZ25hbDogY29uZmlnLmdldFNpZ25hbChvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLnJlcXVlc3RUaW1lb3V0TXMpXG4gICAgfSk7XG4gICAgY29uc3QgZXJyID0gaGFuZGxlQXBpRXJyb3IocmVzKTtcbiAgICBpZiAoZXJyKSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICAgIHJldHVybiAoX2IgPSAoX2EzID0gcmVzLmRhdGEpID09IG51bGwgPyB2b2lkIDAgOiBfYTMubWFwKChtZXRyaWMpID0+ICh7XG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKG1ldHJpYy50aW1lc3RhbXApLFxuICAgICAgY3B1VXNlZFBjdDogbWV0cmljLmNwdVVzZWRQY3QsXG4gICAgICBjcHVDb3VudDogbWV0cmljLmNwdUNvdW50LFxuICAgICAgbWVtVXNlZDogbWV0cmljLm1lbVVzZWQsXG4gICAgICBtZW1Ub3RhbDogbWV0cmljLm1lbVRvdGFsLFxuICAgICAgZGlza1VzZWQ6IG1ldHJpYy5kaXNrVXNlZCxcbiAgICAgIGRpc2tUb3RhbDogbWV0cmljLmRpc2tUb3RhbFxuICAgIH0pKSkgIT0gbnVsbCA/IF9iIDogW107XG4gIH1cbiAgLyoqXG4gICAqIFNldCB0aGUgdGltZW91dCBvZiB0aGUgc3BlY2lmaWVkIHNhbmRib3guXG4gICAqIEFmdGVyIHRoZSB0aW1lb3V0IGV4cGlyZXMgdGhlIHNhbmRib3ggd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGtpbGxlZC5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgY2FuIGV4dGVuZCBvciByZWR1Y2UgdGhlIHNhbmRib3ggdGltZW91dCBzZXQgd2hlbiBjcmVhdGluZyB0aGUgc2FuZGJveCBvciBmcm9tIHRoZSBsYXN0IGNhbGwgdG8ge0BsaW5rIFNhbmRib3guc2V0VGltZW91dH0uXG4gICAqXG4gICAqIE1heGltdW0gdGltZSBhIHNhbmRib3ggY2FuIGJlIGtlcHQgYWxpdmUgaXMgMjQgaG91cnMgKDg2XzQwMF8wMDAgbWlsbGlzZWNvbmRzKSBmb3IgUHJvIHVzZXJzIGFuZCAxIGhvdXIgKDNfNjAwXzAwMCBtaWxsaXNlY29uZHMpIGZvciBIb2JieSB1c2Vycy5cbiAgICpcbiAgICogQHBhcmFtIHNhbmRib3hJZCBzYW5kYm94IElELlxuICAgKiBAcGFyYW0gdGltZW91dE1zIHRpbWVvdXQgaW4gKiptaWxsaXNlY29uZHMqKi5cbiAgICogQHBhcmFtIG9wdHMgY29ubmVjdGlvbiBvcHRpb25zLlxuICAgKi9cbiAgc3RhdGljIGFzeW5jIHNldFRpbWVvdXQoc2FuZGJveElkLCB0aW1lb3V0TXMsIG9wdHMpIHtcbiAgICBjb25zdCBjb25maWcgPSBuZXcgQ29ubmVjdGlvbkNvbmZpZyhvcHRzKTtcbiAgICBjb25zdCBjbGllbnQgPSBuZXcgQXBpQ2xpZW50KGNvbmZpZyk7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgY2xpZW50LmFwaS5QT1NUKFwiL3NhbmRib3hlcy97c2FuZGJveElEfS90aW1lb3V0XCIsIHtcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgc2FuZGJveElEOiBzYW5kYm94SWRcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGJvZHk6IHtcbiAgICAgICAgdGltZW91dDogdGltZW91dFRvU2Vjb25kcyh0aW1lb3V0TXMpXG4gICAgICB9LFxuICAgICAgc2lnbmFsOiBjb25maWcuZ2V0U2lnbmFsKG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMucmVxdWVzdFRpbWVvdXRNcylcbiAgICB9KTtcbiAgICBjb25zdCBlcnIgPSBoYW5kbGVBcGlFcnJvcihyZXMpO1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGFzeW5jIGdldEZ1bGxJbmZvKHNhbmRib3hJZCwgb3B0cykge1xuICAgIHZhciBfYTM7XG4gICAgY29uc3QgY29uZmlnID0gbmV3IENvbm5lY3Rpb25Db25maWcob3B0cyk7XG4gICAgY29uc3QgY2xpZW50ID0gbmV3IEFwaUNsaWVudChjb25maWcpO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGNsaWVudC5hcGkuR0VUKFwiL3NhbmRib3hlcy97c2FuZGJveElEfVwiLCB7XG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgcGF0aDoge1xuICAgICAgICAgIHNhbmRib3hJRDogc2FuZGJveElkXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzaWduYWw6IGNvbmZpZy5nZXRTaWduYWwob3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5yZXF1ZXN0VGltZW91dE1zKVxuICAgIH0pO1xuICAgIGNvbnN0IGVyciA9IGhhbmRsZUFwaUVycm9yKHJlcyk7XG4gICAgaWYgKGVycikge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgICBpZiAoIXJlcy5kYXRhKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTYW5kYm94IG5vdCBmb3VuZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgc2FuZGJveElkOiByZXMuZGF0YS5zYW5kYm94SUQsXG4gICAgICB0ZW1wbGF0ZUlkOiByZXMuZGF0YS50ZW1wbGF0ZUlEXG4gICAgfSwgcmVzLmRhdGEuYWxpYXMgJiYgeyBuYW1lOiByZXMuZGF0YS5hbGlhcyB9KSwge1xuICAgICAgbWV0YWRhdGE6IChfYTMgPSByZXMuZGF0YS5tZXRhZGF0YSkgIT0gbnVsbCA/IF9hMyA6IHt9LFxuICAgICAgZW52ZFZlcnNpb246IHJlcy5kYXRhLmVudmRWZXJzaW9uLFxuICAgICAgZW52ZEFjY2Vzc1Rva2VuOiByZXMuZGF0YS5lbnZkQWNjZXNzVG9rZW4sXG4gICAgICBzdGFydGVkQXQ6IG5ldyBEYXRlKHJlcy5kYXRhLnN0YXJ0ZWRBdCksXG4gICAgICBlbmRBdDogbmV3IERhdGUocmVzLmRhdGEuZW5kQXQpLFxuICAgICAgc3RhdGU6IHJlcy5kYXRhLnN0YXRlLFxuICAgICAgY3B1Q291bnQ6IHJlcy5kYXRhLmNwdUNvdW50LFxuICAgICAgbWVtb3J5TUI6IHJlcy5kYXRhLm1lbW9yeU1CLFxuICAgICAgc2FuZGJveERvbWFpbjogcmVzLmRhdGEuZG9tYWluIHx8IHZvaWQgMFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBQYXVzZSB0aGUgc2FuZGJveCBzcGVjaWZpZWQgYnkgc2FuZGJveCBJRC5cbiAgICpcbiAgICogQHBhcmFtIHNhbmRib3hJZCBzYW5kYm94IElELlxuICAgKiBAcGFyYW0gb3B0cyBjb25uZWN0aW9uIG9wdGlvbnMuXG4gICAqXG4gICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgc2FuZGJveCBnb3QgcGF1c2VkLCBgZmFsc2VgIGlmIHRoZSBzYW5kYm94IHdhcyBhbHJlYWR5IHBhdXNlZC5cbiAgICovXG4gIHN0YXRpYyBhc3luYyBiZXRhUGF1c2Uoc2FuZGJveElkLCBvcHRzKSB7XG4gICAgdmFyIF9hMywgX2I7XG4gICAgY29uc3QgY29uZmlnID0gbmV3IENvbm5lY3Rpb25Db25maWcob3B0cyk7XG4gICAgY29uc3QgY2xpZW50ID0gbmV3IEFwaUNsaWVudChjb25maWcpO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGNsaWVudC5hcGkuUE9TVChcIi9zYW5kYm94ZXMve3NhbmRib3hJRH0vcGF1c2VcIiwge1xuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIHBhdGg6IHtcbiAgICAgICAgICBzYW5kYm94SUQ6IHNhbmRib3hJZFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2lnbmFsOiBjb25maWcuZ2V0U2lnbmFsKG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMucmVxdWVzdFRpbWVvdXRNcylcbiAgICB9KTtcbiAgICBpZiAoKChfYTMgPSByZXMuZXJyb3IpID09IG51bGwgPyB2b2lkIDAgOiBfYTMuY29kZSkgPT09IDQwNCkge1xuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXJyb3IoYFNhbmRib3ggJHtzYW5kYm94SWR9IG5vdCBmb3VuZGApO1xuICAgIH1cbiAgICBpZiAoKChfYiA9IHJlcy5lcnJvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNvZGUpID09PSA0MDkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgZXJyID0gaGFuZGxlQXBpRXJyb3IocmVzKTtcbiAgICBpZiAoZXJyKSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHN0YXRpYyBhc3luYyBjcmVhdGVTYW5kYm94KHRlbXBsYXRlLCB0aW1lb3V0TXMsIG9wdHMpIHtcbiAgICB2YXIgX2EzLCBfYiwgX2M7XG4gICAgY29uc3QgY29uZmlnID0gbmV3IENvbm5lY3Rpb25Db25maWcob3B0cyk7XG4gICAgY29uc3QgY2xpZW50ID0gbmV3IEFwaUNsaWVudChjb25maWcpO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGNsaWVudC5hcGkuUE9TVChcIi9zYW5kYm94ZXNcIiwge1xuICAgICAgYm9keToge1xuICAgICAgICBhdXRvUGF1c2U6IChfYTMgPSBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLmF1dG9QYXVzZSkgIT0gbnVsbCA/IF9hMyA6IGZhbHNlLFxuICAgICAgICB0ZW1wbGF0ZUlEOiB0ZW1wbGF0ZSxcbiAgICAgICAgbWV0YWRhdGE6IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMubWV0YWRhdGEsXG4gICAgICAgIGVudlZhcnM6IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuZW52cyxcbiAgICAgICAgdGltZW91dDogdGltZW91dFRvU2Vjb25kcyh0aW1lb3V0TXMpLFxuICAgICAgICBzZWN1cmU6IChfYiA9IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuc2VjdXJlKSAhPSBudWxsID8gX2IgOiB0cnVlLFxuICAgICAgICBhbGxvd19pbnRlcm5ldF9hY2Nlc3M6IChfYyA9IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuYWxsb3dJbnRlcm5ldEFjY2VzcykgIT0gbnVsbCA/IF9jIDogdHJ1ZVxuICAgICAgfSxcbiAgICAgIHNpZ25hbDogY29uZmlnLmdldFNpZ25hbChvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLnJlcXVlc3RUaW1lb3V0TXMpXG4gICAgfSk7XG4gICAgY29uc3QgZXJyID0gaGFuZGxlQXBpRXJyb3IocmVzKTtcbiAgICBpZiAoZXJyKSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICAgIGlmIChjb21wYXJlVmVyc2lvbnMyKHJlcy5kYXRhLmVudmRWZXJzaW9uLCBcIjAuMS4wXCIpIDwgMCkge1xuICAgICAgYXdhaXQgdGhpcy5raWxsKHJlcy5kYXRhLnNhbmRib3hJRCwgb3B0cyk7XG4gICAgICB0aHJvdyBuZXcgVGVtcGxhdGVFcnJvcihcbiAgICAgICAgXCJZb3UgbmVlZCB0byB1cGRhdGUgdGhlIHRlbXBsYXRlIHRvIHVzZSB0aGUgbmV3IFNESy4gWW91IGNhbiBkbyB0aGlzIGJ5IHJ1bm5pbmcgYGUyYiB0ZW1wbGF0ZSBidWlsZGAgaW4gdGhlIGRpcmVjdG9yeSB3aXRoIHRoZSB0ZW1wbGF0ZS5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHNhbmRib3hJZDogcmVzLmRhdGEuc2FuZGJveElELFxuICAgICAgc2FuZGJveERvbWFpbjogcmVzLmRhdGEuZG9tYWluIHx8IHZvaWQgMCxcbiAgICAgIGVudmRWZXJzaW9uOiByZXMuZGF0YS5lbnZkVmVyc2lvbixcbiAgICAgIGVudmRBY2Nlc3NUb2tlbjogcmVzLmRhdGEuZW52ZEFjY2Vzc1Rva2VuXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgcmVzdW1lU2FuZGJveChzYW5kYm94SWQsIG9wdHMpIHtcbiAgICB2YXIgX2EzLCBfYiwgX2M7XG4gICAgY29uc3QgdGltZW91dE1zID0gKF9hMyA9IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMudGltZW91dE1zKSAhPSBudWxsID8gX2EzIDogREVGQVVMVF9TQU5EQk9YX1RJTUVPVVRfTVM7XG4gICAgY29uc3QgY29uZmlnID0gbmV3IENvbm5lY3Rpb25Db25maWcob3B0cyk7XG4gICAgY29uc3QgY2xpZW50ID0gbmV3IEFwaUNsaWVudChjb25maWcpO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGNsaWVudC5hcGkuUE9TVChcIi9zYW5kYm94ZXMve3NhbmRib3hJRH0vcmVzdW1lXCIsIHtcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgc2FuZGJveElEOiBzYW5kYm94SWRcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGJvZHk6IHtcbiAgICAgICAgdGltZW91dDogdGltZW91dFRvU2Vjb25kcyh0aW1lb3V0TXMpXG4gICAgICB9LFxuICAgICAgc2lnbmFsOiBjb25maWcuZ2V0U2lnbmFsKG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMucmVxdWVzdFRpbWVvdXRNcylcbiAgICB9KTtcbiAgICBpZiAoKChfYiA9IHJlcy5lcnJvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNvZGUpID09PSA0MDQpIHtcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEVycm9yKGBQYXVzZWQgc2FuZGJveCAke3NhbmRib3hJZH0gbm90IGZvdW5kYCk7XG4gICAgfVxuICAgIGlmICgoKF9jID0gcmVzLmVycm9yKSA9PSBudWxsID8gdm9pZCAwIDogX2MuY29kZSkgPT09IDQwOSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBlcnIgPSBoYW5kbGVBcGlFcnJvcihyZXMpO1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG52YXIgU2FuZGJveFBhZ2luYXRvciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHRoaXMuY29uZmlnID0gbmV3IENvbm5lY3Rpb25Db25maWcob3B0cyk7XG4gICAgdGhpcy5jbGllbnQgPSBuZXcgQXBpQ2xpZW50KHRoaXMuY29uZmlnKTtcbiAgICB0aGlzLl9oYXNOZXh0ID0gdHJ1ZTtcbiAgICB0aGlzLl9uZXh0VG9rZW4gPSBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLm5leHRUb2tlbjtcbiAgICB0aGlzLnF1ZXJ5ID0gb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5xdWVyeTtcbiAgICB0aGlzLmxpbWl0ID0gb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5saW1pdDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBUcnVlIGlmIHRoZXJlIGFyZSBtb3JlIGl0ZW1zIHRvIGZldGNoLlxuICAgKi9cbiAgZ2V0IGhhc05leHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hhc05leHQ7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG5leHQgdG9rZW4gdG8gdXNlIGZvciBwYWdpbmF0aW9uLlxuICAgKi9cbiAgZ2V0IG5leHRUb2tlbigpIHtcbiAgICByZXR1cm4gdGhpcy5fbmV4dFRva2VuO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIG5leHQgcGFnZSBvZiBzYW5kYm94ZXMuXG4gICAqXG4gICAqIEB0aHJvd3MgRXJyb3IgaWYgdGhlcmUgYXJlIG5vIG1vcmUgaXRlbXMgdG8gZmV0Y2guIENhbGwgdGhpcyBtZXRob2Qgb25seSBpZiBgaGFzTmV4dGAgaXMgYHRydWVgLlxuICAgKlxuICAgKiBAcmV0dXJucyBMaXN0IG9mIHNhbmRib3hlc1xuICAgKi9cbiAgYXN5bmMgbmV4dEl0ZW1zKCkge1xuICAgIHZhciBfYTMsIF9iLCBfYztcbiAgICBpZiAoIXRoaXMuaGFzTmV4dCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gbW9yZSBpdGVtcyB0byBmZXRjaFwiKTtcbiAgICB9XG4gICAgbGV0IG1ldGFkYXRhID0gdm9pZCAwO1xuICAgIGlmICgoX2EzID0gdGhpcy5xdWVyeSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5tZXRhZGF0YSkge1xuICAgICAgY29uc3QgZW5jb2RlZFBhaXJzID0gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICBPYmplY3QuZW50cmllcyh0aGlzLnF1ZXJ5Lm1ldGFkYXRhKS5tYXAoKFtrZXksIHZhbHVlXSkgPT4gW1xuICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChrZXkpLFxuICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSlcbiAgICAgICAgXSlcbiAgICAgICk7XG4gICAgICBtZXRhZGF0YSA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoZW5jb2RlZFBhaXJzKS50b1N0cmluZygpO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmNsaWVudC5hcGkuR0VUKFwiL3YyL3NhbmRib3hlc1wiLCB7XG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgcXVlcnk6IHtcbiAgICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgICBzdGF0ZTogKF9iID0gdGhpcy5xdWVyeSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnN0YXRlLFxuICAgICAgICAgIGxpbWl0OiB0aGlzLmxpbWl0LFxuICAgICAgICAgIG5leHRUb2tlbjogdGhpcy5uZXh0VG9rZW5cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIHJlcXVlc3RUaW1lb3V0TXMgaXMgYWxyZWFkeSBwYXNzZWQgaGVyZSB2aWEgdGhlIGNvbm5lY3Rpb25Db25maWcuXG4gICAgICBzaWduYWw6IHRoaXMuY29uZmlnLmdldFNpZ25hbCgpXG4gICAgfSk7XG4gICAgY29uc3QgZXJyID0gaGFuZGxlQXBpRXJyb3IocmVzKTtcbiAgICBpZiAoZXJyKSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICAgIHRoaXMuX25leHRUb2tlbiA9IHJlcy5yZXNwb25zZS5oZWFkZXJzLmdldChcIngtbmV4dC10b2tlblwiKSB8fCB2b2lkIDA7XG4gICAgdGhpcy5faGFzTmV4dCA9ICEhdGhpcy5fbmV4dFRva2VuO1xuICAgIHJldHVybiAoKF9jID0gcmVzLmRhdGEpICE9IG51bGwgPyBfYyA6IFtdKS5tYXAoXG4gICAgICAoc2FuZGJveCkgPT4ge1xuICAgICAgICB2YXIgX2E0O1xuICAgICAgICByZXR1cm4gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7XG4gICAgICAgICAgc2FuZGJveElkOiBzYW5kYm94LnNhbmRib3hJRCxcbiAgICAgICAgICB0ZW1wbGF0ZUlkOiBzYW5kYm94LnRlbXBsYXRlSURcbiAgICAgICAgfSwgc2FuZGJveC5hbGlhcyAmJiB7IG5hbWU6IHNhbmRib3guYWxpYXMgfSksIHtcbiAgICAgICAgICBtZXRhZGF0YTogKF9hNCA9IHNhbmRib3gubWV0YWRhdGEpICE9IG51bGwgPyBfYTQgOiB7fSxcbiAgICAgICAgICBzdGFydGVkQXQ6IG5ldyBEYXRlKHNhbmRib3guc3RhcnRlZEF0KSxcbiAgICAgICAgICBlbmRBdDogbmV3IERhdGUoc2FuZGJveC5lbmRBdCksXG4gICAgICAgICAgc3RhdGU6IHNhbmRib3guc3RhdGUsXG4gICAgICAgICAgY3B1Q291bnQ6IHNhbmRib3guY3B1Q291bnQsXG4gICAgICAgICAgbWVtb3J5TUI6IHNhbmRib3gubWVtb3J5TUIsXG4gICAgICAgICAgZW52ZFZlcnNpb246IHNhbmRib3guZW52ZFZlcnNpb25cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgKTtcbiAgfVxufTtcblxuLy8gc3JjL3NhbmRib3gvaW5kZXgudHNcbmltcG9ydCB7IGNvbXBhcmVWZXJzaW9ucyBhcyBjb21wYXJlVmVyc2lvbnMzIH0gZnJvbSBcImNvbXBhcmUtdmVyc2lvbnNcIjtcbnZhciBTYW5kYm94ID0gY2xhc3MgZXh0ZW5kcyBTYW5kYm94QXBpIHtcbiAgLyoqXG4gICAqIFVzZSB7QGxpbmsgU2FuZGJveC5jcmVhdGV9IHRvIGNyZWF0ZSBhIG5ldyBTYW5kYm94IGluc3RlYWQuXG4gICAqXG4gICAqIEBoaWRkZW5cbiAgICogQGhpZGVcbiAgICogQGludGVybmFsXG4gICAqIEBhY2Nlc3MgcHJvdGVjdGVkXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgdmFyIF9hMztcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZW52ZFBvcnQgPSA0OTk4MztcbiAgICB0aGlzLmNvbm5lY3Rpb25Db25maWcgPSBuZXcgQ29ubmVjdGlvbkNvbmZpZyhvcHRzKTtcbiAgICB0aGlzLnNhbmRib3hJZCA9IG9wdHMuc2FuZGJveElkO1xuICAgIHRoaXMuc2FuZGJveERvbWFpbiA9IChfYTMgPSBvcHRzLnNhbmRib3hEb21haW4pICE9IG51bGwgPyBfYTMgOiB0aGlzLmNvbm5lY3Rpb25Db25maWcuZG9tYWluO1xuICAgIHRoaXMuZW52ZEFjY2Vzc1Rva2VuID0gb3B0cy5lbnZkQWNjZXNzVG9rZW47XG4gICAgdGhpcy5lbnZkQXBpVXJsID0gYCR7dGhpcy5jb25uZWN0aW9uQ29uZmlnLmRlYnVnID8gXCJodHRwXCIgOiBcImh0dHBzXCJ9Oi8vJHt0aGlzLmdldEhvc3QodGhpcy5lbnZkUG9ydCl9YDtcbiAgICBjb25zdCBycGNUcmFuc3BvcnQgPSBjcmVhdGVDb25uZWN0VHJhbnNwb3J0KHtcbiAgICAgIGJhc2VVcmw6IHRoaXMuZW52ZEFwaVVybCxcbiAgICAgIHVzZUJpbmFyeUZvcm1hdDogZmFsc2UsXG4gICAgICBpbnRlcmNlcHRvcnM6IChvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLmxvZ2dlcikgPyBbY3JlYXRlUnBjTG9nZ2VyKG9wdHMubG9nZ2VyKV0gOiB2b2lkIDAsXG4gICAgICBmZXRjaDogKHVybCwgb3B0aW9ucykgPT4ge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnModGhpcy5jb25uZWN0aW9uQ29uZmlnLmhlYWRlcnMpO1xuICAgICAgICBuZXcgSGVhZGVycyhvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmhlYWRlcnMpLmZvckVhY2goXG4gICAgICAgICAgKHZhbHVlLCBrZXkpID0+IGhlYWRlcnMuYXBwZW5kKGtleSwgdmFsdWUpXG4gICAgICAgICk7XG4gICAgICAgIGlmICh0aGlzLmVudmRBY2Nlc3NUb2tlbikge1xuICAgICAgICAgIGhlYWRlcnMuYXBwZW5kKFwiWC1BY2Nlc3MtVG9rZW5cIiwgdGhpcy5lbnZkQWNjZXNzVG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMgPSBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zICE9IG51bGwgPyBvcHRpb25zIDoge30pLCB7XG4gICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICByZWRpcmVjdDogXCJmb2xsb3dcIlxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZldGNoKHVybCwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5lbnZkQXBpID0gbmV3IEVudmRBcGlDbGllbnQoXG4gICAgICB7XG4gICAgICAgIGFwaVVybDogdGhpcy5lbnZkQXBpVXJsLFxuICAgICAgICBsb2dnZXI6IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMubG9nZ2VyLFxuICAgICAgICBhY2Nlc3NUb2tlbjogdGhpcy5lbnZkQWNjZXNzVG9rZW4sXG4gICAgICAgIGhlYWRlcnM6IHRoaXMuZW52ZEFjY2Vzc1Rva2VuID8geyBcIlgtQWNjZXNzLVRva2VuXCI6IHRoaXMuZW52ZEFjY2Vzc1Rva2VuIH0gOiB7fVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgdmVyc2lvbjogb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5lbnZkVmVyc2lvblxuICAgICAgfVxuICAgICk7XG4gICAgdGhpcy5maWxlcyA9IG5ldyBGaWxlc3lzdGVtMihcbiAgICAgIHJwY1RyYW5zcG9ydCxcbiAgICAgIHRoaXMuZW52ZEFwaSxcbiAgICAgIHRoaXMuY29ubmVjdGlvbkNvbmZpZ1xuICAgICk7XG4gICAgdGhpcy5jb21tYW5kcyA9IG5ldyBDb21tYW5kcyhycGNUcmFuc3BvcnQsIHRoaXMuY29ubmVjdGlvbkNvbmZpZyk7XG4gICAgdGhpcy5wdHkgPSBuZXcgUHR5KHJwY1RyYW5zcG9ydCwgdGhpcy5jb25uZWN0aW9uQ29uZmlnKTtcbiAgfVxuICAvKipcbiAgICogTGlzdCBhbGwgc2FuZGJveGVzLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0cyBjb25uZWN0aW9uIG9wdGlvbnMuXG4gICAqXG4gICAqIEByZXR1cm5zIHBhZ2luYXRvciBmb3IgbGlzdGluZyBzYW5kYm94ZXMuXG4gICAqL1xuICBzdGF0aWMgbGlzdChvcHRzKSB7XG4gICAgcmV0dXJuIG5ldyBTYW5kYm94UGFnaW5hdG9yKG9wdHMpO1xuICB9XG4gIHN0YXRpYyBhc3luYyBjcmVhdGUodGVtcGxhdGVPck9wdHMsIG9wdHMpIHtcbiAgICB2YXIgX2EzO1xuICAgIGNvbnN0IHsgdGVtcGxhdGUsIHNhbmRib3hPcHRzIH0gPSB0eXBlb2YgdGVtcGxhdGVPck9wdHMgPT09IFwic3RyaW5nXCIgPyB7IHRlbXBsYXRlOiB0ZW1wbGF0ZU9yT3B0cywgc2FuZGJveE9wdHM6IG9wdHMgfSA6IHsgdGVtcGxhdGU6IHRoaXMuZGVmYXVsdFRlbXBsYXRlLCBzYW5kYm94T3B0czogdGVtcGxhdGVPck9wdHMgfTtcbiAgICBjb25zdCBjb25maWcgPSBuZXcgQ29ubmVjdGlvbkNvbmZpZyhzYW5kYm94T3B0cyk7XG4gICAgaWYgKGNvbmZpZy5kZWJ1Zykge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgICAgc2FuZGJveElkOiBcImRlYnVnX3NhbmRib3hfaWRcIlxuICAgICAgfSwgY29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IHNhbmRib3ggPSBhd2FpdCBTYW5kYm94QXBpLmNyZWF0ZVNhbmRib3goXG4gICAgICB0ZW1wbGF0ZSxcbiAgICAgIChfYTMgPSBzYW5kYm94T3B0cyA9PSBudWxsID8gdm9pZCAwIDogc2FuZGJveE9wdHMudGltZW91dE1zKSAhPSBudWxsID8gX2EzIDogdGhpcy5kZWZhdWx0U2FuZGJveFRpbWVvdXRNcyxcbiAgICAgIHNhbmRib3hPcHRzXG4gICAgKTtcbiAgICByZXR1cm4gbmV3IHRoaXMoX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIHNhbmRib3gpLCBjb25maWcpKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgYmV0YUNyZWF0ZSh0ZW1wbGF0ZU9yT3B0cywgb3B0cykge1xuICAgIHZhciBfYTM7XG4gICAgY29uc3QgeyB0ZW1wbGF0ZSwgc2FuZGJveE9wdHMgfSA9IHR5cGVvZiB0ZW1wbGF0ZU9yT3B0cyA9PT0gXCJzdHJpbmdcIiA/IHsgdGVtcGxhdGU6IHRlbXBsYXRlT3JPcHRzLCBzYW5kYm94T3B0czogb3B0cyB9IDogeyB0ZW1wbGF0ZTogdGhpcy5kZWZhdWx0VGVtcGxhdGUsIHNhbmRib3hPcHRzOiB0ZW1wbGF0ZU9yT3B0cyB9O1xuICAgIGNvbnN0IGNvbmZpZyA9IG5ldyBDb25uZWN0aW9uQ29uZmlnKHNhbmRib3hPcHRzKTtcbiAgICBpZiAoY29uZmlnLmRlYnVnKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgICBzYW5kYm94SWQ6IFwiZGVidWdfc2FuZGJveF9pZFwiXG4gICAgICB9LCBjb25maWcpKTtcbiAgICB9XG4gICAgY29uc3Qgc2FuZGJveCA9IGF3YWl0IFNhbmRib3hBcGkuY3JlYXRlU2FuZGJveChcbiAgICAgIHRlbXBsYXRlLFxuICAgICAgKF9hMyA9IHNhbmRib3hPcHRzID09IG51bGwgPyB2b2lkIDAgOiBzYW5kYm94T3B0cy50aW1lb3V0TXMpICE9IG51bGwgPyBfYTMgOiB0aGlzLmRlZmF1bHRTYW5kYm94VGltZW91dE1zLFxuICAgICAgc2FuZGJveE9wdHNcbiAgICApO1xuICAgIHJldHVybiBuZXcgdGhpcyhfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgc2FuZGJveCksIGNvbmZpZykpO1xuICB9XG4gIC8qKlxuICAgKiBDb25uZWN0IHRvIGEgc2FuZGJveC4gSWYgdGhlIHNhbmRib3ggaXMgcGF1c2VkLCBpdCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgcmVzdW1lZC5cbiAgICogU2FuZGJveCBtdXN0IGJlIGVpdGhlciBydW5uaW5nIG9yIGJlIHBhdXNlZC5cbiAgICpcbiAgICogV2l0aCBzYW5kYm94IElEIHlvdSBjYW4gY29ubmVjdCB0byB0aGUgc2FtZSBzYW5kYm94IGZyb20gZGlmZmVyZW50IHBsYWNlcyBvciBlbnZpcm9ubWVudHMgKHNlcnZlcmxlc3MgZnVuY3Rpb25zLCBldGMpLlxuICAgKlxuICAgKiBAcGFyYW0gc2FuZGJveElkIHNhbmRib3ggSUQuXG4gICAqIEBwYXJhbSBvcHRzIGNvbm5lY3Rpb24gb3B0aW9ucy5cbiAgICpcbiAgICogQHJldHVybnMgQSBydW5uaW5nIHNhbmRib3ggaW5zdGFuY2VcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogY29uc3Qgc2FuZGJveCA9IGF3YWl0IFNhbmRib3guY3JlYXRlKClcbiAgICogY29uc3Qgc2FuZGJveElkID0gc2FuZGJveC5zYW5kYm94SWRcbiAgICpcbiAgICogLy8gQ29ubmVjdCB0byB0aGUgc2FtZSBzYW5kYm94LlxuICAgKiBjb25zdCBzYW1lU2FuZGJveCA9IGF3YWl0IFNhbmRib3guY29ubmVjdChzYW5kYm94SWQpXG4gICAqIGBgYFxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGNvbm5lY3Qoc2FuZGJveElkLCBvcHRzKSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IFNhbmRib3hBcGkuc2V0VGltZW91dChcbiAgICAgICAgc2FuZGJveElkLFxuICAgICAgICAob3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy50aW1lb3V0TXMpIHx8IERFRkFVTFRfU0FOREJPWF9USU1FT1VUX01TLFxuICAgICAgICBvcHRzXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlIGluc3RhbmNlb2YgU2FuZGJveEVycm9yKSB7XG4gICAgICAgIGF3YWl0IFNhbmRib3hBcGkucmVzdW1lU2FuZGJveChzYW5kYm94SWQsIG9wdHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaW5mbyA9IGF3YWl0IFNhbmRib3hBcGkuZ2V0RnVsbEluZm8oc2FuZGJveElkLCBvcHRzKTtcbiAgICBjb25zdCBjb25maWcgPSBuZXcgQ29ubmVjdGlvbkNvbmZpZyhvcHRzKTtcbiAgICByZXR1cm4gbmV3IHRoaXMoX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgc2FuZGJveElkLFxuICAgICAgc2FuZGJveERvbWFpbjogaW5mby5zYW5kYm94RG9tYWluLFxuICAgICAgZW52ZEFjY2Vzc1Rva2VuOiBpbmZvLmVudmRBY2Nlc3NUb2tlbixcbiAgICAgIGVudmRWZXJzaW9uOiBpbmZvLmVudmRWZXJzaW9uXG4gICAgfSwgY29uZmlnKSk7XG4gIH1cbiAgLyoqXG4gICAqIENvbm5lY3QgdG8gYSBzYW5kYm94LiBJZiB0aGUgc2FuZGJveCBpcyBwYXVzZWQsIGl0IHdpbGwgYmUgYXV0b21hdGljYWxseSByZXN1bWVkLlxuICAgKiBTYW5kYm94IG11c3QgYmUgZWl0aGVyIHJ1bm5pbmcgb3IgYmUgcGF1c2VkLlxuICAgKlxuICAgKiBXaXRoIHNhbmRib3ggSUQgeW91IGNhbiBjb25uZWN0IHRvIHRoZSBzYW1lIHNhbmRib3ggZnJvbSBkaWZmZXJlbnQgcGxhY2VzIG9yIGVudmlyb25tZW50cyAoc2VydmVybGVzcyBmdW5jdGlvbnMsIGV0YykuXG4gICAqXG4gICAqIEBwYXJhbSBvcHRzIGNvbm5lY3Rpb24gb3B0aW9ucy5cbiAgICpcbiAgICogQHJldHVybnMgQSBydW5uaW5nIHNhbmRib3ggaW5zdGFuY2VcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogY29uc3Qgc2FuZGJveCA9IGF3YWl0IFNhbmRib3guY3JlYXRlKClcbiAgICogYXdhaXQgc2FuZGJveC5iZXRhUGF1c2UoKVxuICAgKlxuICAgKiAvLyBDb25uZWN0IHRvIHRoZSBzYW1lIHNhbmRib3guXG4gICAqIGNvbnN0IHNhbWVTYW5kYm94ID0gYXdhaXQgc2FuZGJveC5jb25uZWN0KClcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBjb25uZWN0KG9wdHMpIHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgU2FuZGJveEFwaS5zZXRUaW1lb3V0KFxuICAgICAgICB0aGlzLnNhbmRib3hJZCxcbiAgICAgICAgKG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMudGltZW91dE1zKSB8fCBERUZBVUxUX1NBTkRCT1hfVElNRU9VVF9NUyxcbiAgICAgICAgb3B0c1xuICAgICAgKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBhd2FpdCBTYW5kYm94QXBpLnJlc3VtZVNhbmRib3godGhpcy5zYW5kYm94SWQsIG9wdHMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBob3N0IGFkZHJlc3MgZm9yIHRoZSBzcGVjaWZpZWQgc2FuZGJveCBwb3J0LlxuICAgKiBZb3UgY2FuIHRoZW4gdXNlIHRoaXMgYWRkcmVzcyB0byBjb25uZWN0IHRvIHRoZSBzYW5kYm94IHBvcnQgZnJvbSBvdXRzaWRlIHRoZSBzYW5kYm94IHZpYSBIVFRQIG9yIFdlYlNvY2tldC5cbiAgICpcbiAgICogQHBhcmFtIHBvcnQgbnVtYmVyIG9mIHRoZSBwb3J0IGluIHRoZSBzYW5kYm94LlxuICAgKlxuICAgKiBAcmV0dXJucyBob3N0IGFkZHJlc3Mgb2YgdGhlIHNhbmRib3ggcG9ydC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogY29uc3Qgc2FuZGJveCA9IGF3YWl0IFNhbmRib3guY3JlYXRlKClcbiAgICogLy8gU3RhcnQgYW4gSFRUUCBzZXJ2ZXJcbiAgICogYXdhaXQgc2FuZGJveC5jb21tYW5kcy5leGVjKCdweXRob24zIC1tIGh0dHAuc2VydmVyIDMwMDAnKVxuICAgKiAvLyBHZXQgdGhlIGhvc3RuYW1lIG9mIHRoZSBIVFRQIHNlcnZlclxuICAgKiBjb25zdCBzZXJ2ZXJVUkwgPSBzYW5kYm94LmdldEhvc3QoMzAwMClcbiAgICogYGBgXG4gICAqL1xuICBnZXRIb3N0KHBvcnQpIHtcbiAgICBpZiAodGhpcy5jb25uZWN0aW9uQ29uZmlnLmRlYnVnKSB7XG4gICAgICByZXR1cm4gYGxvY2FsaG9zdDoke3BvcnR9YDtcbiAgICB9XG4gICAgcmV0dXJuIGAke3BvcnR9LSR7dGhpcy5zYW5kYm94SWR9LiR7dGhpcy5zYW5kYm94RG9tYWlufWA7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSBzYW5kYm94IGlzIHJ1bm5pbmcuXG4gICAqXG4gICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgc2FuZGJveCBpcyBydW5uaW5nLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogY29uc3Qgc2FuZGJveCA9IGF3YWl0IFNhbmRib3guY3JlYXRlKClcbiAgICogYXdhaXQgc2FuZGJveC5pc1J1bm5pbmcoKSAvLyBSZXR1cm5zIHRydWVcbiAgICpcbiAgICogYXdhaXQgc2FuZGJveC5raWxsKClcbiAgICogYXdhaXQgc2FuZGJveC5pc1J1bm5pbmcoKSAvLyBSZXR1cm5zIGZhbHNlXG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgaXNSdW5uaW5nKG9wdHMpIHtcbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLmNvbm5lY3Rpb25Db25maWcuZ2V0U2lnbmFsKG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMucmVxdWVzdFRpbWVvdXRNcyk7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5lbnZkQXBpLmFwaS5HRVQoXCIvaGVhbHRoXCIsIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGlmIChyZXMucmVzcG9uc2Uuc3RhdHVzID09IDUwMikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBlcnIgPSBhd2FpdCBoYW5kbGVFbnZkQXBpRXJyb3IocmVzKTtcbiAgICBpZiAoZXJyKSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgdGhlIHRpbWVvdXQgb2YgdGhlIHNhbmRib3guXG4gICAqIEFmdGVyIHRoZSB0aW1lb3V0IGV4cGlyZXMgdGhlIHNhbmRib3ggd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGtpbGxlZC5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgY2FuIGV4dGVuZCBvciByZWR1Y2UgdGhlIHNhbmRib3ggdGltZW91dCBzZXQgd2hlbiBjcmVhdGluZyB0aGUgc2FuZGJveCBvciBmcm9tIHRoZSBsYXN0IGNhbGwgdG8gYC5zZXRUaW1lb3V0YC5cbiAgICogTWF4aW11bSB0aW1lIGEgc2FuZGJveCBjYW4gYmUga2VwdCBhbGl2ZSBpcyAyNCBob3VycyAoODZfNDAwXzAwMCBtaWxsaXNlY29uZHMpIGZvciBQcm8gdXNlcnMgYW5kIDEgaG91ciAoM182MDBfMDAwIG1pbGxpc2Vjb25kcykgZm9yIEhvYmJ5IHVzZXJzLlxuICAgKlxuICAgKiBAcGFyYW0gdGltZW91dE1zIHRpbWVvdXQgaW4gKiptaWxsaXNlY29uZHMqKi5cbiAgICogQHBhcmFtIG9wdHMgY29ubmVjdGlvbiBvcHRpb25zLlxuICAgKi9cbiAgYXN5bmMgc2V0VGltZW91dCh0aW1lb3V0TXMsIG9wdHMpIHtcbiAgICBpZiAodGhpcy5jb25uZWN0aW9uQ29uZmlnLmRlYnVnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGF3YWl0IFNhbmRib3hBcGkuc2V0VGltZW91dCh0aGlzLnNhbmRib3hJZCwgdGltZW91dE1zLCBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgdGhpcy5jb25uZWN0aW9uQ29uZmlnKSwgb3B0cykpO1xuICB9XG4gIC8qKlxuICAgKiBLaWxsIHRoZSBzYW5kYm94LlxuICAgKlxuICAgKiBAcGFyYW0gb3B0cyBjb25uZWN0aW9uIG9wdGlvbnMuXG4gICAqL1xuICBhc3luYyBraWxsKG9wdHMpIHtcbiAgICBpZiAodGhpcy5jb25uZWN0aW9uQ29uZmlnLmRlYnVnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGF3YWl0IFNhbmRib3hBcGkua2lsbCh0aGlzLnNhbmRib3hJZCwgX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIHRoaXMuY29ubmVjdGlvbkNvbmZpZyksIG9wdHMpKTtcbiAgfVxuICAvKipcbiAgICogQGJldGEgVGhpcyBmZWF0dXJlIGlzIGluIGJldGEgYW5kIG1heSBjaGFuZ2UgaW4gdGhlIGZ1dHVyZS5cbiAgICpcbiAgICogUGF1c2UgYSBzYW5kYm94IGJ5IGl0cyBJRC5cbiAgICpcbiAgICogQHBhcmFtIG9wdHMgY29ubmVjdGlvbiBvcHRpb25zLlxuICAgKlxuICAgKiBAcmV0dXJucyBzYW5kYm94IElEIHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVzdW1lIHRoZSBzYW5kYm94LlxuICAgKi9cbiAgYXN5bmMgYmV0YVBhdXNlKG9wdHMpIHtcbiAgICByZXR1cm4gYXdhaXQgU2FuZGJveEFwaS5iZXRhUGF1c2UodGhpcy5zYW5kYm94SWQsIG9wdHMpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIFVSTCB0byB1cGxvYWQgYSBmaWxlIHRvIHRoZSBzYW5kYm94LlxuICAgKlxuICAgKiBZb3UgaGF2ZSB0byBzZW5kIGEgUE9TVCByZXF1ZXN0IHRvIHRoaXMgVVJMIHdpdGggdGhlIGZpbGUgYXMgbXVsdGlwYXJ0L2Zvcm0tZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHBhdGggcGF0aCB0byB0aGUgZmlsZSBpbiB0aGUgc2FuZGJveC5cbiAgICpcbiAgICogQHBhcmFtIG9wdHMgZG93bmxvYWQgdXJsIG9wdGlvbnMuXG4gICAqXG4gICAqIEByZXR1cm5zIFVSTCBmb3IgdXBsb2FkaW5nIGZpbGUuXG4gICAqL1xuICBhc3luYyB1cGxvYWRVcmwocGF0aDIsIG9wdHMpIHtcbiAgICB2YXIgX2EzO1xuICAgIG9wdHMgPSBvcHRzICE9IG51bGwgPyBvcHRzIDoge307XG4gICAgY29uc3QgdXNlU2lnbmF0dXJlID0gISF0aGlzLmVudmRBY2Nlc3NUb2tlbjtcbiAgICBpZiAoIXVzZVNpZ25hdHVyZSAmJiBvcHRzLnVzZVNpZ25hdHVyZUV4cGlyYXRpb24gIT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiU2lnbmF0dXJlIGV4cGlyYXRpb24gY2FuIGJlIHVzZWQgb25seSB3aGVuIHNhbmRib3ggaXMgY3JlYXRlZCBhcyBzZWN1cmVkLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCB1c2VybmFtZSA9IChfYTMgPSBvcHRzLnVzZXIpICE9IG51bGwgPyBfYTMgOiBkZWZhdWx0VXNlcm5hbWU7XG4gICAgY29uc3QgZmlsZVBhdGggPSBwYXRoMiAhPSBudWxsID8gcGF0aDIgOiBcIlwiO1xuICAgIGNvbnN0IGZpbGVVcmwgPSB0aGlzLmZpbGVVcmwoZmlsZVBhdGgsIHVzZXJuYW1lKTtcbiAgICBpZiAodXNlU2lnbmF0dXJlKSB7XG4gICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGZpbGVVcmwpO1xuICAgICAgY29uc3Qgc2lnID0gYXdhaXQgZ2V0U2lnbmF0dXJlKHtcbiAgICAgICAgcGF0aDogZmlsZVBhdGgsXG4gICAgICAgIG9wZXJhdGlvbjogXCJ3cml0ZVwiLFxuICAgICAgICB1c2VyOiB1c2VybmFtZSxcbiAgICAgICAgZXhwaXJhdGlvbkluU2Vjb25kczogb3B0cy51c2VTaWduYXR1cmVFeHBpcmF0aW9uLFxuICAgICAgICBlbnZkQWNjZXNzVG9rZW46IHRoaXMuZW52ZEFjY2Vzc1Rva2VuXG4gICAgICB9KTtcbiAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KFwic2lnbmF0dXJlXCIsIHNpZy5zaWduYXR1cmUpO1xuICAgICAgaWYgKHNpZy5leHBpcmF0aW9uKSB7XG4gICAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KFwic2lnbmF0dXJlX2V4cGlyYXRpb25cIiwgc2lnLmV4cGlyYXRpb24udG9TdHJpbmcoKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdXJsLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHJldHVybiBmaWxlVXJsO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIFVSTCB0byBkb3dubG9hZCBhIGZpbGUgZnJvbSB0aGUgc2FuZGJveC5cbiAgICpcbiAgICogQHBhcmFtIHBhdGggcGF0aCB0byB0aGUgZmlsZSBpbiB0aGUgc2FuZGJveC5cbiAgICpcbiAgICogQHBhcmFtIG9wdHMgZG93bmxvYWQgdXJsIG9wdGlvbnMuXG4gICAqXG4gICAqIEByZXR1cm5zIFVSTCBmb3IgZG93bmxvYWRpbmcgZmlsZS5cbiAgICovXG4gIGFzeW5jIGRvd25sb2FkVXJsKHBhdGgyLCBvcHRzKSB7XG4gICAgdmFyIF9hMztcbiAgICBvcHRzID0gb3B0cyAhPSBudWxsID8gb3B0cyA6IHt9O1xuICAgIGNvbnN0IHVzZVNpZ25hdHVyZSA9ICEhdGhpcy5lbnZkQWNjZXNzVG9rZW47XG4gICAgaWYgKCF1c2VTaWduYXR1cmUgJiYgb3B0cy51c2VTaWduYXR1cmVFeHBpcmF0aW9uICE9IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIlNpZ25hdHVyZSBleHBpcmF0aW9uIGNhbiBiZSB1c2VkIG9ubHkgd2hlbiBzYW5kYm94IGlzIGNyZWF0ZWQgYXMgc2VjdXJlZC5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgdXNlcm5hbWUgPSAoX2EzID0gb3B0cy51c2VyKSAhPSBudWxsID8gX2EzIDogZGVmYXVsdFVzZXJuYW1lO1xuICAgIGNvbnN0IGZpbGVVcmwgPSB0aGlzLmZpbGVVcmwocGF0aDIsIHVzZXJuYW1lKTtcbiAgICBpZiAodXNlU2lnbmF0dXJlKSB7XG4gICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGZpbGVVcmwpO1xuICAgICAgY29uc3Qgc2lnID0gYXdhaXQgZ2V0U2lnbmF0dXJlKHtcbiAgICAgICAgcGF0aDogcGF0aDIsXG4gICAgICAgIG9wZXJhdGlvbjogXCJyZWFkXCIsXG4gICAgICAgIHVzZXI6IHVzZXJuYW1lLFxuICAgICAgICBleHBpcmF0aW9uSW5TZWNvbmRzOiBvcHRzLnVzZVNpZ25hdHVyZUV4cGlyYXRpb24sXG4gICAgICAgIGVudmRBY2Nlc3NUb2tlbjogdGhpcy5lbnZkQWNjZXNzVG9rZW5cbiAgICAgIH0pO1xuICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoXCJzaWduYXR1cmVcIiwgc2lnLnNpZ25hdHVyZSk7XG4gICAgICBpZiAoc2lnLmV4cGlyYXRpb24pIHtcbiAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoXCJzaWduYXR1cmVfZXhwaXJhdGlvblwiLCBzaWcuZXhwaXJhdGlvbi50b1N0cmluZygpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1cmwudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpbGVVcmw7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBzYW5kYm94IGluZm9ybWF0aW9uIGxpa2Ugc2FuZGJveCBJRCwgdGVtcGxhdGUsIG1ldGFkYXRhLCBzdGFydGVkIGF0L2VuZCBhdCBkYXRlLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0cyBjb25uZWN0aW9uIG9wdGlvbnMuXG4gICAqXG4gICAqIEByZXR1cm5zIGluZm9ybWF0aW9uIGFib3V0IHRoZSBzYW5kYm94XG4gICAqL1xuICBhc3luYyBnZXRJbmZvKG9wdHMpIHtcbiAgICByZXR1cm4gYXdhaXQgU2FuZGJveEFwaS5nZXRJbmZvKHRoaXMuc2FuZGJveElkLCBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgdGhpcy5jb25uZWN0aW9uQ29uZmlnKSwgb3B0cykpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIG1ldHJpY3Mgb2YgdGhlIHNhbmRib3guXG4gICAqXG4gICAqIEBwYXJhbSBvcHRzIGNvbm5lY3Rpb24gb3B0aW9ucy5cbiAgICpcbiAgICogQHJldHVybnMgIExpc3Qgb2Ygc2FuZGJveCBtZXRyaWNzIGNvbnRhaW5pbmcgQ1BVLCBtZW1vcnkgYW5kIGRpc2sgdXNhZ2UgaW5mb3JtYXRpb24uXG4gICAqL1xuICBhc3luYyBnZXRNZXRyaWNzKG9wdHMpIHtcbiAgICB2YXIgX2EzLCBfYjtcbiAgICBpZiAodGhpcy5lbnZkQXBpLnZlcnNpb24pIHtcbiAgICAgIGlmIChjb21wYXJlVmVyc2lvbnMzKHRoaXMuZW52ZEFwaS52ZXJzaW9uLCBcIjAuMS41XCIpIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgU2FuZGJveEVycm9yKFxuICAgICAgICAgIFwiWW91IG5lZWQgdG8gdXBkYXRlIHRoZSB0ZW1wbGF0ZSB0byB1c2UgdGhlIG5ldyBTREsuIFlvdSBjYW4gZG8gdGhpcyBieSBydW5uaW5nIGBlMmIgdGVtcGxhdGUgYnVpbGRgIGluIHRoZSBkaXJlY3Rvcnkgd2l0aCB0aGUgdGVtcGxhdGUuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb21wYXJlVmVyc2lvbnMzKHRoaXMuZW52ZEFwaS52ZXJzaW9uLCBcIjAuMi40XCIpIDwgMCkge1xuICAgICAgICAoX2IgPSAoX2EzID0gdGhpcy5jb25uZWN0aW9uQ29uZmlnLmxvZ2dlcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy53YXJuKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChcbiAgICAgICAgICBfYTMsXG4gICAgICAgICAgXCJEaXNrIG1ldHJpY3MgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyB2ZXJzaW9uIG9mIHRoZSBzYW5kYm94LCBwbGVhc2UgcmVidWlsZCB0aGUgdGVtcGxhdGUgdG8gZ2V0IGRpc2sgbWV0cmljcy5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgU2FuZGJveEFwaS5nZXRNZXRyaWNzKHRoaXMuc2FuZGJveElkLCBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgdGhpcy5jb25uZWN0aW9uQ29uZmlnKSwgb3B0cykpO1xuICB9XG4gIGZpbGVVcmwocGF0aDIsIHVzZXJuYW1lKSB7XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChcIi9maWxlc1wiLCB0aGlzLmVudmRBcGlVcmwpO1xuICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KFwidXNlcm5hbWVcIiwgdXNlcm5hbWUgIT0gbnVsbCA/IHVzZXJuYW1lIDogZGVmYXVsdFVzZXJuYW1lKTtcbiAgICBpZiAocGF0aDIpIHtcbiAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KFwicGF0aFwiLCBwYXRoMik7XG4gICAgfVxuICAgIHJldHVybiB1cmwudG9TdHJpbmcoKTtcbiAgfVxufTtcblNhbmRib3guZGVmYXVsdFRlbXBsYXRlID0gXCJiYXNlXCI7XG5TYW5kYm94LmRlZmF1bHRTYW5kYm94VGltZW91dE1zID0gREVGQVVMVF9TQU5EQk9YX1RJTUVPVVRfTVM7XG5cbi8vIHNyYy90ZW1wbGF0ZS9lcnJvcnMudHNcbnZhciBCdWlsZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSBcIkJ1aWxkRXJyb3JcIjtcbiAgfVxufTtcbnZhciBGaWxlVXBsb2FkRXJyb3IgPSBjbGFzcyBleHRlbmRzIEJ1aWxkRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gXCJGaWxlVXBsb2FkRXJyb3JcIjtcbiAgfVxufTtcblxuLy8gc3JjL3RlbXBsYXRlL3R5cGVzLnRzXG52YXIgTG9nRW50cnkgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHRpbWVzdGFtcCwgbGV2ZWwsIG1lc3NhZ2UpIHtcbiAgICB0aGlzLnRpbWVzdGFtcCA9IHRpbWVzdGFtcDtcbiAgICB0aGlzLmxldmVsID0gbGV2ZWw7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gYFske3RoaXMudGltZXN0YW1wLnRvSVNPU3RyaW5nKCl9XSBbJHt0aGlzLmxldmVsfV0gJHtzdHJpcEFuc2koXG4gICAgICB0aGlzLm1lc3NhZ2VcbiAgICApfWA7XG4gIH1cbn07XG5cbi8vIHNyYy90ZW1wbGF0ZS91dGlscy50c1xuaW1wb3J0IGNyeXB0bzIgZnJvbSBcIm5vZGU6Y3J5cHRvXCI7XG5pbXBvcnQgZnMgZnJvbSBcIm5vZGU6ZnNcIjtcbmltcG9ydCBwYXRoIGZyb20gXCJub2RlOnBhdGhcIjtcbmZ1bmN0aW9uIHJlYWREb2NrZXJpZ25vcmUoY29udGV4dFBhdGgpIHtcbiAgY29uc3QgZG9ja2VyaWdub3JlUGF0aCA9IHBhdGguam9pbihjb250ZXh0UGF0aCwgXCIuZG9ja2VyaWdub3JlXCIpO1xuICBpZiAoIWZzLmV4aXN0c1N5bmMoZG9ja2VyaWdub3JlUGF0aCkpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgY29uc3QgY29udGVudCA9IGZzLnJlYWRGaWxlU3luYyhkb2NrZXJpZ25vcmVQYXRoLCBcInV0Zi04XCIpO1xuICByZXR1cm4gY29udGVudC5zcGxpdChcIlxcblwiKS5tYXAoKGxpbmUpID0+IGxpbmUudHJpbSgpKS5maWx0ZXIoKGxpbmUpID0+IGxpbmUgJiYgIWxpbmUuc3RhcnRzV2l0aChcIiNcIikpO1xufVxuYXN5bmMgZnVuY3Rpb24gY2FsY3VsYXRlRmlsZXNIYXNoKHNyYywgZGVzdCwgY29udGV4dFBhdGgsIGlnbm9yZVBhdHRlcm5zKSB7XG4gIGNvbnN0IHsgZ2xvYlN5bmMgfSA9IGF3YWl0IGR5bmFtaWNHbG9iKCk7XG4gIGNvbnN0IHNyY1BhdGggPSBwYXRoLmpvaW4oY29udGV4dFBhdGgsIHNyYyk7XG4gIGNvbnN0IGhhc2ggPSBjcnlwdG8yLmNyZWF0ZUhhc2goXCJzaGEyNTZcIik7XG4gIGNvbnN0IGNvbnRlbnQgPSBgQ09QWSAke3NyY30gJHtkZXN0fWA7XG4gIGhhc2gudXBkYXRlKGNvbnRlbnQpO1xuICBjb25zdCBmaWxlcyA9IGdsb2JTeW5jKHNyY1BhdGgsIHtcbiAgICBpZ25vcmU6IGlnbm9yZVBhdHRlcm5zXG4gIH0pO1xuICBpZiAoZmlsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBObyBmaWxlcyBmb3VuZCBpbiAke3NyY1BhdGh9YCk7XG4gIH1cbiAgZm9yIChjb25zdCBmaWxlIG9mIGZpbGVzKSB7XG4gICAgY29uc3QgY29udGVudDIgPSBmcy5yZWFkRmlsZVN5bmMoZmlsZSk7XG4gICAgaGFzaC51cGRhdGUobmV3IFVpbnQ4QXJyYXkoY29udGVudDIpKTtcbiAgfVxuICByZXR1cm4gaGFzaC5kaWdlc3QoXCJoZXhcIik7XG59XG5mdW5jdGlvbiBnZXRDYWxsZXJEaXJlY3RvcnkoKSB7XG4gIGNvbnN0IHN0YWNrVHJhY2UgPSBuZXcgRXJyb3IoKS5zdGFjaztcbiAgaWYgKCFzdGFja1RyYWNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGxpbmVzID0gc3RhY2tUcmFjZS5zcGxpdChcIlxcblwiKTtcbiAgY29uc3QgY2FsbGVyID0gbGluZXNbNF07XG4gIGNvbnN0IG1hdGNoID0gY2FsbGVyLm1hdGNoKC9hdCAoW146XSspOlxcZCs6XFxkKy8pO1xuICBpZiAobWF0Y2gpIHtcbiAgICBjb25zdCBmaWxlUGF0aCA9IG1hdGNoWzFdO1xuICAgIHJldHVybiBwYXRoLmRpcm5hbWUoZmlsZVBhdGgpO1xuICB9XG4gIHJldHVybjtcbn1cbmZ1bmN0aW9uIHBhZE9jdGFsKG1vZGUpIHtcbiAgcmV0dXJuIG1vZGUudG9TdHJpbmcoOCkucGFkU3RhcnQoNCwgXCIwXCIpO1xufVxuYXN5bmMgZnVuY3Rpb24gdGFyRmlsZVN0cmVhbShmaWxlTmFtZSwgZmlsZUNvbnRleHRQYXRoKSB7XG4gIGNvbnN0IHsgZ2xvYlN5bmMgfSA9IGF3YWl0IGR5bmFtaWNHbG9iKCk7XG4gIGNvbnN0IHsgY3JlYXRlIH0gPSBhd2FpdCBkeW5hbWljVGFyKCk7XG4gIGNvbnN0IGZpbGVzID0gZ2xvYlN5bmMoZmlsZU5hbWUsIHsgY3dkOiBmaWxlQ29udGV4dFBhdGgsIG5vZGlyOiBmYWxzZSB9KTtcbiAgcmV0dXJuIGNyZWF0ZShcbiAgICB7XG4gICAgICBnemlwOiB0cnVlLFxuICAgICAgY3dkOiBmaWxlQ29udGV4dFBhdGhcbiAgICB9LFxuICAgIGZpbGVzXG4gICk7XG59XG5hc3luYyBmdW5jdGlvbiB0YXJGaWxlU3RyZWFtVXBsb2FkKGZpbGVOYW1lLCBmaWxlQ29udGV4dFBhdGgpIHtcbiAgY29uc3Qgc2l6ZUNhbGN1bGF0aW9uU3RyZWFtID0gYXdhaXQgdGFyRmlsZVN0cmVhbShmaWxlTmFtZSwgZmlsZUNvbnRleHRQYXRoKTtcbiAgbGV0IGNvbnRlbnRMZW5ndGggPSAwO1xuICB0cnkge1xuICAgIGZvciAodmFyIGl0ZXIgPSBfX2ZvckF3YWl0KHNpemVDYWxjdWxhdGlvblN0cmVhbSksIG1vcmUsIHRlbXAsIGVycm9yOyBtb3JlID0gISh0ZW1wID0gYXdhaXQgaXRlci5uZXh0KCkpLmRvbmU7IG1vcmUgPSBmYWxzZSkge1xuICAgICAgY29uc3QgY2h1bmsgPSB0ZW1wLnZhbHVlO1xuICAgICAgY29udGVudExlbmd0aCArPSBjaHVuay5sZW5ndGg7XG4gICAgfVxuICB9IGNhdGNoICh0ZW1wKSB7XG4gICAgZXJyb3IgPSBbdGVtcF07XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIG1vcmUgJiYgKHRlbXAgPSBpdGVyLnJldHVybikgJiYgYXdhaXQgdGVtcC5jYWxsKGl0ZXIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoZXJyb3IpXG4gICAgICAgIHRocm93IGVycm9yWzBdO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIGNvbnRlbnRMZW5ndGgsXG4gICAgdXBsb2FkU3RyZWFtOiBhd2FpdCB0YXJGaWxlU3RyZWFtKGZpbGVOYW1lLCBmaWxlQ29udGV4dFBhdGgpXG4gIH07XG59XG5cbi8vIHNyYy90ZW1wbGF0ZS9idWlsZEFwaS50c1xuYXN5bmMgZnVuY3Rpb24gcmVxdWVzdEJ1aWxkKGNsaWVudCwgeyBhbGlhcywgY3B1Q291bnQsIG1lbW9yeU1CIH0pIHtcbiAgY29uc3QgcmVxdWVzdEJ1aWxkUmVzID0gYXdhaXQgY2xpZW50LmFwaS5QT1NUKFwiL3YyL3RlbXBsYXRlc1wiLCB7XG4gICAgYm9keToge1xuICAgICAgYWxpYXMsXG4gICAgICBjcHVDb3VudCxcbiAgICAgIG1lbW9yeU1CXG4gICAgfVxuICB9KTtcbiAgY29uc3QgZXJyb3IgPSBoYW5kbGVBcGlFcnJvcihyZXF1ZXN0QnVpbGRSZXMsIEJ1aWxkRXJyb3IpO1xuICBpZiAoZXJyb3IpIHtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuICBpZiAoIXJlcXVlc3RCdWlsZFJlcy5kYXRhKSB7XG4gICAgdGhyb3cgbmV3IEJ1aWxkRXJyb3IoXCJGYWlsZWQgdG8gcmVxdWVzdCBidWlsZFwiKTtcbiAgfVxuICByZXR1cm4gcmVxdWVzdEJ1aWxkUmVzLmRhdGE7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRGaWxlVXBsb2FkTGluayhjbGllbnQsIHsgdGVtcGxhdGVJRCwgZmlsZXNIYXNoIH0pIHtcbiAgY29uc3QgZmlsZVVwbG9hZExpbmtSZXMgPSBhd2FpdCBjbGllbnQuYXBpLkdFVChcbiAgICBcIi90ZW1wbGF0ZXMve3RlbXBsYXRlSUR9L2ZpbGVzL3toYXNofVwiLFxuICAgIHtcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgdGVtcGxhdGVJRCxcbiAgICAgICAgICBoYXNoOiBmaWxlc0hhc2hcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgKTtcbiAgY29uc3QgZXJyb3IgPSBoYW5kbGVBcGlFcnJvcihmaWxlVXBsb2FkTGlua1JlcywgRmlsZVVwbG9hZEVycm9yKTtcbiAgaWYgKGVycm9yKSB7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbiAgaWYgKCFmaWxlVXBsb2FkTGlua1Jlcy5kYXRhKSB7XG4gICAgdGhyb3cgbmV3IEZpbGVVcGxvYWRFcnJvcihcIkZhaWxlZCB0byBnZXQgZmlsZSB1cGxvYWQgbGlua1wiKTtcbiAgfVxuICByZXR1cm4gZmlsZVVwbG9hZExpbmtSZXMuZGF0YTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHVwbG9hZEZpbGUob3B0aW9ucykge1xuICBjb25zdCB7IGZpbGVOYW1lLCB1cmwsIGZpbGVDb250ZXh0UGF0aCB9ID0gb3B0aW9ucztcbiAgY29uc3QgeyBjb250ZW50TGVuZ3RoLCB1cGxvYWRTdHJlYW0gfSA9IGF3YWl0IHRhckZpbGVTdHJlYW1VcGxvYWQoXG4gICAgZmlsZU5hbWUsXG4gICAgZmlsZUNvbnRleHRQYXRoXG4gICk7XG4gIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgIG1ldGhvZDogXCJQVVRcIixcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgYm9keTogdXBsb2FkU3RyZWFtLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIFwiQ29udGVudC1MZW5ndGhcIjogY29udGVudExlbmd0aC50b1N0cmluZygpXG4gICAgfSxcbiAgICBkdXBsZXg6IFwiaGFsZlwiXG4gIH0pO1xuICBpZiAoIXJlcy5vaykge1xuICAgIHRocm93IG5ldyBGaWxlVXBsb2FkRXJyb3IoXG4gICAgICBgRmFpbGVkIHRvIHVwbG9hZCBmaWxlOiAke3Jlcy5zdGF0dXNUZXh0fSAke3Jlcy5zdGF0dXN9YFxuICAgICk7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHRyaWdnZXJCdWlsZChjbGllbnQsIHsgdGVtcGxhdGVJRCwgYnVpbGRJRCwgdGVtcGxhdGUgfSkge1xuICBjb25zdCB0cmlnZ2VyQnVpbGRSZXMgPSBhd2FpdCBjbGllbnQuYXBpLlBPU1QoXG4gICAgXCIvdjIvdGVtcGxhdGVzL3t0ZW1wbGF0ZUlEfS9idWlsZHMve2J1aWxkSUR9XCIsXG4gICAge1xuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIHBhdGg6IHtcbiAgICAgICAgICB0ZW1wbGF0ZUlELFxuICAgICAgICAgIGJ1aWxkSURcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGJvZHk6IHRlbXBsYXRlXG4gICAgfVxuICApO1xuICBjb25zdCBlcnJvciA9IGhhbmRsZUFwaUVycm9yKHRyaWdnZXJCdWlsZFJlcywgQnVpbGRFcnJvcik7XG4gIGlmIChlcnJvcikge1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBnZXRCdWlsZFN0YXR1cyhjbGllbnQsIHsgdGVtcGxhdGVJRCwgYnVpbGRJRCwgbG9nc09mZnNldCB9KSB7XG4gIGNvbnN0IGJ1aWxkU3RhdHVzUmVzID0gYXdhaXQgY2xpZW50LmFwaS5HRVQoXG4gICAgXCIvdGVtcGxhdGVzL3t0ZW1wbGF0ZUlEfS9idWlsZHMve2J1aWxkSUR9L3N0YXR1c1wiLFxuICAgIHtcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgdGVtcGxhdGVJRCxcbiAgICAgICAgICBidWlsZElEXG4gICAgICAgIH0sXG4gICAgICAgIHF1ZXJ5OiB7XG4gICAgICAgICAgbG9nc09mZnNldFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICApO1xuICBjb25zdCBlcnJvciA9IGhhbmRsZUFwaUVycm9yKGJ1aWxkU3RhdHVzUmVzLCBCdWlsZEVycm9yKTtcbiAgaWYgKGVycm9yKSB7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbiAgaWYgKCFidWlsZFN0YXR1c1Jlcy5kYXRhKSB7XG4gICAgdGhyb3cgbmV3IEJ1aWxkRXJyb3IoXCJGYWlsZWQgdG8gZ2V0IGJ1aWxkIHN0YXR1c1wiKTtcbiAgfVxuICByZXR1cm4gYnVpbGRTdGF0dXNSZXMuZGF0YTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHdhaXRGb3JCdWlsZEZpbmlzaChjbGllbnQsIHtcbiAgdGVtcGxhdGVJRCxcbiAgYnVpbGRJRCxcbiAgb25CdWlsZExvZ3MsXG4gIGxvZ3NSZWZyZXNoRnJlcXVlbmN5XG59KSB7XG4gIHZhciBfYTMsIF9iO1xuICBsZXQgbG9nc09mZnNldCA9IDA7XG4gIGxldCBzdGF0dXMgPSBcImJ1aWxkaW5nXCI7XG4gIHdoaWxlIChzdGF0dXMgPT09IFwiYnVpbGRpbmdcIiB8fCBzdGF0dXMgPT09IFwid2FpdGluZ1wiKSB7XG4gICAgY29uc3QgYnVpbGRTdGF0dXMgPSBhd2FpdCBnZXRCdWlsZFN0YXR1cyhjbGllbnQsIHtcbiAgICAgIHRlbXBsYXRlSUQsXG4gICAgICBidWlsZElELFxuICAgICAgbG9nc09mZnNldFxuICAgIH0pO1xuICAgIGxvZ3NPZmZzZXQgKz0gYnVpbGRTdGF0dXMubG9nRW50cmllcy5sZW5ndGg7XG4gICAgYnVpbGRTdGF0dXMubG9nRW50cmllcy5mb3JFYWNoKFxuICAgICAgKGxvZ0VudHJ5KSA9PiBvbkJ1aWxkTG9ncyA9PSBudWxsID8gdm9pZCAwIDogb25CdWlsZExvZ3MoXG4gICAgICAgIG5ldyBMb2dFbnRyeShcbiAgICAgICAgICBuZXcgRGF0ZShsb2dFbnRyeS50aW1lc3RhbXApLFxuICAgICAgICAgIGxvZ0VudHJ5LmxldmVsLFxuICAgICAgICAgIHN0cmlwQW5zaShsb2dFbnRyeS5tZXNzYWdlKVxuICAgICAgICApXG4gICAgICApXG4gICAgKTtcbiAgICBzdGF0dXMgPSBidWlsZFN0YXR1cy5zdGF0dXM7XG4gICAgc3dpdGNoIChzdGF0dXMpIHtcbiAgICAgIGNhc2UgXCJyZWFkeVwiOiB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJ3YWl0aW5nXCI6IHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiZXJyb3JcIjoge1xuICAgICAgICB0aHJvdyBuZXcgQnVpbGRFcnJvcigoX2IgPSAoX2EzID0gYnVpbGRTdGF0dXMgPT0gbnVsbCA/IHZvaWQgMCA6IGJ1aWxkU3RhdHVzLnJlYXNvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5tZXNzYWdlKSAhPSBudWxsID8gX2IgOiBcIlVua25vd24gZXJyb3JcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGxvZ3NSZWZyZXNoRnJlcXVlbmN5KSk7XG4gIH1cbiAgdGhyb3cgbmV3IEJ1aWxkRXJyb3IoXCJVbmtub3duIGJ1aWxkIGVycm9yIG9jY3VycmVkLlwiKTtcbn1cblxuLy8gc3JjL3RlbXBsYXRlL2RvY2tlcmZpbGVQYXJzZXIudHNcbmltcG9ydCB7XG4gIERvY2tlcmZpbGVQYXJzZXJcbn0gZnJvbSBcImRvY2tlcmZpbGUtYXN0XCI7XG5pbXBvcnQgZnMyIGZyb20gXCJub2RlOmZzXCI7XG5mdW5jdGlvbiBwYXJzZURvY2tlcmZpbGUoZG9ja2VyZmlsZUNvbnRlbnRPclBhdGgsIHRlbXBsYXRlQnVpbGRlcikge1xuICBsZXQgZG9ja2VyZmlsZUNvbnRlbnQ7XG4gIHRyeSB7XG4gICAgaWYgKGZzMi5leGlzdHNTeW5jKGRvY2tlcmZpbGVDb250ZW50T3JQYXRoKSAmJiBmczIuc3RhdFN5bmMoZG9ja2VyZmlsZUNvbnRlbnRPclBhdGgpLmlzRmlsZSgpKSB7XG4gICAgICBkb2NrZXJmaWxlQ29udGVudCA9IGZzMi5yZWFkRmlsZVN5bmMoZG9ja2VyZmlsZUNvbnRlbnRPclBhdGgsIFwidXRmLThcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRvY2tlcmZpbGVDb250ZW50ID0gZG9ja2VyZmlsZUNvbnRlbnRPclBhdGg7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgZG9ja2VyZmlsZUNvbnRlbnQgPSBkb2NrZXJmaWxlQ29udGVudE9yUGF0aDtcbiAgfVxuICBjb25zdCBkb2NrZXJmaWxlID0gRG9ja2VyZmlsZVBhcnNlci5wYXJzZShkb2NrZXJmaWxlQ29udGVudCk7XG4gIGNvbnN0IGluc3RydWN0aW9ucyA9IGRvY2tlcmZpbGUuZ2V0SW5zdHJ1Y3Rpb25zKCk7XG4gIGNvbnN0IGZyb21JbnN0cnVjdGlvbnMgPSBpbnN0cnVjdGlvbnMuZmlsdGVyKFxuICAgIChpbnN0cnVjdGlvbikgPT4gaW5zdHJ1Y3Rpb24uZ2V0S2V5d29yZCgpID09PSBcIkZST01cIlxuICApO1xuICBpZiAoZnJvbUluc3RydWN0aW9ucy5sZW5ndGggPiAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTXVsdGktc3RhZ2UgRG9ja2VyZmlsZXMgYXJlIG5vdCBzdXBwb3J0ZWRcIik7XG4gIH1cbiAgaWYgKGZyb21JbnN0cnVjdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRG9ja2VyZmlsZSBtdXN0IGNvbnRhaW4gYSBGUk9NIGluc3RydWN0aW9uXCIpO1xuICB9XG4gIGNvbnN0IGZyb21JbnN0cnVjdGlvbiA9IGZyb21JbnN0cnVjdGlvbnNbMF07XG4gIGNvbnN0IGFyZ3VtZW50c0RhdGEgPSBmcm9tSW5zdHJ1Y3Rpb24uZ2V0QXJndW1lbnRzKCk7XG4gIGxldCBiYXNlSW1hZ2UgPSBcImUyYmRldi9iYXNlXCI7XG4gIGlmIChhcmd1bWVudHNEYXRhICYmIGFyZ3VtZW50c0RhdGEubGVuZ3RoID4gMCkge1xuICAgIGJhc2VJbWFnZSA9IGFyZ3VtZW50c0RhdGFbMF0uZ2V0VmFsdWUoKTtcbiAgfVxuICBjb25zdCByZXN1bHRJbnN0cnVjdGlvbnMgPSBbXTtcbiAgZm9yIChjb25zdCBpbnN0cnVjdGlvbiBvZiBpbnN0cnVjdGlvbnMpIHtcbiAgICBjb25zdCBrZXl3b3JkID0gaW5zdHJ1Y3Rpb24uZ2V0S2V5d29yZCgpO1xuICAgIHN3aXRjaCAoa2V5d29yZCkge1xuICAgICAgY2FzZSBcIkZST01cIjpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiUlVOXCI6XG4gICAgICAgIGhhbmRsZVJ1bkluc3RydWN0aW9uKGluc3RydWN0aW9uLCB0ZW1wbGF0ZUJ1aWxkZXIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJDT1BZXCI6XG4gICAgICBjYXNlIFwiQUREXCI6XG4gICAgICAgIGhhbmRsZUNvcHlJbnN0cnVjdGlvbihpbnN0cnVjdGlvbiwgdGVtcGxhdGVCdWlsZGVyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiV09SS0RJUlwiOlxuICAgICAgICBoYW5kbGVXb3JrZGlySW5zdHJ1Y3Rpb24oaW5zdHJ1Y3Rpb24sIHRlbXBsYXRlQnVpbGRlcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIlVTRVJcIjpcbiAgICAgICAgaGFuZGxlVXNlckluc3RydWN0aW9uKGluc3RydWN0aW9uLCB0ZW1wbGF0ZUJ1aWxkZXIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJFTlZcIjpcbiAgICAgIGNhc2UgXCJBUkdcIjpcbiAgICAgICAgaGFuZGxlRW52SW5zdHJ1Y3Rpb24oaW5zdHJ1Y3Rpb24sIHRlbXBsYXRlQnVpbGRlcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkVYUE9TRVwiOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJWT0xVTUVcIjpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiQ01EXCI6XG4gICAgICBjYXNlIFwiRU5UUllQT0lOVFwiOlxuICAgICAgICBoYW5kbGVDbWRFbnRyeXBvaW50SW5zdHJ1Y3Rpb24oaW5zdHJ1Y3Rpb24sIHRlbXBsYXRlQnVpbGRlcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29uc29sZS53YXJuKGBVbnN1cHBvcnRlZCBpbnN0cnVjdGlvbjogJHtrZXl3b3JkfWApO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBiYXNlSW1hZ2UsXG4gICAgaW5zdHJ1Y3Rpb25zOiByZXN1bHRJbnN0cnVjdGlvbnNcbiAgfTtcbn1cbmZ1bmN0aW9uIGhhbmRsZVJ1bkluc3RydWN0aW9uKGluc3RydWN0aW9uLCB0ZW1wbGF0ZUJ1aWxkZXIpIHtcbiAgY29uc3QgYXJndW1lbnRzRGF0YSA9IGluc3RydWN0aW9uLmdldEFyZ3VtZW50cygpO1xuICBpZiAoYXJndW1lbnRzRGF0YSAmJiBhcmd1bWVudHNEYXRhLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBjb21tYW5kID0gYXJndW1lbnRzRGF0YS5tYXAoKGFyZykgPT4gYXJnLmdldFZhbHVlKCkpLmpvaW4oXCIgXCIpO1xuICAgIHRlbXBsYXRlQnVpbGRlci5ydW5DbWQoY29tbWFuZCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZUNvcHlJbnN0cnVjdGlvbihpbnN0cnVjdGlvbiwgdGVtcGxhdGVCdWlsZGVyKSB7XG4gIGNvbnN0IGFyZ3VtZW50c0RhdGEgPSBpbnN0cnVjdGlvbi5nZXRBcmd1bWVudHMoKTtcbiAgaWYgKGFyZ3VtZW50c0RhdGEgJiYgYXJndW1lbnRzRGF0YS5sZW5ndGggPj0gMikge1xuICAgIGNvbnN0IHNyYyA9IGFyZ3VtZW50c0RhdGFbMF0uZ2V0VmFsdWUoKTtcbiAgICBjb25zdCBkZXN0ID0gYXJndW1lbnRzRGF0YVthcmd1bWVudHNEYXRhLmxlbmd0aCAtIDFdLmdldFZhbHVlKCk7XG4gICAgdGVtcGxhdGVCdWlsZGVyLmNvcHkoc3JjLCBkZXN0KTtcbiAgfVxufVxuZnVuY3Rpb24gaGFuZGxlV29ya2Rpckluc3RydWN0aW9uKGluc3RydWN0aW9uLCB0ZW1wbGF0ZUJ1aWxkZXIpIHtcbiAgY29uc3QgYXJndW1lbnRzRGF0YSA9IGluc3RydWN0aW9uLmdldEFyZ3VtZW50cygpO1xuICBpZiAoYXJndW1lbnRzRGF0YSAmJiBhcmd1bWVudHNEYXRhLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCB3b3JrZGlyID0gYXJndW1lbnRzRGF0YVswXS5nZXRWYWx1ZSgpO1xuICAgIHRlbXBsYXRlQnVpbGRlci5zZXRXb3JrZGlyKHdvcmtkaXIpO1xuICB9XG59XG5mdW5jdGlvbiBoYW5kbGVVc2VySW5zdHJ1Y3Rpb24oaW5zdHJ1Y3Rpb24sIHRlbXBsYXRlQnVpbGRlcikge1xuICBjb25zdCBhcmd1bWVudHNEYXRhID0gaW5zdHJ1Y3Rpb24uZ2V0QXJndW1lbnRzKCk7XG4gIGlmIChhcmd1bWVudHNEYXRhICYmIGFyZ3VtZW50c0RhdGEubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IHVzZXIgPSBhcmd1bWVudHNEYXRhWzBdLmdldFZhbHVlKCk7XG4gICAgdGVtcGxhdGVCdWlsZGVyLnNldFVzZXIodXNlcik7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZUVudkluc3RydWN0aW9uKGluc3RydWN0aW9uLCB0ZW1wbGF0ZUJ1aWxkZXIpIHtcbiAgY29uc3QgYXJndW1lbnRzRGF0YSA9IGluc3RydWN0aW9uLmdldEFyZ3VtZW50cygpO1xuICBjb25zdCBrZXl3b3JkID0gaW5zdHJ1Y3Rpb24uZ2V0S2V5d29yZCgpO1xuICBpZiAoYXJndW1lbnRzRGF0YSAmJiBhcmd1bWVudHNEYXRhLmxlbmd0aCA+PSAxKSB7XG4gICAgaWYgKGFyZ3VtZW50c0RhdGEubGVuZ3RoID09PSAyKSB7XG4gICAgICBjb25zdCBmaXJzdEFyZyA9IGFyZ3VtZW50c0RhdGFbMF0uZ2V0VmFsdWUoKTtcbiAgICAgIGNvbnN0IHNlY29uZEFyZyA9IGFyZ3VtZW50c0RhdGFbMV0uZ2V0VmFsdWUoKTtcbiAgICAgIGlmIChmaXJzdEFyZy5pbmNsdWRlcyhcIj1cIikgJiYgc2Vjb25kQXJnLmluY2x1ZGVzKFwiPVwiKSkge1xuICAgICAgICBmb3IgKGNvbnN0IGFyZyBvZiBhcmd1bWVudHNEYXRhKSB7XG4gICAgICAgICAgY29uc3QgZW52U3RyaW5nID0gYXJnLmdldFZhbHVlKCk7XG4gICAgICAgICAgY29uc3QgZXF1YWxJbmRleCA9IGVudlN0cmluZy5pbmRleE9mKFwiPVwiKTtcbiAgICAgICAgICBpZiAoZXF1YWxJbmRleCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGVudlN0cmluZy5zdWJzdHJpbmcoMCwgZXF1YWxJbmRleCk7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGVudlN0cmluZy5zdWJzdHJpbmcoZXF1YWxJbmRleCArIDEpO1xuICAgICAgICAgICAgdGVtcGxhdGVCdWlsZGVyLnNldEVudnMoeyBba2V5XTogdmFsdWUgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZW1wbGF0ZUJ1aWxkZXIuc2V0RW52cyh7IFtmaXJzdEFyZ106IHNlY29uZEFyZyB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50c0RhdGEubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zdCBlbnZTdHJpbmcgPSBhcmd1bWVudHNEYXRhWzBdLmdldFZhbHVlKCk7XG4gICAgICBjb25zdCBlcXVhbEluZGV4ID0gZW52U3RyaW5nLmluZGV4T2YoXCI9XCIpO1xuICAgICAgaWYgKGVxdWFsSW5kZXggPiAwKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGVudlN0cmluZy5zdWJzdHJpbmcoMCwgZXF1YWxJbmRleCk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZW52U3RyaW5nLnN1YnN0cmluZyhlcXVhbEluZGV4ICsgMSk7XG4gICAgICAgIHRlbXBsYXRlQnVpbGRlci5zZXRFbnZzKHsgW2tleV06IHZhbHVlIH0pO1xuICAgICAgfSBlbHNlIGlmIChrZXl3b3JkID09PSBcIkFSR1wiICYmIGVudlN0cmluZy50cmltKCkpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gZW52U3RyaW5nLnRyaW0oKTtcbiAgICAgICAgdGVtcGxhdGVCdWlsZGVyLnNldEVudnMoeyBba2V5XTogXCJcIiB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChjb25zdCBhcmcgb2YgYXJndW1lbnRzRGF0YSkge1xuICAgICAgICBjb25zdCBlbnZTdHJpbmcgPSBhcmcuZ2V0VmFsdWUoKTtcbiAgICAgICAgY29uc3QgZXF1YWxJbmRleCA9IGVudlN0cmluZy5pbmRleE9mKFwiPVwiKTtcbiAgICAgICAgaWYgKGVxdWFsSW5kZXggPiAwKSB7XG4gICAgICAgICAgY29uc3Qga2V5ID0gZW52U3RyaW5nLnN1YnN0cmluZygwLCBlcXVhbEluZGV4KTtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IGVudlN0cmluZy5zdWJzdHJpbmcoZXF1YWxJbmRleCArIDEpO1xuICAgICAgICAgIHRlbXBsYXRlQnVpbGRlci5zZXRFbnZzKHsgW2tleV06IHZhbHVlIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGtleXdvcmQgPT09IFwiQVJHXCIpIHtcbiAgICAgICAgICBjb25zdCBrZXkgPSBlbnZTdHJpbmc7XG4gICAgICAgICAgdGVtcGxhdGVCdWlsZGVyLnNldEVudnMoeyBba2V5XTogXCJcIiB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gaGFuZGxlQ21kRW50cnlwb2ludEluc3RydWN0aW9uKGluc3RydWN0aW9uLCB0ZW1wbGF0ZUJ1aWxkZXIpIHtcbiAgY29uc3QgYXJndW1lbnRzRGF0YSA9IGluc3RydWN0aW9uLmdldEFyZ3VtZW50cygpO1xuICBpZiAoYXJndW1lbnRzRGF0YSAmJiBhcmd1bWVudHNEYXRhLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBjb21tYW5kID0gYXJndW1lbnRzRGF0YS5tYXAoKGFyZykgPT4gYXJnLmdldFZhbHVlKCkpLmpvaW4oXCIgXCIpO1xuICAgIGNvbnN0IHdhaXRGb3JUaW1lb3V0MiA9ICh0aW1lb3V0KSA9PiB7XG4gICAgICBjb25zdCBzZWNvbmRzID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcih0aW1lb3V0IC8gMWUzKSk7XG4gICAgICByZXR1cm4gYHNsZWVwICR7c2Vjb25kc31gO1xuICAgIH07XG4gICAgdGVtcGxhdGVCdWlsZGVyLnNldFN0YXJ0Q21kKGNvbW1hbmQsIHdhaXRGb3JUaW1lb3V0MigyZTQpKTtcbiAgfVxufVxuXG4vLyBzcmMvdGVtcGxhdGUvcmVhZHljbWQudHNcbnZhciBSZWFkeUNtZCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY21kKSB7XG4gICAgdGhpcy5jbWQgPSBjbWQ7XG4gIH1cbiAgZ2V0Q21kKCkge1xuICAgIHJldHVybiB0aGlzLmNtZDtcbiAgfVxufTtcbmZ1bmN0aW9uIHdhaXRGb3JQb3J0KHBvcnQpIHtcbiAgY29uc3QgY21kID0gYHNzIC10dWxuIHwgZ3JlcCA6JHtwb3J0fWA7XG4gIHJldHVybiBuZXcgUmVhZHlDbWQoY21kKTtcbn1cbmZ1bmN0aW9uIHdhaXRGb3JVUkwodXJsLCBzdGF0dXNDb2RlID0gMjAwKSB7XG4gIGNvbnN0IGNtZCA9IGBjdXJsIC1zIC1vIC9kZXYvbnVsbCAtdyBcIiV7aHR0cF9jb2RlfVwiICR7dXJsfSB8IGdyZXAgLXEgXCIke3N0YXR1c0NvZGV9XCJgO1xuICByZXR1cm4gbmV3IFJlYWR5Q21kKGNtZCk7XG59XG5mdW5jdGlvbiB3YWl0Rm9yUHJvY2Vzcyhwcm9jZXNzTmFtZSkge1xuICBjb25zdCBjbWQgPSBgcGdyZXAgJHtwcm9jZXNzTmFtZX0gPiAvZGV2L251bGxgO1xuICByZXR1cm4gbmV3IFJlYWR5Q21kKGNtZCk7XG59XG5mdW5jdGlvbiB3YWl0Rm9yRmlsZShmaWxlbmFtZSkge1xuICBjb25zdCBjbWQgPSBgWyAtZiAke2ZpbGVuYW1lfSBdYDtcbiAgcmV0dXJuIG5ldyBSZWFkeUNtZChjbWQpO1xufVxuZnVuY3Rpb24gd2FpdEZvclRpbWVvdXQodGltZW91dCkge1xuICBjb25zdCBzZWNvbmRzID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcih0aW1lb3V0IC8gMWUzKSk7XG4gIGNvbnN0IGNtZCA9IGBzbGVlcCAke3NlY29uZHN9YDtcbiAgcmV0dXJuIG5ldyBSZWFkeUNtZChjbWQpO1xufVxuXG4vLyBzcmMvdGVtcGxhdGUvaW5kZXgudHNcbnZhciBfYTI7XG52YXIgVGVtcGxhdGVCYXNlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5kZWZhdWx0QmFzZUltYWdlID0gXCJlMmJkZXYvYmFzZVwiO1xuICAgIHRoaXMuYmFzZUltYWdlID0gdGhpcy5kZWZhdWx0QmFzZUltYWdlO1xuICAgIHRoaXMuYmFzZVRlbXBsYXRlID0gdm9pZCAwO1xuICAgIHRoaXMuc3RhcnRDbWQgPSB2b2lkIDA7XG4gICAgdGhpcy5yZWFkeUNtZCA9IHZvaWQgMDtcbiAgICAvLyBGb3JjZSB0aGUgd2hvbGUgdGVtcGxhdGUgdG8gYmUgcmVidWlsdFxuICAgIHRoaXMuZm9yY2UgPSBmYWxzZTtcbiAgICAvLyBGb3JjZSB0aGUgbmV4dCBsYXllciB0byBiZSByZWJ1aWx0XG4gICAgdGhpcy5mb3JjZU5leHRMYXllciA9IGZhbHNlO1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zID0gW107XG4gICAgdGhpcy5maWxlQ29udGV4dFBhdGggPSBydW50aW1lID09PSBcImJyb3dzZXJcIiA/IFwiLlwiIDogKF9hMiA9IGdldENhbGxlckRpcmVjdG9yeSgpKSAhPSBudWxsID8gX2EyIDogXCIuXCI7XG4gICAgdGhpcy5pZ25vcmVGaWxlUGF0aHMgPSBbXTtcbiAgICB0aGlzLmxvZ3NSZWZyZXNoRnJlcXVlbmN5ID0gMjAwO1xuICAgIHZhciBfYTMsIF9iO1xuICAgIHRoaXMuZmlsZUNvbnRleHRQYXRoID0gKF9hMyA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZmlsZUNvbnRleHRQYXRoKSAhPSBudWxsID8gX2EzIDogdGhpcy5maWxlQ29udGV4dFBhdGg7XG4gICAgdGhpcy5pZ25vcmVGaWxlUGF0aHMgPSAoX2IgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmlnbm9yZUZpbGVQYXRocykgIT0gbnVsbCA/IF9iIDogdGhpcy5pZ25vcmVGaWxlUGF0aHM7XG4gIH1cbiAgc3RhdGljIHRvSlNPTih0ZW1wbGF0ZSkge1xuICAgIHJldHVybiB0ZW1wbGF0ZS50b0pTT04oKTtcbiAgfVxuICBzdGF0aWMgdG9Eb2NrZXJmaWxlKHRlbXBsYXRlKSB7XG4gICAgcmV0dXJuIHRlbXBsYXRlLnRvRG9ja2VyZmlsZSgpO1xuICB9XG4gIHN0YXRpYyBidWlsZCh0ZW1wbGF0ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0ZW1wbGF0ZS5idWlsZChvcHRpb25zKTtcbiAgfVxuICAvLyBCdWlsdC1pbiBpbWFnZSBtaXhpbnNcbiAgZnJvbURlYmlhbkltYWdlKHZhcmlhbnQgPSBcInNsaW1cIikge1xuICAgIHJldHVybiB0aGlzLmZyb21JbWFnZShgZGViaWFuOiR7dmFyaWFudH1gKTtcbiAgfVxuICBmcm9tVWJ1bnR1SW1hZ2UodmFyaWFudCA9IFwibHRzXCIpIHtcbiAgICByZXR1cm4gdGhpcy5mcm9tSW1hZ2UoYHVidW50dToke3ZhcmlhbnR9YCk7XG4gIH1cbiAgZnJvbVB5dGhvbkltYWdlKHZlcnNpb24yID0gXCIzLjEzXCIpIHtcbiAgICByZXR1cm4gdGhpcy5mcm9tSW1hZ2UoYHB5dGhvbjoke3ZlcnNpb24yfWApO1xuICB9XG4gIGZyb21Ob2RlSW1hZ2UodmFyaWFudCA9IFwibHRzXCIpIHtcbiAgICByZXR1cm4gdGhpcy5mcm9tSW1hZ2UoYG5vZGU6JHt2YXJpYW50fWApO1xuICB9XG4gIGZyb21CYXNlSW1hZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuZnJvbUltYWdlKHRoaXMuZGVmYXVsdEJhc2VJbWFnZSk7XG4gIH1cbiAgZnJvbUltYWdlKGJhc2VJbWFnZSkge1xuICAgIHRoaXMuYmFzZUltYWdlID0gYmFzZUltYWdlO1xuICAgIHRoaXMuYmFzZVRlbXBsYXRlID0gdm9pZCAwO1xuICAgIGlmICh0aGlzLmZvcmNlTmV4dExheWVyKSB7XG4gICAgICB0aGlzLmZvcmNlID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZnJvbVRlbXBsYXRlKHRlbXBsYXRlKSB7XG4gICAgdGhpcy5iYXNlVGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICB0aGlzLmJhc2VJbWFnZSA9IHZvaWQgMDtcbiAgICBpZiAodGhpcy5mb3JjZU5leHRMYXllcikge1xuICAgICAgdGhpcy5mb3JjZSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBQYXJzZSBhIERvY2tlcmZpbGUgYW5kIGNvbnZlcnQgaXQgdG8gVGVtcGxhdGUgU0RLIGZvcm1hdFxuICAgKlxuICAgKiBAcGFyYW0gZG9ja2VyZmlsZUNvbnRlbnRPclBhdGggRWl0aGVyIHRoZSBEb2NrZXJmaWxlIGNvbnRlbnQgYXMgYSBzdHJpbmcsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvciBhIHBhdGggdG8gYSBEb2NrZXJmaWxlIGZpbGVcbiAgICogQHJldHVybnMgVGVtcGxhdGVCdWlsZGVyIGluc3RhbmNlIGZvciBtZXRob2QgY2hhaW5pbmdcbiAgICovXG4gIGZyb21Eb2NrZXJmaWxlKGRvY2tlcmZpbGVDb250ZW50T3JQYXRoKSB7XG4gICAgY29uc3QgeyBiYXNlSW1hZ2UgfSA9IHBhcnNlRG9ja2VyZmlsZShkb2NrZXJmaWxlQ29udGVudE9yUGF0aCwgdGhpcyk7XG4gICAgdGhpcy5iYXNlSW1hZ2UgPSBiYXNlSW1hZ2U7XG4gICAgdGhpcy5iYXNlVGVtcGxhdGUgPSB2b2lkIDA7XG4gICAgaWYgKHRoaXMuZm9yY2VOZXh0TGF5ZXIpIHtcbiAgICAgIHRoaXMuZm9yY2UgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBjb3B5KHNyY09ySXRlbXMsIGRlc3RPck9wdGlvbnMsIG9wdGlvbnMpIHtcbiAgICB2YXIgX2EzLCBfYjtcbiAgICBpZiAocnVudGltZSA9PT0gXCJicm93c2VyXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkJyb3dzZXIgcnVudGltZSBpcyBub3Qgc3VwcG9ydGVkIGZvciBjb3B5XCIpO1xuICAgIH1cbiAgICBjb25zdCBpdGVtcyA9IEFycmF5LmlzQXJyYXkoc3JjT3JJdGVtcykgPyBzcmNPckl0ZW1zIDogW1xuICAgICAge1xuICAgICAgICBzcmM6IHNyY09ySXRlbXMsXG4gICAgICAgIGRlc3Q6IGRlc3RPck9wdGlvbnMsXG4gICAgICAgIG1vZGU6IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMubW9kZSxcbiAgICAgICAgdXNlcjogb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy51c2VyLFxuICAgICAgICBmb3JjZVVwbG9hZDogb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5mb3JjZVVwbG9hZFxuICAgICAgfVxuICAgIF07XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICBjb25zdCBhcmdzID0gW1xuICAgICAgICBpdGVtLnNyYyxcbiAgICAgICAgaXRlbS5kZXN0LFxuICAgICAgICAoX2EzID0gaXRlbS51c2VyKSAhPSBudWxsID8gX2EzIDogXCJcIixcbiAgICAgICAgaXRlbS5tb2RlID8gcGFkT2N0YWwoaXRlbS5tb2RlKSA6IFwiXCJcbiAgICAgIF07XG4gICAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJDT1BZXCIsXG4gICAgICAgIGFyZ3MsXG4gICAgICAgIGZvcmNlOiAoX2IgPSBpdGVtLmZvcmNlVXBsb2FkKSAhPSBudWxsID8gX2IgOiB0aGlzLmZvcmNlTmV4dExheWVyLFxuICAgICAgICBmb3JjZVVwbG9hZDogaXRlbS5mb3JjZVVwbG9hZFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlbW92ZShwYXRoMiwgb3B0aW9ucykge1xuICAgIGNvbnN0IGFyZ3MgPSBbXCJybVwiLCBwYXRoMl07XG4gICAgaWYgKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMucmVjdXJzaXZlKSB7XG4gICAgICBhcmdzLnB1c2goXCItclwiKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZm9yY2UpIHtcbiAgICAgIGFyZ3MucHVzaChcIi1mXCIpO1xuICAgIH1cbiAgICB0aGlzLnJ1bkNtZChhcmdzLmpvaW4oXCIgXCIpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZW5hbWUoc3JjLCBkZXN0LCBvcHRpb25zKSB7XG4gICAgY29uc3QgYXJncyA9IFtcIm12XCIsIHNyYywgZGVzdF07XG4gICAgaWYgKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZm9yY2UpIHtcbiAgICAgIGFyZ3MucHVzaChcIi1mXCIpO1xuICAgIH1cbiAgICB0aGlzLnJ1bkNtZChhcmdzLmpvaW4oXCIgXCIpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBtYWtlRGlyKHBhdGhzMiwgb3B0aW9ucykge1xuICAgIGNvbnN0IGFyZ3MgPSBbXCJta2RpclwiLCBcIi1wXCIsIC4uLkFycmF5LmlzQXJyYXkocGF0aHMyKSA/IHBhdGhzMiA6IFtwYXRoczJdXTtcbiAgICBpZiAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5tb2RlKSB7XG4gICAgICBhcmdzLnB1c2goYC1tICR7cGFkT2N0YWwob3B0aW9ucy5tb2RlKX1gKTtcbiAgICB9XG4gICAgdGhpcy5ydW5DbWQoYXJncy5qb2luKFwiIFwiKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgbWFrZVN5bWxpbmsoc3JjLCBkZXN0KSB7XG4gICAgY29uc3QgYXJncyA9IFtcImxuXCIsIFwiLXNcIiwgc3JjLCBkZXN0XTtcbiAgICB0aGlzLnJ1bkNtZChhcmdzLmpvaW4oXCIgXCIpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBydW5DbWQoY29tbWFuZE9yQ29tbWFuZHMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBjbWRzID0gQXJyYXkuaXNBcnJheShjb21tYW5kT3JDb21tYW5kcykgPyBjb21tYW5kT3JDb21tYW5kcyA6IFtjb21tYW5kT3JDb21tYW5kc107XG4gICAgY29uc3QgYXJncyA9IFtjbWRzLmpvaW4oXCIgJiYgXCIpXTtcbiAgICBpZiAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy51c2VyKSB7XG4gICAgICBhcmdzLnB1c2gob3B0aW9ucy51c2VyKTtcbiAgICB9XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaCh7XG4gICAgICB0eXBlOiBcIlJVTlwiLFxuICAgICAgYXJncyxcbiAgICAgIGZvcmNlOiB0aGlzLmZvcmNlTmV4dExheWVyXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2V0V29ya2Rpcih3b3JrZGlyKSB7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaCh7XG4gICAgICB0eXBlOiBcIldPUktESVJcIixcbiAgICAgIGFyZ3M6IFt3b3JrZGlyXSxcbiAgICAgIGZvcmNlOiB0aGlzLmZvcmNlTmV4dExheWVyXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2V0VXNlcih1c2VyKSB7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaCh7XG4gICAgICB0eXBlOiBcIlVTRVJcIixcbiAgICAgIGFyZ3M6IFt1c2VyXSxcbiAgICAgIGZvcmNlOiB0aGlzLmZvcmNlTmV4dExheWVyXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcGlwSW5zdGFsbChwYWNrYWdlcykge1xuICAgIGNvbnN0IGFyZ3MgPSBbXCJwaXBcIiwgXCJpbnN0YWxsXCJdO1xuICAgIGNvbnN0IHBhY2thZ2VMaXN0ID0gcGFja2FnZXMgPyBBcnJheS5pc0FycmF5KHBhY2thZ2VzKSA/IHBhY2thZ2VzIDogW3BhY2thZ2VzXSA6IHZvaWQgMDtcbiAgICBpZiAocGFja2FnZUxpc3QpIHtcbiAgICAgIGFyZ3MucHVzaCguLi5wYWNrYWdlTGlzdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFyZ3MucHVzaChcIi5cIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJ1bkNtZChhcmdzKTtcbiAgfVxuICBucG1JbnN0YWxsKHBhY2thZ2VzLCBnKSB7XG4gICAgY29uc3QgYXJncyA9IFtcIm5wbVwiLCBcImluc3RhbGxcIl07XG4gICAgY29uc3QgcGFja2FnZUxpc3QgPSBwYWNrYWdlcyA/IEFycmF5LmlzQXJyYXkocGFja2FnZXMpID8gcGFja2FnZXMgOiBbcGFja2FnZXNdIDogdm9pZCAwO1xuICAgIGlmIChwYWNrYWdlTGlzdCkge1xuICAgICAgYXJncy5wdXNoKC4uLnBhY2thZ2VMaXN0KTtcbiAgICB9XG4gICAgaWYgKGcpIHtcbiAgICAgIGFyZ3MucHVzaChcIi1nXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5ydW5DbWQoYXJncyk7XG4gIH1cbiAgYXB0SW5zdGFsbChwYWNrYWdlcykge1xuICAgIGNvbnN0IHBhY2thZ2VMaXN0ID0gQXJyYXkuaXNBcnJheShwYWNrYWdlcykgPyBwYWNrYWdlcyA6IFtwYWNrYWdlc107XG4gICAgcmV0dXJuIHRoaXMucnVuQ21kKFxuICAgICAgW1xuICAgICAgICBcImFwdC1nZXQgdXBkYXRlXCIsXG4gICAgICAgIGBERUJJQU5fRlJPTlRFTkQ9bm9uaW50ZXJhY3RpdmUgREVCQ09ORl9OT1dBUk5JTkdTPXllcyBhcHQtZ2V0IGluc3RhbGwgLXkgLS1uby1pbnN0YWxsLXJlY29tbWVuZHMgJHtwYWNrYWdlTGlzdC5qb2luKFxuICAgICAgICAgIFwiIFwiXG4gICAgICAgICl9YFxuICAgICAgXSxcbiAgICAgIHsgdXNlcjogXCJyb290XCIgfVxuICAgICk7XG4gIH1cbiAgZ2l0Q2xvbmUodXJsLCBwYXRoMiwgb3B0aW9ucykge1xuICAgIGNvbnN0IGFyZ3MgPSBbXCJnaXRcIiwgXCJjbG9uZVwiLCB1cmwsIHBhdGgyXTtcbiAgICBpZiAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5icmFuY2gpIHtcbiAgICAgIGFyZ3MucHVzaChgLS1icmFuY2ggJHtvcHRpb25zLmJyYW5jaH1gKTtcbiAgICAgIGFyZ3MucHVzaChcIi0tc2luZ2xlLWJyYW5jaFwiKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZGVwdGgpIHtcbiAgICAgIGFyZ3MucHVzaChgLS1kZXB0aCAke29wdGlvbnMuZGVwdGh9YCk7XG4gICAgfVxuICAgIHRoaXMucnVuQ21kKGFyZ3Muam9pbihcIiBcIikpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHNldFN0YXJ0Q21kKHN0YXJ0Q29tbWFuZCwgcmVhZHlDb21tYW5kKSB7XG4gICAgdGhpcy5zdGFydENtZCA9IHN0YXJ0Q29tbWFuZDtcbiAgICBpZiAocmVhZHlDb21tYW5kIGluc3RhbmNlb2YgUmVhZHlDbWQpIHtcbiAgICAgIHRoaXMucmVhZHlDbWQgPSByZWFkeUNvbW1hbmQuZ2V0Q21kKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVhZHlDbWQgPSByZWFkeUNvbW1hbmQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHNldFJlYWR5Q21kKHJlYWR5Q29tbWFuZCkge1xuICAgIGlmIChyZWFkeUNvbW1hbmQgaW5zdGFuY2VvZiBSZWFkeUNtZCkge1xuICAgICAgdGhpcy5yZWFkeUNtZCA9IHJlYWR5Q29tbWFuZC5nZXRDbWQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZWFkeUNtZCA9IHJlYWR5Q29tbWFuZDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2V0RW52cyhlbnZzKSB7XG4gICAgaWYgKE9iamVjdC5rZXlzKGVudnMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goe1xuICAgICAgdHlwZTogXCJFTlZcIixcbiAgICAgIGFyZ3M6IE9iamVjdC5lbnRyaWVzKGVudnMpLmZsYXRNYXAoKFtrZXksIHZhbHVlXSkgPT4gW2tleSwgdmFsdWVdKSxcbiAgICAgIGZvcmNlOiB0aGlzLmZvcmNlTmV4dExheWVyXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2tpcENhY2hlKCkge1xuICAgIHRoaXMuZm9yY2VOZXh0TGF5ZXIgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGFzeW5jIHRvSlNPTigpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoXG4gICAgICB0aGlzLnNlcmlhbGl6ZShhd2FpdCB0aGlzLmNhbGN1bGF0ZUZpbGVzSGFzaGVzKCkpLFxuICAgICAgdm9pZCAwLFxuICAgICAgMlxuICAgICk7XG4gIH1cbiAgdG9Eb2NrZXJmaWxlKCkge1xuICAgIGlmICh0aGlzLmJhc2VUZW1wbGF0ZSAhPT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiQ2Fubm90IGNvbnZlcnQgdGVtcGxhdGUgYnVpbHQgZnJvbSBhbm90aGVyIHRlbXBsYXRlIHRvIERvY2tlcmZpbGUuIFRlbXBsYXRlcyBiYXNlZCBvbiBvdGhlciB0ZW1wbGF0ZXMgY2FuIG9ubHkgYmUgYnVpbHQgdXNpbmcgdGhlIEUyQiBBUEkuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICh0aGlzLmJhc2VJbWFnZSA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBiYXNlIGltYWdlIHNwZWNpZmllZCBmb3IgdGVtcGxhdGVcIik7XG4gICAgfVxuICAgIGxldCBkb2NrZXJmaWxlID0gYEZST00gJHt0aGlzLmJhc2VJbWFnZX1cbmA7XG4gICAgZm9yIChjb25zdCBpbnN0cnVjdGlvbiBvZiB0aGlzLmluc3RydWN0aW9ucykge1xuICAgICAgZG9ja2VyZmlsZSArPSBgJHtpbnN0cnVjdGlvbi50eXBlfSAke2luc3RydWN0aW9uLmFyZ3Muam9pbihcIiBcIil9XG5gO1xuICAgIH1cbiAgICBpZiAodGhpcy5zdGFydENtZCkge1xuICAgICAgZG9ja2VyZmlsZSArPSBgRU5UUllQT0lOVCAke3RoaXMuc3RhcnRDbWR9XG5gO1xuICAgIH1cbiAgICByZXR1cm4gZG9ja2VyZmlsZTtcbiAgfVxuICBhc3luYyBidWlsZChvcHRpb25zKSB7XG4gICAgdmFyIF9hMywgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZztcbiAgICBjb25zdCBjb25maWcgPSBuZXcgQ29ubmVjdGlvbkNvbmZpZyh7XG4gICAgICBkb21haW46IG9wdGlvbnMuZG9tYWluLFxuICAgICAgYXBpS2V5OiBvcHRpb25zLmFwaUtleVxuICAgIH0pO1xuICAgIGNvbnN0IGNsaWVudCA9IG5ldyBBcGlDbGllbnQoY29uZmlnKTtcbiAgICBpZiAob3B0aW9ucy5za2lwQ2FjaGUpIHtcbiAgICAgIHRoaXMuZm9yY2UgPSB0cnVlO1xuICAgIH1cbiAgICAoX2EzID0gb3B0aW9ucy5vbkJ1aWxkTG9ncykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5jYWxsKFxuICAgICAgb3B0aW9ucyxcbiAgICAgIG5ldyBMb2dFbnRyeShcbiAgICAgICAgLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksXG4gICAgICAgIFwiaW5mb1wiLFxuICAgICAgICBgUmVxdWVzdGluZyBidWlsZCBmb3IgdGVtcGxhdGU6ICR7b3B0aW9ucy5hbGlhc31gXG4gICAgICApXG4gICAgKTtcbiAgICBjb25zdCB7IHRlbXBsYXRlSUQsIGJ1aWxkSUQgfSA9IGF3YWl0IHJlcXVlc3RCdWlsZChjbGllbnQsIHtcbiAgICAgIGFsaWFzOiBvcHRpb25zLmFsaWFzLFxuICAgICAgY3B1Q291bnQ6IChfYiA9IG9wdGlvbnMuY3B1Q291bnQpICE9IG51bGwgPyBfYiA6IDEsXG4gICAgICBtZW1vcnlNQjogKF9jID0gb3B0aW9ucy5tZW1vcnlNQikgIT0gbnVsbCA/IF9jIDogMTAyNFxuICAgIH0pO1xuICAgIChfZCA9IG9wdGlvbnMub25CdWlsZExvZ3MpID09IG51bGwgPyB2b2lkIDAgOiBfZC5jYWxsKFxuICAgICAgb3B0aW9ucyxcbiAgICAgIG5ldyBMb2dFbnRyeShcbiAgICAgICAgLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksXG4gICAgICAgIFwiaW5mb1wiLFxuICAgICAgICBgVGVtcGxhdGUgY3JlYXRlZCB3aXRoIElEOiAke3RlbXBsYXRlSUR9LCBCdWlsZCBJRDogJHtidWlsZElEfWBcbiAgICAgIClcbiAgICApO1xuICAgIGNvbnN0IGluc3RydWN0aW9uc1dpdGhIYXNoZXMgPSBhd2FpdCB0aGlzLmNhbGN1bGF0ZUZpbGVzSGFzaGVzKCk7XG4gICAgY29uc3QgZmlsZVVwbG9hZHMgPSBpbnN0cnVjdGlvbnNXaXRoSGFzaGVzLmZpbHRlcigoaW5zdHJ1Y3Rpb24pID0+IGluc3RydWN0aW9uLnR5cGUgPT09IFwiQ09QWVwiKS5tYXAoKGluc3RydWN0aW9uKSA9PiAoe1xuICAgICAgc3JjOiBpbnN0cnVjdGlvbi5hcmdzWzBdLFxuICAgICAgZGVzdDogaW5zdHJ1Y3Rpb24uYXJnc1sxXSxcbiAgICAgIGZpbGVzSGFzaDogaW5zdHJ1Y3Rpb24uZmlsZXNIYXNoLFxuICAgICAgZm9yY2VVcGxvYWQ6IGluc3RydWN0aW9uLmZvcmNlVXBsb2FkXG4gICAgfSkpO1xuICAgIGNvbnN0IHVwbG9hZFByb21pc2VzID0gZmlsZVVwbG9hZHMubWFwKGFzeW5jIChmaWxlKSA9PiB7XG4gICAgICB2YXIgX2E0LCBfYjI7XG4gICAgICBjb25zdCB7IHByZXNlbnQsIHVybCB9ID0gYXdhaXQgZ2V0RmlsZVVwbG9hZExpbmsoY2xpZW50LCB7XG4gICAgICAgIHRlbXBsYXRlSUQsXG4gICAgICAgIGZpbGVzSGFzaDogZmlsZS5maWxlc0hhc2hcbiAgICAgIH0pO1xuICAgICAgaWYgKGZpbGUuZm9yY2VVcGxvYWQgJiYgdXJsICE9IG51bGwgfHwgcHJlc2VudCA9PT0gZmFsc2UgJiYgdXJsICE9IG51bGwpIHtcbiAgICAgICAgYXdhaXQgdXBsb2FkRmlsZSh7XG4gICAgICAgICAgZmlsZU5hbWU6IGZpbGUuc3JjLFxuICAgICAgICAgIGZpbGVDb250ZXh0UGF0aDogdGhpcy5maWxlQ29udGV4dFBhdGgsXG4gICAgICAgICAgdXJsXG4gICAgICAgIH0pO1xuICAgICAgICAoX2E0ID0gb3B0aW9ucy5vbkJ1aWxkTG9ncykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hNC5jYWxsKFxuICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgbmV3IExvZ0VudHJ5KC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLCBcImluZm9cIiwgYFVwbG9hZGVkICcke2ZpbGUuc3JjfSdgKVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKF9iMiA9IG9wdGlvbnMub25CdWlsZExvZ3MpID09IG51bGwgPyB2b2lkIDAgOiBfYjIuY2FsbChcbiAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgIG5ldyBMb2dFbnRyeShcbiAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgXCJpbmZvXCIsXG4gICAgICAgICAgICBgU2tpcHBpbmcgdXBsb2FkIG9mICcke2ZpbGUuc3JjfScsIGFscmVhZHkgY2FjaGVkYFxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBhd2FpdCBQcm9taXNlLmFsbCh1cGxvYWRQcm9taXNlcyk7XG4gICAgKF9lID0gb3B0aW9ucy5vbkJ1aWxkTG9ncykgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLmNhbGwoXG4gICAgICBvcHRpb25zLFxuICAgICAgbmV3IExvZ0VudHJ5KC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLCBcImluZm9cIiwgXCJBbGwgZmlsZSB1cGxvYWRzIGNvbXBsZXRlZFwiKVxuICAgICk7XG4gICAgKF9mID0gb3B0aW9ucy5vbkJ1aWxkTG9ncykgPT0gbnVsbCA/IHZvaWQgMCA6IF9mLmNhbGwoXG4gICAgICBvcHRpb25zLFxuICAgICAgbmV3IExvZ0VudHJ5KC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLCBcImluZm9cIiwgXCJTdGFydGluZyBidWlsZGluZy4uLlwiKVxuICAgICk7XG4gICAgYXdhaXQgdHJpZ2dlckJ1aWxkKGNsaWVudCwge1xuICAgICAgdGVtcGxhdGVJRCxcbiAgICAgIGJ1aWxkSUQsXG4gICAgICB0ZW1wbGF0ZTogdGhpcy5zZXJpYWxpemUoaW5zdHJ1Y3Rpb25zV2l0aEhhc2hlcylcbiAgICB9KTtcbiAgICAoX2cgPSBvcHRpb25zLm9uQnVpbGRMb2dzKSA9PSBudWxsID8gdm9pZCAwIDogX2cuY2FsbChcbiAgICAgIG9wdGlvbnMsXG4gICAgICBuZXcgTG9nRW50cnkoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksIFwiaW5mb1wiLCBcIldhaXRpbmcgZm9yIGxvZ3MuLi5cIilcbiAgICApO1xuICAgIGF3YWl0IHdhaXRGb3JCdWlsZEZpbmlzaChjbGllbnQsIHtcbiAgICAgIHRlbXBsYXRlSUQsXG4gICAgICBidWlsZElELFxuICAgICAgb25CdWlsZExvZ3M6IG9wdGlvbnMub25CdWlsZExvZ3MsXG4gICAgICBsb2dzUmVmcmVzaEZyZXF1ZW5jeTogdGhpcy5sb2dzUmVmcmVzaEZyZXF1ZW5jeVxuICAgIH0pO1xuICB9XG4gIC8vIFdlIG1pZ2h0IG5vIGxvbmdlciBuZWVkIHRoaXMgYXMgd2UgbW92ZSB0aGUgbG9naWMgc2VydmVyLXNpZGVcbiAgYXN5bmMgY2FsY3VsYXRlRmlsZXNIYXNoZXMoKSB7XG4gICAgY29uc3Qgc3RlcHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGluc3RydWN0aW9uIG9mIHRoaXMuaW5zdHJ1Y3Rpb25zKSB7XG4gICAgICBpZiAoaW5zdHJ1Y3Rpb24udHlwZSA9PT0gXCJDT1BZXCIpIHtcbiAgICAgICAgaW5zdHJ1Y3Rpb24uZmlsZXNIYXNoID0gYXdhaXQgY2FsY3VsYXRlRmlsZXNIYXNoKFxuICAgICAgICAgIGluc3RydWN0aW9uLmFyZ3NbMF0sXG4gICAgICAgICAgaW5zdHJ1Y3Rpb24uYXJnc1sxXSxcbiAgICAgICAgICB0aGlzLmZpbGVDb250ZXh0UGF0aCxcbiAgICAgICAgICBbXG4gICAgICAgICAgICAuLi50aGlzLmlnbm9yZUZpbGVQYXRocyxcbiAgICAgICAgICAgIC4uLnJ1bnRpbWUgPT09IFwiYnJvd3NlclwiID8gW10gOiByZWFkRG9ja2VyaWdub3JlKHRoaXMuZmlsZUNvbnRleHRQYXRoKVxuICAgICAgICAgIF1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHN0ZXBzLnB1c2goaW5zdHJ1Y3Rpb24pO1xuICAgIH1cbiAgICByZXR1cm4gc3RlcHM7XG4gIH1cbiAgc2VyaWFsaXplKHN0ZXBzKSB7XG4gICAgY29uc3QgYmFzZURhdGEgPSB7XG4gICAgICBzdGFydENtZDogdGhpcy5zdGFydENtZCxcbiAgICAgIHJlYWR5Q21kOiB0aGlzLnJlYWR5Q21kLFxuICAgICAgc3RlcHMsXG4gICAgICBmb3JjZTogdGhpcy5mb3JjZVxuICAgIH07XG4gICAgaWYgKHRoaXMuYmFzZUltYWdlICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBiYXNlRGF0YSksIHtcbiAgICAgICAgZnJvbUltYWdlOiB0aGlzLmJhc2VJbWFnZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmJhc2VUZW1wbGF0ZSAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgYmFzZURhdGEpLCB7XG4gICAgICAgIGZyb21UZW1wbGF0ZTogdGhpcy5iYXNlVGVtcGxhdGVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgQnVpbGRFcnJvcihcbiAgICAgICAgXCJUZW1wbGF0ZSBtdXN0IHNwZWNpZnkgZWl0aGVyIGZyb21JbWFnZSBvciBmcm9tVGVtcGxhdGVcIlxuICAgICAgKTtcbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiBUZW1wbGF0ZShvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgVGVtcGxhdGVCYXNlKG9wdGlvbnMpO1xufVxuVGVtcGxhdGUuYnVpbGQgPSBUZW1wbGF0ZUJhc2UuYnVpbGQ7XG5UZW1wbGF0ZS50b0pTT04gPSBUZW1wbGF0ZUJhc2UudG9KU09OO1xuVGVtcGxhdGUudG9Eb2NrZXJmaWxlID0gVGVtcGxhdGVCYXNlLnRvRG9ja2VyZmlsZTtcblxuLy8gc3JjL2luZGV4LnRzXG52YXIgc3JjX2RlZmF1bHQgPSBTYW5kYm94O1xuZXhwb3J0IHtcbiAgQXBpQ2xpZW50LFxuICBBdXRoZW50aWNhdGlvbkVycm9yLFxuICBCdWlsZEVycm9yLFxuICBDb21tYW5kRXhpdEVycm9yLFxuICBDb25uZWN0aW9uQ29uZmlnLFxuICBGaWxlVHlwZTIgYXMgRmlsZVR5cGUsXG4gIEZpbGVVcGxvYWRFcnJvcixcbiAgRmlsZXN5c3RlbUV2ZW50VHlwZSxcbiAgSW52YWxpZEFyZ3VtZW50RXJyb3IsXG4gIE5vdEVub3VnaFNwYWNlRXJyb3IsXG4gIE5vdEZvdW5kRXJyb3IsXG4gIFJhdGVMaW1pdEVycm9yLFxuICBTYW5kYm94LFxuICBTYW5kYm94RXJyb3IsXG4gIFRlbXBsYXRlLFxuICBUZW1wbGF0ZUVycm9yLFxuICBUaW1lb3V0RXJyb3IsXG4gIHNyY19kZWZhdWx0IGFzIGRlZmF1bHQsXG4gIGdldFNpZ25hdHVyZSxcbiAgd2FpdEZvckZpbGUsXG4gIHdhaXRGb3JQb3J0LFxuICB3YWl0Rm9yUHJvY2VzcyxcbiAgd2FpdEZvclRpbWVvdXQsXG4gIHdhaXRGb3JVUkxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/e2b/dist/index.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/e2b/node_modules/glob/dist/esm/glob.js":
/*!*************************************************************!*\
  !*** ./node_modules/e2b/node_modules/glob/dist/esm/glob.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Glob: () => (/* binding */ Glob)\n/* harmony export */ });\n/* harmony import */ var minimatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! minimatch */ \"(rsc)/./node_modules/e2b/node_modules/minimatch/dist/esm/index.js\");\n/* harmony import */ var node_url__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:url */ \"node:url\");\n/* harmony import */ var path_scurry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! path-scurry */ \"(rsc)/./node_modules/e2b/node_modules/path-scurry/dist/esm/index.js\");\n/* harmony import */ var _pattern_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pattern.js */ \"(rsc)/./node_modules/e2b/node_modules/glob/dist/esm/pattern.js\");\n/* harmony import */ var _walker_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./walker.js */ \"(rsc)/./node_modules/e2b/node_modules/glob/dist/esm/walker.js\");\n\n\n\n\n\n// if no process global, just call it linux.\n// so we default to case-sensitive, / separators\nconst defaultPlatform = (typeof process === 'object' &&\n    process &&\n    typeof process.platform === 'string') ?\n    process.platform\n    : 'linux';\n/**\n * An object that can perform glob pattern traversals.\n */\nclass Glob {\n    absolute;\n    cwd;\n    root;\n    dot;\n    dotRelative;\n    follow;\n    ignore;\n    magicalBraces;\n    mark;\n    matchBase;\n    maxDepth;\n    nobrace;\n    nocase;\n    nodir;\n    noext;\n    noglobstar;\n    pattern;\n    platform;\n    realpath;\n    scurry;\n    stat;\n    signal;\n    windowsPathsNoEscape;\n    withFileTypes;\n    includeChildMatches;\n    /**\n     * The options provided to the constructor.\n     */\n    opts;\n    /**\n     * An array of parsed immutable {@link Pattern} objects.\n     */\n    patterns;\n    /**\n     * All options are stored as properties on the `Glob` object.\n     *\n     * See {@link GlobOptions} for full options descriptions.\n     *\n     * Note that a previous `Glob` object can be passed as the\n     * `GlobOptions` to another `Glob` instantiation to re-use settings\n     * and caches with a new pattern.\n     *\n     * Traversal functions can be called multiple times to run the walk\n     * again.\n     */\n    constructor(pattern, opts) {\n        /* c8 ignore start */\n        if (!opts)\n            throw new TypeError('glob options required');\n        /* c8 ignore stop */\n        this.withFileTypes = !!opts.withFileTypes;\n        this.signal = opts.signal;\n        this.follow = !!opts.follow;\n        this.dot = !!opts.dot;\n        this.dotRelative = !!opts.dotRelative;\n        this.nodir = !!opts.nodir;\n        this.mark = !!opts.mark;\n        if (!opts.cwd) {\n            this.cwd = '';\n        }\n        else if (opts.cwd instanceof URL || opts.cwd.startsWith('file://')) {\n            opts.cwd = (0,node_url__WEBPACK_IMPORTED_MODULE_1__.fileURLToPath)(opts.cwd);\n        }\n        this.cwd = opts.cwd || '';\n        this.root = opts.root;\n        this.magicalBraces = !!opts.magicalBraces;\n        this.nobrace = !!opts.nobrace;\n        this.noext = !!opts.noext;\n        this.realpath = !!opts.realpath;\n        this.absolute = opts.absolute;\n        this.includeChildMatches = opts.includeChildMatches !== false;\n        this.noglobstar = !!opts.noglobstar;\n        this.matchBase = !!opts.matchBase;\n        this.maxDepth =\n            typeof opts.maxDepth === 'number' ? opts.maxDepth : Infinity;\n        this.stat = !!opts.stat;\n        this.ignore = opts.ignore;\n        if (this.withFileTypes && this.absolute !== undefined) {\n            throw new Error('cannot set absolute and withFileTypes:true');\n        }\n        if (typeof pattern === 'string') {\n            pattern = [pattern];\n        }\n        this.windowsPathsNoEscape =\n            !!opts.windowsPathsNoEscape ||\n                opts.allowWindowsEscape ===\n                    false;\n        if (this.windowsPathsNoEscape) {\n            pattern = pattern.map(p => p.replace(/\\\\/g, '/'));\n        }\n        if (this.matchBase) {\n            if (opts.noglobstar) {\n                throw new TypeError('base matching requires globstar');\n            }\n            pattern = pattern.map(p => (p.includes('/') ? p : `./**/${p}`));\n        }\n        this.pattern = pattern;\n        this.platform = opts.platform || defaultPlatform;\n        this.opts = { ...opts, platform: this.platform };\n        if (opts.scurry) {\n            this.scurry = opts.scurry;\n            if (opts.nocase !== undefined &&\n                opts.nocase !== opts.scurry.nocase) {\n                throw new Error('nocase option contradicts provided scurry option');\n            }\n        }\n        else {\n            const Scurry = opts.platform === 'win32' ? path_scurry__WEBPACK_IMPORTED_MODULE_2__.PathScurryWin32\n                : opts.platform === 'darwin' ? path_scurry__WEBPACK_IMPORTED_MODULE_2__.PathScurryDarwin\n                    : opts.platform ? path_scurry__WEBPACK_IMPORTED_MODULE_2__.PathScurryPosix\n                        : path_scurry__WEBPACK_IMPORTED_MODULE_2__.PathScurry;\n            this.scurry = new Scurry(this.cwd, {\n                nocase: opts.nocase,\n                fs: opts.fs,\n            });\n        }\n        this.nocase = this.scurry.nocase;\n        // If you do nocase:true on a case-sensitive file system, then\n        // we need to use regexps instead of strings for non-magic\n        // path portions, because statting `aBc` won't return results\n        // for the file `AbC` for example.\n        const nocaseMagicOnly = this.platform === 'darwin' || this.platform === 'win32';\n        const mmo = {\n            // default nocase based on platform\n            ...opts,\n            dot: this.dot,\n            matchBase: this.matchBase,\n            nobrace: this.nobrace,\n            nocase: this.nocase,\n            nocaseMagicOnly,\n            nocomment: true,\n            noext: this.noext,\n            nonegate: true,\n            optimizationLevel: 2,\n            platform: this.platform,\n            windowsPathsNoEscape: this.windowsPathsNoEscape,\n            debug: !!this.opts.debug,\n        };\n        const mms = this.pattern.map(p => new minimatch__WEBPACK_IMPORTED_MODULE_0__.Minimatch(p, mmo));\n        const [matchSet, globParts] = mms.reduce((set, m) => {\n            set[0].push(...m.set);\n            set[1].push(...m.globParts);\n            return set;\n        }, [[], []]);\n        this.patterns = matchSet.map((set, i) => {\n            const g = globParts[i];\n            /* c8 ignore start */\n            if (!g)\n                throw new Error('invalid pattern object');\n            /* c8 ignore stop */\n            return new _pattern_js__WEBPACK_IMPORTED_MODULE_3__.Pattern(set, g, 0, this.platform);\n        });\n    }\n    async walk() {\n        // Walkers always return array of Path objects, so we just have to\n        // coerce them into the right shape.  It will have already called\n        // realpath() if the option was set to do so, so we know that's cached.\n        // start out knowing the cwd, at least\n        return [\n            ...(await new _walker_js__WEBPACK_IMPORTED_MODULE_4__.GlobWalker(this.patterns, this.scurry.cwd, {\n                ...this.opts,\n                maxDepth: this.maxDepth !== Infinity ?\n                    this.maxDepth + this.scurry.cwd.depth()\n                    : Infinity,\n                platform: this.platform,\n                nocase: this.nocase,\n                includeChildMatches: this.includeChildMatches,\n            }).walk()),\n        ];\n    }\n    walkSync() {\n        return [\n            ...new _walker_js__WEBPACK_IMPORTED_MODULE_4__.GlobWalker(this.patterns, this.scurry.cwd, {\n                ...this.opts,\n                maxDepth: this.maxDepth !== Infinity ?\n                    this.maxDepth + this.scurry.cwd.depth()\n                    : Infinity,\n                platform: this.platform,\n                nocase: this.nocase,\n                includeChildMatches: this.includeChildMatches,\n            }).walkSync(),\n        ];\n    }\n    stream() {\n        return new _walker_js__WEBPACK_IMPORTED_MODULE_4__.GlobStream(this.patterns, this.scurry.cwd, {\n            ...this.opts,\n            maxDepth: this.maxDepth !== Infinity ?\n                this.maxDepth + this.scurry.cwd.depth()\n                : Infinity,\n            platform: this.platform,\n            nocase: this.nocase,\n            includeChildMatches: this.includeChildMatches,\n        }).stream();\n    }\n    streamSync() {\n        return new _walker_js__WEBPACK_IMPORTED_MODULE_4__.GlobStream(this.patterns, this.scurry.cwd, {\n            ...this.opts,\n            maxDepth: this.maxDepth !== Infinity ?\n                this.maxDepth + this.scurry.cwd.depth()\n                : Infinity,\n            platform: this.platform,\n            nocase: this.nocase,\n            includeChildMatches: this.includeChildMatches,\n        }).streamSync();\n    }\n    /**\n     * Default sync iteration function. Returns a Generator that\n     * iterates over the results.\n     */\n    iterateSync() {\n        return this.streamSync()[Symbol.iterator]();\n    }\n    [Symbol.iterator]() {\n        return this.iterateSync();\n    }\n    /**\n     * Default async iteration function. Returns an AsyncGenerator that\n     * iterates over the results.\n     */\n    iterate() {\n        return this.stream()[Symbol.asyncIterator]();\n    }\n    [Symbol.asyncIterator]() {\n        return this.iterate();\n    }\n}\n//# sourceMappingURL=glob.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZTJiL25vZGVfbW9kdWxlcy9nbG9iL2Rpc3QvZXNtL2dsb2IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQXNDO0FBQ0c7QUFDcUQ7QUFDdkQ7QUFDYztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGVBQWU7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1REFBYTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLEVBQUU7QUFDeEU7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsd0RBQWU7QUFDdEUsK0NBQStDLHlEQUFnQjtBQUMvRCxzQ0FBc0Msd0RBQWU7QUFDckQsMEJBQTBCLG1EQUFVO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGdEQUFTO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnREFBTztBQUM5QixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsa0RBQVU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0RBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtEQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxtQkFBbUIsa0RBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpdmUtdmliZS1haS1uZXh0Ly4vbm9kZV9tb2R1bGVzL2UyYi9ub2RlX21vZHVsZXMvZ2xvYi9kaXN0L2VzbS9nbG9iLmpzPzgxOGUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTWluaW1hdGNoIH0gZnJvbSAnbWluaW1hdGNoJztcbmltcG9ydCB7IGZpbGVVUkxUb1BhdGggfSBmcm9tICdub2RlOnVybCc7XG5pbXBvcnQgeyBQYXRoU2N1cnJ5LCBQYXRoU2N1cnJ5RGFyd2luLCBQYXRoU2N1cnJ5UG9zaXgsIFBhdGhTY3VycnlXaW4zMiwgfSBmcm9tICdwYXRoLXNjdXJyeSc7XG5pbXBvcnQgeyBQYXR0ZXJuIH0gZnJvbSAnLi9wYXR0ZXJuLmpzJztcbmltcG9ydCB7IEdsb2JTdHJlYW0sIEdsb2JXYWxrZXIgfSBmcm9tICcuL3dhbGtlci5qcyc7XG4vLyBpZiBubyBwcm9jZXNzIGdsb2JhbCwganVzdCBjYWxsIGl0IGxpbnV4LlxuLy8gc28gd2UgZGVmYXVsdCB0byBjYXNlLXNlbnNpdGl2ZSwgLyBzZXBhcmF0b3JzXG5jb25zdCBkZWZhdWx0UGxhdGZvcm0gPSAodHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmXG4gICAgcHJvY2VzcyAmJlxuICAgIHR5cGVvZiBwcm9jZXNzLnBsYXRmb3JtID09PSAnc3RyaW5nJykgP1xuICAgIHByb2Nlc3MucGxhdGZvcm1cbiAgICA6ICdsaW51eCc7XG4vKipcbiAqIEFuIG9iamVjdCB0aGF0IGNhbiBwZXJmb3JtIGdsb2IgcGF0dGVybiB0cmF2ZXJzYWxzLlxuICovXG5leHBvcnQgY2xhc3MgR2xvYiB7XG4gICAgYWJzb2x1dGU7XG4gICAgY3dkO1xuICAgIHJvb3Q7XG4gICAgZG90O1xuICAgIGRvdFJlbGF0aXZlO1xuICAgIGZvbGxvdztcbiAgICBpZ25vcmU7XG4gICAgbWFnaWNhbEJyYWNlcztcbiAgICBtYXJrO1xuICAgIG1hdGNoQmFzZTtcbiAgICBtYXhEZXB0aDtcbiAgICBub2JyYWNlO1xuICAgIG5vY2FzZTtcbiAgICBub2RpcjtcbiAgICBub2V4dDtcbiAgICBub2dsb2JzdGFyO1xuICAgIHBhdHRlcm47XG4gICAgcGxhdGZvcm07XG4gICAgcmVhbHBhdGg7XG4gICAgc2N1cnJ5O1xuICAgIHN0YXQ7XG4gICAgc2lnbmFsO1xuICAgIHdpbmRvd3NQYXRoc05vRXNjYXBlO1xuICAgIHdpdGhGaWxlVHlwZXM7XG4gICAgaW5jbHVkZUNoaWxkTWF0Y2hlcztcbiAgICAvKipcbiAgICAgKiBUaGUgb3B0aW9ucyBwcm92aWRlZCB0byB0aGUgY29uc3RydWN0b3IuXG4gICAgICovXG4gICAgb3B0cztcbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBvZiBwYXJzZWQgaW1tdXRhYmxlIHtAbGluayBQYXR0ZXJufSBvYmplY3RzLlxuICAgICAqL1xuICAgIHBhdHRlcm5zO1xuICAgIC8qKlxuICAgICAqIEFsbCBvcHRpb25zIGFyZSBzdG9yZWQgYXMgcHJvcGVydGllcyBvbiB0aGUgYEdsb2JgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIFNlZSB7QGxpbmsgR2xvYk9wdGlvbnN9IGZvciBmdWxsIG9wdGlvbnMgZGVzY3JpcHRpb25zLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IGEgcHJldmlvdXMgYEdsb2JgIG9iamVjdCBjYW4gYmUgcGFzc2VkIGFzIHRoZVxuICAgICAqIGBHbG9iT3B0aW9uc2AgdG8gYW5vdGhlciBgR2xvYmAgaW5zdGFudGlhdGlvbiB0byByZS11c2Ugc2V0dGluZ3NcbiAgICAgKiBhbmQgY2FjaGVzIHdpdGggYSBuZXcgcGF0dGVybi5cbiAgICAgKlxuICAgICAqIFRyYXZlcnNhbCBmdW5jdGlvbnMgY2FuIGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyB0byBydW4gdGhlIHdhbGtcbiAgICAgKiBhZ2Fpbi5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihwYXR0ZXJuLCBvcHRzKSB7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICBpZiAoIW9wdHMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdnbG9iIG9wdGlvbnMgcmVxdWlyZWQnKTtcbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgdGhpcy53aXRoRmlsZVR5cGVzID0gISFvcHRzLndpdGhGaWxlVHlwZXM7XG4gICAgICAgIHRoaXMuc2lnbmFsID0gb3B0cy5zaWduYWw7XG4gICAgICAgIHRoaXMuZm9sbG93ID0gISFvcHRzLmZvbGxvdztcbiAgICAgICAgdGhpcy5kb3QgPSAhIW9wdHMuZG90O1xuICAgICAgICB0aGlzLmRvdFJlbGF0aXZlID0gISFvcHRzLmRvdFJlbGF0aXZlO1xuICAgICAgICB0aGlzLm5vZGlyID0gISFvcHRzLm5vZGlyO1xuICAgICAgICB0aGlzLm1hcmsgPSAhIW9wdHMubWFyaztcbiAgICAgICAgaWYgKCFvcHRzLmN3ZCkge1xuICAgICAgICAgICAgdGhpcy5jd2QgPSAnJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHRzLmN3ZCBpbnN0YW5jZW9mIFVSTCB8fCBvcHRzLmN3ZC5zdGFydHNXaXRoKCdmaWxlOi8vJykpIHtcbiAgICAgICAgICAgIG9wdHMuY3dkID0gZmlsZVVSTFRvUGF0aChvcHRzLmN3ZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jd2QgPSBvcHRzLmN3ZCB8fCAnJztcbiAgICAgICAgdGhpcy5yb290ID0gb3B0cy5yb290O1xuICAgICAgICB0aGlzLm1hZ2ljYWxCcmFjZXMgPSAhIW9wdHMubWFnaWNhbEJyYWNlcztcbiAgICAgICAgdGhpcy5ub2JyYWNlID0gISFvcHRzLm5vYnJhY2U7XG4gICAgICAgIHRoaXMubm9leHQgPSAhIW9wdHMubm9leHQ7XG4gICAgICAgIHRoaXMucmVhbHBhdGggPSAhIW9wdHMucmVhbHBhdGg7XG4gICAgICAgIHRoaXMuYWJzb2x1dGUgPSBvcHRzLmFic29sdXRlO1xuICAgICAgICB0aGlzLmluY2x1ZGVDaGlsZE1hdGNoZXMgPSBvcHRzLmluY2x1ZGVDaGlsZE1hdGNoZXMgIT09IGZhbHNlO1xuICAgICAgICB0aGlzLm5vZ2xvYnN0YXIgPSAhIW9wdHMubm9nbG9ic3RhcjtcbiAgICAgICAgdGhpcy5tYXRjaEJhc2UgPSAhIW9wdHMubWF0Y2hCYXNlO1xuICAgICAgICB0aGlzLm1heERlcHRoID1cbiAgICAgICAgICAgIHR5cGVvZiBvcHRzLm1heERlcHRoID09PSAnbnVtYmVyJyA/IG9wdHMubWF4RGVwdGggOiBJbmZpbml0eTtcbiAgICAgICAgdGhpcy5zdGF0ID0gISFvcHRzLnN0YXQ7XG4gICAgICAgIHRoaXMuaWdub3JlID0gb3B0cy5pZ25vcmU7XG4gICAgICAgIGlmICh0aGlzLndpdGhGaWxlVHlwZXMgJiYgdGhpcy5hYnNvbHV0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBzZXQgYWJzb2x1dGUgYW5kIHdpdGhGaWxlVHlwZXM6dHJ1ZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHBhdHRlcm4gPSBbcGF0dGVybl07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53aW5kb3dzUGF0aHNOb0VzY2FwZSA9XG4gICAgICAgICAgICAhIW9wdHMud2luZG93c1BhdGhzTm9Fc2NhcGUgfHxcbiAgICAgICAgICAgICAgICBvcHRzLmFsbG93V2luZG93c0VzY2FwZSA9PT1cbiAgICAgICAgICAgICAgICAgICAgZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLndpbmRvd3NQYXRoc05vRXNjYXBlKSB7XG4gICAgICAgICAgICBwYXR0ZXJuID0gcGF0dGVybi5tYXAocCA9PiBwLnJlcGxhY2UoL1xcXFwvZywgJy8nKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubWF0Y2hCYXNlKSB7XG4gICAgICAgICAgICBpZiAob3B0cy5ub2dsb2JzdGFyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYmFzZSBtYXRjaGluZyByZXF1aXJlcyBnbG9ic3RhcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGF0dGVybiA9IHBhdHRlcm4ubWFwKHAgPT4gKHAuaW5jbHVkZXMoJy8nKSA/IHAgOiBgLi8qKi8ke3B9YCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGF0dGVybiA9IHBhdHRlcm47XG4gICAgICAgIHRoaXMucGxhdGZvcm0gPSBvcHRzLnBsYXRmb3JtIHx8IGRlZmF1bHRQbGF0Zm9ybTtcbiAgICAgICAgdGhpcy5vcHRzID0geyAuLi5vcHRzLCBwbGF0Zm9ybTogdGhpcy5wbGF0Zm9ybSB9O1xuICAgICAgICBpZiAob3B0cy5zY3VycnkpIHtcbiAgICAgICAgICAgIHRoaXMuc2N1cnJ5ID0gb3B0cy5zY3Vycnk7XG4gICAgICAgICAgICBpZiAob3B0cy5ub2Nhc2UgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIG9wdHMubm9jYXNlICE9PSBvcHRzLnNjdXJyeS5ub2Nhc2UpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vY2FzZSBvcHRpb24gY29udHJhZGljdHMgcHJvdmlkZWQgc2N1cnJ5IG9wdGlvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgU2N1cnJ5ID0gb3B0cy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyA/IFBhdGhTY3VycnlXaW4zMlxuICAgICAgICAgICAgICAgIDogb3B0cy5wbGF0Zm9ybSA9PT0gJ2RhcndpbicgPyBQYXRoU2N1cnJ5RGFyd2luXG4gICAgICAgICAgICAgICAgICAgIDogb3B0cy5wbGF0Zm9ybSA/IFBhdGhTY3VycnlQb3NpeFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBQYXRoU2N1cnJ5O1xuICAgICAgICAgICAgdGhpcy5zY3VycnkgPSBuZXcgU2N1cnJ5KHRoaXMuY3dkLCB7XG4gICAgICAgICAgICAgICAgbm9jYXNlOiBvcHRzLm5vY2FzZSxcbiAgICAgICAgICAgICAgICBmczogb3B0cy5mcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubm9jYXNlID0gdGhpcy5zY3Vycnkubm9jYXNlO1xuICAgICAgICAvLyBJZiB5b3UgZG8gbm9jYXNlOnRydWUgb24gYSBjYXNlLXNlbnNpdGl2ZSBmaWxlIHN5c3RlbSwgdGhlblxuICAgICAgICAvLyB3ZSBuZWVkIHRvIHVzZSByZWdleHBzIGluc3RlYWQgb2Ygc3RyaW5ncyBmb3Igbm9uLW1hZ2ljXG4gICAgICAgIC8vIHBhdGggcG9ydGlvbnMsIGJlY2F1c2Ugc3RhdHRpbmcgYGFCY2Agd29uJ3QgcmV0dXJuIHJlc3VsdHNcbiAgICAgICAgLy8gZm9yIHRoZSBmaWxlIGBBYkNgIGZvciBleGFtcGxlLlxuICAgICAgICBjb25zdCBub2Nhc2VNYWdpY09ubHkgPSB0aGlzLnBsYXRmb3JtID09PSAnZGFyd2luJyB8fCB0aGlzLnBsYXRmb3JtID09PSAnd2luMzInO1xuICAgICAgICBjb25zdCBtbW8gPSB7XG4gICAgICAgICAgICAvLyBkZWZhdWx0IG5vY2FzZSBiYXNlZCBvbiBwbGF0Zm9ybVxuICAgICAgICAgICAgLi4ub3B0cyxcbiAgICAgICAgICAgIGRvdDogdGhpcy5kb3QsXG4gICAgICAgICAgICBtYXRjaEJhc2U6IHRoaXMubWF0Y2hCYXNlLFxuICAgICAgICAgICAgbm9icmFjZTogdGhpcy5ub2JyYWNlLFxuICAgICAgICAgICAgbm9jYXNlOiB0aGlzLm5vY2FzZSxcbiAgICAgICAgICAgIG5vY2FzZU1hZ2ljT25seSxcbiAgICAgICAgICAgIG5vY29tbWVudDogdHJ1ZSxcbiAgICAgICAgICAgIG5vZXh0OiB0aGlzLm5vZXh0LFxuICAgICAgICAgICAgbm9uZWdhdGU6IHRydWUsXG4gICAgICAgICAgICBvcHRpbWl6YXRpb25MZXZlbDogMixcbiAgICAgICAgICAgIHBsYXRmb3JtOiB0aGlzLnBsYXRmb3JtLFxuICAgICAgICAgICAgd2luZG93c1BhdGhzTm9Fc2NhcGU6IHRoaXMud2luZG93c1BhdGhzTm9Fc2NhcGUsXG4gICAgICAgICAgICBkZWJ1ZzogISF0aGlzLm9wdHMuZGVidWcsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG1tcyA9IHRoaXMucGF0dGVybi5tYXAocCA9PiBuZXcgTWluaW1hdGNoKHAsIG1tbykpO1xuICAgICAgICBjb25zdCBbbWF0Y2hTZXQsIGdsb2JQYXJ0c10gPSBtbXMucmVkdWNlKChzZXQsIG0pID0+IHtcbiAgICAgICAgICAgIHNldFswXS5wdXNoKC4uLm0uc2V0KTtcbiAgICAgICAgICAgIHNldFsxXS5wdXNoKC4uLm0uZ2xvYlBhcnRzKTtcbiAgICAgICAgICAgIHJldHVybiBzZXQ7XG4gICAgICAgIH0sIFtbXSwgW11dKTtcbiAgICAgICAgdGhpcy5wYXR0ZXJucyA9IG1hdGNoU2V0Lm1hcCgoc2V0LCBpKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBnID0gZ2xvYlBhcnRzW2ldO1xuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICBpZiAoIWcpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHBhdHRlcm4gb2JqZWN0Jyk7XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQYXR0ZXJuKHNldCwgZywgMCwgdGhpcy5wbGF0Zm9ybSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyB3YWxrKCkge1xuICAgICAgICAvLyBXYWxrZXJzIGFsd2F5cyByZXR1cm4gYXJyYXkgb2YgUGF0aCBvYmplY3RzLCBzbyB3ZSBqdXN0IGhhdmUgdG9cbiAgICAgICAgLy8gY29lcmNlIHRoZW0gaW50byB0aGUgcmlnaHQgc2hhcGUuICBJdCB3aWxsIGhhdmUgYWxyZWFkeSBjYWxsZWRcbiAgICAgICAgLy8gcmVhbHBhdGgoKSBpZiB0aGUgb3B0aW9uIHdhcyBzZXQgdG8gZG8gc28sIHNvIHdlIGtub3cgdGhhdCdzIGNhY2hlZC5cbiAgICAgICAgLy8gc3RhcnQgb3V0IGtub3dpbmcgdGhlIGN3ZCwgYXQgbGVhc3RcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIC4uLihhd2FpdCBuZXcgR2xvYldhbGtlcih0aGlzLnBhdHRlcm5zLCB0aGlzLnNjdXJyeS5jd2QsIHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLm9wdHMsXG4gICAgICAgICAgICAgICAgbWF4RGVwdGg6IHRoaXMubWF4RGVwdGggIT09IEluZmluaXR5ID9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXhEZXB0aCArIHRoaXMuc2N1cnJ5LmN3ZC5kZXB0aCgpXG4gICAgICAgICAgICAgICAgICAgIDogSW5maW5pdHksXG4gICAgICAgICAgICAgICAgcGxhdGZvcm06IHRoaXMucGxhdGZvcm0sXG4gICAgICAgICAgICAgICAgbm9jYXNlOiB0aGlzLm5vY2FzZSxcbiAgICAgICAgICAgICAgICBpbmNsdWRlQ2hpbGRNYXRjaGVzOiB0aGlzLmluY2x1ZGVDaGlsZE1hdGNoZXMsXG4gICAgICAgICAgICB9KS53YWxrKCkpLFxuICAgICAgICBdO1xuICAgIH1cbiAgICB3YWxrU3luYygpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIC4uLm5ldyBHbG9iV2Fsa2VyKHRoaXMucGF0dGVybnMsIHRoaXMuc2N1cnJ5LmN3ZCwge1xuICAgICAgICAgICAgICAgIC4uLnRoaXMub3B0cyxcbiAgICAgICAgICAgICAgICBtYXhEZXB0aDogdGhpcy5tYXhEZXB0aCAhPT0gSW5maW5pdHkgP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1heERlcHRoICsgdGhpcy5zY3VycnkuY3dkLmRlcHRoKClcbiAgICAgICAgICAgICAgICAgICAgOiBJbmZpbml0eSxcbiAgICAgICAgICAgICAgICBwbGF0Zm9ybTogdGhpcy5wbGF0Zm9ybSxcbiAgICAgICAgICAgICAgICBub2Nhc2U6IHRoaXMubm9jYXNlLFxuICAgICAgICAgICAgICAgIGluY2x1ZGVDaGlsZE1hdGNoZXM6IHRoaXMuaW5jbHVkZUNoaWxkTWF0Y2hlcyxcbiAgICAgICAgICAgIH0pLndhbGtTeW5jKCksXG4gICAgICAgIF07XG4gICAgfVxuICAgIHN0cmVhbSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBHbG9iU3RyZWFtKHRoaXMucGF0dGVybnMsIHRoaXMuc2N1cnJ5LmN3ZCwge1xuICAgICAgICAgICAgLi4udGhpcy5vcHRzLFxuICAgICAgICAgICAgbWF4RGVwdGg6IHRoaXMubWF4RGVwdGggIT09IEluZmluaXR5ID9cbiAgICAgICAgICAgICAgICB0aGlzLm1heERlcHRoICsgdGhpcy5zY3VycnkuY3dkLmRlcHRoKClcbiAgICAgICAgICAgICAgICA6IEluZmluaXR5LFxuICAgICAgICAgICAgcGxhdGZvcm06IHRoaXMucGxhdGZvcm0sXG4gICAgICAgICAgICBub2Nhc2U6IHRoaXMubm9jYXNlLFxuICAgICAgICAgICAgaW5jbHVkZUNoaWxkTWF0Y2hlczogdGhpcy5pbmNsdWRlQ2hpbGRNYXRjaGVzLFxuICAgICAgICB9KS5zdHJlYW0oKTtcbiAgICB9XG4gICAgc3RyZWFtU3luYygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBHbG9iU3RyZWFtKHRoaXMucGF0dGVybnMsIHRoaXMuc2N1cnJ5LmN3ZCwge1xuICAgICAgICAgICAgLi4udGhpcy5vcHRzLFxuICAgICAgICAgICAgbWF4RGVwdGg6IHRoaXMubWF4RGVwdGggIT09IEluZmluaXR5ID9cbiAgICAgICAgICAgICAgICB0aGlzLm1heERlcHRoICsgdGhpcy5zY3VycnkuY3dkLmRlcHRoKClcbiAgICAgICAgICAgICAgICA6IEluZmluaXR5LFxuICAgICAgICAgICAgcGxhdGZvcm06IHRoaXMucGxhdGZvcm0sXG4gICAgICAgICAgICBub2Nhc2U6IHRoaXMubm9jYXNlLFxuICAgICAgICAgICAgaW5jbHVkZUNoaWxkTWF0Y2hlczogdGhpcy5pbmNsdWRlQ2hpbGRNYXRjaGVzLFxuICAgICAgICB9KS5zdHJlYW1TeW5jKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgc3luYyBpdGVyYXRpb24gZnVuY3Rpb24uIFJldHVybnMgYSBHZW5lcmF0b3IgdGhhdFxuICAgICAqIGl0ZXJhdGVzIG92ZXIgdGhlIHJlc3VsdHMuXG4gICAgICovXG4gICAgaXRlcmF0ZVN5bmMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmVhbVN5bmMoKVtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgfVxuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRlU3luYygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IGFzeW5jIGl0ZXJhdGlvbiBmdW5jdGlvbi4gUmV0dXJucyBhbiBBc3luY0dlbmVyYXRvciB0aGF0XG4gICAgICogaXRlcmF0ZXMgb3ZlciB0aGUgcmVzdWx0cy5cbiAgICAgKi9cbiAgICBpdGVyYXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW0oKVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTtcbiAgICB9XG4gICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0ZSgpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdsb2IuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/e2b/node_modules/glob/dist/esm/glob.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/e2b/node_modules/glob/dist/esm/has-magic.js":
/*!******************************************************************!*\
  !*** ./node_modules/e2b/node_modules/glob/dist/esm/has-magic.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   hasMagic: () => (/* binding */ hasMagic)\n/* harmony export */ });\n/* harmony import */ var minimatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! minimatch */ \"(rsc)/./node_modules/e2b/node_modules/minimatch/dist/esm/index.js\");\n\n/**\n * Return true if the patterns provided contain any magic glob characters,\n * given the options provided.\n *\n * Brace expansion is not considered \"magic\" unless the `magicalBraces` option\n * is set, as brace expansion just turns one string into an array of strings.\n * So a pattern like `'x{a,b}y'` would return `false`, because `'xay'` and\n * `'xby'` both do not contain any magic glob characters, and it's treated the\n * same as if you had called it on `['xay', 'xby']`. When `magicalBraces:true`\n * is in the options, brace expansion _is_ treated as a pattern having magic.\n */\nconst hasMagic = (pattern, options = {}) => {\n    if (!Array.isArray(pattern)) {\n        pattern = [pattern];\n    }\n    for (const p of pattern) {\n        if (new minimatch__WEBPACK_IMPORTED_MODULE_0__.Minimatch(p, options).hasMagic())\n            return true;\n    }\n    return false;\n};\n//# sourceMappingURL=has-magic.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZTJiL25vZGVfbW9kdWxlcy9nbG9iL2Rpc3QvZXNtL2hhcy1tYWdpYy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsSUFBSTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNPLHVDQUF1QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnREFBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdml2ZS12aWJlLWFpLW5leHQvLi9ub2RlX21vZHVsZXMvZTJiL25vZGVfbW9kdWxlcy9nbG9iL2Rpc3QvZXNtL2hhcy1tYWdpYy5qcz80OWNmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE1pbmltYXRjaCB9IGZyb20gJ21pbmltYXRjaCc7XG4vKipcbiAqIFJldHVybiB0cnVlIGlmIHRoZSBwYXR0ZXJucyBwcm92aWRlZCBjb250YWluIGFueSBtYWdpYyBnbG9iIGNoYXJhY3RlcnMsXG4gKiBnaXZlbiB0aGUgb3B0aW9ucyBwcm92aWRlZC5cbiAqXG4gKiBCcmFjZSBleHBhbnNpb24gaXMgbm90IGNvbnNpZGVyZWQgXCJtYWdpY1wiIHVubGVzcyB0aGUgYG1hZ2ljYWxCcmFjZXNgIG9wdGlvblxuICogaXMgc2V0LCBhcyBicmFjZSBleHBhbnNpb24ganVzdCB0dXJucyBvbmUgc3RyaW5nIGludG8gYW4gYXJyYXkgb2Ygc3RyaW5ncy5cbiAqIFNvIGEgcGF0dGVybiBsaWtlIGAneHthLGJ9eSdgIHdvdWxkIHJldHVybiBgZmFsc2VgLCBiZWNhdXNlIGAneGF5J2AgYW5kXG4gKiBgJ3hieSdgIGJvdGggZG8gbm90IGNvbnRhaW4gYW55IG1hZ2ljIGdsb2IgY2hhcmFjdGVycywgYW5kIGl0J3MgdHJlYXRlZCB0aGVcbiAqIHNhbWUgYXMgaWYgeW91IGhhZCBjYWxsZWQgaXQgb24gYFsneGF5JywgJ3hieSddYC4gV2hlbiBgbWFnaWNhbEJyYWNlczp0cnVlYFxuICogaXMgaW4gdGhlIG9wdGlvbnMsIGJyYWNlIGV4cGFuc2lvbiBfaXNfIHRyZWF0ZWQgYXMgYSBwYXR0ZXJuIGhhdmluZyBtYWdpYy5cbiAqL1xuZXhwb3J0IGNvbnN0IGhhc01hZ2ljID0gKHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShwYXR0ZXJuKSkge1xuICAgICAgICBwYXR0ZXJuID0gW3BhdHRlcm5dO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHAgb2YgcGF0dGVybikge1xuICAgICAgICBpZiAobmV3IE1pbmltYXRjaChwLCBvcHRpb25zKS5oYXNNYWdpYygpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXMtbWFnaWMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/e2b/node_modules/glob/dist/esm/has-magic.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/e2b/node_modules/glob/dist/esm/ignore.js":
/*!***************************************************************!*\
  !*** ./node_modules/e2b/node_modules/glob/dist/esm/ignore.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Ignore: () => (/* binding */ Ignore)\n/* harmony export */ });\n/* harmony import */ var minimatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! minimatch */ \"(rsc)/./node_modules/e2b/node_modules/minimatch/dist/esm/index.js\");\n/* harmony import */ var _pattern_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pattern.js */ \"(rsc)/./node_modules/e2b/node_modules/glob/dist/esm/pattern.js\");\n// give it a pattern, and it'll be able to tell you if\n// a given path should be ignored.\n// Ignoring a path ignores its children if the pattern ends in /**\n// Ignores are always parsed in dot:true mode\n\n\nconst defaultPlatform = (typeof process === 'object' &&\n    process &&\n    typeof process.platform === 'string') ?\n    process.platform\n    : 'linux';\n/**\n * Class used to process ignored patterns\n */\nclass Ignore {\n    relative;\n    relativeChildren;\n    absolute;\n    absoluteChildren;\n    platform;\n    mmopts;\n    constructor(ignored, { nobrace, nocase, noext, noglobstar, platform = defaultPlatform, }) {\n        this.relative = [];\n        this.absolute = [];\n        this.relativeChildren = [];\n        this.absoluteChildren = [];\n        this.platform = platform;\n        this.mmopts = {\n            dot: true,\n            nobrace,\n            nocase,\n            noext,\n            noglobstar,\n            optimizationLevel: 2,\n            platform,\n            nocomment: true,\n            nonegate: true,\n        };\n        for (const ign of ignored)\n            this.add(ign);\n    }\n    add(ign) {\n        // this is a little weird, but it gives us a clean set of optimized\n        // minimatch matchers, without getting tripped up if one of them\n        // ends in /** inside a brace section, and it's only inefficient at\n        // the start of the walk, not along it.\n        // It'd be nice if the Pattern class just had a .test() method, but\n        // handling globstars is a bit of a pita, and that code already lives\n        // in minimatch anyway.\n        // Another way would be if maybe Minimatch could take its set/globParts\n        // as an option, and then we could at least just use Pattern to test\n        // for absolute-ness.\n        // Yet another way, Minimatch could take an array of glob strings, and\n        // a cwd option, and do the right thing.\n        const mm = new minimatch__WEBPACK_IMPORTED_MODULE_0__.Minimatch(ign, this.mmopts);\n        for (let i = 0; i < mm.set.length; i++) {\n            const parsed = mm.set[i];\n            const globParts = mm.globParts[i];\n            /* c8 ignore start */\n            if (!parsed || !globParts) {\n                throw new Error('invalid pattern object');\n            }\n            // strip off leading ./ portions\n            // https://github.com/isaacs/node-glob/issues/570\n            while (parsed[0] === '.' && globParts[0] === '.') {\n                parsed.shift();\n                globParts.shift();\n            }\n            /* c8 ignore stop */\n            const p = new _pattern_js__WEBPACK_IMPORTED_MODULE_1__.Pattern(parsed, globParts, 0, this.platform);\n            const m = new minimatch__WEBPACK_IMPORTED_MODULE_0__.Minimatch(p.globString(), this.mmopts);\n            const children = globParts[globParts.length - 1] === '**';\n            const absolute = p.isAbsolute();\n            if (absolute)\n                this.absolute.push(m);\n            else\n                this.relative.push(m);\n            if (children) {\n                if (absolute)\n                    this.absoluteChildren.push(m);\n                else\n                    this.relativeChildren.push(m);\n            }\n        }\n    }\n    ignored(p) {\n        const fullpath = p.fullpath();\n        const fullpaths = `${fullpath}/`;\n        const relative = p.relative() || '.';\n        const relatives = `${relative}/`;\n        for (const m of this.relative) {\n            if (m.match(relative) || m.match(relatives))\n                return true;\n        }\n        for (const m of this.absolute) {\n            if (m.match(fullpath) || m.match(fullpaths))\n                return true;\n        }\n        return false;\n    }\n    childrenIgnored(p) {\n        const fullpath = p.fullpath() + '/';\n        const relative = (p.relative() || '.') + '/';\n        for (const m of this.relativeChildren) {\n            if (m.match(relative))\n                return true;\n        }\n        for (const m of this.absoluteChildren) {\n            if (m.match(fullpath))\n                return true;\n        }\n        return false;\n    }\n}\n//# sourceMappingURL=ignore.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZTJiL25vZGVfbW9kdWxlcy9nbG9iL2Rpc3QvZXNtL2lnbm9yZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNzQztBQUNDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpRUFBaUU7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnREFBUztBQUNoQyx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdEQUFPO0FBQ2pDLDBCQUEwQixnREFBUztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixTQUFTO0FBQ3RDO0FBQ0EsNkJBQTZCLFNBQVM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aXZlLXZpYmUtYWktbmV4dC8uL25vZGVfbW9kdWxlcy9lMmIvbm9kZV9tb2R1bGVzL2dsb2IvZGlzdC9lc20vaWdub3JlLmpzPzA3MjQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZ2l2ZSBpdCBhIHBhdHRlcm4sIGFuZCBpdCdsbCBiZSBhYmxlIHRvIHRlbGwgeW91IGlmXG4vLyBhIGdpdmVuIHBhdGggc2hvdWxkIGJlIGlnbm9yZWQuXG4vLyBJZ25vcmluZyBhIHBhdGggaWdub3JlcyBpdHMgY2hpbGRyZW4gaWYgdGhlIHBhdHRlcm4gZW5kcyBpbiAvKipcbi8vIElnbm9yZXMgYXJlIGFsd2F5cyBwYXJzZWQgaW4gZG90OnRydWUgbW9kZVxuaW1wb3J0IHsgTWluaW1hdGNoIH0gZnJvbSAnbWluaW1hdGNoJztcbmltcG9ydCB7IFBhdHRlcm4gfSBmcm9tICcuL3BhdHRlcm4uanMnO1xuY29uc3QgZGVmYXVsdFBsYXRmb3JtID0gKHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJlxuICAgIHByb2Nlc3MgJiZcbiAgICB0eXBlb2YgcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3N0cmluZycpID9cbiAgICBwcm9jZXNzLnBsYXRmb3JtXG4gICAgOiAnbGludXgnO1xuLyoqXG4gKiBDbGFzcyB1c2VkIHRvIHByb2Nlc3MgaWdub3JlZCBwYXR0ZXJuc1xuICovXG5leHBvcnQgY2xhc3MgSWdub3JlIHtcbiAgICByZWxhdGl2ZTtcbiAgICByZWxhdGl2ZUNoaWxkcmVuO1xuICAgIGFic29sdXRlO1xuICAgIGFic29sdXRlQ2hpbGRyZW47XG4gICAgcGxhdGZvcm07XG4gICAgbW1vcHRzO1xuICAgIGNvbnN0cnVjdG9yKGlnbm9yZWQsIHsgbm9icmFjZSwgbm9jYXNlLCBub2V4dCwgbm9nbG9ic3RhciwgcGxhdGZvcm0gPSBkZWZhdWx0UGxhdGZvcm0sIH0pIHtcbiAgICAgICAgdGhpcy5yZWxhdGl2ZSA9IFtdO1xuICAgICAgICB0aGlzLmFic29sdXRlID0gW107XG4gICAgICAgIHRoaXMucmVsYXRpdmVDaGlsZHJlbiA9IFtdO1xuICAgICAgICB0aGlzLmFic29sdXRlQ2hpbGRyZW4gPSBbXTtcbiAgICAgICAgdGhpcy5wbGF0Zm9ybSA9IHBsYXRmb3JtO1xuICAgICAgICB0aGlzLm1tb3B0cyA9IHtcbiAgICAgICAgICAgIGRvdDogdHJ1ZSxcbiAgICAgICAgICAgIG5vYnJhY2UsXG4gICAgICAgICAgICBub2Nhc2UsXG4gICAgICAgICAgICBub2V4dCxcbiAgICAgICAgICAgIG5vZ2xvYnN0YXIsXG4gICAgICAgICAgICBvcHRpbWl6YXRpb25MZXZlbDogMixcbiAgICAgICAgICAgIHBsYXRmb3JtLFxuICAgICAgICAgICAgbm9jb21tZW50OiB0cnVlLFxuICAgICAgICAgICAgbm9uZWdhdGU6IHRydWUsXG4gICAgICAgIH07XG4gICAgICAgIGZvciAoY29uc3QgaWduIG9mIGlnbm9yZWQpXG4gICAgICAgICAgICB0aGlzLmFkZChpZ24pO1xuICAgIH1cbiAgICBhZGQoaWduKSB7XG4gICAgICAgIC8vIHRoaXMgaXMgYSBsaXR0bGUgd2VpcmQsIGJ1dCBpdCBnaXZlcyB1cyBhIGNsZWFuIHNldCBvZiBvcHRpbWl6ZWRcbiAgICAgICAgLy8gbWluaW1hdGNoIG1hdGNoZXJzLCB3aXRob3V0IGdldHRpbmcgdHJpcHBlZCB1cCBpZiBvbmUgb2YgdGhlbVxuICAgICAgICAvLyBlbmRzIGluIC8qKiBpbnNpZGUgYSBicmFjZSBzZWN0aW9uLCBhbmQgaXQncyBvbmx5IGluZWZmaWNpZW50IGF0XG4gICAgICAgIC8vIHRoZSBzdGFydCBvZiB0aGUgd2Fsaywgbm90IGFsb25nIGl0LlxuICAgICAgICAvLyBJdCdkIGJlIG5pY2UgaWYgdGhlIFBhdHRlcm4gY2xhc3MganVzdCBoYWQgYSAudGVzdCgpIG1ldGhvZCwgYnV0XG4gICAgICAgIC8vIGhhbmRsaW5nIGdsb2JzdGFycyBpcyBhIGJpdCBvZiBhIHBpdGEsIGFuZCB0aGF0IGNvZGUgYWxyZWFkeSBsaXZlc1xuICAgICAgICAvLyBpbiBtaW5pbWF0Y2ggYW55d2F5LlxuICAgICAgICAvLyBBbm90aGVyIHdheSB3b3VsZCBiZSBpZiBtYXliZSBNaW5pbWF0Y2ggY291bGQgdGFrZSBpdHMgc2V0L2dsb2JQYXJ0c1xuICAgICAgICAvLyBhcyBhbiBvcHRpb24sIGFuZCB0aGVuIHdlIGNvdWxkIGF0IGxlYXN0IGp1c3QgdXNlIFBhdHRlcm4gdG8gdGVzdFxuICAgICAgICAvLyBmb3IgYWJzb2x1dGUtbmVzcy5cbiAgICAgICAgLy8gWWV0IGFub3RoZXIgd2F5LCBNaW5pbWF0Y2ggY291bGQgdGFrZSBhbiBhcnJheSBvZiBnbG9iIHN0cmluZ3MsIGFuZFxuICAgICAgICAvLyBhIGN3ZCBvcHRpb24sIGFuZCBkbyB0aGUgcmlnaHQgdGhpbmcuXG4gICAgICAgIGNvbnN0IG1tID0gbmV3IE1pbmltYXRjaChpZ24sIHRoaXMubW1vcHRzKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtbS5zZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IG1tLnNldFtpXTtcbiAgICAgICAgICAgIGNvbnN0IGdsb2JQYXJ0cyA9IG1tLmdsb2JQYXJ0c1tpXTtcbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgaWYgKCFwYXJzZWQgfHwgIWdsb2JQYXJ0cykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwYXR0ZXJuIG9iamVjdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc3RyaXAgb2ZmIGxlYWRpbmcgLi8gcG9ydGlvbnNcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9pc2FhY3Mvbm9kZS1nbG9iL2lzc3Vlcy81NzBcbiAgICAgICAgICAgIHdoaWxlIChwYXJzZWRbMF0gPT09ICcuJyAmJiBnbG9iUGFydHNbMF0gPT09ICcuJykge1xuICAgICAgICAgICAgICAgIHBhcnNlZC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIGdsb2JQYXJ0cy5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgICAgIGNvbnN0IHAgPSBuZXcgUGF0dGVybihwYXJzZWQsIGdsb2JQYXJ0cywgMCwgdGhpcy5wbGF0Zm9ybSk7XG4gICAgICAgICAgICBjb25zdCBtID0gbmV3IE1pbmltYXRjaChwLmdsb2JTdHJpbmcoKSwgdGhpcy5tbW9wdHMpO1xuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBnbG9iUGFydHNbZ2xvYlBhcnRzLmxlbmd0aCAtIDFdID09PSAnKionO1xuICAgICAgICAgICAgY29uc3QgYWJzb2x1dGUgPSBwLmlzQWJzb2x1dGUoKTtcbiAgICAgICAgICAgIGlmIChhYnNvbHV0ZSlcbiAgICAgICAgICAgICAgICB0aGlzLmFic29sdXRlLnB1c2gobSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5yZWxhdGl2ZS5wdXNoKG0pO1xuICAgICAgICAgICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFic29sdXRlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFic29sdXRlQ2hpbGRyZW4ucHVzaChtKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVsYXRpdmVDaGlsZHJlbi5wdXNoKG0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlnbm9yZWQocCkge1xuICAgICAgICBjb25zdCBmdWxscGF0aCA9IHAuZnVsbHBhdGgoKTtcbiAgICAgICAgY29uc3QgZnVsbHBhdGhzID0gYCR7ZnVsbHBhdGh9L2A7XG4gICAgICAgIGNvbnN0IHJlbGF0aXZlID0gcC5yZWxhdGl2ZSgpIHx8ICcuJztcbiAgICAgICAgY29uc3QgcmVsYXRpdmVzID0gYCR7cmVsYXRpdmV9L2A7XG4gICAgICAgIGZvciAoY29uc3QgbSBvZiB0aGlzLnJlbGF0aXZlKSB7XG4gICAgICAgICAgICBpZiAobS5tYXRjaChyZWxhdGl2ZSkgfHwgbS5tYXRjaChyZWxhdGl2ZXMpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgbSBvZiB0aGlzLmFic29sdXRlKSB7XG4gICAgICAgICAgICBpZiAobS5tYXRjaChmdWxscGF0aCkgfHwgbS5tYXRjaChmdWxscGF0aHMpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY2hpbGRyZW5JZ25vcmVkKHApIHtcbiAgICAgICAgY29uc3QgZnVsbHBhdGggPSBwLmZ1bGxwYXRoKCkgKyAnLyc7XG4gICAgICAgIGNvbnN0IHJlbGF0aXZlID0gKHAucmVsYXRpdmUoKSB8fCAnLicpICsgJy8nO1xuICAgICAgICBmb3IgKGNvbnN0IG0gb2YgdGhpcy5yZWxhdGl2ZUNoaWxkcmVuKSB7XG4gICAgICAgICAgICBpZiAobS5tYXRjaChyZWxhdGl2ZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBtIG9mIHRoaXMuYWJzb2x1dGVDaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKG0ubWF0Y2goZnVsbHBhdGgpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pZ25vcmUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/e2b/node_modules/glob/dist/esm/ignore.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/e2b/node_modules/glob/dist/esm/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/e2b/node_modules/glob/dist/esm/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Glob: () => (/* reexport safe */ _glob_js__WEBPACK_IMPORTED_MODULE_1__.Glob),\n/* harmony export */   Ignore: () => (/* reexport safe */ _ignore_js__WEBPACK_IMPORTED_MODULE_3__.Ignore),\n/* harmony export */   escape: () => (/* reexport safe */ minimatch__WEBPACK_IMPORTED_MODULE_0__.escape),\n/* harmony export */   glob: () => (/* binding */ glob),\n/* harmony export */   globIterate: () => (/* binding */ globIterate),\n/* harmony export */   globIterateSync: () => (/* binding */ globIterateSync),\n/* harmony export */   globStream: () => (/* binding */ globStream),\n/* harmony export */   globStreamSync: () => (/* binding */ globStreamSync),\n/* harmony export */   globSync: () => (/* binding */ globSync),\n/* harmony export */   hasMagic: () => (/* reexport safe */ _has_magic_js__WEBPACK_IMPORTED_MODULE_2__.hasMagic),\n/* harmony export */   iterate: () => (/* binding */ iterate),\n/* harmony export */   iterateSync: () => (/* binding */ iterateSync),\n/* harmony export */   stream: () => (/* binding */ stream),\n/* harmony export */   streamSync: () => (/* binding */ streamSync),\n/* harmony export */   sync: () => (/* binding */ sync),\n/* harmony export */   unescape: () => (/* reexport safe */ minimatch__WEBPACK_IMPORTED_MODULE_0__.unescape)\n/* harmony export */ });\n/* harmony import */ var minimatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! minimatch */ \"(rsc)/./node_modules/e2b/node_modules/minimatch/dist/esm/index.js\");\n/* harmony import */ var _glob_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./glob.js */ \"(rsc)/./node_modules/e2b/node_modules/glob/dist/esm/glob.js\");\n/* harmony import */ var _has_magic_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./has-magic.js */ \"(rsc)/./node_modules/e2b/node_modules/glob/dist/esm/has-magic.js\");\n/* harmony import */ var _ignore_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ignore.js */ \"(rsc)/./node_modules/e2b/node_modules/glob/dist/esm/ignore.js\");\n\n\n\n\n\n\n\nfunction globStreamSync(pattern, options = {}) {\n    return new _glob_js__WEBPACK_IMPORTED_MODULE_1__.Glob(pattern, options).streamSync();\n}\nfunction globStream(pattern, options = {}) {\n    return new _glob_js__WEBPACK_IMPORTED_MODULE_1__.Glob(pattern, options).stream();\n}\nfunction globSync(pattern, options = {}) {\n    return new _glob_js__WEBPACK_IMPORTED_MODULE_1__.Glob(pattern, options).walkSync();\n}\nasync function glob_(pattern, options = {}) {\n    return new _glob_js__WEBPACK_IMPORTED_MODULE_1__.Glob(pattern, options).walk();\n}\nfunction globIterateSync(pattern, options = {}) {\n    return new _glob_js__WEBPACK_IMPORTED_MODULE_1__.Glob(pattern, options).iterateSync();\n}\nfunction globIterate(pattern, options = {}) {\n    return new _glob_js__WEBPACK_IMPORTED_MODULE_1__.Glob(pattern, options).iterate();\n}\n// aliases: glob.sync.stream() glob.stream.sync() glob.sync() etc\nconst streamSync = globStreamSync;\nconst stream = Object.assign(globStream, { sync: globStreamSync });\nconst iterateSync = globIterateSync;\nconst iterate = Object.assign(globIterate, {\n    sync: globIterateSync,\n});\nconst sync = Object.assign(globSync, {\n    stream: globStreamSync,\n    iterate: globIterateSync,\n});\nconst glob = Object.assign(glob_, {\n    glob: glob_,\n    globSync,\n    sync,\n    globStream,\n    stream,\n    globStreamSync,\n    streamSync,\n    globIterate,\n    iterate,\n    globIterateSync,\n    iterateSync,\n    Glob: _glob_js__WEBPACK_IMPORTED_MODULE_1__.Glob,\n    hasMagic: _has_magic_js__WEBPACK_IMPORTED_MODULE_2__.hasMagic,\n    escape: minimatch__WEBPACK_IMPORTED_MODULE_0__.escape,\n    unescape: minimatch__WEBPACK_IMPORTED_MODULE_0__.unescape,\n});\nglob.glob = glob;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZTJiL25vZGVfbW9kdWxlcy9nbG9iL2Rpc3QvZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTZDO0FBQ1o7QUFDUztBQUNHO0FBQ1o7QUFDUztBQUNMO0FBQzlCLDZDQUE2QztBQUNwRCxlQUFlLDBDQUFJO0FBQ25CO0FBQ08seUNBQXlDO0FBQ2hELGVBQWUsMENBQUk7QUFDbkI7QUFDTyx1Q0FBdUM7QUFDOUMsZUFBZSwwQ0FBSTtBQUNuQjtBQUNBLDBDQUEwQztBQUMxQyxlQUFlLDBDQUFJO0FBQ25CO0FBQ08sOENBQThDO0FBQ3JELGVBQWUsMENBQUk7QUFDbkI7QUFDTywwQ0FBMEM7QUFDakQsZUFBZSwwQ0FBSTtBQUNuQjtBQUNBO0FBQ087QUFDQSwyQ0FBMkMsc0JBQXNCO0FBQ2pFO0FBQ0E7QUFDUDtBQUNBLENBQUM7QUFDTTtBQUNQO0FBQ0E7QUFDQSxDQUFDO0FBQ007QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLFlBQVk7QUFDWixVQUFVO0FBQ1YsWUFBWTtBQUNaLENBQUM7QUFDRDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdml2ZS12aWJlLWFpLW5leHQvLi9ub2RlX21vZHVsZXMvZTJiL25vZGVfbW9kdWxlcy9nbG9iL2Rpc3QvZXNtL2luZGV4LmpzPzQ0ZTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZXNjYXBlLCB1bmVzY2FwZSB9IGZyb20gJ21pbmltYXRjaCc7XG5pbXBvcnQgeyBHbG9iIH0gZnJvbSAnLi9nbG9iLmpzJztcbmltcG9ydCB7IGhhc01hZ2ljIH0gZnJvbSAnLi9oYXMtbWFnaWMuanMnO1xuZXhwb3J0IHsgZXNjYXBlLCB1bmVzY2FwZSB9IGZyb20gJ21pbmltYXRjaCc7XG5leHBvcnQgeyBHbG9iIH0gZnJvbSAnLi9nbG9iLmpzJztcbmV4cG9ydCB7IGhhc01hZ2ljIH0gZnJvbSAnLi9oYXMtbWFnaWMuanMnO1xuZXhwb3J0IHsgSWdub3JlIH0gZnJvbSAnLi9pZ25vcmUuanMnO1xuZXhwb3J0IGZ1bmN0aW9uIGdsb2JTdHJlYW1TeW5jKHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBuZXcgR2xvYihwYXR0ZXJuLCBvcHRpb25zKS5zdHJlYW1TeW5jKCk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2xvYlN0cmVhbShwYXR0ZXJuLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gbmV3IEdsb2IocGF0dGVybiwgb3B0aW9ucykuc3RyZWFtKCk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2xvYlN5bmMocGF0dGVybiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBHbG9iKHBhdHRlcm4sIG9wdGlvbnMpLndhbGtTeW5jKCk7XG59XG5hc3luYyBmdW5jdGlvbiBnbG9iXyhwYXR0ZXJuLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gbmV3IEdsb2IocGF0dGVybiwgb3B0aW9ucykud2FsaygpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsb2JJdGVyYXRlU3luYyhwYXR0ZXJuLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gbmV3IEdsb2IocGF0dGVybiwgb3B0aW9ucykuaXRlcmF0ZVN5bmMoKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnbG9iSXRlcmF0ZShwYXR0ZXJuLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gbmV3IEdsb2IocGF0dGVybiwgb3B0aW9ucykuaXRlcmF0ZSgpO1xufVxuLy8gYWxpYXNlczogZ2xvYi5zeW5jLnN0cmVhbSgpIGdsb2Iuc3RyZWFtLnN5bmMoKSBnbG9iLnN5bmMoKSBldGNcbmV4cG9ydCBjb25zdCBzdHJlYW1TeW5jID0gZ2xvYlN0cmVhbVN5bmM7XG5leHBvcnQgY29uc3Qgc3RyZWFtID0gT2JqZWN0LmFzc2lnbihnbG9iU3RyZWFtLCB7IHN5bmM6IGdsb2JTdHJlYW1TeW5jIH0pO1xuZXhwb3J0IGNvbnN0IGl0ZXJhdGVTeW5jID0gZ2xvYkl0ZXJhdGVTeW5jO1xuZXhwb3J0IGNvbnN0IGl0ZXJhdGUgPSBPYmplY3QuYXNzaWduKGdsb2JJdGVyYXRlLCB7XG4gICAgc3luYzogZ2xvYkl0ZXJhdGVTeW5jLFxufSk7XG5leHBvcnQgY29uc3Qgc3luYyA9IE9iamVjdC5hc3NpZ24oZ2xvYlN5bmMsIHtcbiAgICBzdHJlYW06IGdsb2JTdHJlYW1TeW5jLFxuICAgIGl0ZXJhdGU6IGdsb2JJdGVyYXRlU3luYyxcbn0pO1xuZXhwb3J0IGNvbnN0IGdsb2IgPSBPYmplY3QuYXNzaWduKGdsb2JfLCB7XG4gICAgZ2xvYjogZ2xvYl8sXG4gICAgZ2xvYlN5bmMsXG4gICAgc3luYyxcbiAgICBnbG9iU3RyZWFtLFxuICAgIHN0cmVhbSxcbiAgICBnbG9iU3RyZWFtU3luYyxcbiAgICBzdHJlYW1TeW5jLFxuICAgIGdsb2JJdGVyYXRlLFxuICAgIGl0ZXJhdGUsXG4gICAgZ2xvYkl0ZXJhdGVTeW5jLFxuICAgIGl0ZXJhdGVTeW5jLFxuICAgIEdsb2IsXG4gICAgaGFzTWFnaWMsXG4gICAgZXNjYXBlLFxuICAgIHVuZXNjYXBlLFxufSk7XG5nbG9iLmdsb2IgPSBnbG9iO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/e2b/node_modules/glob/dist/esm/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/e2b/node_modules/glob/dist/esm/pattern.js":
/*!****************************************************************!*\
  !*** ./node_modules/e2b/node_modules/glob/dist/esm/pattern.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Pattern: () => (/* binding */ Pattern)\n/* harmony export */ });\n/* harmony import */ var minimatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! minimatch */ \"(rsc)/./node_modules/e2b/node_modules/minimatch/dist/esm/index.js\");\n// this is just a very light wrapper around 2 arrays with an offset index\n\nconst isPatternList = (pl) => pl.length >= 1;\nconst isGlobList = (gl) => gl.length >= 1;\n/**\n * An immutable-ish view on an array of glob parts and their parsed\n * results\n */\nclass Pattern {\n    #patternList;\n    #globList;\n    #index;\n    length;\n    #platform;\n    #rest;\n    #globString;\n    #isDrive;\n    #isUNC;\n    #isAbsolute;\n    #followGlobstar = true;\n    constructor(patternList, globList, index, platform) {\n        if (!isPatternList(patternList)) {\n            throw new TypeError('empty pattern list');\n        }\n        if (!isGlobList(globList)) {\n            throw new TypeError('empty glob list');\n        }\n        if (globList.length !== patternList.length) {\n            throw new TypeError('mismatched pattern list and glob list lengths');\n        }\n        this.length = patternList.length;\n        if (index < 0 || index >= this.length) {\n            throw new TypeError('index out of range');\n        }\n        this.#patternList = patternList;\n        this.#globList = globList;\n        this.#index = index;\n        this.#platform = platform;\n        // normalize root entries of absolute patterns on initial creation.\n        if (this.#index === 0) {\n            // c: => ['c:/']\n            // C:/ => ['C:/']\n            // C:/x => ['C:/', 'x']\n            // //host/share => ['//host/share/']\n            // //host/share/ => ['//host/share/']\n            // //host/share/x => ['//host/share/', 'x']\n            // /etc => ['/', 'etc']\n            // / => ['/']\n            if (this.isUNC()) {\n                // '' / '' / 'host' / 'share'\n                const [p0, p1, p2, p3, ...prest] = this.#patternList;\n                const [g0, g1, g2, g3, ...grest] = this.#globList;\n                if (prest[0] === '') {\n                    // ends in /\n                    prest.shift();\n                    grest.shift();\n                }\n                const p = [p0, p1, p2, p3, ''].join('/');\n                const g = [g0, g1, g2, g3, ''].join('/');\n                this.#patternList = [p, ...prest];\n                this.#globList = [g, ...grest];\n                this.length = this.#patternList.length;\n            }\n            else if (this.isDrive() || this.isAbsolute()) {\n                const [p1, ...prest] = this.#patternList;\n                const [g1, ...grest] = this.#globList;\n                if (prest[0] === '') {\n                    // ends in /\n                    prest.shift();\n                    grest.shift();\n                }\n                const p = p1 + '/';\n                const g = g1 + '/';\n                this.#patternList = [p, ...prest];\n                this.#globList = [g, ...grest];\n                this.length = this.#patternList.length;\n            }\n        }\n    }\n    /**\n     * The first entry in the parsed list of patterns\n     */\n    pattern() {\n        return this.#patternList[this.#index];\n    }\n    /**\n     * true of if pattern() returns a string\n     */\n    isString() {\n        return typeof this.#patternList[this.#index] === 'string';\n    }\n    /**\n     * true of if pattern() returns GLOBSTAR\n     */\n    isGlobstar() {\n        return this.#patternList[this.#index] === minimatch__WEBPACK_IMPORTED_MODULE_0__.GLOBSTAR;\n    }\n    /**\n     * true if pattern() returns a regexp\n     */\n    isRegExp() {\n        return this.#patternList[this.#index] instanceof RegExp;\n    }\n    /**\n     * The /-joined set of glob parts that make up this pattern\n     */\n    globString() {\n        return (this.#globString =\n            this.#globString ||\n                (this.#index === 0 ?\n                    this.isAbsolute() ?\n                        this.#globList[0] + this.#globList.slice(1).join('/')\n                        : this.#globList.join('/')\n                    : this.#globList.slice(this.#index).join('/')));\n    }\n    /**\n     * true if there are more pattern parts after this one\n     */\n    hasMore() {\n        return this.length > this.#index + 1;\n    }\n    /**\n     * The rest of the pattern after this part, or null if this is the end\n     */\n    rest() {\n        if (this.#rest !== undefined)\n            return this.#rest;\n        if (!this.hasMore())\n            return (this.#rest = null);\n        this.#rest = new Pattern(this.#patternList, this.#globList, this.#index + 1, this.#platform);\n        this.#rest.#isAbsolute = this.#isAbsolute;\n        this.#rest.#isUNC = this.#isUNC;\n        this.#rest.#isDrive = this.#isDrive;\n        return this.#rest;\n    }\n    /**\n     * true if the pattern represents a //unc/path/ on windows\n     */\n    isUNC() {\n        const pl = this.#patternList;\n        return this.#isUNC !== undefined ?\n            this.#isUNC\n            : (this.#isUNC =\n                this.#platform === 'win32' &&\n                    this.#index === 0 &&\n                    pl[0] === '' &&\n                    pl[1] === '' &&\n                    typeof pl[2] === 'string' &&\n                    !!pl[2] &&\n                    typeof pl[3] === 'string' &&\n                    !!pl[3]);\n    }\n    // pattern like C:/...\n    // split = ['C:', ...]\n    // XXX: would be nice to handle patterns like `c:*` to test the cwd\n    // in c: for *, but I don't know of a way to even figure out what that\n    // cwd is without actually chdir'ing into it?\n    /**\n     * True if the pattern starts with a drive letter on Windows\n     */\n    isDrive() {\n        const pl = this.#patternList;\n        return this.#isDrive !== undefined ?\n            this.#isDrive\n            : (this.#isDrive =\n                this.#platform === 'win32' &&\n                    this.#index === 0 &&\n                    this.length > 1 &&\n                    typeof pl[0] === 'string' &&\n                    /^[a-z]:$/i.test(pl[0]));\n    }\n    // pattern = '/' or '/...' or '/x/...'\n    // split = ['', ''] or ['', ...] or ['', 'x', ...]\n    // Drive and UNC both considered absolute on windows\n    /**\n     * True if the pattern is rooted on an absolute path\n     */\n    isAbsolute() {\n        const pl = this.#patternList;\n        return this.#isAbsolute !== undefined ?\n            this.#isAbsolute\n            : (this.#isAbsolute =\n                (pl[0] === '' && pl.length > 1) ||\n                    this.isDrive() ||\n                    this.isUNC());\n    }\n    /**\n     * consume the root of the pattern, and return it\n     */\n    root() {\n        const p = this.#patternList[0];\n        return (typeof p === 'string' && this.isAbsolute() && this.#index === 0) ?\n            p\n            : '';\n    }\n    /**\n     * Check to see if the current globstar pattern is allowed to follow\n     * a symbolic link.\n     */\n    checkFollowGlobstar() {\n        return !(this.#index === 0 ||\n            !this.isGlobstar() ||\n            !this.#followGlobstar);\n    }\n    /**\n     * Mark that the current globstar pattern is following a symbolic link\n     */\n    markFollowGlobstar() {\n        if (this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar)\n            return false;\n        this.#followGlobstar = false;\n        return true;\n    }\n}\n//# sourceMappingURL=pattern.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZTJiL25vZGVfbW9kdWxlcy9nbG9iL2Rpc3QvZXNtL3BhdHRlcm4uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsK0NBQVE7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpdmUtdmliZS1haS1uZXh0Ly4vbm9kZV9tb2R1bGVzL2UyYi9ub2RlX21vZHVsZXMvZ2xvYi9kaXN0L2VzbS9wYXR0ZXJuLmpzP2EyMjEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gdGhpcyBpcyBqdXN0IGEgdmVyeSBsaWdodCB3cmFwcGVyIGFyb3VuZCAyIGFycmF5cyB3aXRoIGFuIG9mZnNldCBpbmRleFxuaW1wb3J0IHsgR0xPQlNUQVIgfSBmcm9tICdtaW5pbWF0Y2gnO1xuY29uc3QgaXNQYXR0ZXJuTGlzdCA9IChwbCkgPT4gcGwubGVuZ3RoID49IDE7XG5jb25zdCBpc0dsb2JMaXN0ID0gKGdsKSA9PiBnbC5sZW5ndGggPj0gMTtcbi8qKlxuICogQW4gaW1tdXRhYmxlLWlzaCB2aWV3IG9uIGFuIGFycmF5IG9mIGdsb2IgcGFydHMgYW5kIHRoZWlyIHBhcnNlZFxuICogcmVzdWx0c1xuICovXG5leHBvcnQgY2xhc3MgUGF0dGVybiB7XG4gICAgI3BhdHRlcm5MaXN0O1xuICAgICNnbG9iTGlzdDtcbiAgICAjaW5kZXg7XG4gICAgbGVuZ3RoO1xuICAgICNwbGF0Zm9ybTtcbiAgICAjcmVzdDtcbiAgICAjZ2xvYlN0cmluZztcbiAgICAjaXNEcml2ZTtcbiAgICAjaXNVTkM7XG4gICAgI2lzQWJzb2x1dGU7XG4gICAgI2ZvbGxvd0dsb2JzdGFyID0gdHJ1ZTtcbiAgICBjb25zdHJ1Y3RvcihwYXR0ZXJuTGlzdCwgZ2xvYkxpc3QsIGluZGV4LCBwbGF0Zm9ybSkge1xuICAgICAgICBpZiAoIWlzUGF0dGVybkxpc3QocGF0dGVybkxpc3QpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbXB0eSBwYXR0ZXJuIGxpc3QnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzR2xvYkxpc3QoZ2xvYkxpc3QpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbXB0eSBnbG9iIGxpc3QnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ2xvYkxpc3QubGVuZ3RoICE9PSBwYXR0ZXJuTGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21pc21hdGNoZWQgcGF0dGVybiBsaXN0IGFuZCBnbG9iIGxpc3QgbGVuZ3RocycpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGVuZ3RoID0gcGF0dGVybkxpc3QubGVuZ3RoO1xuICAgICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbmRleCBvdXQgb2YgcmFuZ2UnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNwYXR0ZXJuTGlzdCA9IHBhdHRlcm5MaXN0O1xuICAgICAgICB0aGlzLiNnbG9iTGlzdCA9IGdsb2JMaXN0O1xuICAgICAgICB0aGlzLiNpbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLiNwbGF0Zm9ybSA9IHBsYXRmb3JtO1xuICAgICAgICAvLyBub3JtYWxpemUgcm9vdCBlbnRyaWVzIG9mIGFic29sdXRlIHBhdHRlcm5zIG9uIGluaXRpYWwgY3JlYXRpb24uXG4gICAgICAgIGlmICh0aGlzLiNpbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gYzogPT4gWydjOi8nXVxuICAgICAgICAgICAgLy8gQzovID0+IFsnQzovJ11cbiAgICAgICAgICAgIC8vIEM6L3ggPT4gWydDOi8nLCAneCddXG4gICAgICAgICAgICAvLyAvL2hvc3Qvc2hhcmUgPT4gWycvL2hvc3Qvc2hhcmUvJ11cbiAgICAgICAgICAgIC8vIC8vaG9zdC9zaGFyZS8gPT4gWycvL2hvc3Qvc2hhcmUvJ11cbiAgICAgICAgICAgIC8vIC8vaG9zdC9zaGFyZS94ID0+IFsnLy9ob3N0L3NoYXJlLycsICd4J11cbiAgICAgICAgICAgIC8vIC9ldGMgPT4gWycvJywgJ2V0YyddXG4gICAgICAgICAgICAvLyAvID0+IFsnLyddXG4gICAgICAgICAgICBpZiAodGhpcy5pc1VOQygpKSB7XG4gICAgICAgICAgICAgICAgLy8gJycgLyAnJyAvICdob3N0JyAvICdzaGFyZSdcbiAgICAgICAgICAgICAgICBjb25zdCBbcDAsIHAxLCBwMiwgcDMsIC4uLnByZXN0XSA9IHRoaXMuI3BhdHRlcm5MaXN0O1xuICAgICAgICAgICAgICAgIGNvbnN0IFtnMCwgZzEsIGcyLCBnMywgLi4uZ3Jlc3RdID0gdGhpcy4jZ2xvYkxpc3Q7XG4gICAgICAgICAgICAgICAgaWYgKHByZXN0WzBdID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBlbmRzIGluIC9cbiAgICAgICAgICAgICAgICAgICAgcHJlc3Quc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZ3Jlc3Quc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcCA9IFtwMCwgcDEsIHAyLCBwMywgJyddLmpvaW4oJy8nKTtcbiAgICAgICAgICAgICAgICBjb25zdCBnID0gW2cwLCBnMSwgZzIsIGczLCAnJ10uam9pbignLycpO1xuICAgICAgICAgICAgICAgIHRoaXMuI3BhdHRlcm5MaXN0ID0gW3AsIC4uLnByZXN0XTtcbiAgICAgICAgICAgICAgICB0aGlzLiNnbG9iTGlzdCA9IFtnLCAuLi5ncmVzdF07XG4gICAgICAgICAgICAgICAgdGhpcy5sZW5ndGggPSB0aGlzLiNwYXR0ZXJuTGlzdC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmlzRHJpdmUoKSB8fCB0aGlzLmlzQWJzb2x1dGUoKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtwMSwgLi4ucHJlc3RdID0gdGhpcy4jcGF0dGVybkxpc3Q7XG4gICAgICAgICAgICAgICAgY29uc3QgW2cxLCAuLi5ncmVzdF0gPSB0aGlzLiNnbG9iTGlzdDtcbiAgICAgICAgICAgICAgICBpZiAocHJlc3RbMF0gPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVuZHMgaW4gL1xuICAgICAgICAgICAgICAgICAgICBwcmVzdC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBncmVzdC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBwID0gcDEgKyAnLyc7XG4gICAgICAgICAgICAgICAgY29uc3QgZyA9IGcxICsgJy8nO1xuICAgICAgICAgICAgICAgIHRoaXMuI3BhdHRlcm5MaXN0ID0gW3AsIC4uLnByZXN0XTtcbiAgICAgICAgICAgICAgICB0aGlzLiNnbG9iTGlzdCA9IFtnLCAuLi5ncmVzdF07XG4gICAgICAgICAgICAgICAgdGhpcy5sZW5ndGggPSB0aGlzLiNwYXR0ZXJuTGlzdC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGZpcnN0IGVudHJ5IGluIHRoZSBwYXJzZWQgbGlzdCBvZiBwYXR0ZXJuc1xuICAgICAqL1xuICAgIHBhdHRlcm4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNwYXR0ZXJuTGlzdFt0aGlzLiNpbmRleF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHRydWUgb2YgaWYgcGF0dGVybigpIHJldHVybnMgYSBzdHJpbmdcbiAgICAgKi9cbiAgICBpc1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB0aGlzLiNwYXR0ZXJuTGlzdFt0aGlzLiNpbmRleF0gPT09ICdzdHJpbmcnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB0cnVlIG9mIGlmIHBhdHRlcm4oKSByZXR1cm5zIEdMT0JTVEFSXG4gICAgICovXG4gICAgaXNHbG9ic3RhcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3BhdHRlcm5MaXN0W3RoaXMuI2luZGV4XSA9PT0gR0xPQlNUQVI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHRydWUgaWYgcGF0dGVybigpIHJldHVybnMgYSByZWdleHBcbiAgICAgKi9cbiAgICBpc1JlZ0V4cCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3BhdHRlcm5MaXN0W3RoaXMuI2luZGV4XSBpbnN0YW5jZW9mIFJlZ0V4cDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIC8tam9pbmVkIHNldCBvZiBnbG9iIHBhcnRzIHRoYXQgbWFrZSB1cCB0aGlzIHBhdHRlcm5cbiAgICAgKi9cbiAgICBnbG9iU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuI2dsb2JTdHJpbmcgPVxuICAgICAgICAgICAgdGhpcy4jZ2xvYlN0cmluZyB8fFxuICAgICAgICAgICAgICAgICh0aGlzLiNpbmRleCA9PT0gMCA/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNBYnNvbHV0ZSgpID9cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuI2dsb2JMaXN0WzBdICsgdGhpcy4jZ2xvYkxpc3Quc2xpY2UoMSkuam9pbignLycpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMuI2dsb2JMaXN0LmpvaW4oJy8nKVxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuI2dsb2JMaXN0LnNsaWNlKHRoaXMuI2luZGV4KS5qb2luKCcvJykpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogdHJ1ZSBpZiB0aGVyZSBhcmUgbW9yZSBwYXR0ZXJuIHBhcnRzIGFmdGVyIHRoaXMgb25lXG4gICAgICovXG4gICAgaGFzTW9yZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoID4gdGhpcy4jaW5kZXggKyAxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgcmVzdCBvZiB0aGUgcGF0dGVybiBhZnRlciB0aGlzIHBhcnQsIG9yIG51bGwgaWYgdGhpcyBpcyB0aGUgZW5kXG4gICAgICovXG4gICAgcmVzdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuI3Jlc3QgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNyZXN0O1xuICAgICAgICBpZiAoIXRoaXMuaGFzTW9yZSgpKVxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLiNyZXN0ID0gbnVsbCk7XG4gICAgICAgIHRoaXMuI3Jlc3QgPSBuZXcgUGF0dGVybih0aGlzLiNwYXR0ZXJuTGlzdCwgdGhpcy4jZ2xvYkxpc3QsIHRoaXMuI2luZGV4ICsgMSwgdGhpcy4jcGxhdGZvcm0pO1xuICAgICAgICB0aGlzLiNyZXN0LiNpc0Fic29sdXRlID0gdGhpcy4jaXNBYnNvbHV0ZTtcbiAgICAgICAgdGhpcy4jcmVzdC4jaXNVTkMgPSB0aGlzLiNpc1VOQztcbiAgICAgICAgdGhpcy4jcmVzdC4jaXNEcml2ZSA9IHRoaXMuI2lzRHJpdmU7XG4gICAgICAgIHJldHVybiB0aGlzLiNyZXN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB0cnVlIGlmIHRoZSBwYXR0ZXJuIHJlcHJlc2VudHMgYSAvL3VuYy9wYXRoLyBvbiB3aW5kb3dzXG4gICAgICovXG4gICAgaXNVTkMoKSB7XG4gICAgICAgIGNvbnN0IHBsID0gdGhpcy4jcGF0dGVybkxpc3Q7XG4gICAgICAgIHJldHVybiB0aGlzLiNpc1VOQyAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgIHRoaXMuI2lzVU5DXG4gICAgICAgICAgICA6ICh0aGlzLiNpc1VOQyA9XG4gICAgICAgICAgICAgICAgdGhpcy4jcGxhdGZvcm0gPT09ICd3aW4zMicgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jaW5kZXggPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgcGxbMF0gPT09ICcnICYmXG4gICAgICAgICAgICAgICAgICAgIHBsWzFdID09PSAnJyAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgcGxbMl0gPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgICAgICEhcGxbMl0gJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHBsWzNdID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgICAgICAgICAhIXBsWzNdKTtcbiAgICB9XG4gICAgLy8gcGF0dGVybiBsaWtlIEM6Ly4uLlxuICAgIC8vIHNwbGl0ID0gWydDOicsIC4uLl1cbiAgICAvLyBYWFg6IHdvdWxkIGJlIG5pY2UgdG8gaGFuZGxlIHBhdHRlcm5zIGxpa2UgYGM6KmAgdG8gdGVzdCB0aGUgY3dkXG4gICAgLy8gaW4gYzogZm9yICosIGJ1dCBJIGRvbid0IGtub3cgb2YgYSB3YXkgdG8gZXZlbiBmaWd1cmUgb3V0IHdoYXQgdGhhdFxuICAgIC8vIGN3ZCBpcyB3aXRob3V0IGFjdHVhbGx5IGNoZGlyJ2luZyBpbnRvIGl0P1xuICAgIC8qKlxuICAgICAqIFRydWUgaWYgdGhlIHBhdHRlcm4gc3RhcnRzIHdpdGggYSBkcml2ZSBsZXR0ZXIgb24gV2luZG93c1xuICAgICAqL1xuICAgIGlzRHJpdmUoKSB7XG4gICAgICAgIGNvbnN0IHBsID0gdGhpcy4jcGF0dGVybkxpc3Q7XG4gICAgICAgIHJldHVybiB0aGlzLiNpc0RyaXZlICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgdGhpcy4jaXNEcml2ZVxuICAgICAgICAgICAgOiAodGhpcy4jaXNEcml2ZSA9XG4gICAgICAgICAgICAgICAgdGhpcy4jcGxhdGZvcm0gPT09ICd3aW4zMicgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jaW5kZXggPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sZW5ndGggPiAxICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBwbFswXSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgICAgICAgICAgL15bYS16XTokL2kudGVzdChwbFswXSkpO1xuICAgIH1cbiAgICAvLyBwYXR0ZXJuID0gJy8nIG9yICcvLi4uJyBvciAnL3gvLi4uJ1xuICAgIC8vIHNwbGl0ID0gWycnLCAnJ10gb3IgWycnLCAuLi5dIG9yIFsnJywgJ3gnLCAuLi5dXG4gICAgLy8gRHJpdmUgYW5kIFVOQyBib3RoIGNvbnNpZGVyZWQgYWJzb2x1dGUgb24gd2luZG93c1xuICAgIC8qKlxuICAgICAqIFRydWUgaWYgdGhlIHBhdHRlcm4gaXMgcm9vdGVkIG9uIGFuIGFic29sdXRlIHBhdGhcbiAgICAgKi9cbiAgICBpc0Fic29sdXRlKCkge1xuICAgICAgICBjb25zdCBwbCA9IHRoaXMuI3BhdHRlcm5MaXN0O1xuICAgICAgICByZXR1cm4gdGhpcy4jaXNBYnNvbHV0ZSAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgIHRoaXMuI2lzQWJzb2x1dGVcbiAgICAgICAgICAgIDogKHRoaXMuI2lzQWJzb2x1dGUgPVxuICAgICAgICAgICAgICAgIChwbFswXSA9PT0gJycgJiYgcGwubGVuZ3RoID4gMSkgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc0RyaXZlKCkgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc1VOQygpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogY29uc3VtZSB0aGUgcm9vdCBvZiB0aGUgcGF0dGVybiwgYW5kIHJldHVybiBpdFxuICAgICAqL1xuICAgIHJvb3QoKSB7XG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLiNwYXR0ZXJuTGlzdFswXTtcbiAgICAgICAgcmV0dXJuICh0eXBlb2YgcCA9PT0gJ3N0cmluZycgJiYgdGhpcy5pc0Fic29sdXRlKCkgJiYgdGhpcy4jaW5kZXggPT09IDApID9cbiAgICAgICAgICAgIHBcbiAgICAgICAgICAgIDogJyc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIHRvIHNlZSBpZiB0aGUgY3VycmVudCBnbG9ic3RhciBwYXR0ZXJuIGlzIGFsbG93ZWQgdG8gZm9sbG93XG4gICAgICogYSBzeW1ib2xpYyBsaW5rLlxuICAgICAqL1xuICAgIGNoZWNrRm9sbG93R2xvYnN0YXIoKSB7XG4gICAgICAgIHJldHVybiAhKHRoaXMuI2luZGV4ID09PSAwIHx8XG4gICAgICAgICAgICAhdGhpcy5pc0dsb2JzdGFyKCkgfHxcbiAgICAgICAgICAgICF0aGlzLiNmb2xsb3dHbG9ic3Rhcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hcmsgdGhhdCB0aGUgY3VycmVudCBnbG9ic3RhciBwYXR0ZXJuIGlzIGZvbGxvd2luZyBhIHN5bWJvbGljIGxpbmtcbiAgICAgKi9cbiAgICBtYXJrRm9sbG93R2xvYnN0YXIoKSB7XG4gICAgICAgIGlmICh0aGlzLiNpbmRleCA9PT0gMCB8fCAhdGhpcy5pc0dsb2JzdGFyKCkgfHwgIXRoaXMuI2ZvbGxvd0dsb2JzdGFyKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLiNmb2xsb3dHbG9ic3RhciA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXR0ZXJuLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/e2b/node_modules/glob/dist/esm/pattern.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/e2b/node_modules/glob/dist/esm/processor.js":
/*!******************************************************************!*\
  !*** ./node_modules/e2b/node_modules/glob/dist/esm/processor.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HasWalkedCache: () => (/* binding */ HasWalkedCache),\n/* harmony export */   MatchRecord: () => (/* binding */ MatchRecord),\n/* harmony export */   Processor: () => (/* binding */ Processor),\n/* harmony export */   SubWalks: () => (/* binding */ SubWalks)\n/* harmony export */ });\n/* harmony import */ var minimatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! minimatch */ \"(rsc)/./node_modules/e2b/node_modules/minimatch/dist/esm/index.js\");\n// synchronous utility for filtering entries and calculating subwalks\n\n/**\n * A cache of which patterns have been processed for a given Path\n */\nclass HasWalkedCache {\n    store;\n    constructor(store = new Map()) {\n        this.store = store;\n    }\n    copy() {\n        return new HasWalkedCache(new Map(this.store));\n    }\n    hasWalked(target, pattern) {\n        return this.store.get(target.fullpath())?.has(pattern.globString());\n    }\n    storeWalked(target, pattern) {\n        const fullpath = target.fullpath();\n        const cached = this.store.get(fullpath);\n        if (cached)\n            cached.add(pattern.globString());\n        else\n            this.store.set(fullpath, new Set([pattern.globString()]));\n    }\n}\n/**\n * A record of which paths have been matched in a given walk step,\n * and whether they only are considered a match if they are a directory,\n * and whether their absolute or relative path should be returned.\n */\nclass MatchRecord {\n    store = new Map();\n    add(target, absolute, ifDir) {\n        const n = (absolute ? 2 : 0) | (ifDir ? 1 : 0);\n        const current = this.store.get(target);\n        this.store.set(target, current === undefined ? n : n & current);\n    }\n    // match, absolute, ifdir\n    entries() {\n        return [...this.store.entries()].map(([path, n]) => [\n            path,\n            !!(n & 2),\n            !!(n & 1),\n        ]);\n    }\n}\n/**\n * A collection of patterns that must be processed in a subsequent step\n * for a given path.\n */\nclass SubWalks {\n    store = new Map();\n    add(target, pattern) {\n        if (!target.canReaddir()) {\n            return;\n        }\n        const subs = this.store.get(target);\n        if (subs) {\n            if (!subs.find(p => p.globString() === pattern.globString())) {\n                subs.push(pattern);\n            }\n        }\n        else\n            this.store.set(target, [pattern]);\n    }\n    get(target) {\n        const subs = this.store.get(target);\n        /* c8 ignore start */\n        if (!subs) {\n            throw new Error('attempting to walk unknown path');\n        }\n        /* c8 ignore stop */\n        return subs;\n    }\n    entries() {\n        return this.keys().map(k => [k, this.store.get(k)]);\n    }\n    keys() {\n        return [...this.store.keys()].filter(t => t.canReaddir());\n    }\n}\n/**\n * The class that processes patterns for a given path.\n *\n * Handles child entry filtering, and determining whether a path's\n * directory contents must be read.\n */\nclass Processor {\n    hasWalkedCache;\n    matches = new MatchRecord();\n    subwalks = new SubWalks();\n    patterns;\n    follow;\n    dot;\n    opts;\n    constructor(opts, hasWalkedCache) {\n        this.opts = opts;\n        this.follow = !!opts.follow;\n        this.dot = !!opts.dot;\n        this.hasWalkedCache =\n            hasWalkedCache ? hasWalkedCache.copy() : new HasWalkedCache();\n    }\n    processPatterns(target, patterns) {\n        this.patterns = patterns;\n        const processingSet = patterns.map(p => [target, p]);\n        // map of paths to the magic-starting subwalks they need to walk\n        // first item in patterns is the filter\n        for (let [t, pattern] of processingSet) {\n            this.hasWalkedCache.storeWalked(t, pattern);\n            const root = pattern.root();\n            const absolute = pattern.isAbsolute() && this.opts.absolute !== false;\n            // start absolute patterns at root\n            if (root) {\n                t = t.resolve(root === '/' && this.opts.root !== undefined ?\n                    this.opts.root\n                    : root);\n                const rest = pattern.rest();\n                if (!rest) {\n                    this.matches.add(t, true, false);\n                    continue;\n                }\n                else {\n                    pattern = rest;\n                }\n            }\n            if (t.isENOENT())\n                continue;\n            let p;\n            let rest;\n            let changed = false;\n            while (typeof (p = pattern.pattern()) === 'string' &&\n                (rest = pattern.rest())) {\n                const c = t.resolve(p);\n                t = c;\n                pattern = rest;\n                changed = true;\n            }\n            p = pattern.pattern();\n            rest = pattern.rest();\n            if (changed) {\n                if (this.hasWalkedCache.hasWalked(t, pattern))\n                    continue;\n                this.hasWalkedCache.storeWalked(t, pattern);\n            }\n            // now we have either a final string for a known entry,\n            // more strings for an unknown entry,\n            // or a pattern starting with magic, mounted on t.\n            if (typeof p === 'string') {\n                // must not be final entry, otherwise we would have\n                // concatenated it earlier.\n                const ifDir = p === '..' || p === '' || p === '.';\n                this.matches.add(t.resolve(p), absolute, ifDir);\n                continue;\n            }\n            else if (p === minimatch__WEBPACK_IMPORTED_MODULE_0__.GLOBSTAR) {\n                // if no rest, match and subwalk pattern\n                // if rest, process rest and subwalk pattern\n                // if it's a symlink, but we didn't get here by way of a\n                // globstar match (meaning it's the first time THIS globstar\n                // has traversed a symlink), then we follow it. Otherwise, stop.\n                if (!t.isSymbolicLink() ||\n                    this.follow ||\n                    pattern.checkFollowGlobstar()) {\n                    this.subwalks.add(t, pattern);\n                }\n                const rp = rest?.pattern();\n                const rrest = rest?.rest();\n                if (!rest || ((rp === '' || rp === '.') && !rrest)) {\n                    // only HAS to be a dir if it ends in **/ or **/.\n                    // but ending in ** will match files as well.\n                    this.matches.add(t, absolute, rp === '' || rp === '.');\n                }\n                else {\n                    if (rp === '..') {\n                        // this would mean you're matching **/.. at the fs root,\n                        // and no thanks, I'm not gonna test that specific case.\n                        /* c8 ignore start */\n                        const tp = t.parent || t;\n                        /* c8 ignore stop */\n                        if (!rrest)\n                            this.matches.add(tp, absolute, true);\n                        else if (!this.hasWalkedCache.hasWalked(tp, rrest)) {\n                            this.subwalks.add(tp, rrest);\n                        }\n                    }\n                }\n            }\n            else if (p instanceof RegExp) {\n                this.subwalks.add(t, pattern);\n            }\n        }\n        return this;\n    }\n    subwalkTargets() {\n        return this.subwalks.keys();\n    }\n    child() {\n        return new Processor(this.opts, this.hasWalkedCache);\n    }\n    // return a new Processor containing the subwalks for each\n    // child entry, and a set of matches, and\n    // a hasWalkedCache that's a copy of this one\n    // then we're going to call\n    filterEntries(parent, entries) {\n        const patterns = this.subwalks.get(parent);\n        // put matches and entry walks into the results processor\n        const results = this.child();\n        for (const e of entries) {\n            for (const pattern of patterns) {\n                const absolute = pattern.isAbsolute();\n                const p = pattern.pattern();\n                const rest = pattern.rest();\n                if (p === minimatch__WEBPACK_IMPORTED_MODULE_0__.GLOBSTAR) {\n                    results.testGlobstar(e, pattern, rest, absolute);\n                }\n                else if (p instanceof RegExp) {\n                    results.testRegExp(e, p, rest, absolute);\n                }\n                else {\n                    results.testString(e, p, rest, absolute);\n                }\n            }\n        }\n        return results;\n    }\n    testGlobstar(e, pattern, rest, absolute) {\n        if (this.dot || !e.name.startsWith('.')) {\n            if (!pattern.hasMore()) {\n                this.matches.add(e, absolute, false);\n            }\n            if (e.canReaddir()) {\n                // if we're in follow mode or it's not a symlink, just keep\n                // testing the same pattern. If there's more after the globstar,\n                // then this symlink consumes the globstar. If not, then we can\n                // follow at most ONE symlink along the way, so we mark it, which\n                // also checks to ensure that it wasn't already marked.\n                if (this.follow || !e.isSymbolicLink()) {\n                    this.subwalks.add(e, pattern);\n                }\n                else if (e.isSymbolicLink()) {\n                    if (rest && pattern.checkFollowGlobstar()) {\n                        this.subwalks.add(e, rest);\n                    }\n                    else if (pattern.markFollowGlobstar()) {\n                        this.subwalks.add(e, pattern);\n                    }\n                }\n            }\n        }\n        // if the NEXT thing matches this entry, then also add\n        // the rest.\n        if (rest) {\n            const rp = rest.pattern();\n            if (typeof rp === 'string' &&\n                // dots and empty were handled already\n                rp !== '..' &&\n                rp !== '' &&\n                rp !== '.') {\n                this.testString(e, rp, rest.rest(), absolute);\n            }\n            else if (rp === '..') {\n                /* c8 ignore start */\n                const ep = e.parent || e;\n                /* c8 ignore stop */\n                this.subwalks.add(ep, rest);\n            }\n            else if (rp instanceof RegExp) {\n                this.testRegExp(e, rp, rest.rest(), absolute);\n            }\n        }\n    }\n    testRegExp(e, p, rest, absolute) {\n        if (!p.test(e.name))\n            return;\n        if (!rest) {\n            this.matches.add(e, absolute, false);\n        }\n        else {\n            this.subwalks.add(e, rest);\n        }\n    }\n    testString(e, p, rest, absolute) {\n        // should never happen?\n        if (!e.isNamed(p))\n            return;\n        if (!rest) {\n            this.matches.add(e, absolute, false);\n        }\n        else {\n            this.subwalks.add(e, rest);\n        }\n    }\n}\n//# sourceMappingURL=processor.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZTJiL25vZGVfbW9kdWxlcy9nbG9iL2Rpc3QvZXNtL3Byb2Nlc3Nvci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ3FDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsK0NBQVE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLCtDQUFRO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpdmUtdmliZS1haS1uZXh0Ly4vbm9kZV9tb2R1bGVzL2UyYi9ub2RlX21vZHVsZXMvZ2xvYi9kaXN0L2VzbS9wcm9jZXNzb3IuanM/N2I5NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzeW5jaHJvbm91cyB1dGlsaXR5IGZvciBmaWx0ZXJpbmcgZW50cmllcyBhbmQgY2FsY3VsYXRpbmcgc3Vid2Fsa3NcbmltcG9ydCB7IEdMT0JTVEFSIH0gZnJvbSAnbWluaW1hdGNoJztcbi8qKlxuICogQSBjYWNoZSBvZiB3aGljaCBwYXR0ZXJucyBoYXZlIGJlZW4gcHJvY2Vzc2VkIGZvciBhIGdpdmVuIFBhdGhcbiAqL1xuZXhwb3J0IGNsYXNzIEhhc1dhbGtlZENhY2hlIHtcbiAgICBzdG9yZTtcbiAgICBjb25zdHJ1Y3RvcihzdG9yZSA9IG5ldyBNYXAoKSkge1xuICAgICAgICB0aGlzLnN0b3JlID0gc3RvcmU7XG4gICAgfVxuICAgIGNvcHkoKSB7XG4gICAgICAgIHJldHVybiBuZXcgSGFzV2Fsa2VkQ2FjaGUobmV3IE1hcCh0aGlzLnN0b3JlKSk7XG4gICAgfVxuICAgIGhhc1dhbGtlZCh0YXJnZXQsIHBhdHRlcm4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmUuZ2V0KHRhcmdldC5mdWxscGF0aCgpKT8uaGFzKHBhdHRlcm4uZ2xvYlN0cmluZygpKTtcbiAgICB9XG4gICAgc3RvcmVXYWxrZWQodGFyZ2V0LCBwYXR0ZXJuKSB7XG4gICAgICAgIGNvbnN0IGZ1bGxwYXRoID0gdGFyZ2V0LmZ1bGxwYXRoKCk7XG4gICAgICAgIGNvbnN0IGNhY2hlZCA9IHRoaXMuc3RvcmUuZ2V0KGZ1bGxwYXRoKTtcbiAgICAgICAgaWYgKGNhY2hlZClcbiAgICAgICAgICAgIGNhY2hlZC5hZGQocGF0dGVybi5nbG9iU3RyaW5nKCkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnN0b3JlLnNldChmdWxscGF0aCwgbmV3IFNldChbcGF0dGVybi5nbG9iU3RyaW5nKCldKSk7XG4gICAgfVxufVxuLyoqXG4gKiBBIHJlY29yZCBvZiB3aGljaCBwYXRocyBoYXZlIGJlZW4gbWF0Y2hlZCBpbiBhIGdpdmVuIHdhbGsgc3RlcCxcbiAqIGFuZCB3aGV0aGVyIHRoZXkgb25seSBhcmUgY29uc2lkZXJlZCBhIG1hdGNoIGlmIHRoZXkgYXJlIGEgZGlyZWN0b3J5LFxuICogYW5kIHdoZXRoZXIgdGhlaXIgYWJzb2x1dGUgb3IgcmVsYXRpdmUgcGF0aCBzaG91bGQgYmUgcmV0dXJuZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBNYXRjaFJlY29yZCB7XG4gICAgc3RvcmUgPSBuZXcgTWFwKCk7XG4gICAgYWRkKHRhcmdldCwgYWJzb2x1dGUsIGlmRGlyKSB7XG4gICAgICAgIGNvbnN0IG4gPSAoYWJzb2x1dGUgPyAyIDogMCkgfCAoaWZEaXIgPyAxIDogMCk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLnN0b3JlLmdldCh0YXJnZXQpO1xuICAgICAgICB0aGlzLnN0b3JlLnNldCh0YXJnZXQsIGN1cnJlbnQgPT09IHVuZGVmaW5lZCA/IG4gOiBuICYgY3VycmVudCk7XG4gICAgfVxuICAgIC8vIG1hdGNoLCBhYnNvbHV0ZSwgaWZkaXJcbiAgICBlbnRyaWVzKCkge1xuICAgICAgICByZXR1cm4gWy4uLnRoaXMuc3RvcmUuZW50cmllcygpXS5tYXAoKFtwYXRoLCBuXSkgPT4gW1xuICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgICEhKG4gJiAyKSxcbiAgICAgICAgICAgICEhKG4gJiAxKSxcbiAgICAgICAgXSk7XG4gICAgfVxufVxuLyoqXG4gKiBBIGNvbGxlY3Rpb24gb2YgcGF0dGVybnMgdGhhdCBtdXN0IGJlIHByb2Nlc3NlZCBpbiBhIHN1YnNlcXVlbnQgc3RlcFxuICogZm9yIGEgZ2l2ZW4gcGF0aC5cbiAqL1xuZXhwb3J0IGNsYXNzIFN1YldhbGtzIHtcbiAgICBzdG9yZSA9IG5ldyBNYXAoKTtcbiAgICBhZGQodGFyZ2V0LCBwYXR0ZXJuKSB7XG4gICAgICAgIGlmICghdGFyZ2V0LmNhblJlYWRkaXIoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN1YnMgPSB0aGlzLnN0b3JlLmdldCh0YXJnZXQpO1xuICAgICAgICBpZiAoc3Vicykge1xuICAgICAgICAgICAgaWYgKCFzdWJzLmZpbmQocCA9PiBwLmdsb2JTdHJpbmcoKSA9PT0gcGF0dGVybi5nbG9iU3RyaW5nKCkpKSB7XG4gICAgICAgICAgICAgICAgc3Vicy5wdXNoKHBhdHRlcm4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuc3RvcmUuc2V0KHRhcmdldCwgW3BhdHRlcm5dKTtcbiAgICB9XG4gICAgZ2V0KHRhcmdldCkge1xuICAgICAgICBjb25zdCBzdWJzID0gdGhpcy5zdG9yZS5nZXQodGFyZ2V0KTtcbiAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIGlmICghc3Vicykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhdHRlbXB0aW5nIHRvIHdhbGsgdW5rbm93biBwYXRoJyk7XG4gICAgICAgIH1cbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgcmV0dXJuIHN1YnM7XG4gICAgfVxuICAgIGVudHJpZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleXMoKS5tYXAoayA9PiBbaywgdGhpcy5zdG9yZS5nZXQoayldKTtcbiAgICB9XG4gICAga2V5cygpIHtcbiAgICAgICAgcmV0dXJuIFsuLi50aGlzLnN0b3JlLmtleXMoKV0uZmlsdGVyKHQgPT4gdC5jYW5SZWFkZGlyKCkpO1xuICAgIH1cbn1cbi8qKlxuICogVGhlIGNsYXNzIHRoYXQgcHJvY2Vzc2VzIHBhdHRlcm5zIGZvciBhIGdpdmVuIHBhdGguXG4gKlxuICogSGFuZGxlcyBjaGlsZCBlbnRyeSBmaWx0ZXJpbmcsIGFuZCBkZXRlcm1pbmluZyB3aGV0aGVyIGEgcGF0aCdzXG4gKiBkaXJlY3RvcnkgY29udGVudHMgbXVzdCBiZSByZWFkLlxuICovXG5leHBvcnQgY2xhc3MgUHJvY2Vzc29yIHtcbiAgICBoYXNXYWxrZWRDYWNoZTtcbiAgICBtYXRjaGVzID0gbmV3IE1hdGNoUmVjb3JkKCk7XG4gICAgc3Vid2Fsa3MgPSBuZXcgU3ViV2Fsa3MoKTtcbiAgICBwYXR0ZXJucztcbiAgICBmb2xsb3c7XG4gICAgZG90O1xuICAgIG9wdHM7XG4gICAgY29uc3RydWN0b3Iob3B0cywgaGFzV2Fsa2VkQ2FjaGUpIHtcbiAgICAgICAgdGhpcy5vcHRzID0gb3B0cztcbiAgICAgICAgdGhpcy5mb2xsb3cgPSAhIW9wdHMuZm9sbG93O1xuICAgICAgICB0aGlzLmRvdCA9ICEhb3B0cy5kb3Q7XG4gICAgICAgIHRoaXMuaGFzV2Fsa2VkQ2FjaGUgPVxuICAgICAgICAgICAgaGFzV2Fsa2VkQ2FjaGUgPyBoYXNXYWxrZWRDYWNoZS5jb3B5KCkgOiBuZXcgSGFzV2Fsa2VkQ2FjaGUoKTtcbiAgICB9XG4gICAgcHJvY2Vzc1BhdHRlcm5zKHRhcmdldCwgcGF0dGVybnMpIHtcbiAgICAgICAgdGhpcy5wYXR0ZXJucyA9IHBhdHRlcm5zO1xuICAgICAgICBjb25zdCBwcm9jZXNzaW5nU2V0ID0gcGF0dGVybnMubWFwKHAgPT4gW3RhcmdldCwgcF0pO1xuICAgICAgICAvLyBtYXAgb2YgcGF0aHMgdG8gdGhlIG1hZ2ljLXN0YXJ0aW5nIHN1YndhbGtzIHRoZXkgbmVlZCB0byB3YWxrXG4gICAgICAgIC8vIGZpcnN0IGl0ZW0gaW4gcGF0dGVybnMgaXMgdGhlIGZpbHRlclxuICAgICAgICBmb3IgKGxldCBbdCwgcGF0dGVybl0gb2YgcHJvY2Vzc2luZ1NldCkge1xuICAgICAgICAgICAgdGhpcy5oYXNXYWxrZWRDYWNoZS5zdG9yZVdhbGtlZCh0LCBwYXR0ZXJuKTtcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSBwYXR0ZXJuLnJvb3QoKTtcbiAgICAgICAgICAgIGNvbnN0IGFic29sdXRlID0gcGF0dGVybi5pc0Fic29sdXRlKCkgJiYgdGhpcy5vcHRzLmFic29sdXRlICE9PSBmYWxzZTtcbiAgICAgICAgICAgIC8vIHN0YXJ0IGFic29sdXRlIHBhdHRlcm5zIGF0IHJvb3RcbiAgICAgICAgICAgIGlmIChyb290KSB7XG4gICAgICAgICAgICAgICAgdCA9IHQucmVzb2x2ZShyb290ID09PSAnLycgJiYgdGhpcy5vcHRzLnJvb3QgIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0cy5yb290XG4gICAgICAgICAgICAgICAgICAgIDogcm9vdCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdCA9IHBhdHRlcm4ucmVzdCgpO1xuICAgICAgICAgICAgICAgIGlmICghcmVzdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoZXMuYWRkKHQsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuID0gcmVzdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodC5pc0VOT0VOVCgpKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgbGV0IHA7XG4gICAgICAgICAgICBsZXQgcmVzdDtcbiAgICAgICAgICAgIGxldCBjaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgICAgICB3aGlsZSAodHlwZW9mIChwID0gcGF0dGVybi5wYXR0ZXJuKCkpID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgICAgIChyZXN0ID0gcGF0dGVybi5yZXN0KCkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYyA9IHQucmVzb2x2ZShwKTtcbiAgICAgICAgICAgICAgICB0ID0gYztcbiAgICAgICAgICAgICAgICBwYXR0ZXJuID0gcmVzdDtcbiAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHAgPSBwYXR0ZXJuLnBhdHRlcm4oKTtcbiAgICAgICAgICAgIHJlc3QgPSBwYXR0ZXJuLnJlc3QoKTtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzV2Fsa2VkQ2FjaGUuaGFzV2Fsa2VkKHQsIHBhdHRlcm4pKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmhhc1dhbGtlZENhY2hlLnN0b3JlV2Fsa2VkKHQsIHBhdHRlcm4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbm93IHdlIGhhdmUgZWl0aGVyIGEgZmluYWwgc3RyaW5nIGZvciBhIGtub3duIGVudHJ5LFxuICAgICAgICAgICAgLy8gbW9yZSBzdHJpbmdzIGZvciBhbiB1bmtub3duIGVudHJ5LFxuICAgICAgICAgICAgLy8gb3IgYSBwYXR0ZXJuIHN0YXJ0aW5nIHdpdGggbWFnaWMsIG1vdW50ZWQgb24gdC5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvLyBtdXN0IG5vdCBiZSBmaW5hbCBlbnRyeSwgb3RoZXJ3aXNlIHdlIHdvdWxkIGhhdmVcbiAgICAgICAgICAgICAgICAvLyBjb25jYXRlbmF0ZWQgaXQgZWFybGllci5cbiAgICAgICAgICAgICAgICBjb25zdCBpZkRpciA9IHAgPT09ICcuLicgfHwgcCA9PT0gJycgfHwgcCA9PT0gJy4nO1xuICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hlcy5hZGQodC5yZXNvbHZlKHApLCBhYnNvbHV0ZSwgaWZEaXIpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocCA9PT0gR0xPQlNUQVIpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBubyByZXN0LCBtYXRjaCBhbmQgc3Vid2FsayBwYXR0ZXJuXG4gICAgICAgICAgICAgICAgLy8gaWYgcmVzdCwgcHJvY2VzcyByZXN0IGFuZCBzdWJ3YWxrIHBhdHRlcm5cbiAgICAgICAgICAgICAgICAvLyBpZiBpdCdzIGEgc3ltbGluaywgYnV0IHdlIGRpZG4ndCBnZXQgaGVyZSBieSB3YXkgb2YgYVxuICAgICAgICAgICAgICAgIC8vIGdsb2JzdGFyIG1hdGNoIChtZWFuaW5nIGl0J3MgdGhlIGZpcnN0IHRpbWUgVEhJUyBnbG9ic3RhclxuICAgICAgICAgICAgICAgIC8vIGhhcyB0cmF2ZXJzZWQgYSBzeW1saW5rKSwgdGhlbiB3ZSBmb2xsb3cgaXQuIE90aGVyd2lzZSwgc3RvcC5cbiAgICAgICAgICAgICAgICBpZiAoIXQuaXNTeW1ib2xpY0xpbmsoKSB8fFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZvbGxvdyB8fFxuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuLmNoZWNrRm9sbG93R2xvYnN0YXIoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN1YndhbGtzLmFkZCh0LCBwYXR0ZXJuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcnAgPSByZXN0Py5wYXR0ZXJuKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcnJlc3QgPSByZXN0Py5yZXN0KCk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXN0IHx8ICgocnAgPT09ICcnIHx8IHJwID09PSAnLicpICYmICFycmVzdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gb25seSBIQVMgdG8gYmUgYSBkaXIgaWYgaXQgZW5kcyBpbiAqKi8gb3IgKiovLlxuICAgICAgICAgICAgICAgICAgICAvLyBidXQgZW5kaW5nIGluICoqIHdpbGwgbWF0Y2ggZmlsZXMgYXMgd2VsbC5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaGVzLmFkZCh0LCBhYnNvbHV0ZSwgcnAgPT09ICcnIHx8IHJwID09PSAnLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJwID09PSAnLi4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHdvdWxkIG1lYW4geW91J3JlIG1hdGNoaW5nICoqLy4uIGF0IHRoZSBmcyByb290LFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIG5vIHRoYW5rcywgSSdtIG5vdCBnb25uYSB0ZXN0IHRoYXQgc3BlY2lmaWMgY2FzZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHAgPSB0LnBhcmVudCB8fCB0O1xuICAgICAgICAgICAgICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcnJlc3QpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaGVzLmFkZCh0cCwgYWJzb2x1dGUsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMuaGFzV2Fsa2VkQ2FjaGUuaGFzV2Fsa2VkKHRwLCBycmVzdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN1YndhbGtzLmFkZCh0cCwgcnJlc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3Vid2Fsa3MuYWRkKHQsIHBhdHRlcm4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzdWJ3YWxrVGFyZ2V0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3Vid2Fsa3Mua2V5cygpO1xuICAgIH1cbiAgICBjaGlsZCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9jZXNzb3IodGhpcy5vcHRzLCB0aGlzLmhhc1dhbGtlZENhY2hlKTtcbiAgICB9XG4gICAgLy8gcmV0dXJuIGEgbmV3IFByb2Nlc3NvciBjb250YWluaW5nIHRoZSBzdWJ3YWxrcyBmb3IgZWFjaFxuICAgIC8vIGNoaWxkIGVudHJ5LCBhbmQgYSBzZXQgb2YgbWF0Y2hlcywgYW5kXG4gICAgLy8gYSBoYXNXYWxrZWRDYWNoZSB0aGF0J3MgYSBjb3B5IG9mIHRoaXMgb25lXG4gICAgLy8gdGhlbiB3ZSdyZSBnb2luZyB0byBjYWxsXG4gICAgZmlsdGVyRW50cmllcyhwYXJlbnQsIGVudHJpZXMpIHtcbiAgICAgICAgY29uc3QgcGF0dGVybnMgPSB0aGlzLnN1YndhbGtzLmdldChwYXJlbnQpO1xuICAgICAgICAvLyBwdXQgbWF0Y2hlcyBhbmQgZW50cnkgd2Fsa3MgaW50byB0aGUgcmVzdWx0cyBwcm9jZXNzb3JcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IHRoaXMuY2hpbGQoKTtcbiAgICAgICAgZm9yIChjb25zdCBlIG9mIGVudHJpZXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGF0dGVybiBvZiBwYXR0ZXJucykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFic29sdXRlID0gcGF0dGVybi5pc0Fic29sdXRlKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcCA9IHBhdHRlcm4ucGF0dGVybigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3QgPSBwYXR0ZXJuLnJlc3QoKTtcbiAgICAgICAgICAgICAgICBpZiAocCA9PT0gR0xPQlNUQVIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy50ZXN0R2xvYnN0YXIoZSwgcGF0dGVybiwgcmVzdCwgYWJzb2x1dGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMudGVzdFJlZ0V4cChlLCBwLCByZXN0LCBhYnNvbHV0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnRlc3RTdHJpbmcoZSwgcCwgcmVzdCwgYWJzb2x1dGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG4gICAgdGVzdEdsb2JzdGFyKGUsIHBhdHRlcm4sIHJlc3QsIGFic29sdXRlKSB7XG4gICAgICAgIGlmICh0aGlzLmRvdCB8fCAhZS5uYW1lLnN0YXJ0c1dpdGgoJy4nKSkge1xuICAgICAgICAgICAgaWYgKCFwYXR0ZXJuLmhhc01vcmUoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hlcy5hZGQoZSwgYWJzb2x1dGUsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlLmNhblJlYWRkaXIoKSkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHdlJ3JlIGluIGZvbGxvdyBtb2RlIG9yIGl0J3Mgbm90IGEgc3ltbGluaywganVzdCBrZWVwXG4gICAgICAgICAgICAgICAgLy8gdGVzdGluZyB0aGUgc2FtZSBwYXR0ZXJuLiBJZiB0aGVyZSdzIG1vcmUgYWZ0ZXIgdGhlIGdsb2JzdGFyLFxuICAgICAgICAgICAgICAgIC8vIHRoZW4gdGhpcyBzeW1saW5rIGNvbnN1bWVzIHRoZSBnbG9ic3Rhci4gSWYgbm90LCB0aGVuIHdlIGNhblxuICAgICAgICAgICAgICAgIC8vIGZvbGxvdyBhdCBtb3N0IE9ORSBzeW1saW5rIGFsb25nIHRoZSB3YXksIHNvIHdlIG1hcmsgaXQsIHdoaWNoXG4gICAgICAgICAgICAgICAgLy8gYWxzbyBjaGVja3MgdG8gZW5zdXJlIHRoYXQgaXQgd2Fzbid0IGFscmVhZHkgbWFya2VkLlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZvbGxvdyB8fCAhZS5pc1N5bWJvbGljTGluaygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3Vid2Fsa3MuYWRkKGUsIHBhdHRlcm4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChlLmlzU3ltYm9saWNMaW5rKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3QgJiYgcGF0dGVybi5jaGVja0ZvbGxvd0dsb2JzdGFyKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3Vid2Fsa3MuYWRkKGUsIHJlc3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhdHRlcm4ubWFya0ZvbGxvd0dsb2JzdGFyKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3Vid2Fsa3MuYWRkKGUsIHBhdHRlcm4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHRoZSBORVhUIHRoaW5nIG1hdGNoZXMgdGhpcyBlbnRyeSwgdGhlbiBhbHNvIGFkZFxuICAgICAgICAvLyB0aGUgcmVzdC5cbiAgICAgICAgaWYgKHJlc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHJwID0gcmVzdC5wYXR0ZXJuKCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJwID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgICAgIC8vIGRvdHMgYW5kIGVtcHR5IHdlcmUgaGFuZGxlZCBhbHJlYWR5XG4gICAgICAgICAgICAgICAgcnAgIT09ICcuLicgJiZcbiAgICAgICAgICAgICAgICBycCAhPT0gJycgJiZcbiAgICAgICAgICAgICAgICBycCAhPT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXN0U3RyaW5nKGUsIHJwLCByZXN0LnJlc3QoKSwgYWJzb2x1dGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocnAgPT09ICcuLicpIHtcbiAgICAgICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgICAgICAgICBjb25zdCBlcCA9IGUucGFyZW50IHx8IGU7XG4gICAgICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgICAgICAgICB0aGlzLnN1YndhbGtzLmFkZChlcCwgcmVzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChycCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgICAgICAgIHRoaXMudGVzdFJlZ0V4cChlLCBycCwgcmVzdC5yZXN0KCksIGFic29sdXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB0ZXN0UmVnRXhwKGUsIHAsIHJlc3QsIGFic29sdXRlKSB7XG4gICAgICAgIGlmICghcC50ZXN0KGUubmFtZSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICghcmVzdCkge1xuICAgICAgICAgICAgdGhpcy5tYXRjaGVzLmFkZChlLCBhYnNvbHV0ZSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdWJ3YWxrcy5hZGQoZSwgcmVzdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGVzdFN0cmluZyhlLCBwLCByZXN0LCBhYnNvbHV0ZSkge1xuICAgICAgICAvLyBzaG91bGQgbmV2ZXIgaGFwcGVuP1xuICAgICAgICBpZiAoIWUuaXNOYW1lZChwKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCFyZXN0KSB7XG4gICAgICAgICAgICB0aGlzLm1hdGNoZXMuYWRkKGUsIGFic29sdXRlLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN1YndhbGtzLmFkZChlLCByZXN0KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb2Nlc3Nvci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/e2b/node_modules/glob/dist/esm/processor.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/e2b/node_modules/glob/dist/esm/walker.js":
/*!***************************************************************!*\
  !*** ./node_modules/e2b/node_modules/glob/dist/esm/walker.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GlobStream: () => (/* binding */ GlobStream),\n/* harmony export */   GlobUtil: () => (/* binding */ GlobUtil),\n/* harmony export */   GlobWalker: () => (/* binding */ GlobWalker)\n/* harmony export */ });\n/* harmony import */ var minipass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! minipass */ \"(rsc)/./node_modules/minipass/dist/esm/index.js\");\n/* harmony import */ var _ignore_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ignore.js */ \"(rsc)/./node_modules/e2b/node_modules/glob/dist/esm/ignore.js\");\n/* harmony import */ var _processor_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./processor.js */ \"(rsc)/./node_modules/e2b/node_modules/glob/dist/esm/processor.js\");\n/**\n * Single-use utility classes to provide functionality to the {@link Glob}\n * methods.\n *\n * @module\n */\n\n\n\nconst makeIgnore = (ignore, opts) => typeof ignore === 'string' ? new _ignore_js__WEBPACK_IMPORTED_MODULE_1__.Ignore([ignore], opts)\n    : Array.isArray(ignore) ? new _ignore_js__WEBPACK_IMPORTED_MODULE_1__.Ignore(ignore, opts)\n        : ignore;\n/**\n * basic walking utilities that all the glob walker types use\n */\nclass GlobUtil {\n    path;\n    patterns;\n    opts;\n    seen = new Set();\n    paused = false;\n    aborted = false;\n    #onResume = [];\n    #ignore;\n    #sep;\n    signal;\n    maxDepth;\n    includeChildMatches;\n    constructor(patterns, path, opts) {\n        this.patterns = patterns;\n        this.path = path;\n        this.opts = opts;\n        this.#sep = !opts.posix && opts.platform === 'win32' ? '\\\\' : '/';\n        this.includeChildMatches = opts.includeChildMatches !== false;\n        if (opts.ignore || !this.includeChildMatches) {\n            this.#ignore = makeIgnore(opts.ignore ?? [], opts);\n            if (!this.includeChildMatches &&\n                typeof this.#ignore.add !== 'function') {\n                const m = 'cannot ignore child matches, ignore lacks add() method.';\n                throw new Error(m);\n            }\n        }\n        // ignore, always set with maxDepth, but it's optional on the\n        // GlobOptions type\n        /* c8 ignore start */\n        this.maxDepth = opts.maxDepth || Infinity;\n        /* c8 ignore stop */\n        if (opts.signal) {\n            this.signal = opts.signal;\n            this.signal.addEventListener('abort', () => {\n                this.#onResume.length = 0;\n            });\n        }\n    }\n    #ignored(path) {\n        return this.seen.has(path) || !!this.#ignore?.ignored?.(path);\n    }\n    #childrenIgnored(path) {\n        return !!this.#ignore?.childrenIgnored?.(path);\n    }\n    // backpressure mechanism\n    pause() {\n        this.paused = true;\n    }\n    resume() {\n        /* c8 ignore start */\n        if (this.signal?.aborted)\n            return;\n        /* c8 ignore stop */\n        this.paused = false;\n        let fn = undefined;\n        while (!this.paused && (fn = this.#onResume.shift())) {\n            fn();\n        }\n    }\n    onResume(fn) {\n        if (this.signal?.aborted)\n            return;\n        /* c8 ignore start */\n        if (!this.paused) {\n            fn();\n        }\n        else {\n            /* c8 ignore stop */\n            this.#onResume.push(fn);\n        }\n    }\n    // do the requisite realpath/stat checking, and return the path\n    // to add or undefined to filter it out.\n    async matchCheck(e, ifDir) {\n        if (ifDir && this.opts.nodir)\n            return undefined;\n        let rpc;\n        if (this.opts.realpath) {\n            rpc = e.realpathCached() || (await e.realpath());\n            if (!rpc)\n                return undefined;\n            e = rpc;\n        }\n        const needStat = e.isUnknown() || this.opts.stat;\n        const s = needStat ? await e.lstat() : e;\n        if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {\n            const target = await s.realpath();\n            /* c8 ignore start */\n            if (target && (target.isUnknown() || this.opts.stat)) {\n                await target.lstat();\n            }\n            /* c8 ignore stop */\n        }\n        return this.matchCheckTest(s, ifDir);\n    }\n    matchCheckTest(e, ifDir) {\n        return (e &&\n            (this.maxDepth === Infinity || e.depth() <= this.maxDepth) &&\n            (!ifDir || e.canReaddir()) &&\n            (!this.opts.nodir || !e.isDirectory()) &&\n            (!this.opts.nodir ||\n                !this.opts.follow ||\n                !e.isSymbolicLink() ||\n                !e.realpathCached()?.isDirectory()) &&\n            !this.#ignored(e)) ?\n            e\n            : undefined;\n    }\n    matchCheckSync(e, ifDir) {\n        if (ifDir && this.opts.nodir)\n            return undefined;\n        let rpc;\n        if (this.opts.realpath) {\n            rpc = e.realpathCached() || e.realpathSync();\n            if (!rpc)\n                return undefined;\n            e = rpc;\n        }\n        const needStat = e.isUnknown() || this.opts.stat;\n        const s = needStat ? e.lstatSync() : e;\n        if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {\n            const target = s.realpathSync();\n            if (target && (target?.isUnknown() || this.opts.stat)) {\n                target.lstatSync();\n            }\n        }\n        return this.matchCheckTest(s, ifDir);\n    }\n    matchFinish(e, absolute) {\n        if (this.#ignored(e))\n            return;\n        // we know we have an ignore if this is false, but TS doesn't\n        if (!this.includeChildMatches && this.#ignore?.add) {\n            const ign = `${e.relativePosix()}/**`;\n            this.#ignore.add(ign);\n        }\n        const abs = this.opts.absolute === undefined ? absolute : this.opts.absolute;\n        this.seen.add(e);\n        const mark = this.opts.mark && e.isDirectory() ? this.#sep : '';\n        // ok, we have what we need!\n        if (this.opts.withFileTypes) {\n            this.matchEmit(e);\n        }\n        else if (abs) {\n            const abs = this.opts.posix ? e.fullpathPosix() : e.fullpath();\n            this.matchEmit(abs + mark);\n        }\n        else {\n            const rel = this.opts.posix ? e.relativePosix() : e.relative();\n            const pre = this.opts.dotRelative && !rel.startsWith('..' + this.#sep) ?\n                '.' + this.#sep\n                : '';\n            this.matchEmit(!rel ? '.' + mark : pre + rel + mark);\n        }\n    }\n    async match(e, absolute, ifDir) {\n        const p = await this.matchCheck(e, ifDir);\n        if (p)\n            this.matchFinish(p, absolute);\n    }\n    matchSync(e, absolute, ifDir) {\n        const p = this.matchCheckSync(e, ifDir);\n        if (p)\n            this.matchFinish(p, absolute);\n    }\n    walkCB(target, patterns, cb) {\n        /* c8 ignore start */\n        if (this.signal?.aborted)\n            cb();\n        /* c8 ignore stop */\n        this.walkCB2(target, patterns, new _processor_js__WEBPACK_IMPORTED_MODULE_2__.Processor(this.opts), cb);\n    }\n    walkCB2(target, patterns, processor, cb) {\n        if (this.#childrenIgnored(target))\n            return cb();\n        if (this.signal?.aborted)\n            cb();\n        if (this.paused) {\n            this.onResume(() => this.walkCB2(target, patterns, processor, cb));\n            return;\n        }\n        processor.processPatterns(target, patterns);\n        // done processing.  all of the above is sync, can be abstracted out.\n        // subwalks is a map of paths to the entry filters they need\n        // matches is a map of paths to [absolute, ifDir] tuples.\n        let tasks = 1;\n        const next = () => {\n            if (--tasks === 0)\n                cb();\n        };\n        for (const [m, absolute, ifDir] of processor.matches.entries()) {\n            if (this.#ignored(m))\n                continue;\n            tasks++;\n            this.match(m, absolute, ifDir).then(() => next());\n        }\n        for (const t of processor.subwalkTargets()) {\n            if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {\n                continue;\n            }\n            tasks++;\n            const childrenCached = t.readdirCached();\n            if (t.calledReaddir())\n                this.walkCB3(t, childrenCached, processor, next);\n            else {\n                t.readdirCB((_, entries) => this.walkCB3(t, entries, processor, next), true);\n            }\n        }\n        next();\n    }\n    walkCB3(target, entries, processor, cb) {\n        processor = processor.filterEntries(target, entries);\n        let tasks = 1;\n        const next = () => {\n            if (--tasks === 0)\n                cb();\n        };\n        for (const [m, absolute, ifDir] of processor.matches.entries()) {\n            if (this.#ignored(m))\n                continue;\n            tasks++;\n            this.match(m, absolute, ifDir).then(() => next());\n        }\n        for (const [target, patterns] of processor.subwalks.entries()) {\n            tasks++;\n            this.walkCB2(target, patterns, processor.child(), next);\n        }\n        next();\n    }\n    walkCBSync(target, patterns, cb) {\n        /* c8 ignore start */\n        if (this.signal?.aborted)\n            cb();\n        /* c8 ignore stop */\n        this.walkCB2Sync(target, patterns, new _processor_js__WEBPACK_IMPORTED_MODULE_2__.Processor(this.opts), cb);\n    }\n    walkCB2Sync(target, patterns, processor, cb) {\n        if (this.#childrenIgnored(target))\n            return cb();\n        if (this.signal?.aborted)\n            cb();\n        if (this.paused) {\n            this.onResume(() => this.walkCB2Sync(target, patterns, processor, cb));\n            return;\n        }\n        processor.processPatterns(target, patterns);\n        // done processing.  all of the above is sync, can be abstracted out.\n        // subwalks is a map of paths to the entry filters they need\n        // matches is a map of paths to [absolute, ifDir] tuples.\n        let tasks = 1;\n        const next = () => {\n            if (--tasks === 0)\n                cb();\n        };\n        for (const [m, absolute, ifDir] of processor.matches.entries()) {\n            if (this.#ignored(m))\n                continue;\n            this.matchSync(m, absolute, ifDir);\n        }\n        for (const t of processor.subwalkTargets()) {\n            if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {\n                continue;\n            }\n            tasks++;\n            const children = t.readdirSync();\n            this.walkCB3Sync(t, children, processor, next);\n        }\n        next();\n    }\n    walkCB3Sync(target, entries, processor, cb) {\n        processor = processor.filterEntries(target, entries);\n        let tasks = 1;\n        const next = () => {\n            if (--tasks === 0)\n                cb();\n        };\n        for (const [m, absolute, ifDir] of processor.matches.entries()) {\n            if (this.#ignored(m))\n                continue;\n            this.matchSync(m, absolute, ifDir);\n        }\n        for (const [target, patterns] of processor.subwalks.entries()) {\n            tasks++;\n            this.walkCB2Sync(target, patterns, processor.child(), next);\n        }\n        next();\n    }\n}\nclass GlobWalker extends GlobUtil {\n    matches = new Set();\n    constructor(patterns, path, opts) {\n        super(patterns, path, opts);\n    }\n    matchEmit(e) {\n        this.matches.add(e);\n    }\n    async walk() {\n        if (this.signal?.aborted)\n            throw this.signal.reason;\n        if (this.path.isUnknown()) {\n            await this.path.lstat();\n        }\n        await new Promise((res, rej) => {\n            this.walkCB(this.path, this.patterns, () => {\n                if (this.signal?.aborted) {\n                    rej(this.signal.reason);\n                }\n                else {\n                    res(this.matches);\n                }\n            });\n        });\n        return this.matches;\n    }\n    walkSync() {\n        if (this.signal?.aborted)\n            throw this.signal.reason;\n        if (this.path.isUnknown()) {\n            this.path.lstatSync();\n        }\n        // nothing for the callback to do, because this never pauses\n        this.walkCBSync(this.path, this.patterns, () => {\n            if (this.signal?.aborted)\n                throw this.signal.reason;\n        });\n        return this.matches;\n    }\n}\nclass GlobStream extends GlobUtil {\n    results;\n    constructor(patterns, path, opts) {\n        super(patterns, path, opts);\n        this.results = new minipass__WEBPACK_IMPORTED_MODULE_0__.Minipass({\n            signal: this.signal,\n            objectMode: true,\n        });\n        this.results.on('drain', () => this.resume());\n        this.results.on('resume', () => this.resume());\n    }\n    matchEmit(e) {\n        this.results.write(e);\n        if (!this.results.flowing)\n            this.pause();\n    }\n    stream() {\n        const target = this.path;\n        if (target.isUnknown()) {\n            target.lstat().then(() => {\n                this.walkCB(target, this.patterns, () => this.results.end());\n            });\n        }\n        else {\n            this.walkCB(target, this.patterns, () => this.results.end());\n        }\n        return this.results;\n    }\n    streamSync() {\n        if (this.path.isUnknown()) {\n            this.path.lstatSync();\n        }\n        this.walkCBSync(this.path, this.patterns, () => this.results.end());\n        return this.results;\n    }\n}\n//# sourceMappingURL=walker.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZTJiL25vZGVfbW9kdWxlcy9nbG9iL2Rpc3QvZXNtL3dhbGtlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNvQztBQUNDO0FBQ007QUFDM0Msc0VBQXNFLDhDQUFNO0FBQzVFLGtDQUFrQyw4Q0FBTTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixrQkFBa0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLG9EQUFTO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxvREFBUztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw4Q0FBUTtBQUNuQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpdmUtdmliZS1haS1uZXh0Ly4vbm9kZV9tb2R1bGVzL2UyYi9ub2RlX21vZHVsZXMvZ2xvYi9kaXN0L2VzbS93YWxrZXIuanM/ZWNkOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFNpbmdsZS11c2UgdXRpbGl0eSBjbGFzc2VzIHRvIHByb3ZpZGUgZnVuY3Rpb25hbGl0eSB0byB0aGUge0BsaW5rIEdsb2J9XG4gKiBtZXRob2RzLlxuICpcbiAqIEBtb2R1bGVcbiAqL1xuaW1wb3J0IHsgTWluaXBhc3MgfSBmcm9tICdtaW5pcGFzcyc7XG5pbXBvcnQgeyBJZ25vcmUgfSBmcm9tICcuL2lnbm9yZS5qcyc7XG5pbXBvcnQgeyBQcm9jZXNzb3IgfSBmcm9tICcuL3Byb2Nlc3Nvci5qcyc7XG5jb25zdCBtYWtlSWdub3JlID0gKGlnbm9yZSwgb3B0cykgPT4gdHlwZW9mIGlnbm9yZSA9PT0gJ3N0cmluZycgPyBuZXcgSWdub3JlKFtpZ25vcmVdLCBvcHRzKVxuICAgIDogQXJyYXkuaXNBcnJheShpZ25vcmUpID8gbmV3IElnbm9yZShpZ25vcmUsIG9wdHMpXG4gICAgICAgIDogaWdub3JlO1xuLyoqXG4gKiBiYXNpYyB3YWxraW5nIHV0aWxpdGllcyB0aGF0IGFsbCB0aGUgZ2xvYiB3YWxrZXIgdHlwZXMgdXNlXG4gKi9cbmV4cG9ydCBjbGFzcyBHbG9iVXRpbCB7XG4gICAgcGF0aDtcbiAgICBwYXR0ZXJucztcbiAgICBvcHRzO1xuICAgIHNlZW4gPSBuZXcgU2V0KCk7XG4gICAgcGF1c2VkID0gZmFsc2U7XG4gICAgYWJvcnRlZCA9IGZhbHNlO1xuICAgICNvblJlc3VtZSA9IFtdO1xuICAgICNpZ25vcmU7XG4gICAgI3NlcDtcbiAgICBzaWduYWw7XG4gICAgbWF4RGVwdGg7XG4gICAgaW5jbHVkZUNoaWxkTWF0Y2hlcztcbiAgICBjb25zdHJ1Y3RvcihwYXR0ZXJucywgcGF0aCwgb3B0cykge1xuICAgICAgICB0aGlzLnBhdHRlcm5zID0gcGF0dGVybnM7XG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgICAgIHRoaXMuI3NlcCA9ICFvcHRzLnBvc2l4ICYmIG9wdHMucGxhdGZvcm0gPT09ICd3aW4zMicgPyAnXFxcXCcgOiAnLyc7XG4gICAgICAgIHRoaXMuaW5jbHVkZUNoaWxkTWF0Y2hlcyA9IG9wdHMuaW5jbHVkZUNoaWxkTWF0Y2hlcyAhPT0gZmFsc2U7XG4gICAgICAgIGlmIChvcHRzLmlnbm9yZSB8fCAhdGhpcy5pbmNsdWRlQ2hpbGRNYXRjaGVzKSB7XG4gICAgICAgICAgICB0aGlzLiNpZ25vcmUgPSBtYWtlSWdub3JlKG9wdHMuaWdub3JlID8/IFtdLCBvcHRzKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5pbmNsdWRlQ2hpbGRNYXRjaGVzICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIHRoaXMuI2lnbm9yZS5hZGQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtID0gJ2Nhbm5vdCBpZ25vcmUgY2hpbGQgbWF0Y2hlcywgaWdub3JlIGxhY2tzIGFkZCgpIG1ldGhvZC4nO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpZ25vcmUsIGFsd2F5cyBzZXQgd2l0aCBtYXhEZXB0aCwgYnV0IGl0J3Mgb3B0aW9uYWwgb24gdGhlXG4gICAgICAgIC8vIEdsb2JPcHRpb25zIHR5cGVcbiAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIHRoaXMubWF4RGVwdGggPSBvcHRzLm1heERlcHRoIHx8IEluZmluaXR5O1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICBpZiAob3B0cy5zaWduYWwpIHtcbiAgICAgICAgICAgIHRoaXMuc2lnbmFsID0gb3B0cy5zaWduYWw7XG4gICAgICAgICAgICB0aGlzLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLiNvblJlc3VtZS5sZW5ndGggPSAwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgI2lnbm9yZWQocGF0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWVuLmhhcyhwYXRoKSB8fCAhIXRoaXMuI2lnbm9yZT8uaWdub3JlZD8uKHBhdGgpO1xuICAgIH1cbiAgICAjY2hpbGRyZW5JZ25vcmVkKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy4jaWdub3JlPy5jaGlsZHJlbklnbm9yZWQ/LihwYXRoKTtcbiAgICB9XG4gICAgLy8gYmFja3ByZXNzdXJlIG1lY2hhbmlzbVxuICAgIHBhdXNlKCkge1xuICAgICAgICB0aGlzLnBhdXNlZCA9IHRydWU7XG4gICAgfVxuICAgIHJlc3VtZSgpIHtcbiAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIGlmICh0aGlzLnNpZ25hbD8uYWJvcnRlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgdGhpcy5wYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IGZuID0gdW5kZWZpbmVkO1xuICAgICAgICB3aGlsZSAoIXRoaXMucGF1c2VkICYmIChmbiA9IHRoaXMuI29uUmVzdW1lLnNoaWZ0KCkpKSB7XG4gICAgICAgICAgICBmbigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uUmVzdW1lKGZuKSB7XG4gICAgICAgIGlmICh0aGlzLnNpZ25hbD8uYWJvcnRlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIGlmICghdGhpcy5wYXVzZWQpIHtcbiAgICAgICAgICAgIGZuKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgdGhpcy4jb25SZXN1bWUucHVzaChmbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gZG8gdGhlIHJlcXVpc2l0ZSByZWFscGF0aC9zdGF0IGNoZWNraW5nLCBhbmQgcmV0dXJuIHRoZSBwYXRoXG4gICAgLy8gdG8gYWRkIG9yIHVuZGVmaW5lZCB0byBmaWx0ZXIgaXQgb3V0LlxuICAgIGFzeW5jIG1hdGNoQ2hlY2soZSwgaWZEaXIpIHtcbiAgICAgICAgaWYgKGlmRGlyICYmIHRoaXMub3B0cy5ub2RpcilcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBycGM7XG4gICAgICAgIGlmICh0aGlzLm9wdHMucmVhbHBhdGgpIHtcbiAgICAgICAgICAgIHJwYyA9IGUucmVhbHBhdGhDYWNoZWQoKSB8fCAoYXdhaXQgZS5yZWFscGF0aCgpKTtcbiAgICAgICAgICAgIGlmICghcnBjKVxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBlID0gcnBjO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5lZWRTdGF0ID0gZS5pc1Vua25vd24oKSB8fCB0aGlzLm9wdHMuc3RhdDtcbiAgICAgICAgY29uc3QgcyA9IG5lZWRTdGF0ID8gYXdhaXQgZS5sc3RhdCgpIDogZTtcbiAgICAgICAgaWYgKHRoaXMub3B0cy5mb2xsb3cgJiYgdGhpcy5vcHRzLm5vZGlyICYmIHM/LmlzU3ltYm9saWNMaW5rKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGF3YWl0IHMucmVhbHBhdGgoKTtcbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgaWYgKHRhcmdldCAmJiAodGFyZ2V0LmlzVW5rbm93bigpIHx8IHRoaXMub3B0cy5zdGF0KSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRhcmdldC5sc3RhdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5tYXRjaENoZWNrVGVzdChzLCBpZkRpcik7XG4gICAgfVxuICAgIG1hdGNoQ2hlY2tUZXN0KGUsIGlmRGlyKSB7XG4gICAgICAgIHJldHVybiAoZSAmJlxuICAgICAgICAgICAgKHRoaXMubWF4RGVwdGggPT09IEluZmluaXR5IHx8IGUuZGVwdGgoKSA8PSB0aGlzLm1heERlcHRoKSAmJlxuICAgICAgICAgICAgKCFpZkRpciB8fCBlLmNhblJlYWRkaXIoKSkgJiZcbiAgICAgICAgICAgICghdGhpcy5vcHRzLm5vZGlyIHx8ICFlLmlzRGlyZWN0b3J5KCkpICYmXG4gICAgICAgICAgICAoIXRoaXMub3B0cy5ub2RpciB8fFxuICAgICAgICAgICAgICAgICF0aGlzLm9wdHMuZm9sbG93IHx8XG4gICAgICAgICAgICAgICAgIWUuaXNTeW1ib2xpY0xpbmsoKSB8fFxuICAgICAgICAgICAgICAgICFlLnJlYWxwYXRoQ2FjaGVkKCk/LmlzRGlyZWN0b3J5KCkpICYmXG4gICAgICAgICAgICAhdGhpcy4jaWdub3JlZChlKSkgP1xuICAgICAgICAgICAgZVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIG1hdGNoQ2hlY2tTeW5jKGUsIGlmRGlyKSB7XG4gICAgICAgIGlmIChpZkRpciAmJiB0aGlzLm9wdHMubm9kaXIpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgcnBjO1xuICAgICAgICBpZiAodGhpcy5vcHRzLnJlYWxwYXRoKSB7XG4gICAgICAgICAgICBycGMgPSBlLnJlYWxwYXRoQ2FjaGVkKCkgfHwgZS5yZWFscGF0aFN5bmMoKTtcbiAgICAgICAgICAgIGlmICghcnBjKVxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBlID0gcnBjO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5lZWRTdGF0ID0gZS5pc1Vua25vd24oKSB8fCB0aGlzLm9wdHMuc3RhdDtcbiAgICAgICAgY29uc3QgcyA9IG5lZWRTdGF0ID8gZS5sc3RhdFN5bmMoKSA6IGU7XG4gICAgICAgIGlmICh0aGlzLm9wdHMuZm9sbG93ICYmIHRoaXMub3B0cy5ub2RpciAmJiBzPy5pc1N5bWJvbGljTGluaygpKSB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBzLnJlYWxwYXRoU3luYygpO1xuICAgICAgICAgICAgaWYgKHRhcmdldCAmJiAodGFyZ2V0Py5pc1Vua25vd24oKSB8fCB0aGlzLm9wdHMuc3RhdCkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQubHN0YXRTeW5jKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubWF0Y2hDaGVja1Rlc3QocywgaWZEaXIpO1xuICAgIH1cbiAgICBtYXRjaEZpbmlzaChlLCBhYnNvbHV0ZSkge1xuICAgICAgICBpZiAodGhpcy4jaWdub3JlZChlKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gd2Uga25vdyB3ZSBoYXZlIGFuIGlnbm9yZSBpZiB0aGlzIGlzIGZhbHNlLCBidXQgVFMgZG9lc24ndFxuICAgICAgICBpZiAoIXRoaXMuaW5jbHVkZUNoaWxkTWF0Y2hlcyAmJiB0aGlzLiNpZ25vcmU/LmFkZCkge1xuICAgICAgICAgICAgY29uc3QgaWduID0gYCR7ZS5yZWxhdGl2ZVBvc2l4KCl9LyoqYDtcbiAgICAgICAgICAgIHRoaXMuI2lnbm9yZS5hZGQoaWduKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhYnMgPSB0aGlzLm9wdHMuYWJzb2x1dGUgPT09IHVuZGVmaW5lZCA/IGFic29sdXRlIDogdGhpcy5vcHRzLmFic29sdXRlO1xuICAgICAgICB0aGlzLnNlZW4uYWRkKGUpO1xuICAgICAgICBjb25zdCBtYXJrID0gdGhpcy5vcHRzLm1hcmsgJiYgZS5pc0RpcmVjdG9yeSgpID8gdGhpcy4jc2VwIDogJyc7XG4gICAgICAgIC8vIG9rLCB3ZSBoYXZlIHdoYXQgd2UgbmVlZCFcbiAgICAgICAgaWYgKHRoaXMub3B0cy53aXRoRmlsZVR5cGVzKSB7XG4gICAgICAgICAgICB0aGlzLm1hdGNoRW1pdChlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhYnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGFicyA9IHRoaXMub3B0cy5wb3NpeCA/IGUuZnVsbHBhdGhQb3NpeCgpIDogZS5mdWxscGF0aCgpO1xuICAgICAgICAgICAgdGhpcy5tYXRjaEVtaXQoYWJzICsgbWFyayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCByZWwgPSB0aGlzLm9wdHMucG9zaXggPyBlLnJlbGF0aXZlUG9zaXgoKSA6IGUucmVsYXRpdmUoKTtcbiAgICAgICAgICAgIGNvbnN0IHByZSA9IHRoaXMub3B0cy5kb3RSZWxhdGl2ZSAmJiAhcmVsLnN0YXJ0c1dpdGgoJy4uJyArIHRoaXMuI3NlcCkgP1xuICAgICAgICAgICAgICAgICcuJyArIHRoaXMuI3NlcFxuICAgICAgICAgICAgICAgIDogJyc7XG4gICAgICAgICAgICB0aGlzLm1hdGNoRW1pdCghcmVsID8gJy4nICsgbWFyayA6IHByZSArIHJlbCArIG1hcmspO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIG1hdGNoKGUsIGFic29sdXRlLCBpZkRpcikge1xuICAgICAgICBjb25zdCBwID0gYXdhaXQgdGhpcy5tYXRjaENoZWNrKGUsIGlmRGlyKTtcbiAgICAgICAgaWYgKHApXG4gICAgICAgICAgICB0aGlzLm1hdGNoRmluaXNoKHAsIGFic29sdXRlKTtcbiAgICB9XG4gICAgbWF0Y2hTeW5jKGUsIGFic29sdXRlLCBpZkRpcikge1xuICAgICAgICBjb25zdCBwID0gdGhpcy5tYXRjaENoZWNrU3luYyhlLCBpZkRpcik7XG4gICAgICAgIGlmIChwKVxuICAgICAgICAgICAgdGhpcy5tYXRjaEZpbmlzaChwLCBhYnNvbHV0ZSk7XG4gICAgfVxuICAgIHdhbGtDQih0YXJnZXQsIHBhdHRlcm5zLCBjYikge1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgaWYgKHRoaXMuc2lnbmFsPy5hYm9ydGVkKVxuICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgdGhpcy53YWxrQ0IyKHRhcmdldCwgcGF0dGVybnMsIG5ldyBQcm9jZXNzb3IodGhpcy5vcHRzKSwgY2IpO1xuICAgIH1cbiAgICB3YWxrQ0IyKHRhcmdldCwgcGF0dGVybnMsIHByb2Nlc3NvciwgY2IpIHtcbiAgICAgICAgaWYgKHRoaXMuI2NoaWxkcmVuSWdub3JlZCh0YXJnZXQpKVxuICAgICAgICAgICAgcmV0dXJuIGNiKCk7XG4gICAgICAgIGlmICh0aGlzLnNpZ25hbD8uYWJvcnRlZClcbiAgICAgICAgICAgIGNiKCk7XG4gICAgICAgIGlmICh0aGlzLnBhdXNlZCkge1xuICAgICAgICAgICAgdGhpcy5vblJlc3VtZSgoKSA9PiB0aGlzLndhbGtDQjIodGFyZ2V0LCBwYXR0ZXJucywgcHJvY2Vzc29yLCBjYikpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHByb2Nlc3Nvci5wcm9jZXNzUGF0dGVybnModGFyZ2V0LCBwYXR0ZXJucyk7XG4gICAgICAgIC8vIGRvbmUgcHJvY2Vzc2luZy4gIGFsbCBvZiB0aGUgYWJvdmUgaXMgc3luYywgY2FuIGJlIGFic3RyYWN0ZWQgb3V0LlxuICAgICAgICAvLyBzdWJ3YWxrcyBpcyBhIG1hcCBvZiBwYXRocyB0byB0aGUgZW50cnkgZmlsdGVycyB0aGV5IG5lZWRcbiAgICAgICAgLy8gbWF0Y2hlcyBpcyBhIG1hcCBvZiBwYXRocyB0byBbYWJzb2x1dGUsIGlmRGlyXSB0dXBsZXMuXG4gICAgICAgIGxldCB0YXNrcyA9IDE7XG4gICAgICAgIGNvbnN0IG5leHQgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoLS10YXNrcyA9PT0gMClcbiAgICAgICAgICAgICAgICBjYigpO1xuICAgICAgICB9O1xuICAgICAgICBmb3IgKGNvbnN0IFttLCBhYnNvbHV0ZSwgaWZEaXJdIG9mIHByb2Nlc3Nvci5tYXRjaGVzLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuI2lnbm9yZWQobSkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB0YXNrcysrO1xuICAgICAgICAgICAgdGhpcy5tYXRjaChtLCBhYnNvbHV0ZSwgaWZEaXIpLnRoZW4oKCkgPT4gbmV4dCgpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHQgb2YgcHJvY2Vzc29yLnN1YndhbGtUYXJnZXRzKCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1heERlcHRoICE9PSBJbmZpbml0eSAmJiB0LmRlcHRoKCkgPj0gdGhpcy5tYXhEZXB0aCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFza3MrKztcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuQ2FjaGVkID0gdC5yZWFkZGlyQ2FjaGVkKCk7XG4gICAgICAgICAgICBpZiAodC5jYWxsZWRSZWFkZGlyKCkpXG4gICAgICAgICAgICAgICAgdGhpcy53YWxrQ0IzKHQsIGNoaWxkcmVuQ2FjaGVkLCBwcm9jZXNzb3IsIG5leHQpO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdC5yZWFkZGlyQ0IoKF8sIGVudHJpZXMpID0+IHRoaXMud2Fsa0NCMyh0LCBlbnRyaWVzLCBwcm9jZXNzb3IsIG5leHQpLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBuZXh0KCk7XG4gICAgfVxuICAgIHdhbGtDQjModGFyZ2V0LCBlbnRyaWVzLCBwcm9jZXNzb3IsIGNiKSB7XG4gICAgICAgIHByb2Nlc3NvciA9IHByb2Nlc3Nvci5maWx0ZXJFbnRyaWVzKHRhcmdldCwgZW50cmllcyk7XG4gICAgICAgIGxldCB0YXNrcyA9IDE7XG4gICAgICAgIGNvbnN0IG5leHQgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoLS10YXNrcyA9PT0gMClcbiAgICAgICAgICAgICAgICBjYigpO1xuICAgICAgICB9O1xuICAgICAgICBmb3IgKGNvbnN0IFttLCBhYnNvbHV0ZSwgaWZEaXJdIG9mIHByb2Nlc3Nvci5tYXRjaGVzLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuI2lnbm9yZWQobSkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB0YXNrcysrO1xuICAgICAgICAgICAgdGhpcy5tYXRjaChtLCBhYnNvbHV0ZSwgaWZEaXIpLnRoZW4oKCkgPT4gbmV4dCgpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IFt0YXJnZXQsIHBhdHRlcm5zXSBvZiBwcm9jZXNzb3Iuc3Vid2Fsa3MuZW50cmllcygpKSB7XG4gICAgICAgICAgICB0YXNrcysrO1xuICAgICAgICAgICAgdGhpcy53YWxrQ0IyKHRhcmdldCwgcGF0dGVybnMsIHByb2Nlc3Nvci5jaGlsZCgpLCBuZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBuZXh0KCk7XG4gICAgfVxuICAgIHdhbGtDQlN5bmModGFyZ2V0LCBwYXR0ZXJucywgY2IpIHtcbiAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIGlmICh0aGlzLnNpZ25hbD8uYWJvcnRlZClcbiAgICAgICAgICAgIGNiKCk7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgIHRoaXMud2Fsa0NCMlN5bmModGFyZ2V0LCBwYXR0ZXJucywgbmV3IFByb2Nlc3Nvcih0aGlzLm9wdHMpLCBjYik7XG4gICAgfVxuICAgIHdhbGtDQjJTeW5jKHRhcmdldCwgcGF0dGVybnMsIHByb2Nlc3NvciwgY2IpIHtcbiAgICAgICAgaWYgKHRoaXMuI2NoaWxkcmVuSWdub3JlZCh0YXJnZXQpKVxuICAgICAgICAgICAgcmV0dXJuIGNiKCk7XG4gICAgICAgIGlmICh0aGlzLnNpZ25hbD8uYWJvcnRlZClcbiAgICAgICAgICAgIGNiKCk7XG4gICAgICAgIGlmICh0aGlzLnBhdXNlZCkge1xuICAgICAgICAgICAgdGhpcy5vblJlc3VtZSgoKSA9PiB0aGlzLndhbGtDQjJTeW5jKHRhcmdldCwgcGF0dGVybnMsIHByb2Nlc3NvciwgY2IpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwcm9jZXNzb3IucHJvY2Vzc1BhdHRlcm5zKHRhcmdldCwgcGF0dGVybnMpO1xuICAgICAgICAvLyBkb25lIHByb2Nlc3NpbmcuICBhbGwgb2YgdGhlIGFib3ZlIGlzIHN5bmMsIGNhbiBiZSBhYnN0cmFjdGVkIG91dC5cbiAgICAgICAgLy8gc3Vid2Fsa3MgaXMgYSBtYXAgb2YgcGF0aHMgdG8gdGhlIGVudHJ5IGZpbHRlcnMgdGhleSBuZWVkXG4gICAgICAgIC8vIG1hdGNoZXMgaXMgYSBtYXAgb2YgcGF0aHMgdG8gW2Fic29sdXRlLCBpZkRpcl0gdHVwbGVzLlxuICAgICAgICBsZXQgdGFza3MgPSAxO1xuICAgICAgICBjb25zdCBuZXh0ID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKC0tdGFza3MgPT09IDApXG4gICAgICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChjb25zdCBbbSwgYWJzb2x1dGUsIGlmRGlyXSBvZiBwcm9jZXNzb3IubWF0Y2hlcy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNpZ25vcmVkKG0pKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgdGhpcy5tYXRjaFN5bmMobSwgYWJzb2x1dGUsIGlmRGlyKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHQgb2YgcHJvY2Vzc29yLnN1YndhbGtUYXJnZXRzKCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1heERlcHRoICE9PSBJbmZpbml0eSAmJiB0LmRlcHRoKCkgPj0gdGhpcy5tYXhEZXB0aCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFza3MrKztcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gdC5yZWFkZGlyU3luYygpO1xuICAgICAgICAgICAgdGhpcy53YWxrQ0IzU3luYyh0LCBjaGlsZHJlbiwgcHJvY2Vzc29yLCBuZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBuZXh0KCk7XG4gICAgfVxuICAgIHdhbGtDQjNTeW5jKHRhcmdldCwgZW50cmllcywgcHJvY2Vzc29yLCBjYikge1xuICAgICAgICBwcm9jZXNzb3IgPSBwcm9jZXNzb3IuZmlsdGVyRW50cmllcyh0YXJnZXQsIGVudHJpZXMpO1xuICAgICAgICBsZXQgdGFza3MgPSAxO1xuICAgICAgICBjb25zdCBuZXh0ID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKC0tdGFza3MgPT09IDApXG4gICAgICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChjb25zdCBbbSwgYWJzb2x1dGUsIGlmRGlyXSBvZiBwcm9jZXNzb3IubWF0Y2hlcy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNpZ25vcmVkKG0pKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgdGhpcy5tYXRjaFN5bmMobSwgYWJzb2x1dGUsIGlmRGlyKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IFt0YXJnZXQsIHBhdHRlcm5zXSBvZiBwcm9jZXNzb3Iuc3Vid2Fsa3MuZW50cmllcygpKSB7XG4gICAgICAgICAgICB0YXNrcysrO1xuICAgICAgICAgICAgdGhpcy53YWxrQ0IyU3luYyh0YXJnZXQsIHBhdHRlcm5zLCBwcm9jZXNzb3IuY2hpbGQoKSwgbmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dCgpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBHbG9iV2Fsa2VyIGV4dGVuZHMgR2xvYlV0aWwge1xuICAgIG1hdGNoZXMgPSBuZXcgU2V0KCk7XG4gICAgY29uc3RydWN0b3IocGF0dGVybnMsIHBhdGgsIG9wdHMpIHtcbiAgICAgICAgc3VwZXIocGF0dGVybnMsIHBhdGgsIG9wdHMpO1xuICAgIH1cbiAgICBtYXRjaEVtaXQoZSkge1xuICAgICAgICB0aGlzLm1hdGNoZXMuYWRkKGUpO1xuICAgIH1cbiAgICBhc3luYyB3YWxrKCkge1xuICAgICAgICBpZiAodGhpcy5zaWduYWw/LmFib3J0ZWQpXG4gICAgICAgICAgICB0aHJvdyB0aGlzLnNpZ25hbC5yZWFzb247XG4gICAgICAgIGlmICh0aGlzLnBhdGguaXNVbmtub3duKCkpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGF0aC5sc3RhdCgpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgICAgICAgICAgdGhpcy53YWxrQ0IodGhpcy5wYXRoLCB0aGlzLnBhdHRlcm5zLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2lnbmFsPy5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlaih0aGlzLnNpZ25hbC5yZWFzb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzKHRoaXMubWF0Y2hlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5tYXRjaGVzO1xuICAgIH1cbiAgICB3YWxrU3luYygpIHtcbiAgICAgICAgaWYgKHRoaXMuc2lnbmFsPy5hYm9ydGVkKVxuICAgICAgICAgICAgdGhyb3cgdGhpcy5zaWduYWwucmVhc29uO1xuICAgICAgICBpZiAodGhpcy5wYXRoLmlzVW5rbm93bigpKSB7XG4gICAgICAgICAgICB0aGlzLnBhdGgubHN0YXRTeW5jKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm90aGluZyBmb3IgdGhlIGNhbGxiYWNrIHRvIGRvLCBiZWNhdXNlIHRoaXMgbmV2ZXIgcGF1c2VzXG4gICAgICAgIHRoaXMud2Fsa0NCU3luYyh0aGlzLnBhdGgsIHRoaXMucGF0dGVybnMsICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNpZ25hbD8uYWJvcnRlZClcbiAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLnNpZ25hbC5yZWFzb247XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5tYXRjaGVzO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBHbG9iU3RyZWFtIGV4dGVuZHMgR2xvYlV0aWwge1xuICAgIHJlc3VsdHM7XG4gICAgY29uc3RydWN0b3IocGF0dGVybnMsIHBhdGgsIG9wdHMpIHtcbiAgICAgICAgc3VwZXIocGF0dGVybnMsIHBhdGgsIG9wdHMpO1xuICAgICAgICB0aGlzLnJlc3VsdHMgPSBuZXcgTWluaXBhc3Moe1xuICAgICAgICAgICAgc2lnbmFsOiB0aGlzLnNpZ25hbCxcbiAgICAgICAgICAgIG9iamVjdE1vZGU6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlc3VsdHMub24oJ2RyYWluJywgKCkgPT4gdGhpcy5yZXN1bWUoKSk7XG4gICAgICAgIHRoaXMucmVzdWx0cy5vbigncmVzdW1lJywgKCkgPT4gdGhpcy5yZXN1bWUoKSk7XG4gICAgfVxuICAgIG1hdGNoRW1pdChlKSB7XG4gICAgICAgIHRoaXMucmVzdWx0cy53cml0ZShlKTtcbiAgICAgICAgaWYgKCF0aGlzLnJlc3VsdHMuZmxvd2luZylcbiAgICAgICAgICAgIHRoaXMucGF1c2UoKTtcbiAgICB9XG4gICAgc3RyZWFtKCkge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLnBhdGg7XG4gICAgICAgIGlmICh0YXJnZXQuaXNVbmtub3duKCkpIHtcbiAgICAgICAgICAgIHRhcmdldC5sc3RhdCgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMud2Fsa0NCKHRhcmdldCwgdGhpcy5wYXR0ZXJucywgKCkgPT4gdGhpcy5yZXN1bHRzLmVuZCgpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy53YWxrQ0IodGFyZ2V0LCB0aGlzLnBhdHRlcm5zLCAoKSA9PiB0aGlzLnJlc3VsdHMuZW5kKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3VsdHM7XG4gICAgfVxuICAgIHN0cmVhbVN5bmMoKSB7XG4gICAgICAgIGlmICh0aGlzLnBhdGguaXNVbmtub3duKCkpIHtcbiAgICAgICAgICAgIHRoaXMucGF0aC5sc3RhdFN5bmMoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndhbGtDQlN5bmModGhpcy5wYXRoLCB0aGlzLnBhdHRlcm5zLCAoKSA9PiB0aGlzLnJlc3VsdHMuZW5kKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRzO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdhbGtlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/e2b/node_modules/glob/dist/esm/walker.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/e2b/node_modules/lru-cache/dist/esm/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/e2b/node_modules/lru-cache/dist/esm/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LRUCache: () => (/* binding */ LRUCache)\n/* harmony export */ });\n/**\n * @module LRUCache\n */\nconst defaultPerf = (typeof performance === 'object' &&\n    performance &&\n    typeof performance.now === 'function') ?\n    performance\n    : Date;\nconst warned = new Set();\n/* c8 ignore start */\nconst PROCESS = (typeof process === 'object' && !!process ?\n    process\n    : {});\n/* c8 ignore start */\nconst emitWarning = (msg, type, code, fn) => {\n    typeof PROCESS.emitWarning === 'function' ?\n        PROCESS.emitWarning(msg, type, code, fn)\n        : console.error(`[${code}] ${type}: ${msg}`);\n};\nlet AC = globalThis.AbortController;\nlet AS = globalThis.AbortSignal;\n/* c8 ignore start */\nif (typeof AC === 'undefined') {\n    //@ts-ignore\n    AS = class AbortSignal {\n        onabort;\n        _onabort = [];\n        reason;\n        aborted = false;\n        addEventListener(_, fn) {\n            this._onabort.push(fn);\n        }\n    };\n    //@ts-ignore\n    AC = class AbortController {\n        constructor() {\n            warnACPolyfill();\n        }\n        signal = new AS();\n        abort(reason) {\n            if (this.signal.aborted)\n                return;\n            //@ts-ignore\n            this.signal.reason = reason;\n            //@ts-ignore\n            this.signal.aborted = true;\n            //@ts-ignore\n            for (const fn of this.signal._onabort) {\n                fn(reason);\n            }\n            this.signal.onabort?.(reason);\n        }\n    };\n    let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== '1';\n    const warnACPolyfill = () => {\n        if (!printACPolyfillWarning)\n            return;\n        printACPolyfillWarning = false;\n        emitWarning('AbortController is not defined. If using lru-cache in ' +\n            'node 14, load an AbortController polyfill from the ' +\n            '`node-abort-controller` package. A minimal polyfill is ' +\n            'provided for use by LRUCache.fetch(), but it should not be ' +\n            'relied upon in other contexts (eg, passing it to other APIs that ' +\n            'use AbortController/AbortSignal might have undesirable effects). ' +\n            'You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.', 'NO_ABORT_CONTROLLER', 'ENOTSUP', warnACPolyfill);\n    };\n}\n/* c8 ignore stop */\nconst shouldWarn = (code) => !warned.has(code);\nconst TYPE = Symbol('type');\nconst isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);\n/* c8 ignore start */\n// This is a little bit ridiculous, tbh.\n// The maximum array length is 2^32-1 or thereabouts on most JS impls.\n// And well before that point, you're caching the entire world, I mean,\n// that's ~32GB of just integers for the next/prev links, plus whatever\n// else to hold that many keys and values.  Just filling the memory with\n// zeroes at init time is brutal when you get that big.\n// But why not be complete?\n// Maybe in the future, these limits will have expanded.\nconst getUintArray = (max) => !isPosInt(max) ? null\n    : max <= Math.pow(2, 8) ? Uint8Array\n        : max <= Math.pow(2, 16) ? Uint16Array\n            : max <= Math.pow(2, 32) ? Uint32Array\n                : max <= Number.MAX_SAFE_INTEGER ? ZeroArray\n                    : null;\n/* c8 ignore stop */\nclass ZeroArray extends Array {\n    constructor(size) {\n        super(size);\n        this.fill(0);\n    }\n}\nclass Stack {\n    heap;\n    length;\n    // private constructor\n    static #constructing = false;\n    static create(max) {\n        const HeapCls = getUintArray(max);\n        if (!HeapCls)\n            return [];\n        Stack.#constructing = true;\n        const s = new Stack(max, HeapCls);\n        Stack.#constructing = false;\n        return s;\n    }\n    constructor(max, HeapCls) {\n        /* c8 ignore start */\n        if (!Stack.#constructing) {\n            throw new TypeError('instantiate Stack using Stack.create(n)');\n        }\n        /* c8 ignore stop */\n        this.heap = new HeapCls(max);\n        this.length = 0;\n    }\n    push(n) {\n        this.heap[this.length++] = n;\n    }\n    pop() {\n        return this.heap[--this.length];\n    }\n}\n/**\n * Default export, the thing you're using this module to get.\n *\n * The `K` and `V` types define the key and value types, respectively. The\n * optional `FC` type defines the type of the `context` object passed to\n * `cache.fetch()` and `cache.memo()`.\n *\n * Keys and values **must not** be `null` or `undefined`.\n *\n * All properties from the options object (with the exception of `max`,\n * `maxSize`, `fetchMethod`, `memoMethod`, `dispose` and `disposeAfter`) are\n * added as normal public members. (The listed options are read-only getters.)\n *\n * Changing any of these will alter the defaults for subsequent method calls.\n */\nclass LRUCache {\n    // options that cannot be changed without disaster\n    #max;\n    #maxSize;\n    #dispose;\n    #onInsert;\n    #disposeAfter;\n    #fetchMethod;\n    #memoMethod;\n    #perf;\n    /**\n     * {@link LRUCache.OptionsBase.perf}\n     */\n    get perf() {\n        return this.#perf;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.ttl}\n     */\n    ttl;\n    /**\n     * {@link LRUCache.OptionsBase.ttlResolution}\n     */\n    ttlResolution;\n    /**\n     * {@link LRUCache.OptionsBase.ttlAutopurge}\n     */\n    ttlAutopurge;\n    /**\n     * {@link LRUCache.OptionsBase.updateAgeOnGet}\n     */\n    updateAgeOnGet;\n    /**\n     * {@link LRUCache.OptionsBase.updateAgeOnHas}\n     */\n    updateAgeOnHas;\n    /**\n     * {@link LRUCache.OptionsBase.allowStale}\n     */\n    allowStale;\n    /**\n     * {@link LRUCache.OptionsBase.noDisposeOnSet}\n     */\n    noDisposeOnSet;\n    /**\n     * {@link LRUCache.OptionsBase.noUpdateTTL}\n     */\n    noUpdateTTL;\n    /**\n     * {@link LRUCache.OptionsBase.maxEntrySize}\n     */\n    maxEntrySize;\n    /**\n     * {@link LRUCache.OptionsBase.sizeCalculation}\n     */\n    sizeCalculation;\n    /**\n     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}\n     */\n    noDeleteOnFetchRejection;\n    /**\n     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}\n     */\n    noDeleteOnStaleGet;\n    /**\n     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}\n     */\n    allowStaleOnFetchAbort;\n    /**\n     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}\n     */\n    allowStaleOnFetchRejection;\n    /**\n     * {@link LRUCache.OptionsBase.ignoreFetchAbort}\n     */\n    ignoreFetchAbort;\n    // computed properties\n    #size;\n    #calculatedSize;\n    #keyMap;\n    #keyList;\n    #valList;\n    #next;\n    #prev;\n    #head;\n    #tail;\n    #free;\n    #disposed;\n    #sizes;\n    #starts;\n    #ttls;\n    #hasDispose;\n    #hasFetchMethod;\n    #hasDisposeAfter;\n    #hasOnInsert;\n    /**\n     * Do not call this method unless you need to inspect the\n     * inner workings of the cache.  If anything returned by this\n     * object is modified in any way, strange breakage may occur.\n     *\n     * These fields are private for a reason!\n     *\n     * @internal\n     */\n    static unsafeExposeInternals(c) {\n        return {\n            // properties\n            starts: c.#starts,\n            ttls: c.#ttls,\n            sizes: c.#sizes,\n            keyMap: c.#keyMap,\n            keyList: c.#keyList,\n            valList: c.#valList,\n            next: c.#next,\n            prev: c.#prev,\n            get head() {\n                return c.#head;\n            },\n            get tail() {\n                return c.#tail;\n            },\n            free: c.#free,\n            // methods\n            isBackgroundFetch: (p) => c.#isBackgroundFetch(p),\n            backgroundFetch: (k, index, options, context) => c.#backgroundFetch(k, index, options, context),\n            moveToTail: (index) => c.#moveToTail(index),\n            indexes: (options) => c.#indexes(options),\n            rindexes: (options) => c.#rindexes(options),\n            isStale: (index) => c.#isStale(index),\n        };\n    }\n    // Protected read-only members\n    /**\n     * {@link LRUCache.OptionsBase.max} (read-only)\n     */\n    get max() {\n        return this.#max;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.maxSize} (read-only)\n     */\n    get maxSize() {\n        return this.#maxSize;\n    }\n    /**\n     * The total computed size of items in the cache (read-only)\n     */\n    get calculatedSize() {\n        return this.#calculatedSize;\n    }\n    /**\n     * The number of items stored in the cache (read-only)\n     */\n    get size() {\n        return this.#size;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.fetchMethod} (read-only)\n     */\n    get fetchMethod() {\n        return this.#fetchMethod;\n    }\n    get memoMethod() {\n        return this.#memoMethod;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.dispose} (read-only)\n     */\n    get dispose() {\n        return this.#dispose;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.onInsert} (read-only)\n     */\n    get onInsert() {\n        return this.#onInsert;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.disposeAfter} (read-only)\n     */\n    get disposeAfter() {\n        return this.#disposeAfter;\n    }\n    constructor(options) {\n        const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, onInsert, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort, perf, } = options;\n        if (perf !== undefined) {\n            if (typeof perf?.now !== 'function') {\n                throw new TypeError('perf option must have a now() method if specified');\n            }\n        }\n        this.#perf = perf ?? defaultPerf;\n        if (max !== 0 && !isPosInt(max)) {\n            throw new TypeError('max option must be a nonnegative integer');\n        }\n        const UintArray = max ? getUintArray(max) : Array;\n        if (!UintArray) {\n            throw new Error('invalid max value: ' + max);\n        }\n        this.#max = max;\n        this.#maxSize = maxSize;\n        this.maxEntrySize = maxEntrySize || this.#maxSize;\n        this.sizeCalculation = sizeCalculation;\n        if (this.sizeCalculation) {\n            if (!this.#maxSize && !this.maxEntrySize) {\n                throw new TypeError('cannot set sizeCalculation without setting maxSize or maxEntrySize');\n            }\n            if (typeof this.sizeCalculation !== 'function') {\n                throw new TypeError('sizeCalculation set to non-function');\n            }\n        }\n        if (memoMethod !== undefined &&\n            typeof memoMethod !== 'function') {\n            throw new TypeError('memoMethod must be a function if defined');\n        }\n        this.#memoMethod = memoMethod;\n        if (fetchMethod !== undefined &&\n            typeof fetchMethod !== 'function') {\n            throw new TypeError('fetchMethod must be a function if specified');\n        }\n        this.#fetchMethod = fetchMethod;\n        this.#hasFetchMethod = !!fetchMethod;\n        this.#keyMap = new Map();\n        this.#keyList = new Array(max).fill(undefined);\n        this.#valList = new Array(max).fill(undefined);\n        this.#next = new UintArray(max);\n        this.#prev = new UintArray(max);\n        this.#head = 0;\n        this.#tail = 0;\n        this.#free = Stack.create(max);\n        this.#size = 0;\n        this.#calculatedSize = 0;\n        if (typeof dispose === 'function') {\n            this.#dispose = dispose;\n        }\n        if (typeof onInsert === 'function') {\n            this.#onInsert = onInsert;\n        }\n        if (typeof disposeAfter === 'function') {\n            this.#disposeAfter = disposeAfter;\n            this.#disposed = [];\n        }\n        else {\n            this.#disposeAfter = undefined;\n            this.#disposed = undefined;\n        }\n        this.#hasDispose = !!this.#dispose;\n        this.#hasOnInsert = !!this.#onInsert;\n        this.#hasDisposeAfter = !!this.#disposeAfter;\n        this.noDisposeOnSet = !!noDisposeOnSet;\n        this.noUpdateTTL = !!noUpdateTTL;\n        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;\n        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;\n        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;\n        this.ignoreFetchAbort = !!ignoreFetchAbort;\n        // NB: maxEntrySize is set to maxSize if it's set\n        if (this.maxEntrySize !== 0) {\n            if (this.#maxSize !== 0) {\n                if (!isPosInt(this.#maxSize)) {\n                    throw new TypeError('maxSize must be a positive integer if specified');\n                }\n            }\n            if (!isPosInt(this.maxEntrySize)) {\n                throw new TypeError('maxEntrySize must be a positive integer if specified');\n            }\n            this.#initializeSizeTracking();\n        }\n        this.allowStale = !!allowStale;\n        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;\n        this.updateAgeOnGet = !!updateAgeOnGet;\n        this.updateAgeOnHas = !!updateAgeOnHas;\n        this.ttlResolution =\n            isPosInt(ttlResolution) || ttlResolution === 0 ?\n                ttlResolution\n                : 1;\n        this.ttlAutopurge = !!ttlAutopurge;\n        this.ttl = ttl || 0;\n        if (this.ttl) {\n            if (!isPosInt(this.ttl)) {\n                throw new TypeError('ttl must be a positive integer if specified');\n            }\n            this.#initializeTTLTracking();\n        }\n        // do not allow completely unbounded caches\n        if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {\n            throw new TypeError('At least one of max, maxSize, or ttl is required');\n        }\n        if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {\n            const code = 'LRU_CACHE_UNBOUNDED';\n            if (shouldWarn(code)) {\n                warned.add(code);\n                const msg = 'TTL caching without ttlAutopurge, max, or maxSize can ' +\n                    'result in unbounded memory consumption.';\n                emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache);\n            }\n        }\n    }\n    /**\n     * Return the number of ms left in the item's TTL. If item is not in cache,\n     * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.\n     */\n    getRemainingTTL(key) {\n        return this.#keyMap.has(key) ? Infinity : 0;\n    }\n    #initializeTTLTracking() {\n        const ttls = new ZeroArray(this.#max);\n        const starts = new ZeroArray(this.#max);\n        this.#ttls = ttls;\n        this.#starts = starts;\n        this.#setItemTTL = (index, ttl, start = this.#perf.now()) => {\n            starts[index] = ttl !== 0 ? start : 0;\n            ttls[index] = ttl;\n            if (ttl !== 0 && this.ttlAutopurge) {\n                const t = setTimeout(() => {\n                    if (this.#isStale(index)) {\n                        this.#delete(this.#keyList[index], 'expire');\n                    }\n                }, ttl + 1);\n                // unref() not supported on all platforms\n                /* c8 ignore start */\n                if (t.unref) {\n                    t.unref();\n                }\n                /* c8 ignore stop */\n            }\n        };\n        this.#updateItemAge = index => {\n            starts[index] = ttls[index] !== 0 ? this.#perf.now() : 0;\n        };\n        this.#statusTTL = (status, index) => {\n            if (ttls[index]) {\n                const ttl = ttls[index];\n                const start = starts[index];\n                /* c8 ignore next */\n                if (!ttl || !start)\n                    return;\n                status.ttl = ttl;\n                status.start = start;\n                status.now = cachedNow || getNow();\n                const age = status.now - start;\n                status.remainingTTL = ttl - age;\n            }\n        };\n        // debounce calls to perf.now() to 1s so we're not hitting\n        // that costly call repeatedly.\n        let cachedNow = 0;\n        const getNow = () => {\n            const n = this.#perf.now();\n            if (this.ttlResolution > 0) {\n                cachedNow = n;\n                const t = setTimeout(() => (cachedNow = 0), this.ttlResolution);\n                // not available on all platforms\n                /* c8 ignore start */\n                if (t.unref) {\n                    t.unref();\n                }\n                /* c8 ignore stop */\n            }\n            return n;\n        };\n        this.getRemainingTTL = key => {\n            const index = this.#keyMap.get(key);\n            if (index === undefined) {\n                return 0;\n            }\n            const ttl = ttls[index];\n            const start = starts[index];\n            if (!ttl || !start) {\n                return Infinity;\n            }\n            const age = (cachedNow || getNow()) - start;\n            return ttl - age;\n        };\n        this.#isStale = index => {\n            const s = starts[index];\n            const t = ttls[index];\n            return !!t && !!s && (cachedNow || getNow()) - s > t;\n        };\n    }\n    // conditionally set private methods related to TTL\n    #updateItemAge = () => { };\n    #statusTTL = () => { };\n    #setItemTTL = () => { };\n    /* c8 ignore stop */\n    #isStale = () => false;\n    #initializeSizeTracking() {\n        const sizes = new ZeroArray(this.#max);\n        this.#calculatedSize = 0;\n        this.#sizes = sizes;\n        this.#removeItemSize = index => {\n            this.#calculatedSize -= sizes[index];\n            sizes[index] = 0;\n        };\n        this.#requireSize = (k, v, size, sizeCalculation) => {\n            // provisionally accept background fetches.\n            // actual value size will be checked when they return.\n            if (this.#isBackgroundFetch(v)) {\n                return 0;\n            }\n            if (!isPosInt(size)) {\n                if (sizeCalculation) {\n                    if (typeof sizeCalculation !== 'function') {\n                        throw new TypeError('sizeCalculation must be a function');\n                    }\n                    size = sizeCalculation(v, k);\n                    if (!isPosInt(size)) {\n                        throw new TypeError('sizeCalculation return invalid (expect positive integer)');\n                    }\n                }\n                else {\n                    throw new TypeError('invalid size value (must be positive integer). ' +\n                        'When maxSize or maxEntrySize is used, sizeCalculation ' +\n                        'or size must be set.');\n                }\n            }\n            return size;\n        };\n        this.#addItemSize = (index, size, status) => {\n            sizes[index] = size;\n            if (this.#maxSize) {\n                const maxSize = this.#maxSize - sizes[index];\n                while (this.#calculatedSize > maxSize) {\n                    this.#evict(true);\n                }\n            }\n            this.#calculatedSize += sizes[index];\n            if (status) {\n                status.entrySize = size;\n                status.totalCalculatedSize = this.#calculatedSize;\n            }\n        };\n    }\n    #removeItemSize = _i => { };\n    #addItemSize = (_i, _s, _st) => { };\n    #requireSize = (_k, _v, size, sizeCalculation) => {\n        if (size || sizeCalculation) {\n            throw new TypeError('cannot set size without setting maxSize or maxEntrySize on cache');\n        }\n        return 0;\n    };\n    *#indexes({ allowStale = this.allowStale } = {}) {\n        if (this.#size) {\n            for (let i = this.#tail; true;) {\n                if (!this.#isValidIndex(i)) {\n                    break;\n                }\n                if (allowStale || !this.#isStale(i)) {\n                    yield i;\n                }\n                if (i === this.#head) {\n                    break;\n                }\n                else {\n                    i = this.#prev[i];\n                }\n            }\n        }\n    }\n    *#rindexes({ allowStale = this.allowStale } = {}) {\n        if (this.#size) {\n            for (let i = this.#head; true;) {\n                if (!this.#isValidIndex(i)) {\n                    break;\n                }\n                if (allowStale || !this.#isStale(i)) {\n                    yield i;\n                }\n                if (i === this.#tail) {\n                    break;\n                }\n                else {\n                    i = this.#next[i];\n                }\n            }\n        }\n    }\n    #isValidIndex(index) {\n        return (index !== undefined &&\n            this.#keyMap.get(this.#keyList[index]) === index);\n    }\n    /**\n     * Return a generator yielding `[key, value]` pairs,\n     * in order from most recently used to least recently used.\n     */\n    *entries() {\n        for (const i of this.#indexes()) {\n            if (this.#valList[i] !== undefined &&\n                this.#keyList[i] !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield [this.#keyList[i], this.#valList[i]];\n            }\n        }\n    }\n    /**\n     * Inverse order version of {@link LRUCache.entries}\n     *\n     * Return a generator yielding `[key, value]` pairs,\n     * in order from least recently used to most recently used.\n     */\n    *rentries() {\n        for (const i of this.#rindexes()) {\n            if (this.#valList[i] !== undefined &&\n                this.#keyList[i] !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield [this.#keyList[i], this.#valList[i]];\n            }\n        }\n    }\n    /**\n     * Return a generator yielding the keys in the cache,\n     * in order from most recently used to least recently used.\n     */\n    *keys() {\n        for (const i of this.#indexes()) {\n            const k = this.#keyList[i];\n            if (k !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield k;\n            }\n        }\n    }\n    /**\n     * Inverse order version of {@link LRUCache.keys}\n     *\n     * Return a generator yielding the keys in the cache,\n     * in order from least recently used to most recently used.\n     */\n    *rkeys() {\n        for (const i of this.#rindexes()) {\n            const k = this.#keyList[i];\n            if (k !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield k;\n            }\n        }\n    }\n    /**\n     * Return a generator yielding the values in the cache,\n     * in order from most recently used to least recently used.\n     */\n    *values() {\n        for (const i of this.#indexes()) {\n            const v = this.#valList[i];\n            if (v !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield this.#valList[i];\n            }\n        }\n    }\n    /**\n     * Inverse order version of {@link LRUCache.values}\n     *\n     * Return a generator yielding the values in the cache,\n     * in order from least recently used to most recently used.\n     */\n    *rvalues() {\n        for (const i of this.#rindexes()) {\n            const v = this.#valList[i];\n            if (v !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield this.#valList[i];\n            }\n        }\n    }\n    /**\n     * Iterating over the cache itself yields the same results as\n     * {@link LRUCache.entries}\n     */\n    [Symbol.iterator]() {\n        return this.entries();\n    }\n    /**\n     * A String value that is used in the creation of the default string\n     * description of an object. Called by the built-in method\n     * `Object.prototype.toString`.\n     */\n    [Symbol.toStringTag] = 'LRUCache';\n    /**\n     * Find a value for which the supplied fn method returns a truthy value,\n     * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.\n     */\n    find(fn, getOptions = {}) {\n        for (const i of this.#indexes()) {\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n            if (value === undefined)\n                continue;\n            if (fn(value, this.#keyList[i], this)) {\n                return this.get(this.#keyList[i], getOptions);\n            }\n        }\n    }\n    /**\n     * Call the supplied function on each item in the cache, in order from most\n     * recently used to least recently used.\n     *\n     * `fn` is called as `fn(value, key, cache)`.\n     *\n     * If `thisp` is provided, function will be called in the `this`-context of\n     * the provided object, or the cache if no `thisp` object is provided.\n     *\n     * Does not update age or recenty of use, or iterate over stale values.\n     */\n    forEach(fn, thisp = this) {\n        for (const i of this.#indexes()) {\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n            if (value === undefined)\n                continue;\n            fn.call(thisp, value, this.#keyList[i], this);\n        }\n    }\n    /**\n     * The same as {@link LRUCache.forEach} but items are iterated over in\n     * reverse order.  (ie, less recently used items are iterated over first.)\n     */\n    rforEach(fn, thisp = this) {\n        for (const i of this.#rindexes()) {\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n            if (value === undefined)\n                continue;\n            fn.call(thisp, value, this.#keyList[i], this);\n        }\n    }\n    /**\n     * Delete any stale entries. Returns true if anything was removed,\n     * false otherwise.\n     */\n    purgeStale() {\n        let deleted = false;\n        for (const i of this.#rindexes({ allowStale: true })) {\n            if (this.#isStale(i)) {\n                this.#delete(this.#keyList[i], 'expire');\n                deleted = true;\n            }\n        }\n        return deleted;\n    }\n    /**\n     * Get the extended info about a given entry, to get its value, size, and\n     * TTL info simultaneously. Returns `undefined` if the key is not present.\n     *\n     * Unlike {@link LRUCache#dump}, which is designed to be portable and survive\n     * serialization, the `start` value is always the current timestamp, and the\n     * `ttl` is a calculated remaining time to live (negative if expired).\n     *\n     * Always returns stale values, if their info is found in the cache, so be\n     * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})\n     * if relevant.\n     */\n    info(key) {\n        const i = this.#keyMap.get(key);\n        if (i === undefined)\n            return undefined;\n        const v = this.#valList[i];\n        /* c8 ignore start - this isn't tested for the info function,\n         * but it's the same logic as found in other places. */\n        const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n        if (value === undefined)\n            return undefined;\n        /* c8 ignore end */\n        const entry = { value };\n        if (this.#ttls && this.#starts) {\n            const ttl = this.#ttls[i];\n            const start = this.#starts[i];\n            if (ttl && start) {\n                const remain = ttl - (this.#perf.now() - start);\n                entry.ttl = remain;\n                entry.start = Date.now();\n            }\n        }\n        if (this.#sizes) {\n            entry.size = this.#sizes[i];\n        }\n        return entry;\n    }\n    /**\n     * Return an array of [key, {@link LRUCache.Entry}] tuples which can be\n     * passed to {@link LRUCache#load}.\n     *\n     * The `start` fields are calculated relative to a portable `Date.now()`\n     * timestamp, even if `performance.now()` is available.\n     *\n     * Stale entries are always included in the `dump`, even if\n     * {@link LRUCache.OptionsBase.allowStale} is false.\n     *\n     * Note: this returns an actual array, not a generator, so it can be more\n     * easily passed around.\n     */\n    dump() {\n        const arr = [];\n        for (const i of this.#indexes({ allowStale: true })) {\n            const key = this.#keyList[i];\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n            if (value === undefined || key === undefined)\n                continue;\n            const entry = { value };\n            if (this.#ttls && this.#starts) {\n                entry.ttl = this.#ttls[i];\n                // always dump the start relative to a portable timestamp\n                // it's ok for this to be a bit slow, it's a rare operation.\n                const age = this.#perf.now() - this.#starts[i];\n                entry.start = Math.floor(Date.now() - age);\n            }\n            if (this.#sizes) {\n                entry.size = this.#sizes[i];\n            }\n            arr.unshift([key, entry]);\n        }\n        return arr;\n    }\n    /**\n     * Reset the cache and load in the items in entries in the order listed.\n     *\n     * The shape of the resulting cache may be different if the same options are\n     * not used in both caches.\n     *\n     * The `start` fields are assumed to be calculated relative to a portable\n     * `Date.now()` timestamp, even if `performance.now()` is available.\n     */\n    load(arr) {\n        this.clear();\n        for (const [key, entry] of arr) {\n            if (entry.start) {\n                // entry.start is a portable timestamp, but we may be using\n                // node's performance.now(), so calculate the offset, so that\n                // we get the intended remaining TTL, no matter how long it's\n                // been on ice.\n                //\n                // it's ok for this to be a bit slow, it's a rare operation.\n                const age = Date.now() - entry.start;\n                entry.start = this.#perf.now() - age;\n            }\n            this.set(key, entry.value, entry);\n        }\n    }\n    /**\n     * Add a value to the cache.\n     *\n     * Note: if `undefined` is specified as a value, this is an alias for\n     * {@link LRUCache#delete}\n     *\n     * Fields on the {@link LRUCache.SetOptions} options param will override\n     * their corresponding values in the constructor options for the scope\n     * of this single `set()` operation.\n     *\n     * If `start` is provided, then that will set the effective start\n     * time for the TTL calculation. Note that this must be a previous\n     * value of `performance.now()` if supported, or a previous value of\n     * `Date.now()` if not.\n     *\n     * Options object may also include `size`, which will prevent\n     * calling the `sizeCalculation` function and just use the specified\n     * number if it is a positive integer, and `noDisposeOnSet` which\n     * will prevent calling a `dispose` function in the case of\n     * overwrites.\n     *\n     * If the `size` (or return value of `sizeCalculation`) for a given\n     * entry is greater than `maxEntrySize`, then the item will not be\n     * added to the cache.\n     *\n     * Will update the recency of the entry.\n     *\n     * If the value is `undefined`, then this is an alias for\n     * `cache.delete(key)`. `undefined` is never stored in the cache.\n     */\n    set(k, v, setOptions = {}) {\n        if (v === undefined) {\n            this.delete(k);\n            return this;\n        }\n        const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status, } = setOptions;\n        let { noUpdateTTL = this.noUpdateTTL } = setOptions;\n        const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);\n        // if the item doesn't fit, don't do anything\n        // NB: maxEntrySize set to maxSize by default\n        if (this.maxEntrySize && size > this.maxEntrySize) {\n            if (status) {\n                status.set = 'miss';\n                status.maxEntrySizeExceeded = true;\n            }\n            // have to delete, in case something is there already.\n            this.#delete(k, 'set');\n            return this;\n        }\n        let index = this.#size === 0 ? undefined : this.#keyMap.get(k);\n        if (index === undefined) {\n            // addition\n            index = (this.#size === 0 ? this.#tail\n                : this.#free.length !== 0 ? this.#free.pop()\n                    : this.#size === this.#max ? this.#evict(false)\n                        : this.#size);\n            this.#keyList[index] = k;\n            this.#valList[index] = v;\n            this.#keyMap.set(k, index);\n            this.#next[this.#tail] = index;\n            this.#prev[index] = this.#tail;\n            this.#tail = index;\n            this.#size++;\n            this.#addItemSize(index, size, status);\n            if (status)\n                status.set = 'add';\n            noUpdateTTL = false;\n            if (this.#hasOnInsert) {\n                this.#onInsert?.(v, k, 'add');\n            }\n        }\n        else {\n            // update\n            this.#moveToTail(index);\n            const oldVal = this.#valList[index];\n            if (v !== oldVal) {\n                if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {\n                    oldVal.__abortController.abort(new Error('replaced'));\n                    const { __staleWhileFetching: s } = oldVal;\n                    if (s !== undefined && !noDisposeOnSet) {\n                        if (this.#hasDispose) {\n                            this.#dispose?.(s, k, 'set');\n                        }\n                        if (this.#hasDisposeAfter) {\n                            this.#disposed?.push([s, k, 'set']);\n                        }\n                    }\n                }\n                else if (!noDisposeOnSet) {\n                    if (this.#hasDispose) {\n                        this.#dispose?.(oldVal, k, 'set');\n                    }\n                    if (this.#hasDisposeAfter) {\n                        this.#disposed?.push([oldVal, k, 'set']);\n                    }\n                }\n                this.#removeItemSize(index);\n                this.#addItemSize(index, size, status);\n                this.#valList[index] = v;\n                if (status) {\n                    status.set = 'replace';\n                    const oldValue = oldVal && this.#isBackgroundFetch(oldVal) ?\n                        oldVal.__staleWhileFetching\n                        : oldVal;\n                    if (oldValue !== undefined)\n                        status.oldValue = oldValue;\n                }\n            }\n            else if (status) {\n                status.set = 'update';\n            }\n            if (this.#hasOnInsert) {\n                this.onInsert?.(v, k, v === oldVal ? 'update' : 'replace');\n            }\n        }\n        if (ttl !== 0 && !this.#ttls) {\n            this.#initializeTTLTracking();\n        }\n        if (this.#ttls) {\n            if (!noUpdateTTL) {\n                this.#setItemTTL(index, ttl, start);\n            }\n            if (status)\n                this.#statusTTL(status, index);\n        }\n        if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {\n            const dt = this.#disposed;\n            let task;\n            while ((task = dt?.shift())) {\n                this.#disposeAfter?.(...task);\n            }\n        }\n        return this;\n    }\n    /**\n     * Evict the least recently used item, returning its value or\n     * `undefined` if cache is empty.\n     */\n    pop() {\n        try {\n            while (this.#size) {\n                const val = this.#valList[this.#head];\n                this.#evict(true);\n                if (this.#isBackgroundFetch(val)) {\n                    if (val.__staleWhileFetching) {\n                        return val.__staleWhileFetching;\n                    }\n                }\n                else if (val !== undefined) {\n                    return val;\n                }\n            }\n        }\n        finally {\n            if (this.#hasDisposeAfter && this.#disposed) {\n                const dt = this.#disposed;\n                let task;\n                while ((task = dt?.shift())) {\n                    this.#disposeAfter?.(...task);\n                }\n            }\n        }\n    }\n    #evict(free) {\n        const head = this.#head;\n        const k = this.#keyList[head];\n        const v = this.#valList[head];\n        if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {\n            v.__abortController.abort(new Error('evicted'));\n        }\n        else if (this.#hasDispose || this.#hasDisposeAfter) {\n            if (this.#hasDispose) {\n                this.#dispose?.(v, k, 'evict');\n            }\n            if (this.#hasDisposeAfter) {\n                this.#disposed?.push([v, k, 'evict']);\n            }\n        }\n        this.#removeItemSize(head);\n        // if we aren't about to use the index, then null these out\n        if (free) {\n            this.#keyList[head] = undefined;\n            this.#valList[head] = undefined;\n            this.#free.push(head);\n        }\n        if (this.#size === 1) {\n            this.#head = this.#tail = 0;\n            this.#free.length = 0;\n        }\n        else {\n            this.#head = this.#next[head];\n        }\n        this.#keyMap.delete(k);\n        this.#size--;\n        return head;\n    }\n    /**\n     * Check if a key is in the cache, without updating the recency of use.\n     * Will return false if the item is stale, even though it is technically\n     * in the cache.\n     *\n     * Check if a key is in the cache, without updating the recency of\n     * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set\n     * to `true` in either the options or the constructor.\n     *\n     * Will return `false` if the item is stale, even though it is technically in\n     * the cache. The difference can be determined (if it matters) by using a\n     * `status` argument, and inspecting the `has` field.\n     *\n     * Will not update item age unless\n     * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.\n     */\n    has(k, hasOptions = {}) {\n        const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;\n        const index = this.#keyMap.get(k);\n        if (index !== undefined) {\n            const v = this.#valList[index];\n            if (this.#isBackgroundFetch(v) &&\n                v.__staleWhileFetching === undefined) {\n                return false;\n            }\n            if (!this.#isStale(index)) {\n                if (updateAgeOnHas) {\n                    this.#updateItemAge(index);\n                }\n                if (status) {\n                    status.has = 'hit';\n                    this.#statusTTL(status, index);\n                }\n                return true;\n            }\n            else if (status) {\n                status.has = 'stale';\n                this.#statusTTL(status, index);\n            }\n        }\n        else if (status) {\n            status.has = 'miss';\n        }\n        return false;\n    }\n    /**\n     * Like {@link LRUCache#get} but doesn't update recency or delete stale\n     * items.\n     *\n     * Returns `undefined` if the item is stale, unless\n     * {@link LRUCache.OptionsBase.allowStale} is set.\n     */\n    peek(k, peekOptions = {}) {\n        const { allowStale = this.allowStale } = peekOptions;\n        const index = this.#keyMap.get(k);\n        if (index === undefined ||\n            (!allowStale && this.#isStale(index))) {\n            return;\n        }\n        const v = this.#valList[index];\n        // either stale and allowed, or forcing a refresh of non-stale value\n        return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n    }\n    #backgroundFetch(k, index, options, context) {\n        const v = index === undefined ? undefined : this.#valList[index];\n        if (this.#isBackgroundFetch(v)) {\n            return v;\n        }\n        const ac = new AC();\n        const { signal } = options;\n        // when/if our AC signals, then stop listening to theirs.\n        signal?.addEventListener('abort', () => ac.abort(signal.reason), {\n            signal: ac.signal,\n        });\n        const fetchOpts = {\n            signal: ac.signal,\n            options,\n            context,\n        };\n        const cb = (v, updateCache = false) => {\n            const { aborted } = ac.signal;\n            const ignoreAbort = options.ignoreFetchAbort && v !== undefined;\n            if (options.status) {\n                if (aborted && !updateCache) {\n                    options.status.fetchAborted = true;\n                    options.status.fetchError = ac.signal.reason;\n                    if (ignoreAbort)\n                        options.status.fetchAbortIgnored = true;\n                }\n                else {\n                    options.status.fetchResolved = true;\n                }\n            }\n            if (aborted && !ignoreAbort && !updateCache) {\n                return fetchFail(ac.signal.reason);\n            }\n            // either we didn't abort, and are still here, or we did, and ignored\n            const bf = p;\n            if (this.#valList[index] === p) {\n                if (v === undefined) {\n                    if (bf.__staleWhileFetching !== undefined) {\n                        this.#valList[index] = bf.__staleWhileFetching;\n                    }\n                    else {\n                        this.#delete(k, 'fetch');\n                    }\n                }\n                else {\n                    if (options.status)\n                        options.status.fetchUpdated = true;\n                    this.set(k, v, fetchOpts.options);\n                }\n            }\n            return v;\n        };\n        const eb = (er) => {\n            if (options.status) {\n                options.status.fetchRejected = true;\n                options.status.fetchError = er;\n            }\n            return fetchFail(er);\n        };\n        const fetchFail = (er) => {\n            const { aborted } = ac.signal;\n            const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;\n            const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;\n            const noDelete = allowStale || options.noDeleteOnFetchRejection;\n            const bf = p;\n            if (this.#valList[index] === p) {\n                // if we allow stale on fetch rejections, then we need to ensure that\n                // the stale value is not removed from the cache when the fetch fails.\n                const del = !noDelete || bf.__staleWhileFetching === undefined;\n                if (del) {\n                    this.#delete(k, 'fetch');\n                }\n                else if (!allowStaleAborted) {\n                    // still replace the *promise* with the stale value,\n                    // since we are done with the promise at this point.\n                    // leave it untouched if we're still waiting for an\n                    // aborted background fetch that hasn't yet returned.\n                    this.#valList[index] = bf.__staleWhileFetching;\n                }\n            }\n            if (allowStale) {\n                if (options.status && bf.__staleWhileFetching !== undefined) {\n                    options.status.returnedStale = true;\n                }\n                return bf.__staleWhileFetching;\n            }\n            else if (bf.__returned === bf) {\n                throw er;\n            }\n        };\n        const pcall = (res, rej) => {\n            const fmp = this.#fetchMethod?.(k, v, fetchOpts);\n            if (fmp && fmp instanceof Promise) {\n                fmp.then(v => res(v === undefined ? undefined : v), rej);\n            }\n            // ignored, we go until we finish, regardless.\n            // defer check until we are actually aborting,\n            // so fetchMethod can override.\n            ac.signal.addEventListener('abort', () => {\n                if (!options.ignoreFetchAbort ||\n                    options.allowStaleOnFetchAbort) {\n                    res(undefined);\n                    // when it eventually resolves, update the cache.\n                    if (options.allowStaleOnFetchAbort) {\n                        res = v => cb(v, true);\n                    }\n                }\n            });\n        };\n        if (options.status)\n            options.status.fetchDispatched = true;\n        const p = new Promise(pcall).then(cb, eb);\n        const bf = Object.assign(p, {\n            __abortController: ac,\n            __staleWhileFetching: v,\n            __returned: undefined,\n        });\n        if (index === undefined) {\n            // internal, don't expose status.\n            this.set(k, bf, { ...fetchOpts.options, status: undefined });\n            index = this.#keyMap.get(k);\n        }\n        else {\n            this.#valList[index] = bf;\n        }\n        return bf;\n    }\n    #isBackgroundFetch(p) {\n        if (!this.#hasFetchMethod)\n            return false;\n        const b = p;\n        return (!!b &&\n            b instanceof Promise &&\n            b.hasOwnProperty('__staleWhileFetching') &&\n            b.__abortController instanceof AC);\n    }\n    async fetch(k, fetchOptions = {}) {\n        const { \n        // get options\n        allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, \n        // set options\n        ttl = this.ttl, noDisposeOnSet = this.noDisposeOnSet, size = 0, sizeCalculation = this.sizeCalculation, noUpdateTTL = this.noUpdateTTL, \n        // fetch exclusive options\n        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection, allowStaleOnFetchRejection = this.allowStaleOnFetchRejection, ignoreFetchAbort = this.ignoreFetchAbort, allowStaleOnFetchAbort = this.allowStaleOnFetchAbort, context, forceRefresh = false, status, signal, } = fetchOptions;\n        if (!this.#hasFetchMethod) {\n            if (status)\n                status.fetch = 'get';\n            return this.get(k, {\n                allowStale,\n                updateAgeOnGet,\n                noDeleteOnStaleGet,\n                status,\n            });\n        }\n        const options = {\n            allowStale,\n            updateAgeOnGet,\n            noDeleteOnStaleGet,\n            ttl,\n            noDisposeOnSet,\n            size,\n            sizeCalculation,\n            noUpdateTTL,\n            noDeleteOnFetchRejection,\n            allowStaleOnFetchRejection,\n            allowStaleOnFetchAbort,\n            ignoreFetchAbort,\n            status,\n            signal,\n        };\n        let index = this.#keyMap.get(k);\n        if (index === undefined) {\n            if (status)\n                status.fetch = 'miss';\n            const p = this.#backgroundFetch(k, index, options, context);\n            return (p.__returned = p);\n        }\n        else {\n            // in cache, maybe already fetching\n            const v = this.#valList[index];\n            if (this.#isBackgroundFetch(v)) {\n                const stale = allowStale && v.__staleWhileFetching !== undefined;\n                if (status) {\n                    status.fetch = 'inflight';\n                    if (stale)\n                        status.returnedStale = true;\n                }\n                return stale ? v.__staleWhileFetching : (v.__returned = v);\n            }\n            // if we force a refresh, that means do NOT serve the cached value,\n            // unless we are already in the process of refreshing the cache.\n            const isStale = this.#isStale(index);\n            if (!forceRefresh && !isStale) {\n                if (status)\n                    status.fetch = 'hit';\n                this.#moveToTail(index);\n                if (updateAgeOnGet) {\n                    this.#updateItemAge(index);\n                }\n                if (status)\n                    this.#statusTTL(status, index);\n                return v;\n            }\n            // ok, it is stale or a forced refresh, and not already fetching.\n            // refresh the cache.\n            const p = this.#backgroundFetch(k, index, options, context);\n            const hasStale = p.__staleWhileFetching !== undefined;\n            const staleVal = hasStale && allowStale;\n            if (status) {\n                status.fetch = isStale ? 'stale' : 'refresh';\n                if (staleVal && isStale)\n                    status.returnedStale = true;\n            }\n            return staleVal ? p.__staleWhileFetching : (p.__returned = p);\n        }\n    }\n    async forceFetch(k, fetchOptions = {}) {\n        const v = await this.fetch(k, fetchOptions);\n        if (v === undefined)\n            throw new Error('fetch() returned undefined');\n        return v;\n    }\n    memo(k, memoOptions = {}) {\n        const memoMethod = this.#memoMethod;\n        if (!memoMethod) {\n            throw new Error('no memoMethod provided to constructor');\n        }\n        const { context, forceRefresh, ...options } = memoOptions;\n        const v = this.get(k, options);\n        if (!forceRefresh && v !== undefined)\n            return v;\n        const vv = memoMethod(k, v, {\n            options,\n            context,\n        });\n        this.set(k, vv, options);\n        return vv;\n    }\n    /**\n     * Return a value from the cache. Will update the recency of the cache\n     * entry found.\n     *\n     * If the key is not found, get() will return `undefined`.\n     */\n    get(k, getOptions = {}) {\n        const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status, } = getOptions;\n        const index = this.#keyMap.get(k);\n        if (index !== undefined) {\n            const value = this.#valList[index];\n            const fetching = this.#isBackgroundFetch(value);\n            if (status)\n                this.#statusTTL(status, index);\n            if (this.#isStale(index)) {\n                if (status)\n                    status.get = 'stale';\n                // delete only if not an in-flight background fetch\n                if (!fetching) {\n                    if (!noDeleteOnStaleGet) {\n                        this.#delete(k, 'expire');\n                    }\n                    if (status && allowStale)\n                        status.returnedStale = true;\n                    return allowStale ? value : undefined;\n                }\n                else {\n                    if (status &&\n                        allowStale &&\n                        value.__staleWhileFetching !== undefined) {\n                        status.returnedStale = true;\n                    }\n                    return allowStale ? value.__staleWhileFetching : undefined;\n                }\n            }\n            else {\n                if (status)\n                    status.get = 'hit';\n                // if we're currently fetching it, we don't actually have it yet\n                // it's not stale, which means this isn't a staleWhileRefetching.\n                // If it's not stale, and fetching, AND has a __staleWhileFetching\n                // value, then that means the user fetched with {forceRefresh:true},\n                // so it's safe to return that value.\n                if (fetching) {\n                    return value.__staleWhileFetching;\n                }\n                this.#moveToTail(index);\n                if (updateAgeOnGet) {\n                    this.#updateItemAge(index);\n                }\n                return value;\n            }\n        }\n        else if (status) {\n            status.get = 'miss';\n        }\n    }\n    #connect(p, n) {\n        this.#prev[n] = p;\n        this.#next[p] = n;\n    }\n    #moveToTail(index) {\n        // if tail already, nothing to do\n        // if head, move head to next[index]\n        // else\n        //   move next[prev[index]] to next[index] (head has no prev)\n        //   move prev[next[index]] to prev[index]\n        // prev[index] = tail\n        // next[tail] = index\n        // tail = index\n        if (index !== this.#tail) {\n            if (index === this.#head) {\n                this.#head = this.#next[index];\n            }\n            else {\n                this.#connect(this.#prev[index], this.#next[index]);\n            }\n            this.#connect(this.#tail, index);\n            this.#tail = index;\n        }\n    }\n    /**\n     * Deletes a key out of the cache.\n     *\n     * Returns true if the key was deleted, false otherwise.\n     */\n    delete(k) {\n        return this.#delete(k, 'delete');\n    }\n    #delete(k, reason) {\n        let deleted = false;\n        if (this.#size !== 0) {\n            const index = this.#keyMap.get(k);\n            if (index !== undefined) {\n                deleted = true;\n                if (this.#size === 1) {\n                    this.#clear(reason);\n                }\n                else {\n                    this.#removeItemSize(index);\n                    const v = this.#valList[index];\n                    if (this.#isBackgroundFetch(v)) {\n                        v.__abortController.abort(new Error('deleted'));\n                    }\n                    else if (this.#hasDispose || this.#hasDisposeAfter) {\n                        if (this.#hasDispose) {\n                            this.#dispose?.(v, k, reason);\n                        }\n                        if (this.#hasDisposeAfter) {\n                            this.#disposed?.push([v, k, reason]);\n                        }\n                    }\n                    this.#keyMap.delete(k);\n                    this.#keyList[index] = undefined;\n                    this.#valList[index] = undefined;\n                    if (index === this.#tail) {\n                        this.#tail = this.#prev[index];\n                    }\n                    else if (index === this.#head) {\n                        this.#head = this.#next[index];\n                    }\n                    else {\n                        const pi = this.#prev[index];\n                        this.#next[pi] = this.#next[index];\n                        const ni = this.#next[index];\n                        this.#prev[ni] = this.#prev[index];\n                    }\n                    this.#size--;\n                    this.#free.push(index);\n                }\n            }\n        }\n        if (this.#hasDisposeAfter && this.#disposed?.length) {\n            const dt = this.#disposed;\n            let task;\n            while ((task = dt?.shift())) {\n                this.#disposeAfter?.(...task);\n            }\n        }\n        return deleted;\n    }\n    /**\n     * Clear the cache entirely, throwing away all values.\n     */\n    clear() {\n        return this.#clear('delete');\n    }\n    #clear(reason) {\n        for (const index of this.#rindexes({ allowStale: true })) {\n            const v = this.#valList[index];\n            if (this.#isBackgroundFetch(v)) {\n                v.__abortController.abort(new Error('deleted'));\n            }\n            else {\n                const k = this.#keyList[index];\n                if (this.#hasDispose) {\n                    this.#dispose?.(v, k, reason);\n                }\n                if (this.#hasDisposeAfter) {\n                    this.#disposed?.push([v, k, reason]);\n                }\n            }\n        }\n        this.#keyMap.clear();\n        this.#valList.fill(undefined);\n        this.#keyList.fill(undefined);\n        if (this.#ttls && this.#starts) {\n            this.#ttls.fill(0);\n            this.#starts.fill(0);\n        }\n        if (this.#sizes) {\n            this.#sizes.fill(0);\n        }\n        this.#head = 0;\n        this.#tail = 0;\n        this.#free.length = 0;\n        this.#calculatedSize = 0;\n        this.#size = 0;\n        if (this.#hasDisposeAfter && this.#disposed) {\n            const dt = this.#disposed;\n            let task;\n            while ((task = dt?.shift())) {\n                this.#disposeAfter?.(...task);\n            }\n        }\n    }\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZTJiL25vZGVfbW9kdWxlcy9scnUtY2FjaGUvZGlzdC9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixLQUFLLElBQUksS0FBSyxJQUFJLElBQUk7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdDQUFnQztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvQ0FBb0M7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsd0NBQXdDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9DQUFvQztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxxQ0FBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEseUNBQXlDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsOFZBQThWO0FBQzlXO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQkFBK0IsSUFBSTtBQUNuRDtBQUNBLHFDQUFxQyxLQUFLO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwrQkFBK0IsSUFBSTtBQUNwRDtBQUNBLHFDQUFxQyxLQUFLO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdCQUF3QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGtCQUFrQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QseUJBQXlCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxxQkFBcUI7QUFDdEQsa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1Q0FBdUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGtCQUFrQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esc0JBQXNCLDJCQUEyQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtHQUErRztBQUMvSCxjQUFjLGlDQUFpQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDBCQUEwQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMkNBQTJDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwyQ0FBMkM7QUFDbkQ7QUFDQSwwQkFBMEI7QUFDMUIsZ0JBQWdCLCtDQUErQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdUNBQXVDO0FBQy9DO0FBQ0EsNEJBQTRCO0FBQzVCLGdCQUFnQiwrQkFBK0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDhCQUE4Qix5Q0FBeUM7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaVJBQWlSO0FBQ2pSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0NBQW9DO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsZ0JBQWdCLDRIQUE0SDtBQUM1STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsa0JBQWtCO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGtCQUFrQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aXZlLXZpYmUtYWktbmV4dC8uL25vZGVfbW9kdWxlcy9lMmIvbm9kZV9tb2R1bGVzL2xydS1jYWNoZS9kaXN0L2VzbS9pbmRleC5qcz85YTYxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBMUlVDYWNoZVxuICovXG5jb25zdCBkZWZhdWx0UGVyZiA9ICh0eXBlb2YgcGVyZm9ybWFuY2UgPT09ICdvYmplY3QnICYmXG4gICAgcGVyZm9ybWFuY2UgJiZcbiAgICB0eXBlb2YgcGVyZm9ybWFuY2Uubm93ID09PSAnZnVuY3Rpb24nKSA/XG4gICAgcGVyZm9ybWFuY2VcbiAgICA6IERhdGU7XG5jb25zdCB3YXJuZWQgPSBuZXcgU2V0KCk7XG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cbmNvbnN0IFBST0NFU1MgPSAodHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmICEhcHJvY2VzcyA/XG4gICAgcHJvY2Vzc1xuICAgIDoge30pO1xuLyogYzggaWdub3JlIHN0YXJ0ICovXG5jb25zdCBlbWl0V2FybmluZyA9IChtc2csIHR5cGUsIGNvZGUsIGZuKSA9PiB7XG4gICAgdHlwZW9mIFBST0NFU1MuZW1pdFdhcm5pbmcgPT09ICdmdW5jdGlvbicgP1xuICAgICAgICBQUk9DRVNTLmVtaXRXYXJuaW5nKG1zZywgdHlwZSwgY29kZSwgZm4pXG4gICAgICAgIDogY29uc29sZS5lcnJvcihgWyR7Y29kZX1dICR7dHlwZX06ICR7bXNnfWApO1xufTtcbmxldCBBQyA9IGdsb2JhbFRoaXMuQWJvcnRDb250cm9sbGVyO1xubGV0IEFTID0gZ2xvYmFsVGhpcy5BYm9ydFNpZ25hbDtcbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xuaWYgKHR5cGVvZiBBQyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvL0B0cy1pZ25vcmVcbiAgICBBUyA9IGNsYXNzIEFib3J0U2lnbmFsIHtcbiAgICAgICAgb25hYm9ydDtcbiAgICAgICAgX29uYWJvcnQgPSBbXTtcbiAgICAgICAgcmVhc29uO1xuICAgICAgICBhYm9ydGVkID0gZmFsc2U7XG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoXywgZm4pIHtcbiAgICAgICAgICAgIHRoaXMuX29uYWJvcnQucHVzaChmbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vQHRzLWlnbm9yZVxuICAgIEFDID0gY2xhc3MgQWJvcnRDb250cm9sbGVyIHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICB3YXJuQUNQb2x5ZmlsbCgpO1xuICAgICAgICB9XG4gICAgICAgIHNpZ25hbCA9IG5ldyBBUygpO1xuICAgICAgICBhYm9ydChyZWFzb24pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNpZ25hbC5hYm9ydGVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgICAgICAgdGhpcy5zaWduYWwucmVhc29uID0gcmVhc29uO1xuICAgICAgICAgICAgLy9AdHMtaWdub3JlXG4gICAgICAgICAgICB0aGlzLnNpZ25hbC5hYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgICAgICAgZm9yIChjb25zdCBmbiBvZiB0aGlzLnNpZ25hbC5fb25hYm9ydCkge1xuICAgICAgICAgICAgICAgIGZuKHJlYXNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNpZ25hbC5vbmFib3J0Py4ocmVhc29uKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgbGV0IHByaW50QUNQb2x5ZmlsbFdhcm5pbmcgPSBQUk9DRVNTLmVudj8uTFJVX0NBQ0hFX0lHTk9SRV9BQ19XQVJOSU5HICE9PSAnMSc7XG4gICAgY29uc3Qgd2FybkFDUG9seWZpbGwgPSAoKSA9PiB7XG4gICAgICAgIGlmICghcHJpbnRBQ1BvbHlmaWxsV2FybmluZylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcHJpbnRBQ1BvbHlmaWxsV2FybmluZyA9IGZhbHNlO1xuICAgICAgICBlbWl0V2FybmluZygnQWJvcnRDb250cm9sbGVyIGlzIG5vdCBkZWZpbmVkLiBJZiB1c2luZyBscnUtY2FjaGUgaW4gJyArXG4gICAgICAgICAgICAnbm9kZSAxNCwgbG9hZCBhbiBBYm9ydENvbnRyb2xsZXIgcG9seWZpbGwgZnJvbSB0aGUgJyArXG4gICAgICAgICAgICAnYG5vZGUtYWJvcnQtY29udHJvbGxlcmAgcGFja2FnZS4gQSBtaW5pbWFsIHBvbHlmaWxsIGlzICcgK1xuICAgICAgICAgICAgJ3Byb3ZpZGVkIGZvciB1c2UgYnkgTFJVQ2FjaGUuZmV0Y2goKSwgYnV0IGl0IHNob3VsZCBub3QgYmUgJyArXG4gICAgICAgICAgICAncmVsaWVkIHVwb24gaW4gb3RoZXIgY29udGV4dHMgKGVnLCBwYXNzaW5nIGl0IHRvIG90aGVyIEFQSXMgdGhhdCAnICtcbiAgICAgICAgICAgICd1c2UgQWJvcnRDb250cm9sbGVyL0Fib3J0U2lnbmFsIG1pZ2h0IGhhdmUgdW5kZXNpcmFibGUgZWZmZWN0cykuICcgK1xuICAgICAgICAgICAgJ1lvdSBtYXkgZGlzYWJsZSB0aGlzIHdpdGggTFJVX0NBQ0hFX0lHTk9SRV9BQ19XQVJOSU5HPTEgaW4gdGhlIGVudi4nLCAnTk9fQUJPUlRfQ09OVFJPTExFUicsICdFTk9UU1VQJywgd2FybkFDUG9seWZpbGwpO1xuICAgIH07XG59XG4vKiBjOCBpZ25vcmUgc3RvcCAqL1xuY29uc3Qgc2hvdWxkV2FybiA9IChjb2RlKSA9PiAhd2FybmVkLmhhcyhjb2RlKTtcbmNvbnN0IFRZUEUgPSBTeW1ib2woJ3R5cGUnKTtcbmNvbnN0IGlzUG9zSW50ID0gKG4pID0+IG4gJiYgbiA9PT0gTWF0aC5mbG9vcihuKSAmJiBuID4gMCAmJiBpc0Zpbml0ZShuKTtcbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xuLy8gVGhpcyBpcyBhIGxpdHRsZSBiaXQgcmlkaWN1bG91cywgdGJoLlxuLy8gVGhlIG1heGltdW0gYXJyYXkgbGVuZ3RoIGlzIDJeMzItMSBvciB0aGVyZWFib3V0cyBvbiBtb3N0IEpTIGltcGxzLlxuLy8gQW5kIHdlbGwgYmVmb3JlIHRoYXQgcG9pbnQsIHlvdSdyZSBjYWNoaW5nIHRoZSBlbnRpcmUgd29ybGQsIEkgbWVhbixcbi8vIHRoYXQncyB+MzJHQiBvZiBqdXN0IGludGVnZXJzIGZvciB0aGUgbmV4dC9wcmV2IGxpbmtzLCBwbHVzIHdoYXRldmVyXG4vLyBlbHNlIHRvIGhvbGQgdGhhdCBtYW55IGtleXMgYW5kIHZhbHVlcy4gIEp1c3QgZmlsbGluZyB0aGUgbWVtb3J5IHdpdGhcbi8vIHplcm9lcyBhdCBpbml0IHRpbWUgaXMgYnJ1dGFsIHdoZW4geW91IGdldCB0aGF0IGJpZy5cbi8vIEJ1dCB3aHkgbm90IGJlIGNvbXBsZXRlP1xuLy8gTWF5YmUgaW4gdGhlIGZ1dHVyZSwgdGhlc2UgbGltaXRzIHdpbGwgaGF2ZSBleHBhbmRlZC5cbmNvbnN0IGdldFVpbnRBcnJheSA9IChtYXgpID0+ICFpc1Bvc0ludChtYXgpID8gbnVsbFxuICAgIDogbWF4IDw9IE1hdGgucG93KDIsIDgpID8gVWludDhBcnJheVxuICAgICAgICA6IG1heCA8PSBNYXRoLnBvdygyLCAxNikgPyBVaW50MTZBcnJheVxuICAgICAgICAgICAgOiBtYXggPD0gTWF0aC5wb3coMiwgMzIpID8gVWludDMyQXJyYXlcbiAgICAgICAgICAgICAgICA6IG1heCA8PSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiA/IFplcm9BcnJheVxuICAgICAgICAgICAgICAgICAgICA6IG51bGw7XG4vKiBjOCBpZ25vcmUgc3RvcCAqL1xuY2xhc3MgWmVyb0FycmF5IGV4dGVuZHMgQXJyYXkge1xuICAgIGNvbnN0cnVjdG9yKHNpemUpIHtcbiAgICAgICAgc3VwZXIoc2l6ZSk7XG4gICAgICAgIHRoaXMuZmlsbCgwKTtcbiAgICB9XG59XG5jbGFzcyBTdGFjayB7XG4gICAgaGVhcDtcbiAgICBsZW5ndGg7XG4gICAgLy8gcHJpdmF0ZSBjb25zdHJ1Y3RvclxuICAgIHN0YXRpYyAjY29uc3RydWN0aW5nID0gZmFsc2U7XG4gICAgc3RhdGljIGNyZWF0ZShtYXgpIHtcbiAgICAgICAgY29uc3QgSGVhcENscyA9IGdldFVpbnRBcnJheShtYXgpO1xuICAgICAgICBpZiAoIUhlYXBDbHMpXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIFN0YWNrLiNjb25zdHJ1Y3RpbmcgPSB0cnVlO1xuICAgICAgICBjb25zdCBzID0gbmV3IFN0YWNrKG1heCwgSGVhcENscyk7XG4gICAgICAgIFN0YWNrLiNjb25zdHJ1Y3RpbmcgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG1heCwgSGVhcENscykge1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgaWYgKCFTdGFjay4jY29uc3RydWN0aW5nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnN0YW50aWF0ZSBTdGFjayB1c2luZyBTdGFjay5jcmVhdGUobiknKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICB0aGlzLmhlYXAgPSBuZXcgSGVhcENscyhtYXgpO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIHB1c2gobikge1xuICAgICAgICB0aGlzLmhlYXBbdGhpcy5sZW5ndGgrK10gPSBuO1xuICAgIH1cbiAgICBwb3AoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhlYXBbLS10aGlzLmxlbmd0aF07XG4gICAgfVxufVxuLyoqXG4gKiBEZWZhdWx0IGV4cG9ydCwgdGhlIHRoaW5nIHlvdSdyZSB1c2luZyB0aGlzIG1vZHVsZSB0byBnZXQuXG4gKlxuICogVGhlIGBLYCBhbmQgYFZgIHR5cGVzIGRlZmluZSB0aGUga2V5IGFuZCB2YWx1ZSB0eXBlcywgcmVzcGVjdGl2ZWx5LiBUaGVcbiAqIG9wdGlvbmFsIGBGQ2AgdHlwZSBkZWZpbmVzIHRoZSB0eXBlIG9mIHRoZSBgY29udGV4dGAgb2JqZWN0IHBhc3NlZCB0b1xuICogYGNhY2hlLmZldGNoKClgIGFuZCBgY2FjaGUubWVtbygpYC5cbiAqXG4gKiBLZXlzIGFuZCB2YWx1ZXMgKiptdXN0IG5vdCoqIGJlIGBudWxsYCBvciBgdW5kZWZpbmVkYC5cbiAqXG4gKiBBbGwgcHJvcGVydGllcyBmcm9tIHRoZSBvcHRpb25zIG9iamVjdCAod2l0aCB0aGUgZXhjZXB0aW9uIG9mIGBtYXhgLFxuICogYG1heFNpemVgLCBgZmV0Y2hNZXRob2RgLCBgbWVtb01ldGhvZGAsIGBkaXNwb3NlYCBhbmQgYGRpc3Bvc2VBZnRlcmApIGFyZVxuICogYWRkZWQgYXMgbm9ybWFsIHB1YmxpYyBtZW1iZXJzLiAoVGhlIGxpc3RlZCBvcHRpb25zIGFyZSByZWFkLW9ubHkgZ2V0dGVycy4pXG4gKlxuICogQ2hhbmdpbmcgYW55IG9mIHRoZXNlIHdpbGwgYWx0ZXIgdGhlIGRlZmF1bHRzIGZvciBzdWJzZXF1ZW50IG1ldGhvZCBjYWxscy5cbiAqL1xuZXhwb3J0IGNsYXNzIExSVUNhY2hlIHtcbiAgICAvLyBvcHRpb25zIHRoYXQgY2Fubm90IGJlIGNoYW5nZWQgd2l0aG91dCBkaXNhc3RlclxuICAgICNtYXg7XG4gICAgI21heFNpemU7XG4gICAgI2Rpc3Bvc2U7XG4gICAgI29uSW5zZXJ0O1xuICAgICNkaXNwb3NlQWZ0ZXI7XG4gICAgI2ZldGNoTWV0aG9kO1xuICAgICNtZW1vTWV0aG9kO1xuICAgICNwZXJmO1xuICAgIC8qKlxuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS5wZXJmfVxuICAgICAqL1xuICAgIGdldCBwZXJmKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jcGVyZjtcbiAgICB9XG4gICAgLyoqXG4gICAgICoge0BsaW5rIExSVUNhY2hlLk9wdGlvbnNCYXNlLnR0bH1cbiAgICAgKi9cbiAgICB0dGw7XG4gICAgLyoqXG4gICAgICoge0BsaW5rIExSVUNhY2hlLk9wdGlvbnNCYXNlLnR0bFJlc29sdXRpb259XG4gICAgICovXG4gICAgdHRsUmVzb2x1dGlvbjtcbiAgICAvKipcbiAgICAgKiB7QGxpbmsgTFJVQ2FjaGUuT3B0aW9uc0Jhc2UudHRsQXV0b3B1cmdlfVxuICAgICAqL1xuICAgIHR0bEF1dG9wdXJnZTtcbiAgICAvKipcbiAgICAgKiB7QGxpbmsgTFJVQ2FjaGUuT3B0aW9uc0Jhc2UudXBkYXRlQWdlT25HZXR9XG4gICAgICovXG4gICAgdXBkYXRlQWdlT25HZXQ7XG4gICAgLyoqXG4gICAgICoge0BsaW5rIExSVUNhY2hlLk9wdGlvbnNCYXNlLnVwZGF0ZUFnZU9uSGFzfVxuICAgICAqL1xuICAgIHVwZGF0ZUFnZU9uSGFzO1xuICAgIC8qKlxuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS5hbGxvd1N0YWxlfVxuICAgICAqL1xuICAgIGFsbG93U3RhbGU7XG4gICAgLyoqXG4gICAgICoge0BsaW5rIExSVUNhY2hlLk9wdGlvbnNCYXNlLm5vRGlzcG9zZU9uU2V0fVxuICAgICAqL1xuICAgIG5vRGlzcG9zZU9uU2V0O1xuICAgIC8qKlxuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS5ub1VwZGF0ZVRUTH1cbiAgICAgKi9cbiAgICBub1VwZGF0ZVRUTDtcbiAgICAvKipcbiAgICAgKiB7QGxpbmsgTFJVQ2FjaGUuT3B0aW9uc0Jhc2UubWF4RW50cnlTaXplfVxuICAgICAqL1xuICAgIG1heEVudHJ5U2l6ZTtcbiAgICAvKipcbiAgICAgKiB7QGxpbmsgTFJVQ2FjaGUuT3B0aW9uc0Jhc2Uuc2l6ZUNhbGN1bGF0aW9ufVxuICAgICAqL1xuICAgIHNpemVDYWxjdWxhdGlvbjtcbiAgICAvKipcbiAgICAgKiB7QGxpbmsgTFJVQ2FjaGUuT3B0aW9uc0Jhc2Uubm9EZWxldGVPbkZldGNoUmVqZWN0aW9ufVxuICAgICAqL1xuICAgIG5vRGVsZXRlT25GZXRjaFJlamVjdGlvbjtcbiAgICAvKipcbiAgICAgKiB7QGxpbmsgTFJVQ2FjaGUuT3B0aW9uc0Jhc2Uubm9EZWxldGVPblN0YWxlR2V0fVxuICAgICAqL1xuICAgIG5vRGVsZXRlT25TdGFsZUdldDtcbiAgICAvKipcbiAgICAgKiB7QGxpbmsgTFJVQ2FjaGUuT3B0aW9uc0Jhc2UuYWxsb3dTdGFsZU9uRmV0Y2hBYm9ydH1cbiAgICAgKi9cbiAgICBhbGxvd1N0YWxlT25GZXRjaEFib3J0O1xuICAgIC8qKlxuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS5hbGxvd1N0YWxlT25GZXRjaFJlamVjdGlvbn1cbiAgICAgKi9cbiAgICBhbGxvd1N0YWxlT25GZXRjaFJlamVjdGlvbjtcbiAgICAvKipcbiAgICAgKiB7QGxpbmsgTFJVQ2FjaGUuT3B0aW9uc0Jhc2UuaWdub3JlRmV0Y2hBYm9ydH1cbiAgICAgKi9cbiAgICBpZ25vcmVGZXRjaEFib3J0O1xuICAgIC8vIGNvbXB1dGVkIHByb3BlcnRpZXNcbiAgICAjc2l6ZTtcbiAgICAjY2FsY3VsYXRlZFNpemU7XG4gICAgI2tleU1hcDtcbiAgICAja2V5TGlzdDtcbiAgICAjdmFsTGlzdDtcbiAgICAjbmV4dDtcbiAgICAjcHJldjtcbiAgICAjaGVhZDtcbiAgICAjdGFpbDtcbiAgICAjZnJlZTtcbiAgICAjZGlzcG9zZWQ7XG4gICAgI3NpemVzO1xuICAgICNzdGFydHM7XG4gICAgI3R0bHM7XG4gICAgI2hhc0Rpc3Bvc2U7XG4gICAgI2hhc0ZldGNoTWV0aG9kO1xuICAgICNoYXNEaXNwb3NlQWZ0ZXI7XG4gICAgI2hhc09uSW5zZXJ0O1xuICAgIC8qKlxuICAgICAqIERvIG5vdCBjYWxsIHRoaXMgbWV0aG9kIHVubGVzcyB5b3UgbmVlZCB0byBpbnNwZWN0IHRoZVxuICAgICAqIGlubmVyIHdvcmtpbmdzIG9mIHRoZSBjYWNoZS4gIElmIGFueXRoaW5nIHJldHVybmVkIGJ5IHRoaXNcbiAgICAgKiBvYmplY3QgaXMgbW9kaWZpZWQgaW4gYW55IHdheSwgc3RyYW5nZSBicmVha2FnZSBtYXkgb2NjdXIuXG4gICAgICpcbiAgICAgKiBUaGVzZSBmaWVsZHMgYXJlIHByaXZhdGUgZm9yIGEgcmVhc29uIVxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgc3RhdGljIHVuc2FmZUV4cG9zZUludGVybmFscyhjKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAvLyBwcm9wZXJ0aWVzXG4gICAgICAgICAgICBzdGFydHM6IGMuI3N0YXJ0cyxcbiAgICAgICAgICAgIHR0bHM6IGMuI3R0bHMsXG4gICAgICAgICAgICBzaXplczogYy4jc2l6ZXMsXG4gICAgICAgICAgICBrZXlNYXA6IGMuI2tleU1hcCxcbiAgICAgICAgICAgIGtleUxpc3Q6IGMuI2tleUxpc3QsXG4gICAgICAgICAgICB2YWxMaXN0OiBjLiN2YWxMaXN0LFxuICAgICAgICAgICAgbmV4dDogYy4jbmV4dCxcbiAgICAgICAgICAgIHByZXY6IGMuI3ByZXYsXG4gICAgICAgICAgICBnZXQgaGVhZCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYy4jaGVhZDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQgdGFpbCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYy4jdGFpbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmcmVlOiBjLiNmcmVlLFxuICAgICAgICAgICAgLy8gbWV0aG9kc1xuICAgICAgICAgICAgaXNCYWNrZ3JvdW5kRmV0Y2g6IChwKSA9PiBjLiNpc0JhY2tncm91bmRGZXRjaChwKSxcbiAgICAgICAgICAgIGJhY2tncm91bmRGZXRjaDogKGssIGluZGV4LCBvcHRpb25zLCBjb250ZXh0KSA9PiBjLiNiYWNrZ3JvdW5kRmV0Y2goaywgaW5kZXgsIG9wdGlvbnMsIGNvbnRleHQpLFxuICAgICAgICAgICAgbW92ZVRvVGFpbDogKGluZGV4KSA9PiBjLiNtb3ZlVG9UYWlsKGluZGV4KSxcbiAgICAgICAgICAgIGluZGV4ZXM6IChvcHRpb25zKSA9PiBjLiNpbmRleGVzKG9wdGlvbnMpLFxuICAgICAgICAgICAgcmluZGV4ZXM6IChvcHRpb25zKSA9PiBjLiNyaW5kZXhlcyhvcHRpb25zKSxcbiAgICAgICAgICAgIGlzU3RhbGU6IChpbmRleCkgPT4gYy4jaXNTdGFsZShpbmRleCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIFByb3RlY3RlZCByZWFkLW9ubHkgbWVtYmVyc1xuICAgIC8qKlxuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS5tYXh9IChyZWFkLW9ubHkpXG4gICAgICovXG4gICAgZ2V0IG1heCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI21heDtcbiAgICB9XG4gICAgLyoqXG4gICAgICoge0BsaW5rIExSVUNhY2hlLk9wdGlvbnNCYXNlLm1heFNpemV9IChyZWFkLW9ubHkpXG4gICAgICovXG4gICAgZ2V0IG1heFNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNtYXhTaXplO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgdG90YWwgY29tcHV0ZWQgc2l6ZSBvZiBpdGVtcyBpbiB0aGUgY2FjaGUgKHJlYWQtb25seSlcbiAgICAgKi9cbiAgICBnZXQgY2FsY3VsYXRlZFNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNjYWxjdWxhdGVkU2l6ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBpdGVtcyBzdG9yZWQgaW4gdGhlIGNhY2hlIChyZWFkLW9ubHkpXG4gICAgICovXG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNzaXplO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB7QGxpbmsgTFJVQ2FjaGUuT3B0aW9uc0Jhc2UuZmV0Y2hNZXRob2R9IChyZWFkLW9ubHkpXG4gICAgICovXG4gICAgZ2V0IGZldGNoTWV0aG9kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jZmV0Y2hNZXRob2Q7XG4gICAgfVxuICAgIGdldCBtZW1vTWV0aG9kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jbWVtb01ldGhvZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICoge0BsaW5rIExSVUNhY2hlLk9wdGlvbnNCYXNlLmRpc3Bvc2V9IChyZWFkLW9ubHkpXG4gICAgICovXG4gICAgZ2V0IGRpc3Bvc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNkaXNwb3NlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB7QGxpbmsgTFJVQ2FjaGUuT3B0aW9uc0Jhc2Uub25JbnNlcnR9IChyZWFkLW9ubHkpXG4gICAgICovXG4gICAgZ2V0IG9uSW5zZXJ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jb25JbnNlcnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS5kaXNwb3NlQWZ0ZXJ9IChyZWFkLW9ubHkpXG4gICAgICovXG4gICAgZ2V0IGRpc3Bvc2VBZnRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2Rpc3Bvc2VBZnRlcjtcbiAgICB9XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IG1heCA9IDAsIHR0bCwgdHRsUmVzb2x1dGlvbiA9IDEsIHR0bEF1dG9wdXJnZSwgdXBkYXRlQWdlT25HZXQsIHVwZGF0ZUFnZU9uSGFzLCBhbGxvd1N0YWxlLCBkaXNwb3NlLCBvbkluc2VydCwgZGlzcG9zZUFmdGVyLCBub0Rpc3Bvc2VPblNldCwgbm9VcGRhdGVUVEwsIG1heFNpemUgPSAwLCBtYXhFbnRyeVNpemUgPSAwLCBzaXplQ2FsY3VsYXRpb24sIGZldGNoTWV0aG9kLCBtZW1vTWV0aG9kLCBub0RlbGV0ZU9uRmV0Y2hSZWplY3Rpb24sIG5vRGVsZXRlT25TdGFsZUdldCwgYWxsb3dTdGFsZU9uRmV0Y2hSZWplY3Rpb24sIGFsbG93U3RhbGVPbkZldGNoQWJvcnQsIGlnbm9yZUZldGNoQWJvcnQsIHBlcmYsIH0gPSBvcHRpb25zO1xuICAgICAgICBpZiAocGVyZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBlcmY/Lm5vdyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3BlcmYgb3B0aW9uIG11c3QgaGF2ZSBhIG5vdygpIG1ldGhvZCBpZiBzcGVjaWZpZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNwZXJmID0gcGVyZiA/PyBkZWZhdWx0UGVyZjtcbiAgICAgICAgaWYgKG1heCAhPT0gMCAmJiAhaXNQb3NJbnQobWF4KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWF4IG9wdGlvbiBtdXN0IGJlIGEgbm9ubmVnYXRpdmUgaW50ZWdlcicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFVpbnRBcnJheSA9IG1heCA/IGdldFVpbnRBcnJheShtYXgpIDogQXJyYXk7XG4gICAgICAgIGlmICghVWludEFycmF5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgbWF4IHZhbHVlOiAnICsgbWF4KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNtYXggPSBtYXg7XG4gICAgICAgIHRoaXMuI21heFNpemUgPSBtYXhTaXplO1xuICAgICAgICB0aGlzLm1heEVudHJ5U2l6ZSA9IG1heEVudHJ5U2l6ZSB8fCB0aGlzLiNtYXhTaXplO1xuICAgICAgICB0aGlzLnNpemVDYWxjdWxhdGlvbiA9IHNpemVDYWxjdWxhdGlvbjtcbiAgICAgICAgaWYgKHRoaXMuc2l6ZUNhbGN1bGF0aW9uKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuI21heFNpemUgJiYgIXRoaXMubWF4RW50cnlTaXplKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2Fubm90IHNldCBzaXplQ2FsY3VsYXRpb24gd2l0aG91dCBzZXR0aW5nIG1heFNpemUgb3IgbWF4RW50cnlTaXplJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuc2l6ZUNhbGN1bGF0aW9uICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc2l6ZUNhbGN1bGF0aW9uIHNldCB0byBub24tZnVuY3Rpb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWVtb01ldGhvZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICB0eXBlb2YgbWVtb01ldGhvZCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWVtb01ldGhvZCBtdXN0IGJlIGEgZnVuY3Rpb24gaWYgZGVmaW5lZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI21lbW9NZXRob2QgPSBtZW1vTWV0aG9kO1xuICAgICAgICBpZiAoZmV0Y2hNZXRob2QgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgdHlwZW9mIGZldGNoTWV0aG9kICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdmZXRjaE1ldGhvZCBtdXN0IGJlIGEgZnVuY3Rpb24gaWYgc3BlY2lmaWVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jZmV0Y2hNZXRob2QgPSBmZXRjaE1ldGhvZDtcbiAgICAgICAgdGhpcy4jaGFzRmV0Y2hNZXRob2QgPSAhIWZldGNoTWV0aG9kO1xuICAgICAgICB0aGlzLiNrZXlNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuI2tleUxpc3QgPSBuZXcgQXJyYXkobWF4KS5maWxsKHVuZGVmaW5lZCk7XG4gICAgICAgIHRoaXMuI3ZhbExpc3QgPSBuZXcgQXJyYXkobWF4KS5maWxsKHVuZGVmaW5lZCk7XG4gICAgICAgIHRoaXMuI25leHQgPSBuZXcgVWludEFycmF5KG1heCk7XG4gICAgICAgIHRoaXMuI3ByZXYgPSBuZXcgVWludEFycmF5KG1heCk7XG4gICAgICAgIHRoaXMuI2hlYWQgPSAwO1xuICAgICAgICB0aGlzLiN0YWlsID0gMDtcbiAgICAgICAgdGhpcy4jZnJlZSA9IFN0YWNrLmNyZWF0ZShtYXgpO1xuICAgICAgICB0aGlzLiNzaXplID0gMDtcbiAgICAgICAgdGhpcy4jY2FsY3VsYXRlZFNpemUgPSAwO1xuICAgICAgICBpZiAodHlwZW9mIGRpc3Bvc2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMuI2Rpc3Bvc2UgPSBkaXNwb3NlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb25JbnNlcnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMuI29uSW5zZXJ0ID0gb25JbnNlcnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBkaXNwb3NlQWZ0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMuI2Rpc3Bvc2VBZnRlciA9IGRpc3Bvc2VBZnRlcjtcbiAgICAgICAgICAgIHRoaXMuI2Rpc3Bvc2VkID0gW107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiNkaXNwb3NlQWZ0ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLiNkaXNwb3NlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNoYXNEaXNwb3NlID0gISF0aGlzLiNkaXNwb3NlO1xuICAgICAgICB0aGlzLiNoYXNPbkluc2VydCA9ICEhdGhpcy4jb25JbnNlcnQ7XG4gICAgICAgIHRoaXMuI2hhc0Rpc3Bvc2VBZnRlciA9ICEhdGhpcy4jZGlzcG9zZUFmdGVyO1xuICAgICAgICB0aGlzLm5vRGlzcG9zZU9uU2V0ID0gISFub0Rpc3Bvc2VPblNldDtcbiAgICAgICAgdGhpcy5ub1VwZGF0ZVRUTCA9ICEhbm9VcGRhdGVUVEw7XG4gICAgICAgIHRoaXMubm9EZWxldGVPbkZldGNoUmVqZWN0aW9uID0gISFub0RlbGV0ZU9uRmV0Y2hSZWplY3Rpb247XG4gICAgICAgIHRoaXMuYWxsb3dTdGFsZU9uRmV0Y2hSZWplY3Rpb24gPSAhIWFsbG93U3RhbGVPbkZldGNoUmVqZWN0aW9uO1xuICAgICAgICB0aGlzLmFsbG93U3RhbGVPbkZldGNoQWJvcnQgPSAhIWFsbG93U3RhbGVPbkZldGNoQWJvcnQ7XG4gICAgICAgIHRoaXMuaWdub3JlRmV0Y2hBYm9ydCA9ICEhaWdub3JlRmV0Y2hBYm9ydDtcbiAgICAgICAgLy8gTkI6IG1heEVudHJ5U2l6ZSBpcyBzZXQgdG8gbWF4U2l6ZSBpZiBpdCdzIHNldFxuICAgICAgICBpZiAodGhpcy5tYXhFbnRyeVNpemUgIT09IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNtYXhTaXplICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1Bvc0ludCh0aGlzLiNtYXhTaXplKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtYXhTaXplIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIGlmIHNwZWNpZmllZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNQb3NJbnQodGhpcy5tYXhFbnRyeVNpemUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWF4RW50cnlTaXplIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIGlmIHNwZWNpZmllZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4jaW5pdGlhbGl6ZVNpemVUcmFja2luZygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWxsb3dTdGFsZSA9ICEhYWxsb3dTdGFsZTtcbiAgICAgICAgdGhpcy5ub0RlbGV0ZU9uU3RhbGVHZXQgPSAhIW5vRGVsZXRlT25TdGFsZUdldDtcbiAgICAgICAgdGhpcy51cGRhdGVBZ2VPbkdldCA9ICEhdXBkYXRlQWdlT25HZXQ7XG4gICAgICAgIHRoaXMudXBkYXRlQWdlT25IYXMgPSAhIXVwZGF0ZUFnZU9uSGFzO1xuICAgICAgICB0aGlzLnR0bFJlc29sdXRpb24gPVxuICAgICAgICAgICAgaXNQb3NJbnQodHRsUmVzb2x1dGlvbikgfHwgdHRsUmVzb2x1dGlvbiA9PT0gMCA/XG4gICAgICAgICAgICAgICAgdHRsUmVzb2x1dGlvblxuICAgICAgICAgICAgICAgIDogMTtcbiAgICAgICAgdGhpcy50dGxBdXRvcHVyZ2UgPSAhIXR0bEF1dG9wdXJnZTtcbiAgICAgICAgdGhpcy50dGwgPSB0dGwgfHwgMDtcbiAgICAgICAgaWYgKHRoaXMudHRsKSB7XG4gICAgICAgICAgICBpZiAoIWlzUG9zSW50KHRoaXMudHRsKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3R0bCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBpZiBzcGVjaWZpZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuI2luaXRpYWxpemVUVExUcmFja2luZygpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRvIG5vdCBhbGxvdyBjb21wbGV0ZWx5IHVuYm91bmRlZCBjYWNoZXNcbiAgICAgICAgaWYgKHRoaXMuI21heCA9PT0gMCAmJiB0aGlzLnR0bCA9PT0gMCAmJiB0aGlzLiNtYXhTaXplID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBdCBsZWFzdCBvbmUgb2YgbWF4LCBtYXhTaXplLCBvciB0dGwgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMudHRsQXV0b3B1cmdlICYmICF0aGlzLiNtYXggJiYgIXRoaXMuI21heFNpemUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvZGUgPSAnTFJVX0NBQ0hFX1VOQk9VTkRFRCc7XG4gICAgICAgICAgICBpZiAoc2hvdWxkV2Fybihjb2RlKSkge1xuICAgICAgICAgICAgICAgIHdhcm5lZC5hZGQoY29kZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbXNnID0gJ1RUTCBjYWNoaW5nIHdpdGhvdXQgdHRsQXV0b3B1cmdlLCBtYXgsIG9yIG1heFNpemUgY2FuICcgK1xuICAgICAgICAgICAgICAgICAgICAncmVzdWx0IGluIHVuYm91bmRlZCBtZW1vcnkgY29uc3VtcHRpb24uJztcbiAgICAgICAgICAgICAgICBlbWl0V2FybmluZyhtc2csICdVbmJvdW5kZWRDYWNoZVdhcm5pbmcnLCBjb2RlLCBMUlVDYWNoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBudW1iZXIgb2YgbXMgbGVmdCBpbiB0aGUgaXRlbSdzIFRUTC4gSWYgaXRlbSBpcyBub3QgaW4gY2FjaGUsXG4gICAgICogcmV0dXJucyBgMGAuIFJldHVybnMgYEluZmluaXR5YCBpZiBpdGVtIGlzIGluIGNhY2hlIHdpdGhvdXQgYSBkZWZpbmVkIFRUTC5cbiAgICAgKi9cbiAgICBnZXRSZW1haW5pbmdUVEwoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNrZXlNYXAuaGFzKGtleSkgPyBJbmZpbml0eSA6IDA7XG4gICAgfVxuICAgICNpbml0aWFsaXplVFRMVHJhY2tpbmcoKSB7XG4gICAgICAgIGNvbnN0IHR0bHMgPSBuZXcgWmVyb0FycmF5KHRoaXMuI21heCk7XG4gICAgICAgIGNvbnN0IHN0YXJ0cyA9IG5ldyBaZXJvQXJyYXkodGhpcy4jbWF4KTtcbiAgICAgICAgdGhpcy4jdHRscyA9IHR0bHM7XG4gICAgICAgIHRoaXMuI3N0YXJ0cyA9IHN0YXJ0cztcbiAgICAgICAgdGhpcy4jc2V0SXRlbVRUTCA9IChpbmRleCwgdHRsLCBzdGFydCA9IHRoaXMuI3BlcmYubm93KCkpID0+IHtcbiAgICAgICAgICAgIHN0YXJ0c1tpbmRleF0gPSB0dGwgIT09IDAgPyBzdGFydCA6IDA7XG4gICAgICAgICAgICB0dGxzW2luZGV4XSA9IHR0bDtcbiAgICAgICAgICAgIGlmICh0dGwgIT09IDAgJiYgdGhpcy50dGxBdXRvcHVyZ2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLiNpc1N0YWxlKGluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4jZGVsZXRlKHRoaXMuI2tleUxpc3RbaW5kZXhdLCAnZXhwaXJlJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCB0dGwgKyAxKTtcbiAgICAgICAgICAgICAgICAvLyB1bnJlZigpIG5vdCBzdXBwb3J0ZWQgb24gYWxsIHBsYXRmb3Jtc1xuICAgICAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgICAgIGlmICh0LnVucmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIHQudW5yZWYoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy4jdXBkYXRlSXRlbUFnZSA9IGluZGV4ID0+IHtcbiAgICAgICAgICAgIHN0YXJ0c1tpbmRleF0gPSB0dGxzW2luZGV4XSAhPT0gMCA/IHRoaXMuI3BlcmYubm93KCkgOiAwO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLiNzdGF0dXNUVEwgPSAoc3RhdHVzLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKHR0bHNbaW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHRsID0gdHRsc1tpbmRleF07XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBzdGFydHNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgaWYgKCF0dGwgfHwgIXN0YXJ0KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgc3RhdHVzLnR0bCA9IHR0bDtcbiAgICAgICAgICAgICAgICBzdGF0dXMuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgICAgICBzdGF0dXMubm93ID0gY2FjaGVkTm93IHx8IGdldE5vdygpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFnZSA9IHN0YXR1cy5ub3cgLSBzdGFydDtcbiAgICAgICAgICAgICAgICBzdGF0dXMucmVtYWluaW5nVFRMID0gdHRsIC0gYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBkZWJvdW5jZSBjYWxscyB0byBwZXJmLm5vdygpIHRvIDFzIHNvIHdlJ3JlIG5vdCBoaXR0aW5nXG4gICAgICAgIC8vIHRoYXQgY29zdGx5IGNhbGwgcmVwZWF0ZWRseS5cbiAgICAgICAgbGV0IGNhY2hlZE5vdyA9IDA7XG4gICAgICAgIGNvbnN0IGdldE5vdyA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG4gPSB0aGlzLiNwZXJmLm5vdygpO1xuICAgICAgICAgICAgaWYgKHRoaXMudHRsUmVzb2x1dGlvbiA+IDApIHtcbiAgICAgICAgICAgICAgICBjYWNoZWROb3cgPSBuO1xuICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBzZXRUaW1lb3V0KCgpID0+IChjYWNoZWROb3cgPSAwKSwgdGhpcy50dGxSZXNvbHV0aW9uKTtcbiAgICAgICAgICAgICAgICAvLyBub3QgYXZhaWxhYmxlIG9uIGFsbCBwbGF0Zm9ybXNcbiAgICAgICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgICAgICAgICBpZiAodC51bnJlZikge1xuICAgICAgICAgICAgICAgICAgICB0LnVucmVmKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRSZW1haW5pbmdUVEwgPSBrZXkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLiNrZXlNYXAuZ2V0KGtleSk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdHRsID0gdHRsc1tpbmRleF07XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IHN0YXJ0c1tpbmRleF07XG4gICAgICAgICAgICBpZiAoIXR0bCB8fCAhc3RhcnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhZ2UgPSAoY2FjaGVkTm93IHx8IGdldE5vdygpKSAtIHN0YXJ0O1xuICAgICAgICAgICAgcmV0dXJuIHR0bCAtIGFnZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy4jaXNTdGFsZSA9IGluZGV4ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHMgPSBzdGFydHNbaW5kZXhdO1xuICAgICAgICAgICAgY29uc3QgdCA9IHR0bHNbaW5kZXhdO1xuICAgICAgICAgICAgcmV0dXJuICEhdCAmJiAhIXMgJiYgKGNhY2hlZE5vdyB8fCBnZXROb3coKSkgLSBzID4gdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gY29uZGl0aW9uYWxseSBzZXQgcHJpdmF0ZSBtZXRob2RzIHJlbGF0ZWQgdG8gVFRMXG4gICAgI3VwZGF0ZUl0ZW1BZ2UgPSAoKSA9PiB7IH07XG4gICAgI3N0YXR1c1RUTCA9ICgpID0+IHsgfTtcbiAgICAjc2V0SXRlbVRUTCA9ICgpID0+IHsgfTtcbiAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICNpc1N0YWxlID0gKCkgPT4gZmFsc2U7XG4gICAgI2luaXRpYWxpemVTaXplVHJhY2tpbmcoKSB7XG4gICAgICAgIGNvbnN0IHNpemVzID0gbmV3IFplcm9BcnJheSh0aGlzLiNtYXgpO1xuICAgICAgICB0aGlzLiNjYWxjdWxhdGVkU2l6ZSA9IDA7XG4gICAgICAgIHRoaXMuI3NpemVzID0gc2l6ZXM7XG4gICAgICAgIHRoaXMuI3JlbW92ZUl0ZW1TaXplID0gaW5kZXggPT4ge1xuICAgICAgICAgICAgdGhpcy4jY2FsY3VsYXRlZFNpemUgLT0gc2l6ZXNbaW5kZXhdO1xuICAgICAgICAgICAgc2l6ZXNbaW5kZXhdID0gMDtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy4jcmVxdWlyZVNpemUgPSAoaywgdiwgc2l6ZSwgc2l6ZUNhbGN1bGF0aW9uKSA9PiB7XG4gICAgICAgICAgICAvLyBwcm92aXNpb25hbGx5IGFjY2VwdCBiYWNrZ3JvdW5kIGZldGNoZXMuXG4gICAgICAgICAgICAvLyBhY3R1YWwgdmFsdWUgc2l6ZSB3aWxsIGJlIGNoZWNrZWQgd2hlbiB0aGV5IHJldHVybi5cbiAgICAgICAgICAgIGlmICh0aGlzLiNpc0JhY2tncm91bmRGZXRjaCh2KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc1Bvc0ludChzaXplKSkge1xuICAgICAgICAgICAgICAgIGlmIChzaXplQ2FsY3VsYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzaXplQ2FsY3VsYXRpb24gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NpemVDYWxjdWxhdGlvbiBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzaXplID0gc2l6ZUNhbGN1bGF0aW9uKHYsIGspO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUG9zSW50KHNpemUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzaXplQ2FsY3VsYXRpb24gcmV0dXJuIGludmFsaWQgKGV4cGVjdCBwb3NpdGl2ZSBpbnRlZ2VyKScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHNpemUgdmFsdWUgKG11c3QgYmUgcG9zaXRpdmUgaW50ZWdlcikuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1doZW4gbWF4U2l6ZSBvciBtYXhFbnRyeVNpemUgaXMgdXNlZCwgc2l6ZUNhbGN1bGF0aW9uICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ29yIHNpemUgbXVzdCBiZSBzZXQuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuI2FkZEl0ZW1TaXplID0gKGluZGV4LCBzaXplLCBzdGF0dXMpID0+IHtcbiAgICAgICAgICAgIHNpemVzW2luZGV4XSA9IHNpemU7XG4gICAgICAgICAgICBpZiAodGhpcy4jbWF4U2l6ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1heFNpemUgPSB0aGlzLiNtYXhTaXplIC0gc2l6ZXNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLiNjYWxjdWxhdGVkU2l6ZSA+IG1heFNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jZXZpY3QodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4jY2FsY3VsYXRlZFNpemUgKz0gc2l6ZXNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKHN0YXR1cykge1xuICAgICAgICAgICAgICAgIHN0YXR1cy5lbnRyeVNpemUgPSBzaXplO1xuICAgICAgICAgICAgICAgIHN0YXR1cy50b3RhbENhbGN1bGF0ZWRTaXplID0gdGhpcy4jY2FsY3VsYXRlZFNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgICNyZW1vdmVJdGVtU2l6ZSA9IF9pID0+IHsgfTtcbiAgICAjYWRkSXRlbVNpemUgPSAoX2ksIF9zLCBfc3QpID0+IHsgfTtcbiAgICAjcmVxdWlyZVNpemUgPSAoX2ssIF92LCBzaXplLCBzaXplQ2FsY3VsYXRpb24pID0+IHtcbiAgICAgICAgaWYgKHNpemUgfHwgc2l6ZUNhbGN1bGF0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjYW5ub3Qgc2V0IHNpemUgd2l0aG91dCBzZXR0aW5nIG1heFNpemUgb3IgbWF4RW50cnlTaXplIG9uIGNhY2hlJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfTtcbiAgICAqI2luZGV4ZXMoeyBhbGxvd1N0YWxlID0gdGhpcy5hbGxvd1N0YWxlIH0gPSB7fSkge1xuICAgICAgICBpZiAodGhpcy4jc2l6ZSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuI3RhaWw7IHRydWU7KSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLiNpc1ZhbGlkSW5kZXgoaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhbGxvd1N0YWxlIHx8ICF0aGlzLiNpc1N0YWxlKGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpID09PSB0aGlzLiNoZWFkKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaSA9IHRoaXMuI3ByZXZbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgICojcmluZGV4ZXMoeyBhbGxvd1N0YWxlID0gdGhpcy5hbGxvd1N0YWxlIH0gPSB7fSkge1xuICAgICAgICBpZiAodGhpcy4jc2l6ZSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuI2hlYWQ7IHRydWU7KSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLiNpc1ZhbGlkSW5kZXgoaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhbGxvd1N0YWxlIHx8ICF0aGlzLiNpc1N0YWxlKGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpID09PSB0aGlzLiN0YWlsKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaSA9IHRoaXMuI25leHRbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgICNpc1ZhbGlkSW5kZXgoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIChpbmRleCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICB0aGlzLiNrZXlNYXAuZ2V0KHRoaXMuI2tleUxpc3RbaW5kZXhdKSA9PT0gaW5kZXgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBnZW5lcmF0b3IgeWllbGRpbmcgYFtrZXksIHZhbHVlXWAgcGFpcnMsXG4gICAgICogaW4gb3JkZXIgZnJvbSBtb3N0IHJlY2VudGx5IHVzZWQgdG8gbGVhc3QgcmVjZW50bHkgdXNlZC5cbiAgICAgKi9cbiAgICAqZW50cmllcygpIHtcbiAgICAgICAgZm9yIChjb25zdCBpIG9mIHRoaXMuI2luZGV4ZXMoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuI3ZhbExpc3RbaV0gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuI2tleUxpc3RbaV0gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICF0aGlzLiNpc0JhY2tncm91bmRGZXRjaCh0aGlzLiN2YWxMaXN0W2ldKSkge1xuICAgICAgICAgICAgICAgIHlpZWxkIFt0aGlzLiNrZXlMaXN0W2ldLCB0aGlzLiN2YWxMaXN0W2ldXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnZlcnNlIG9yZGVyIHZlcnNpb24gb2Yge0BsaW5rIExSVUNhY2hlLmVudHJpZXN9XG4gICAgICpcbiAgICAgKiBSZXR1cm4gYSBnZW5lcmF0b3IgeWllbGRpbmcgYFtrZXksIHZhbHVlXWAgcGFpcnMsXG4gICAgICogaW4gb3JkZXIgZnJvbSBsZWFzdCByZWNlbnRseSB1c2VkIHRvIG1vc3QgcmVjZW50bHkgdXNlZC5cbiAgICAgKi9cbiAgICAqcmVudHJpZXMoKSB7XG4gICAgICAgIGZvciAoY29uc3QgaSBvZiB0aGlzLiNyaW5kZXhlcygpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4jdmFsTGlzdFtpXSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgdGhpcy4ja2V5TGlzdFtpXSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgIXRoaXMuI2lzQmFja2dyb3VuZEZldGNoKHRoaXMuI3ZhbExpc3RbaV0pKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgW3RoaXMuI2tleUxpc3RbaV0sIHRoaXMuI3ZhbExpc3RbaV1dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIGdlbmVyYXRvciB5aWVsZGluZyB0aGUga2V5cyBpbiB0aGUgY2FjaGUsXG4gICAgICogaW4gb3JkZXIgZnJvbSBtb3N0IHJlY2VudGx5IHVzZWQgdG8gbGVhc3QgcmVjZW50bHkgdXNlZC5cbiAgICAgKi9cbiAgICAqa2V5cygpIHtcbiAgICAgICAgZm9yIChjb25zdCBpIG9mIHRoaXMuI2luZGV4ZXMoKSkge1xuICAgICAgICAgICAgY29uc3QgayA9IHRoaXMuI2tleUxpc3RbaV07XG4gICAgICAgICAgICBpZiAoayAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgIXRoaXMuI2lzQmFja2dyb3VuZEZldGNoKHRoaXMuI3ZhbExpc3RbaV0pKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnZlcnNlIG9yZGVyIHZlcnNpb24gb2Yge0BsaW5rIExSVUNhY2hlLmtleXN9XG4gICAgICpcbiAgICAgKiBSZXR1cm4gYSBnZW5lcmF0b3IgeWllbGRpbmcgdGhlIGtleXMgaW4gdGhlIGNhY2hlLFxuICAgICAqIGluIG9yZGVyIGZyb20gbGVhc3QgcmVjZW50bHkgdXNlZCB0byBtb3N0IHJlY2VudGx5IHVzZWQuXG4gICAgICovXG4gICAgKnJrZXlzKCkge1xuICAgICAgICBmb3IgKGNvbnN0IGkgb2YgdGhpcy4jcmluZGV4ZXMoKSkge1xuICAgICAgICAgICAgY29uc3QgayA9IHRoaXMuI2tleUxpc3RbaV07XG4gICAgICAgICAgICBpZiAoayAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgIXRoaXMuI2lzQmFja2dyb3VuZEZldGNoKHRoaXMuI3ZhbExpc3RbaV0pKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBnZW5lcmF0b3IgeWllbGRpbmcgdGhlIHZhbHVlcyBpbiB0aGUgY2FjaGUsXG4gICAgICogaW4gb3JkZXIgZnJvbSBtb3N0IHJlY2VudGx5IHVzZWQgdG8gbGVhc3QgcmVjZW50bHkgdXNlZC5cbiAgICAgKi9cbiAgICAqdmFsdWVzKCkge1xuICAgICAgICBmb3IgKGNvbnN0IGkgb2YgdGhpcy4jaW5kZXhlcygpKSB7XG4gICAgICAgICAgICBjb25zdCB2ID0gdGhpcy4jdmFsTGlzdFtpXTtcbiAgICAgICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAhdGhpcy4jaXNCYWNrZ3JvdW5kRmV0Y2godGhpcy4jdmFsTGlzdFtpXSkpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLiN2YWxMaXN0W2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludmVyc2Ugb3JkZXIgdmVyc2lvbiBvZiB7QGxpbmsgTFJVQ2FjaGUudmFsdWVzfVxuICAgICAqXG4gICAgICogUmV0dXJuIGEgZ2VuZXJhdG9yIHlpZWxkaW5nIHRoZSB2YWx1ZXMgaW4gdGhlIGNhY2hlLFxuICAgICAqIGluIG9yZGVyIGZyb20gbGVhc3QgcmVjZW50bHkgdXNlZCB0byBtb3N0IHJlY2VudGx5IHVzZWQuXG4gICAgICovXG4gICAgKnJ2YWx1ZXMoKSB7XG4gICAgICAgIGZvciAoY29uc3QgaSBvZiB0aGlzLiNyaW5kZXhlcygpKSB7XG4gICAgICAgICAgICBjb25zdCB2ID0gdGhpcy4jdmFsTGlzdFtpXTtcbiAgICAgICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAhdGhpcy4jaXNCYWNrZ3JvdW5kRmV0Y2godGhpcy4jdmFsTGlzdFtpXSkpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLiN2YWxMaXN0W2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGluZyBvdmVyIHRoZSBjYWNoZSBpdHNlbGYgeWllbGRzIHRoZSBzYW1lIHJlc3VsdHMgYXNcbiAgICAgKiB7QGxpbmsgTFJVQ2FjaGUuZW50cmllc31cbiAgICAgKi9cbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW50cmllcygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIFN0cmluZyB2YWx1ZSB0aGF0IGlzIHVzZWQgaW4gdGhlIGNyZWF0aW9uIG9mIHRoZSBkZWZhdWx0IHN0cmluZ1xuICAgICAqIGRlc2NyaXB0aW9uIG9mIGFuIG9iamVjdC4gQ2FsbGVkIGJ5IHRoZSBidWlsdC1pbiBtZXRob2RcbiAgICAgKiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gICAgICovXG4gICAgW1N5bWJvbC50b1N0cmluZ1RhZ10gPSAnTFJVQ2FjaGUnO1xuICAgIC8qKlxuICAgICAqIEZpbmQgYSB2YWx1ZSBmb3Igd2hpY2ggdGhlIHN1cHBsaWVkIGZuIG1ldGhvZCByZXR1cm5zIGEgdHJ1dGh5IHZhbHVlLFxuICAgICAqIHNpbWlsYXIgdG8gYEFycmF5LmZpbmQoKWAuIGZuIGlzIGNhbGxlZCBhcyBgZm4odmFsdWUsIGtleSwgY2FjaGUpYC5cbiAgICAgKi9cbiAgICBmaW5kKGZuLCBnZXRPcHRpb25zID0ge30pIHtcbiAgICAgICAgZm9yIChjb25zdCBpIG9mIHRoaXMuI2luZGV4ZXMoKSkge1xuICAgICAgICAgICAgY29uc3QgdiA9IHRoaXMuI3ZhbExpc3RbaV07XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI2lzQmFja2dyb3VuZEZldGNoKHYpID8gdi5fX3N0YWxlV2hpbGVGZXRjaGluZyA6IHY7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChmbih2YWx1ZSwgdGhpcy4ja2V5TGlzdFtpXSwgdGhpcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQodGhpcy4ja2V5TGlzdFtpXSwgZ2V0T3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbCB0aGUgc3VwcGxpZWQgZnVuY3Rpb24gb24gZWFjaCBpdGVtIGluIHRoZSBjYWNoZSwgaW4gb3JkZXIgZnJvbSBtb3N0XG4gICAgICogcmVjZW50bHkgdXNlZCB0byBsZWFzdCByZWNlbnRseSB1c2VkLlxuICAgICAqXG4gICAgICogYGZuYCBpcyBjYWxsZWQgYXMgYGZuKHZhbHVlLCBrZXksIGNhY2hlKWAuXG4gICAgICpcbiAgICAgKiBJZiBgdGhpc3BgIGlzIHByb3ZpZGVkLCBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBpbiB0aGUgYHRoaXNgLWNvbnRleHQgb2ZcbiAgICAgKiB0aGUgcHJvdmlkZWQgb2JqZWN0LCBvciB0aGUgY2FjaGUgaWYgbm8gYHRoaXNwYCBvYmplY3QgaXMgcHJvdmlkZWQuXG4gICAgICpcbiAgICAgKiBEb2VzIG5vdCB1cGRhdGUgYWdlIG9yIHJlY2VudHkgb2YgdXNlLCBvciBpdGVyYXRlIG92ZXIgc3RhbGUgdmFsdWVzLlxuICAgICAqL1xuICAgIGZvckVhY2goZm4sIHRoaXNwID0gdGhpcykge1xuICAgICAgICBmb3IgKGNvbnN0IGkgb2YgdGhpcy4jaW5kZXhlcygpKSB7XG4gICAgICAgICAgICBjb25zdCB2ID0gdGhpcy4jdmFsTGlzdFtpXTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jaXNCYWNrZ3JvdW5kRmV0Y2godikgPyB2Ll9fc3RhbGVXaGlsZUZldGNoaW5nIDogdjtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgZm4uY2FsbCh0aGlzcCwgdmFsdWUsIHRoaXMuI2tleUxpc3RbaV0sIHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBzYW1lIGFzIHtAbGluayBMUlVDYWNoZS5mb3JFYWNofSBidXQgaXRlbXMgYXJlIGl0ZXJhdGVkIG92ZXIgaW5cbiAgICAgKiByZXZlcnNlIG9yZGVyLiAgKGllLCBsZXNzIHJlY2VudGx5IHVzZWQgaXRlbXMgYXJlIGl0ZXJhdGVkIG92ZXIgZmlyc3QuKVxuICAgICAqL1xuICAgIHJmb3JFYWNoKGZuLCB0aGlzcCA9IHRoaXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBpIG9mIHRoaXMuI3JpbmRleGVzKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSB0aGlzLiN2YWxMaXN0W2ldO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLiNpc0JhY2tncm91bmRGZXRjaCh2KSA/IHYuX19zdGFsZVdoaWxlRmV0Y2hpbmcgOiB2O1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBmbi5jYWxsKHRoaXNwLCB2YWx1ZSwgdGhpcy4ja2V5TGlzdFtpXSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlIGFueSBzdGFsZSBlbnRyaWVzLiBSZXR1cm5zIHRydWUgaWYgYW55dGhpbmcgd2FzIHJlbW92ZWQsXG4gICAgICogZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHB1cmdlU3RhbGUoKSB7XG4gICAgICAgIGxldCBkZWxldGVkID0gZmFsc2U7XG4gICAgICAgIGZvciAoY29uc3QgaSBvZiB0aGlzLiNyaW5kZXhlcyh7IGFsbG93U3RhbGU6IHRydWUgfSkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNpc1N0YWxlKGkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jZGVsZXRlKHRoaXMuI2tleUxpc3RbaV0sICdleHBpcmUnKTtcbiAgICAgICAgICAgICAgICBkZWxldGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVsZXRlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBleHRlbmRlZCBpbmZvIGFib3V0IGEgZ2l2ZW4gZW50cnksIHRvIGdldCBpdHMgdmFsdWUsIHNpemUsIGFuZFxuICAgICAqIFRUTCBpbmZvIHNpbXVsdGFuZW91c2x5LiBSZXR1cm5zIGB1bmRlZmluZWRgIGlmIHRoZSBrZXkgaXMgbm90IHByZXNlbnQuXG4gICAgICpcbiAgICAgKiBVbmxpa2Uge0BsaW5rIExSVUNhY2hlI2R1bXB9LCB3aGljaCBpcyBkZXNpZ25lZCB0byBiZSBwb3J0YWJsZSBhbmQgc3Vydml2ZVxuICAgICAqIHNlcmlhbGl6YXRpb24sIHRoZSBgc3RhcnRgIHZhbHVlIGlzIGFsd2F5cyB0aGUgY3VycmVudCB0aW1lc3RhbXAsIGFuZCB0aGVcbiAgICAgKiBgdHRsYCBpcyBhIGNhbGN1bGF0ZWQgcmVtYWluaW5nIHRpbWUgdG8gbGl2ZSAobmVnYXRpdmUgaWYgZXhwaXJlZCkuXG4gICAgICpcbiAgICAgKiBBbHdheXMgcmV0dXJucyBzdGFsZSB2YWx1ZXMsIGlmIHRoZWlyIGluZm8gaXMgZm91bmQgaW4gdGhlIGNhY2hlLCBzbyBiZVxuICAgICAqIHN1cmUgdG8gY2hlY2sgZm9yIGV4cGlyYXRpb25zIChpZSwgYSBuZWdhdGl2ZSB7QGxpbmsgTFJVQ2FjaGUuRW50cnkjdHRsfSlcbiAgICAgKiBpZiByZWxldmFudC5cbiAgICAgKi9cbiAgICBpbmZvKGtleSkge1xuICAgICAgICBjb25zdCBpID0gdGhpcy4ja2V5TWFwLmdldChrZXkpO1xuICAgICAgICBpZiAoaSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgdiA9IHRoaXMuI3ZhbExpc3RbaV07XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAtIHRoaXMgaXNuJ3QgdGVzdGVkIGZvciB0aGUgaW5mbyBmdW5jdGlvbixcbiAgICAgICAgICogYnV0IGl0J3MgdGhlIHNhbWUgbG9naWMgYXMgZm91bmQgaW4gb3RoZXIgcGxhY2VzLiAqL1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI2lzQmFja2dyb3VuZEZldGNoKHYpID8gdi5fX3N0YWxlV2hpbGVGZXRjaGluZyA6IHY7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgLyogYzggaWdub3JlIGVuZCAqL1xuICAgICAgICBjb25zdCBlbnRyeSA9IHsgdmFsdWUgfTtcbiAgICAgICAgaWYgKHRoaXMuI3R0bHMgJiYgdGhpcy4jc3RhcnRzKSB7XG4gICAgICAgICAgICBjb25zdCB0dGwgPSB0aGlzLiN0dGxzW2ldO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLiNzdGFydHNbaV07XG4gICAgICAgICAgICBpZiAodHRsICYmIHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVtYWluID0gdHRsIC0gKHRoaXMuI3BlcmYubm93KCkgLSBzdGFydCk7XG4gICAgICAgICAgICAgICAgZW50cnkudHRsID0gcmVtYWluO1xuICAgICAgICAgICAgICAgIGVudHJ5LnN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy4jc2l6ZXMpIHtcbiAgICAgICAgICAgIGVudHJ5LnNpemUgPSB0aGlzLiNzaXplc1tpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW50cnk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhbiBhcnJheSBvZiBba2V5LCB7QGxpbmsgTFJVQ2FjaGUuRW50cnl9XSB0dXBsZXMgd2hpY2ggY2FuIGJlXG4gICAgICogcGFzc2VkIHRvIHtAbGluayBMUlVDYWNoZSNsb2FkfS5cbiAgICAgKlxuICAgICAqIFRoZSBgc3RhcnRgIGZpZWxkcyBhcmUgY2FsY3VsYXRlZCByZWxhdGl2ZSB0byBhIHBvcnRhYmxlIGBEYXRlLm5vdygpYFxuICAgICAqIHRpbWVzdGFtcCwgZXZlbiBpZiBgcGVyZm9ybWFuY2Uubm93KClgIGlzIGF2YWlsYWJsZS5cbiAgICAgKlxuICAgICAqIFN0YWxlIGVudHJpZXMgYXJlIGFsd2F5cyBpbmNsdWRlZCBpbiB0aGUgYGR1bXBgLCBldmVuIGlmXG4gICAgICoge0BsaW5rIExSVUNhY2hlLk9wdGlvbnNCYXNlLmFsbG93U3RhbGV9IGlzIGZhbHNlLlxuICAgICAqXG4gICAgICogTm90ZTogdGhpcyByZXR1cm5zIGFuIGFjdHVhbCBhcnJheSwgbm90IGEgZ2VuZXJhdG9yLCBzbyBpdCBjYW4gYmUgbW9yZVxuICAgICAqIGVhc2lseSBwYXNzZWQgYXJvdW5kLlxuICAgICAqL1xuICAgIGR1bXAoKSB7XG4gICAgICAgIGNvbnN0IGFyciA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGkgb2YgdGhpcy4jaW5kZXhlcyh7IGFsbG93U3RhbGU6IHRydWUgfSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHRoaXMuI2tleUxpc3RbaV07XG4gICAgICAgICAgICBjb25zdCB2ID0gdGhpcy4jdmFsTGlzdFtpXTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jaXNCYWNrZ3JvdW5kRmV0Y2godikgPyB2Ll9fc3RhbGVXaGlsZUZldGNoaW5nIDogdjtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IGtleSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29uc3QgZW50cnkgPSB7IHZhbHVlIH07XG4gICAgICAgICAgICBpZiAodGhpcy4jdHRscyAmJiB0aGlzLiNzdGFydHMpIHtcbiAgICAgICAgICAgICAgICBlbnRyeS50dGwgPSB0aGlzLiN0dGxzW2ldO1xuICAgICAgICAgICAgICAgIC8vIGFsd2F5cyBkdW1wIHRoZSBzdGFydCByZWxhdGl2ZSB0byBhIHBvcnRhYmxlIHRpbWVzdGFtcFxuICAgICAgICAgICAgICAgIC8vIGl0J3Mgb2sgZm9yIHRoaXMgdG8gYmUgYSBiaXQgc2xvdywgaXQncyBhIHJhcmUgb3BlcmF0aW9uLlxuICAgICAgICAgICAgICAgIGNvbnN0IGFnZSA9IHRoaXMuI3BlcmYubm93KCkgLSB0aGlzLiNzdGFydHNbaV07XG4gICAgICAgICAgICAgICAgZW50cnkuc3RhcnQgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLSBhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuI3NpemVzKSB7XG4gICAgICAgICAgICAgICAgZW50cnkuc2l6ZSA9IHRoaXMuI3NpemVzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXJyLnVuc2hpZnQoW2tleSwgZW50cnldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNldCB0aGUgY2FjaGUgYW5kIGxvYWQgaW4gdGhlIGl0ZW1zIGluIGVudHJpZXMgaW4gdGhlIG9yZGVyIGxpc3RlZC5cbiAgICAgKlxuICAgICAqIFRoZSBzaGFwZSBvZiB0aGUgcmVzdWx0aW5nIGNhY2hlIG1heSBiZSBkaWZmZXJlbnQgaWYgdGhlIHNhbWUgb3B0aW9ucyBhcmVcbiAgICAgKiBub3QgdXNlZCBpbiBib3RoIGNhY2hlcy5cbiAgICAgKlxuICAgICAqIFRoZSBgc3RhcnRgIGZpZWxkcyBhcmUgYXNzdW1lZCB0byBiZSBjYWxjdWxhdGVkIHJlbGF0aXZlIHRvIGEgcG9ydGFibGVcbiAgICAgKiBgRGF0ZS5ub3coKWAgdGltZXN0YW1wLCBldmVuIGlmIGBwZXJmb3JtYW5jZS5ub3coKWAgaXMgYXZhaWxhYmxlLlxuICAgICAqL1xuICAgIGxvYWQoYXJyKSB7XG4gICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCBlbnRyeV0gb2YgYXJyKSB7XG4gICAgICAgICAgICBpZiAoZW50cnkuc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAvLyBlbnRyeS5zdGFydCBpcyBhIHBvcnRhYmxlIHRpbWVzdGFtcCwgYnV0IHdlIG1heSBiZSB1c2luZ1xuICAgICAgICAgICAgICAgIC8vIG5vZGUncyBwZXJmb3JtYW5jZS5ub3coKSwgc28gY2FsY3VsYXRlIHRoZSBvZmZzZXQsIHNvIHRoYXRcbiAgICAgICAgICAgICAgICAvLyB3ZSBnZXQgdGhlIGludGVuZGVkIHJlbWFpbmluZyBUVEwsIG5vIG1hdHRlciBob3cgbG9uZyBpdCdzXG4gICAgICAgICAgICAgICAgLy8gYmVlbiBvbiBpY2UuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBpdCdzIG9rIGZvciB0aGlzIHRvIGJlIGEgYml0IHNsb3csIGl0J3MgYSByYXJlIG9wZXJhdGlvbi5cbiAgICAgICAgICAgICAgICBjb25zdCBhZ2UgPSBEYXRlLm5vdygpIC0gZW50cnkuc3RhcnQ7XG4gICAgICAgICAgICAgICAgZW50cnkuc3RhcnQgPSB0aGlzLiNwZXJmLm5vdygpIC0gYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXQoa2V5LCBlbnRyeS52YWx1ZSwgZW50cnkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhIHZhbHVlIHRvIHRoZSBjYWNoZS5cbiAgICAgKlxuICAgICAqIE5vdGU6IGlmIGB1bmRlZmluZWRgIGlzIHNwZWNpZmllZCBhcyBhIHZhbHVlLCB0aGlzIGlzIGFuIGFsaWFzIGZvclxuICAgICAqIHtAbGluayBMUlVDYWNoZSNkZWxldGV9XG4gICAgICpcbiAgICAgKiBGaWVsZHMgb24gdGhlIHtAbGluayBMUlVDYWNoZS5TZXRPcHRpb25zfSBvcHRpb25zIHBhcmFtIHdpbGwgb3ZlcnJpZGVcbiAgICAgKiB0aGVpciBjb3JyZXNwb25kaW5nIHZhbHVlcyBpbiB0aGUgY29uc3RydWN0b3Igb3B0aW9ucyBmb3IgdGhlIHNjb3BlXG4gICAgICogb2YgdGhpcyBzaW5nbGUgYHNldCgpYCBvcGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBJZiBgc3RhcnRgIGlzIHByb3ZpZGVkLCB0aGVuIHRoYXQgd2lsbCBzZXQgdGhlIGVmZmVjdGl2ZSBzdGFydFxuICAgICAqIHRpbWUgZm9yIHRoZSBUVEwgY2FsY3VsYXRpb24uIE5vdGUgdGhhdCB0aGlzIG11c3QgYmUgYSBwcmV2aW91c1xuICAgICAqIHZhbHVlIG9mIGBwZXJmb3JtYW5jZS5ub3coKWAgaWYgc3VwcG9ydGVkLCBvciBhIHByZXZpb3VzIHZhbHVlIG9mXG4gICAgICogYERhdGUubm93KClgIGlmIG5vdC5cbiAgICAgKlxuICAgICAqIE9wdGlvbnMgb2JqZWN0IG1heSBhbHNvIGluY2x1ZGUgYHNpemVgLCB3aGljaCB3aWxsIHByZXZlbnRcbiAgICAgKiBjYWxsaW5nIHRoZSBgc2l6ZUNhbGN1bGF0aW9uYCBmdW5jdGlvbiBhbmQganVzdCB1c2UgdGhlIHNwZWNpZmllZFxuICAgICAqIG51bWJlciBpZiBpdCBpcyBhIHBvc2l0aXZlIGludGVnZXIsIGFuZCBgbm9EaXNwb3NlT25TZXRgIHdoaWNoXG4gICAgICogd2lsbCBwcmV2ZW50IGNhbGxpbmcgYSBgZGlzcG9zZWAgZnVuY3Rpb24gaW4gdGhlIGNhc2Ugb2ZcbiAgICAgKiBvdmVyd3JpdGVzLlxuICAgICAqXG4gICAgICogSWYgdGhlIGBzaXplYCAob3IgcmV0dXJuIHZhbHVlIG9mIGBzaXplQ2FsY3VsYXRpb25gKSBmb3IgYSBnaXZlblxuICAgICAqIGVudHJ5IGlzIGdyZWF0ZXIgdGhhbiBgbWF4RW50cnlTaXplYCwgdGhlbiB0aGUgaXRlbSB3aWxsIG5vdCBiZVxuICAgICAqIGFkZGVkIHRvIHRoZSBjYWNoZS5cbiAgICAgKlxuICAgICAqIFdpbGwgdXBkYXRlIHRoZSByZWNlbmN5IG9mIHRoZSBlbnRyeS5cbiAgICAgKlxuICAgICAqIElmIHRoZSB2YWx1ZSBpcyBgdW5kZWZpbmVkYCwgdGhlbiB0aGlzIGlzIGFuIGFsaWFzIGZvclxuICAgICAqIGBjYWNoZS5kZWxldGUoa2V5KWAuIGB1bmRlZmluZWRgIGlzIG5ldmVyIHN0b3JlZCBpbiB0aGUgY2FjaGUuXG4gICAgICovXG4gICAgc2V0KGssIHYsIHNldE9wdGlvbnMgPSB7fSkge1xuICAgICAgICBpZiAodiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmRlbGV0ZShrKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgdHRsID0gdGhpcy50dGwsIHN0YXJ0LCBub0Rpc3Bvc2VPblNldCA9IHRoaXMubm9EaXNwb3NlT25TZXQsIHNpemVDYWxjdWxhdGlvbiA9IHRoaXMuc2l6ZUNhbGN1bGF0aW9uLCBzdGF0dXMsIH0gPSBzZXRPcHRpb25zO1xuICAgICAgICBsZXQgeyBub1VwZGF0ZVRUTCA9IHRoaXMubm9VcGRhdGVUVEwgfSA9IHNldE9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLiNyZXF1aXJlU2l6ZShrLCB2LCBzZXRPcHRpb25zLnNpemUgfHwgMCwgc2l6ZUNhbGN1bGF0aW9uKTtcbiAgICAgICAgLy8gaWYgdGhlIGl0ZW0gZG9lc24ndCBmaXQsIGRvbid0IGRvIGFueXRoaW5nXG4gICAgICAgIC8vIE5COiBtYXhFbnRyeVNpemUgc2V0IHRvIG1heFNpemUgYnkgZGVmYXVsdFxuICAgICAgICBpZiAodGhpcy5tYXhFbnRyeVNpemUgJiYgc2l6ZSA+IHRoaXMubWF4RW50cnlTaXplKSB7XG4gICAgICAgICAgICBpZiAoc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzLnNldCA9ICdtaXNzJztcbiAgICAgICAgICAgICAgICBzdGF0dXMubWF4RW50cnlTaXplRXhjZWVkZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaGF2ZSB0byBkZWxldGUsIGluIGNhc2Ugc29tZXRoaW5nIGlzIHRoZXJlIGFscmVhZHkuXG4gICAgICAgICAgICB0aGlzLiNkZWxldGUoaywgJ3NldCcpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGluZGV4ID0gdGhpcy4jc2l6ZSA9PT0gMCA/IHVuZGVmaW5lZCA6IHRoaXMuI2tleU1hcC5nZXQoayk7XG4gICAgICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBhZGRpdGlvblxuICAgICAgICAgICAgaW5kZXggPSAodGhpcy4jc2l6ZSA9PT0gMCA/IHRoaXMuI3RhaWxcbiAgICAgICAgICAgICAgICA6IHRoaXMuI2ZyZWUubGVuZ3RoICE9PSAwID8gdGhpcy4jZnJlZS5wb3AoKVxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuI3NpemUgPT09IHRoaXMuI21heCA/IHRoaXMuI2V2aWN0KGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLiNzaXplKTtcbiAgICAgICAgICAgIHRoaXMuI2tleUxpc3RbaW5kZXhdID0gaztcbiAgICAgICAgICAgIHRoaXMuI3ZhbExpc3RbaW5kZXhdID0gdjtcbiAgICAgICAgICAgIHRoaXMuI2tleU1hcC5zZXQoaywgaW5kZXgpO1xuICAgICAgICAgICAgdGhpcy4jbmV4dFt0aGlzLiN0YWlsXSA9IGluZGV4O1xuICAgICAgICAgICAgdGhpcy4jcHJldltpbmRleF0gPSB0aGlzLiN0YWlsO1xuICAgICAgICAgICAgdGhpcy4jdGFpbCA9IGluZGV4O1xuICAgICAgICAgICAgdGhpcy4jc2l6ZSsrO1xuICAgICAgICAgICAgdGhpcy4jYWRkSXRlbVNpemUoaW5kZXgsIHNpemUsIHN0YXR1cyk7XG4gICAgICAgICAgICBpZiAoc3RhdHVzKVxuICAgICAgICAgICAgICAgIHN0YXR1cy5zZXQgPSAnYWRkJztcbiAgICAgICAgICAgIG5vVXBkYXRlVFRMID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy4jaGFzT25JbnNlcnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNvbkluc2VydD8uKHYsIGssICdhZGQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHVwZGF0ZVxuICAgICAgICAgICAgdGhpcy4jbW92ZVRvVGFpbChpbmRleCk7XG4gICAgICAgICAgICBjb25zdCBvbGRWYWwgPSB0aGlzLiN2YWxMaXN0W2luZGV4XTtcbiAgICAgICAgICAgIGlmICh2ICE9PSBvbGRWYWwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4jaGFzRmV0Y2hNZXRob2QgJiYgdGhpcy4jaXNCYWNrZ3JvdW5kRmV0Y2gob2xkVmFsKSkge1xuICAgICAgICAgICAgICAgICAgICBvbGRWYWwuX19hYm9ydENvbnRyb2xsZXIuYWJvcnQobmV3IEVycm9yKCdyZXBsYWNlZCcpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBfX3N0YWxlV2hpbGVGZXRjaGluZzogcyB9ID0gb2xkVmFsO1xuICAgICAgICAgICAgICAgICAgICBpZiAocyAhPT0gdW5kZWZpbmVkICYmICFub0Rpc3Bvc2VPblNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuI2hhc0Rpc3Bvc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiNkaXNwb3NlPy4ocywgaywgJ3NldCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuI2hhc0Rpc3Bvc2VBZnRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuI2Rpc3Bvc2VkPy5wdXNoKFtzLCBrLCAnc2V0J10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFub0Rpc3Bvc2VPblNldCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy4jaGFzRGlzcG9zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4jZGlzcG9zZT8uKG9sZFZhbCwgaywgJ3NldCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLiNoYXNEaXNwb3NlQWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuI2Rpc3Bvc2VkPy5wdXNoKFtvbGRWYWwsIGssICdzZXQnXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy4jcmVtb3ZlSXRlbVNpemUoaW5kZXgpO1xuICAgICAgICAgICAgICAgIHRoaXMuI2FkZEl0ZW1TaXplKGluZGV4LCBzaXplLCBzdGF0dXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuI3ZhbExpc3RbaW5kZXhdID0gdjtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5zZXQgPSAncmVwbGFjZSc7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9sZFZhbHVlID0gb2xkVmFsICYmIHRoaXMuI2lzQmFja2dyb3VuZEZldGNoKG9sZFZhbCkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgb2xkVmFsLl9fc3RhbGVXaGlsZUZldGNoaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG9sZFZhbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9sZFZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMub2xkVmFsdWUgPSBvbGRWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBzdGF0dXMuc2V0ID0gJ3VwZGF0ZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy4jaGFzT25JbnNlcnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uSW5zZXJ0Py4odiwgaywgdiA9PT0gb2xkVmFsID8gJ3VwZGF0ZScgOiAncmVwbGFjZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0dGwgIT09IDAgJiYgIXRoaXMuI3R0bHMpIHtcbiAgICAgICAgICAgIHRoaXMuI2luaXRpYWxpemVUVExUcmFja2luZygpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLiN0dGxzKSB7XG4gICAgICAgICAgICBpZiAoIW5vVXBkYXRlVFRMKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jc2V0SXRlbVRUTChpbmRleCwgdHRsLCBzdGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdHVzKVxuICAgICAgICAgICAgICAgIHRoaXMuI3N0YXR1c1RUTChzdGF0dXMsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5vRGlzcG9zZU9uU2V0ICYmIHRoaXMuI2hhc0Rpc3Bvc2VBZnRlciAmJiB0aGlzLiNkaXNwb3NlZCkge1xuICAgICAgICAgICAgY29uc3QgZHQgPSB0aGlzLiNkaXNwb3NlZDtcbiAgICAgICAgICAgIGxldCB0YXNrO1xuICAgICAgICAgICAgd2hpbGUgKCh0YXNrID0gZHQ/LnNoaWZ0KCkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jZGlzcG9zZUFmdGVyPy4oLi4udGFzayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV2aWN0IHRoZSBsZWFzdCByZWNlbnRseSB1c2VkIGl0ZW0sIHJldHVybmluZyBpdHMgdmFsdWUgb3JcbiAgICAgKiBgdW5kZWZpbmVkYCBpZiBjYWNoZSBpcyBlbXB0eS5cbiAgICAgKi9cbiAgICBwb3AoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB3aGlsZSAodGhpcy4jc2l6ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IHRoaXMuI3ZhbExpc3RbdGhpcy4jaGVhZF07XG4gICAgICAgICAgICAgICAgdGhpcy4jZXZpY3QodHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuI2lzQmFja2dyb3VuZEZldGNoKHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbC5fX3N0YWxlV2hpbGVGZXRjaGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbC5fX3N0YWxlV2hpbGVGZXRjaGluZztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNoYXNEaXNwb3NlQWZ0ZXIgJiYgdGhpcy4jZGlzcG9zZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkdCA9IHRoaXMuI2Rpc3Bvc2VkO1xuICAgICAgICAgICAgICAgIGxldCB0YXNrO1xuICAgICAgICAgICAgICAgIHdoaWxlICgodGFzayA9IGR0Py5zaGlmdCgpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNkaXNwb3NlQWZ0ZXI/LiguLi50YXNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgI2V2aWN0KGZyZWUpIHtcbiAgICAgICAgY29uc3QgaGVhZCA9IHRoaXMuI2hlYWQ7XG4gICAgICAgIGNvbnN0IGsgPSB0aGlzLiNrZXlMaXN0W2hlYWRdO1xuICAgICAgICBjb25zdCB2ID0gdGhpcy4jdmFsTGlzdFtoZWFkXTtcbiAgICAgICAgaWYgKHRoaXMuI2hhc0ZldGNoTWV0aG9kICYmIHRoaXMuI2lzQmFja2dyb3VuZEZldGNoKHYpKSB7XG4gICAgICAgICAgICB2Ll9fYWJvcnRDb250cm9sbGVyLmFib3J0KG5ldyBFcnJvcignZXZpY3RlZCcpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLiNoYXNEaXNwb3NlIHx8IHRoaXMuI2hhc0Rpc3Bvc2VBZnRlcikge1xuICAgICAgICAgICAgaWYgKHRoaXMuI2hhc0Rpc3Bvc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNkaXNwb3NlPy4odiwgaywgJ2V2aWN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy4jaGFzRGlzcG9zZUFmdGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jZGlzcG9zZWQ/LnB1c2goW3YsIGssICdldmljdCddKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNyZW1vdmVJdGVtU2l6ZShoZWFkKTtcbiAgICAgICAgLy8gaWYgd2UgYXJlbid0IGFib3V0IHRvIHVzZSB0aGUgaW5kZXgsIHRoZW4gbnVsbCB0aGVzZSBvdXRcbiAgICAgICAgaWYgKGZyZWUpIHtcbiAgICAgICAgICAgIHRoaXMuI2tleUxpc3RbaGVhZF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLiN2YWxMaXN0W2hlYWRdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy4jZnJlZS5wdXNoKGhlYWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLiNzaXplID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLiNoZWFkID0gdGhpcy4jdGFpbCA9IDA7XG4gICAgICAgICAgICB0aGlzLiNmcmVlLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiNoZWFkID0gdGhpcy4jbmV4dFtoZWFkXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNrZXlNYXAuZGVsZXRlKGspO1xuICAgICAgICB0aGlzLiNzaXplLS07XG4gICAgICAgIHJldHVybiBoZWFkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIGtleSBpcyBpbiB0aGUgY2FjaGUsIHdpdGhvdXQgdXBkYXRpbmcgdGhlIHJlY2VuY3kgb2YgdXNlLlxuICAgICAqIFdpbGwgcmV0dXJuIGZhbHNlIGlmIHRoZSBpdGVtIGlzIHN0YWxlLCBldmVuIHRob3VnaCBpdCBpcyB0ZWNobmljYWxseVxuICAgICAqIGluIHRoZSBjYWNoZS5cbiAgICAgKlxuICAgICAqIENoZWNrIGlmIGEga2V5IGlzIGluIHRoZSBjYWNoZSwgd2l0aG91dCB1cGRhdGluZyB0aGUgcmVjZW5jeSBvZlxuICAgICAqIHVzZS4gQWdlIGlzIHVwZGF0ZWQgaWYge0BsaW5rIExSVUNhY2hlLk9wdGlvbnNCYXNlLnVwZGF0ZUFnZU9uSGFzfSBpcyBzZXRcbiAgICAgKiB0byBgdHJ1ZWAgaW4gZWl0aGVyIHRoZSBvcHRpb25zIG9yIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgKlxuICAgICAqIFdpbGwgcmV0dXJuIGBmYWxzZWAgaWYgdGhlIGl0ZW0gaXMgc3RhbGUsIGV2ZW4gdGhvdWdoIGl0IGlzIHRlY2huaWNhbGx5IGluXG4gICAgICogdGhlIGNhY2hlLiBUaGUgZGlmZmVyZW5jZSBjYW4gYmUgZGV0ZXJtaW5lZCAoaWYgaXQgbWF0dGVycykgYnkgdXNpbmcgYVxuICAgICAqIGBzdGF0dXNgIGFyZ3VtZW50LCBhbmQgaW5zcGVjdGluZyB0aGUgYGhhc2AgZmllbGQuXG4gICAgICpcbiAgICAgKiBXaWxsIG5vdCB1cGRhdGUgaXRlbSBhZ2UgdW5sZXNzXG4gICAgICoge0BsaW5rIExSVUNhY2hlLk9wdGlvbnNCYXNlLnVwZGF0ZUFnZU9uSGFzfSBpcyBzZXQuXG4gICAgICovXG4gICAgaGFzKGssIGhhc09wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCB7IHVwZGF0ZUFnZU9uSGFzID0gdGhpcy51cGRhdGVBZ2VPbkhhcywgc3RhdHVzIH0gPSBoYXNPcHRpb25zO1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuI2tleU1hcC5nZXQoayk7XG4gICAgICAgIGlmIChpbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCB2ID0gdGhpcy4jdmFsTGlzdFtpbmRleF07XG4gICAgICAgICAgICBpZiAodGhpcy4jaXNCYWNrZ3JvdW5kRmV0Y2godikgJiZcbiAgICAgICAgICAgICAgICB2Ll9fc3RhbGVXaGlsZUZldGNoaW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuI2lzU3RhbGUoaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHVwZGF0ZUFnZU9uSGFzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI3VwZGF0ZUl0ZW1BZ2UoaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5oYXMgPSAnaGl0JztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jc3RhdHVzVFRMKHN0YXR1cywgaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN0YXR1cykge1xuICAgICAgICAgICAgICAgIHN0YXR1cy5oYXMgPSAnc3RhbGUnO1xuICAgICAgICAgICAgICAgIHRoaXMuI3N0YXR1c1RUTChzdGF0dXMsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0dXMpIHtcbiAgICAgICAgICAgIHN0YXR1cy5oYXMgPSAnbWlzcyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaWtlIHtAbGluayBMUlVDYWNoZSNnZXR9IGJ1dCBkb2Vzbid0IHVwZGF0ZSByZWNlbmN5IG9yIGRlbGV0ZSBzdGFsZVxuICAgICAqIGl0ZW1zLlxuICAgICAqXG4gICAgICogUmV0dXJucyBgdW5kZWZpbmVkYCBpZiB0aGUgaXRlbSBpcyBzdGFsZSwgdW5sZXNzXG4gICAgICoge0BsaW5rIExSVUNhY2hlLk9wdGlvbnNCYXNlLmFsbG93U3RhbGV9IGlzIHNldC5cbiAgICAgKi9cbiAgICBwZWVrKGssIHBlZWtPcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgeyBhbGxvd1N0YWxlID0gdGhpcy5hbGxvd1N0YWxlIH0gPSBwZWVrT3B0aW9ucztcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLiNrZXlNYXAuZ2V0KGspO1xuICAgICAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgKCFhbGxvd1N0YWxlICYmIHRoaXMuI2lzU3RhbGUoaW5kZXgpKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHYgPSB0aGlzLiN2YWxMaXN0W2luZGV4XTtcbiAgICAgICAgLy8gZWl0aGVyIHN0YWxlIGFuZCBhbGxvd2VkLCBvciBmb3JjaW5nIGEgcmVmcmVzaCBvZiBub24tc3RhbGUgdmFsdWVcbiAgICAgICAgcmV0dXJuIHRoaXMuI2lzQmFja2dyb3VuZEZldGNoKHYpID8gdi5fX3N0YWxlV2hpbGVGZXRjaGluZyA6IHY7XG4gICAgfVxuICAgICNiYWNrZ3JvdW5kRmV0Y2goaywgaW5kZXgsIG9wdGlvbnMsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgdiA9IGluZGV4ID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiB0aGlzLiN2YWxMaXN0W2luZGV4XTtcbiAgICAgICAgaWYgKHRoaXMuI2lzQmFja2dyb3VuZEZldGNoKHYpKSB7XG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhYyA9IG5ldyBBQygpO1xuICAgICAgICBjb25zdCB7IHNpZ25hbCB9ID0gb3B0aW9ucztcbiAgICAgICAgLy8gd2hlbi9pZiBvdXIgQUMgc2lnbmFscywgdGhlbiBzdG9wIGxpc3RlbmluZyB0byB0aGVpcnMuXG4gICAgICAgIHNpZ25hbD8uYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiBhYy5hYm9ydChzaWduYWwucmVhc29uKSwge1xuICAgICAgICAgICAgc2lnbmFsOiBhYy5zaWduYWwsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBmZXRjaE9wdHMgPSB7XG4gICAgICAgICAgICBzaWduYWw6IGFjLnNpZ25hbCxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjYiA9ICh2LCB1cGRhdGVDYWNoZSA9IGZhbHNlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGFib3J0ZWQgfSA9IGFjLnNpZ25hbDtcbiAgICAgICAgICAgIGNvbnN0IGlnbm9yZUFib3J0ID0gb3B0aW9ucy5pZ25vcmVGZXRjaEFib3J0ICYmIHYgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnN0YXR1cykge1xuICAgICAgICAgICAgICAgIGlmIChhYm9ydGVkICYmICF1cGRhdGVDYWNoZSkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnN0YXR1cy5mZXRjaEFib3J0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnN0YXR1cy5mZXRjaEVycm9yID0gYWMuc2lnbmFsLnJlYXNvbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlnbm9yZUFib3J0KVxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zdGF0dXMuZmV0Y2hBYm9ydElnbm9yZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zdGF0dXMuZmV0Y2hSZXNvbHZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFib3J0ZWQgJiYgIWlnbm9yZUFib3J0ICYmICF1cGRhdGVDYWNoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmZXRjaEZhaWwoYWMuc2lnbmFsLnJlYXNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlaXRoZXIgd2UgZGlkbid0IGFib3J0LCBhbmQgYXJlIHN0aWxsIGhlcmUsIG9yIHdlIGRpZCwgYW5kIGlnbm9yZWRcbiAgICAgICAgICAgIGNvbnN0IGJmID0gcDtcbiAgICAgICAgICAgIGlmICh0aGlzLiN2YWxMaXN0W2luZGV4XSA9PT0gcCkge1xuICAgICAgICAgICAgICAgIGlmICh2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJmLl9fc3RhbGVXaGlsZUZldGNoaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuI3ZhbExpc3RbaW5kZXhdID0gYmYuX19zdGFsZVdoaWxlRmV0Y2hpbmc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiNkZWxldGUoaywgJ2ZldGNoJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnN0YXR1cylcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc3RhdHVzLmZldGNoVXBkYXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0KGssIHYsIGZldGNoT3B0cy5vcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZWIgPSAoZXIpID0+IHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnN0YXR1cykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuc3RhdHVzLmZldGNoUmVqZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuc3RhdHVzLmZldGNoRXJyb3IgPSBlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmZXRjaEZhaWwoZXIpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBmZXRjaEZhaWwgPSAoZXIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgYWJvcnRlZCB9ID0gYWMuc2lnbmFsO1xuICAgICAgICAgICAgY29uc3QgYWxsb3dTdGFsZUFib3J0ZWQgPSBhYm9ydGVkICYmIG9wdGlvbnMuYWxsb3dTdGFsZU9uRmV0Y2hBYm9ydDtcbiAgICAgICAgICAgIGNvbnN0IGFsbG93U3RhbGUgPSBhbGxvd1N0YWxlQWJvcnRlZCB8fCBvcHRpb25zLmFsbG93U3RhbGVPbkZldGNoUmVqZWN0aW9uO1xuICAgICAgICAgICAgY29uc3Qgbm9EZWxldGUgPSBhbGxvd1N0YWxlIHx8IG9wdGlvbnMubm9EZWxldGVPbkZldGNoUmVqZWN0aW9uO1xuICAgICAgICAgICAgY29uc3QgYmYgPSBwO1xuICAgICAgICAgICAgaWYgKHRoaXMuI3ZhbExpc3RbaW5kZXhdID09PSBwKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgd2UgYWxsb3cgc3RhbGUgb24gZmV0Y2ggcmVqZWN0aW9ucywgdGhlbiB3ZSBuZWVkIHRvIGVuc3VyZSB0aGF0XG4gICAgICAgICAgICAgICAgLy8gdGhlIHN0YWxlIHZhbHVlIGlzIG5vdCByZW1vdmVkIGZyb20gdGhlIGNhY2hlIHdoZW4gdGhlIGZldGNoIGZhaWxzLlxuICAgICAgICAgICAgICAgIGNvbnN0IGRlbCA9ICFub0RlbGV0ZSB8fCBiZi5fX3N0YWxlV2hpbGVGZXRjaGluZyA9PT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlmIChkZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jZGVsZXRlKGssICdmZXRjaCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghYWxsb3dTdGFsZUFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RpbGwgcmVwbGFjZSB0aGUgKnByb21pc2UqIHdpdGggdGhlIHN0YWxlIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAvLyBzaW5jZSB3ZSBhcmUgZG9uZSB3aXRoIHRoZSBwcm9taXNlIGF0IHRoaXMgcG9pbnQuXG4gICAgICAgICAgICAgICAgICAgIC8vIGxlYXZlIGl0IHVudG91Y2hlZCBpZiB3ZSdyZSBzdGlsbCB3YWl0aW5nIGZvciBhblxuICAgICAgICAgICAgICAgICAgICAvLyBhYm9ydGVkIGJhY2tncm91bmQgZmV0Y2ggdGhhdCBoYXNuJ3QgeWV0IHJldHVybmVkLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLiN2YWxMaXN0W2luZGV4XSA9IGJmLl9fc3RhbGVXaGlsZUZldGNoaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbGxvd1N0YWxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc3RhdHVzICYmIGJmLl9fc3RhbGVXaGlsZUZldGNoaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zdGF0dXMucmV0dXJuZWRTdGFsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBiZi5fX3N0YWxlV2hpbGVGZXRjaGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJmLl9fcmV0dXJuZWQgPT09IGJmKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHBjYWxsID0gKHJlcywgcmVqKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmbXAgPSB0aGlzLiNmZXRjaE1ldGhvZD8uKGssIHYsIGZldGNoT3B0cyk7XG4gICAgICAgICAgICBpZiAoZm1wICYmIGZtcCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICBmbXAudGhlbih2ID0+IHJlcyh2ID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiB2KSwgcmVqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlnbm9yZWQsIHdlIGdvIHVudGlsIHdlIGZpbmlzaCwgcmVnYXJkbGVzcy5cbiAgICAgICAgICAgIC8vIGRlZmVyIGNoZWNrIHVudGlsIHdlIGFyZSBhY3R1YWxseSBhYm9ydGluZyxcbiAgICAgICAgICAgIC8vIHNvIGZldGNoTWV0aG9kIGNhbiBvdmVycmlkZS5cbiAgICAgICAgICAgIGFjLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMuaWdub3JlRmV0Y2hBYm9ydCB8fFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmFsbG93U3RhbGVPbkZldGNoQWJvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gaXQgZXZlbnR1YWxseSByZXNvbHZlcywgdXBkYXRlIHRoZSBjYWNoZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYWxsb3dTdGFsZU9uRmV0Y2hBYm9ydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0gdiA9PiBjYih2LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBpZiAob3B0aW9ucy5zdGF0dXMpXG4gICAgICAgICAgICBvcHRpb25zLnN0YXR1cy5mZXRjaERpc3BhdGNoZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCBwID0gbmV3IFByb21pc2UocGNhbGwpLnRoZW4oY2IsIGViKTtcbiAgICAgICAgY29uc3QgYmYgPSBPYmplY3QuYXNzaWduKHAsIHtcbiAgICAgICAgICAgIF9fYWJvcnRDb250cm9sbGVyOiBhYyxcbiAgICAgICAgICAgIF9fc3RhbGVXaGlsZUZldGNoaW5nOiB2LFxuICAgICAgICAgICAgX19yZXR1cm5lZDogdW5kZWZpbmVkLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIGludGVybmFsLCBkb24ndCBleHBvc2Ugc3RhdHVzLlxuICAgICAgICAgICAgdGhpcy5zZXQoaywgYmYsIHsgLi4uZmV0Y2hPcHRzLm9wdGlvbnMsIHN0YXR1czogdW5kZWZpbmVkIH0pO1xuICAgICAgICAgICAgaW5kZXggPSB0aGlzLiNrZXlNYXAuZ2V0KGspO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4jdmFsTGlzdFtpbmRleF0gPSBiZjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmY7XG4gICAgfVxuICAgICNpc0JhY2tncm91bmRGZXRjaChwKSB7XG4gICAgICAgIGlmICghdGhpcy4jaGFzRmV0Y2hNZXRob2QpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IGIgPSBwO1xuICAgICAgICByZXR1cm4gKCEhYiAmJlxuICAgICAgICAgICAgYiBpbnN0YW5jZW9mIFByb21pc2UgJiZcbiAgICAgICAgICAgIGIuaGFzT3duUHJvcGVydHkoJ19fc3RhbGVXaGlsZUZldGNoaW5nJykgJiZcbiAgICAgICAgICAgIGIuX19hYm9ydENvbnRyb2xsZXIgaW5zdGFuY2VvZiBBQyk7XG4gICAgfVxuICAgIGFzeW5jIGZldGNoKGssIGZldGNoT3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHsgXG4gICAgICAgIC8vIGdldCBvcHRpb25zXG4gICAgICAgIGFsbG93U3RhbGUgPSB0aGlzLmFsbG93U3RhbGUsIHVwZGF0ZUFnZU9uR2V0ID0gdGhpcy51cGRhdGVBZ2VPbkdldCwgbm9EZWxldGVPblN0YWxlR2V0ID0gdGhpcy5ub0RlbGV0ZU9uU3RhbGVHZXQsIFxuICAgICAgICAvLyBzZXQgb3B0aW9uc1xuICAgICAgICB0dGwgPSB0aGlzLnR0bCwgbm9EaXNwb3NlT25TZXQgPSB0aGlzLm5vRGlzcG9zZU9uU2V0LCBzaXplID0gMCwgc2l6ZUNhbGN1bGF0aW9uID0gdGhpcy5zaXplQ2FsY3VsYXRpb24sIG5vVXBkYXRlVFRMID0gdGhpcy5ub1VwZGF0ZVRUTCwgXG4gICAgICAgIC8vIGZldGNoIGV4Y2x1c2l2ZSBvcHRpb25zXG4gICAgICAgIG5vRGVsZXRlT25GZXRjaFJlamVjdGlvbiA9IHRoaXMubm9EZWxldGVPbkZldGNoUmVqZWN0aW9uLCBhbGxvd1N0YWxlT25GZXRjaFJlamVjdGlvbiA9IHRoaXMuYWxsb3dTdGFsZU9uRmV0Y2hSZWplY3Rpb24sIGlnbm9yZUZldGNoQWJvcnQgPSB0aGlzLmlnbm9yZUZldGNoQWJvcnQsIGFsbG93U3RhbGVPbkZldGNoQWJvcnQgPSB0aGlzLmFsbG93U3RhbGVPbkZldGNoQWJvcnQsIGNvbnRleHQsIGZvcmNlUmVmcmVzaCA9IGZhbHNlLCBzdGF0dXMsIHNpZ25hbCwgfSA9IGZldGNoT3B0aW9ucztcbiAgICAgICAgaWYgKCF0aGlzLiNoYXNGZXRjaE1ldGhvZCkge1xuICAgICAgICAgICAgaWYgKHN0YXR1cylcbiAgICAgICAgICAgICAgICBzdGF0dXMuZmV0Y2ggPSAnZ2V0JztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldChrLCB7XG4gICAgICAgICAgICAgICAgYWxsb3dTdGFsZSxcbiAgICAgICAgICAgICAgICB1cGRhdGVBZ2VPbkdldCxcbiAgICAgICAgICAgICAgICBub0RlbGV0ZU9uU3RhbGVHZXQsXG4gICAgICAgICAgICAgICAgc3RhdHVzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGFsbG93U3RhbGUsXG4gICAgICAgICAgICB1cGRhdGVBZ2VPbkdldCxcbiAgICAgICAgICAgIG5vRGVsZXRlT25TdGFsZUdldCxcbiAgICAgICAgICAgIHR0bCxcbiAgICAgICAgICAgIG5vRGlzcG9zZU9uU2V0LFxuICAgICAgICAgICAgc2l6ZSxcbiAgICAgICAgICAgIHNpemVDYWxjdWxhdGlvbixcbiAgICAgICAgICAgIG5vVXBkYXRlVFRMLFxuICAgICAgICAgICAgbm9EZWxldGVPbkZldGNoUmVqZWN0aW9uLFxuICAgICAgICAgICAgYWxsb3dTdGFsZU9uRmV0Y2hSZWplY3Rpb24sXG4gICAgICAgICAgICBhbGxvd1N0YWxlT25GZXRjaEFib3J0LFxuICAgICAgICAgICAgaWdub3JlRmV0Y2hBYm9ydCxcbiAgICAgICAgICAgIHN0YXR1cyxcbiAgICAgICAgICAgIHNpZ25hbCxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGluZGV4ID0gdGhpcy4ja2V5TWFwLmdldChrKTtcbiAgICAgICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChzdGF0dXMpXG4gICAgICAgICAgICAgICAgc3RhdHVzLmZldGNoID0gJ21pc3MnO1xuICAgICAgICAgICAgY29uc3QgcCA9IHRoaXMuI2JhY2tncm91bmRGZXRjaChrLCBpbmRleCwgb3B0aW9ucywgY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gKHAuX19yZXR1cm5lZCA9IHApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gaW4gY2FjaGUsIG1heWJlIGFscmVhZHkgZmV0Y2hpbmdcbiAgICAgICAgICAgIGNvbnN0IHYgPSB0aGlzLiN2YWxMaXN0W2luZGV4XTtcbiAgICAgICAgICAgIGlmICh0aGlzLiNpc0JhY2tncm91bmRGZXRjaCh2KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YWxlID0gYWxsb3dTdGFsZSAmJiB2Ll9fc3RhbGVXaGlsZUZldGNoaW5nICE9PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZmV0Y2ggPSAnaW5mbGlnaHQnO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhbGUpXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMucmV0dXJuZWRTdGFsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzdGFsZSA/IHYuX19zdGFsZVdoaWxlRmV0Y2hpbmcgOiAodi5fX3JldHVybmVkID0gdik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiB3ZSBmb3JjZSBhIHJlZnJlc2gsIHRoYXQgbWVhbnMgZG8gTk9UIHNlcnZlIHRoZSBjYWNoZWQgdmFsdWUsXG4gICAgICAgICAgICAvLyB1bmxlc3Mgd2UgYXJlIGFscmVhZHkgaW4gdGhlIHByb2Nlc3Mgb2YgcmVmcmVzaGluZyB0aGUgY2FjaGUuXG4gICAgICAgICAgICBjb25zdCBpc1N0YWxlID0gdGhpcy4jaXNTdGFsZShpbmRleCk7XG4gICAgICAgICAgICBpZiAoIWZvcmNlUmVmcmVzaCAmJiAhaXNTdGFsZSkge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMpXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5mZXRjaCA9ICdoaXQnO1xuICAgICAgICAgICAgICAgIHRoaXMuI21vdmVUb1RhaWwoaW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmICh1cGRhdGVBZ2VPbkdldCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiN1cGRhdGVJdGVtQWdlKGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jc3RhdHVzVFRMKHN0YXR1cywgaW5kZXgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gb2ssIGl0IGlzIHN0YWxlIG9yIGEgZm9yY2VkIHJlZnJlc2gsIGFuZCBub3QgYWxyZWFkeSBmZXRjaGluZy5cbiAgICAgICAgICAgIC8vIHJlZnJlc2ggdGhlIGNhY2hlLlxuICAgICAgICAgICAgY29uc3QgcCA9IHRoaXMuI2JhY2tncm91bmRGZXRjaChrLCBpbmRleCwgb3B0aW9ucywgY29udGV4dCk7XG4gICAgICAgICAgICBjb25zdCBoYXNTdGFsZSA9IHAuX19zdGFsZVdoaWxlRmV0Y2hpbmcgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnN0IHN0YWxlVmFsID0gaGFzU3RhbGUgJiYgYWxsb3dTdGFsZTtcbiAgICAgICAgICAgIGlmIChzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZmV0Y2ggPSBpc1N0YWxlID8gJ3N0YWxlJyA6ICdyZWZyZXNoJztcbiAgICAgICAgICAgICAgICBpZiAoc3RhbGVWYWwgJiYgaXNTdGFsZSlcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLnJldHVybmVkU3RhbGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0YWxlVmFsID8gcC5fX3N0YWxlV2hpbGVGZXRjaGluZyA6IChwLl9fcmV0dXJuZWQgPSBwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBmb3JjZUZldGNoKGssIGZldGNoT3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHYgPSBhd2FpdCB0aGlzLmZldGNoKGssIGZldGNoT3B0aW9ucyk7XG4gICAgICAgIGlmICh2ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZldGNoKCkgcmV0dXJuZWQgdW5kZWZpbmVkJyk7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICBtZW1vKGssIG1lbW9PcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgbWVtb01ldGhvZCA9IHRoaXMuI21lbW9NZXRob2Q7XG4gICAgICAgIGlmICghbWVtb01ldGhvZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBtZW1vTWV0aG9kIHByb3ZpZGVkIHRvIGNvbnN0cnVjdG9yJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBjb250ZXh0LCBmb3JjZVJlZnJlc2gsIC4uLm9wdGlvbnMgfSA9IG1lbW9PcHRpb25zO1xuICAgICAgICBjb25zdCB2ID0gdGhpcy5nZXQoaywgb3B0aW9ucyk7XG4gICAgICAgIGlmICghZm9yY2VSZWZyZXNoICYmIHYgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjb25zdCB2diA9IG1lbW9NZXRob2Qoaywgdiwge1xuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNldChrLCB2diwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB2djtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgdmFsdWUgZnJvbSB0aGUgY2FjaGUuIFdpbGwgdXBkYXRlIHRoZSByZWNlbmN5IG9mIHRoZSBjYWNoZVxuICAgICAqIGVudHJ5IGZvdW5kLlxuICAgICAqXG4gICAgICogSWYgdGhlIGtleSBpcyBub3QgZm91bmQsIGdldCgpIHdpbGwgcmV0dXJuIGB1bmRlZmluZWRgLlxuICAgICAqL1xuICAgIGdldChrLCBnZXRPcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgeyBhbGxvd1N0YWxlID0gdGhpcy5hbGxvd1N0YWxlLCB1cGRhdGVBZ2VPbkdldCA9IHRoaXMudXBkYXRlQWdlT25HZXQsIG5vRGVsZXRlT25TdGFsZUdldCA9IHRoaXMubm9EZWxldGVPblN0YWxlR2V0LCBzdGF0dXMsIH0gPSBnZXRPcHRpb25zO1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuI2tleU1hcC5nZXQoayk7XG4gICAgICAgIGlmIChpbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI3ZhbExpc3RbaW5kZXhdO1xuICAgICAgICAgICAgY29uc3QgZmV0Y2hpbmcgPSB0aGlzLiNpc0JhY2tncm91bmRGZXRjaCh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoc3RhdHVzKVxuICAgICAgICAgICAgICAgIHRoaXMuI3N0YXR1c1RUTChzdGF0dXMsIGluZGV4KTtcbiAgICAgICAgICAgIGlmICh0aGlzLiNpc1N0YWxlKGluZGV4KSkge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMpXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5nZXQgPSAnc3RhbGUnO1xuICAgICAgICAgICAgICAgIC8vIGRlbGV0ZSBvbmx5IGlmIG5vdCBhbiBpbi1mbGlnaHQgYmFja2dyb3VuZCBmZXRjaFxuICAgICAgICAgICAgICAgIGlmICghZmV0Y2hpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub0RlbGV0ZU9uU3RhbGVHZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuI2RlbGV0ZShrLCAnZXhwaXJlJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cyAmJiBhbGxvd1N0YWxlKVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzLnJldHVybmVkU3RhbGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWxsb3dTdGFsZSA/IHZhbHVlIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dTdGFsZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuX19zdGFsZVdoaWxlRmV0Y2hpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzLnJldHVybmVkU3RhbGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhbGxvd1N0YWxlID8gdmFsdWUuX19zdGFsZVdoaWxlRmV0Y2hpbmcgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cylcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmdldCA9ICdoaXQnO1xuICAgICAgICAgICAgICAgIC8vIGlmIHdlJ3JlIGN1cnJlbnRseSBmZXRjaGluZyBpdCwgd2UgZG9uJ3QgYWN0dWFsbHkgaGF2ZSBpdCB5ZXRcbiAgICAgICAgICAgICAgICAvLyBpdCdzIG5vdCBzdGFsZSwgd2hpY2ggbWVhbnMgdGhpcyBpc24ndCBhIHN0YWxlV2hpbGVSZWZldGNoaW5nLlxuICAgICAgICAgICAgICAgIC8vIElmIGl0J3Mgbm90IHN0YWxlLCBhbmQgZmV0Y2hpbmcsIEFORCBoYXMgYSBfX3N0YWxlV2hpbGVGZXRjaGluZ1xuICAgICAgICAgICAgICAgIC8vIHZhbHVlLCB0aGVuIHRoYXQgbWVhbnMgdGhlIHVzZXIgZmV0Y2hlZCB3aXRoIHtmb3JjZVJlZnJlc2g6dHJ1ZX0sXG4gICAgICAgICAgICAgICAgLy8gc28gaXQncyBzYWZlIHRvIHJldHVybiB0aGF0IHZhbHVlLlxuICAgICAgICAgICAgICAgIGlmIChmZXRjaGluZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuX19zdGFsZVdoaWxlRmV0Y2hpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuI21vdmVUb1RhaWwoaW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmICh1cGRhdGVBZ2VPbkdldCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiN1cGRhdGVJdGVtQWdlKGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXR1cykge1xuICAgICAgICAgICAgc3RhdHVzLmdldCA9ICdtaXNzJztcbiAgICAgICAgfVxuICAgIH1cbiAgICAjY29ubmVjdChwLCBuKSB7XG4gICAgICAgIHRoaXMuI3ByZXZbbl0gPSBwO1xuICAgICAgICB0aGlzLiNuZXh0W3BdID0gbjtcbiAgICB9XG4gICAgI21vdmVUb1RhaWwoaW5kZXgpIHtcbiAgICAgICAgLy8gaWYgdGFpbCBhbHJlYWR5LCBub3RoaW5nIHRvIGRvXG4gICAgICAgIC8vIGlmIGhlYWQsIG1vdmUgaGVhZCB0byBuZXh0W2luZGV4XVxuICAgICAgICAvLyBlbHNlXG4gICAgICAgIC8vICAgbW92ZSBuZXh0W3ByZXZbaW5kZXhdXSB0byBuZXh0W2luZGV4XSAoaGVhZCBoYXMgbm8gcHJldilcbiAgICAgICAgLy8gICBtb3ZlIHByZXZbbmV4dFtpbmRleF1dIHRvIHByZXZbaW5kZXhdXG4gICAgICAgIC8vIHByZXZbaW5kZXhdID0gdGFpbFxuICAgICAgICAvLyBuZXh0W3RhaWxdID0gaW5kZXhcbiAgICAgICAgLy8gdGFpbCA9IGluZGV4XG4gICAgICAgIGlmIChpbmRleCAhPT0gdGhpcy4jdGFpbCkge1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSB0aGlzLiNoZWFkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jaGVhZCA9IHRoaXMuI25leHRbaW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jY29ubmVjdCh0aGlzLiNwcmV2W2luZGV4XSwgdGhpcy4jbmV4dFtpbmRleF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4jY29ubmVjdCh0aGlzLiN0YWlsLCBpbmRleCk7XG4gICAgICAgICAgICB0aGlzLiN0YWlsID0gaW5kZXg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBhIGtleSBvdXQgb2YgdGhlIGNhY2hlLlxuICAgICAqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBrZXkgd2FzIGRlbGV0ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBkZWxldGUoaykge1xuICAgICAgICByZXR1cm4gdGhpcy4jZGVsZXRlKGssICdkZWxldGUnKTtcbiAgICB9XG4gICAgI2RlbGV0ZShrLCByZWFzb24pIHtcbiAgICAgICAgbGV0IGRlbGV0ZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuI3NpemUgIT09IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy4ja2V5TWFwLmdldChrKTtcbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuI3NpemUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jY2xlYXIocmVhc29uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI3JlbW92ZUl0ZW1TaXplKGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdiA9IHRoaXMuI3ZhbExpc3RbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy4jaXNCYWNrZ3JvdW5kRmV0Y2godikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHYuX19hYm9ydENvbnRyb2xsZXIuYWJvcnQobmV3IEVycm9yKCdkZWxldGVkJykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuI2hhc0Rpc3Bvc2UgfHwgdGhpcy4jaGFzRGlzcG9zZUFmdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy4jaGFzRGlzcG9zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuI2Rpc3Bvc2U/Lih2LCBrLCByZWFzb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuI2hhc0Rpc3Bvc2VBZnRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuI2Rpc3Bvc2VkPy5wdXNoKFt2LCBrLCByZWFzb25dKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLiNrZXlNYXAuZGVsZXRlKGspO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNrZXlMaXN0W2luZGV4XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jdmFsTGlzdFtpbmRleF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gdGhpcy4jdGFpbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4jdGFpbCA9IHRoaXMuI3ByZXZbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGluZGV4ID09PSB0aGlzLiNoZWFkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiNoZWFkID0gdGhpcy4jbmV4dFtpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwaSA9IHRoaXMuI3ByZXZbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4jbmV4dFtwaV0gPSB0aGlzLiNuZXh0W2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5pID0gdGhpcy4jbmV4dFtpbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiNwcmV2W25pXSA9IHRoaXMuI3ByZXZbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI3NpemUtLTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jZnJlZS5wdXNoKGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuI2hhc0Rpc3Bvc2VBZnRlciAmJiB0aGlzLiNkaXNwb3NlZD8ubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBkdCA9IHRoaXMuI2Rpc3Bvc2VkO1xuICAgICAgICAgICAgbGV0IHRhc2s7XG4gICAgICAgICAgICB3aGlsZSAoKHRhc2sgPSBkdD8uc2hpZnQoKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNkaXNwb3NlQWZ0ZXI/LiguLi50YXNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVsZXRlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYXIgdGhlIGNhY2hlIGVudGlyZWx5LCB0aHJvd2luZyBhd2F5IGFsbCB2YWx1ZXMuXG4gICAgICovXG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNjbGVhcignZGVsZXRlJyk7XG4gICAgfVxuICAgICNjbGVhcihyZWFzb24pIHtcbiAgICAgICAgZm9yIChjb25zdCBpbmRleCBvZiB0aGlzLiNyaW5kZXhlcyh7IGFsbG93U3RhbGU6IHRydWUgfSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSB0aGlzLiN2YWxMaXN0W2luZGV4XTtcbiAgICAgICAgICAgIGlmICh0aGlzLiNpc0JhY2tncm91bmRGZXRjaCh2KSkge1xuICAgICAgICAgICAgICAgIHYuX19hYm9ydENvbnRyb2xsZXIuYWJvcnQobmV3IEVycm9yKCdkZWxldGVkJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgayA9IHRoaXMuI2tleUxpc3RbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiNoYXNEaXNwb3NlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI2Rpc3Bvc2U/Lih2LCBrLCByZWFzb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy4jaGFzRGlzcG9zZUFmdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI2Rpc3Bvc2VkPy5wdXNoKFt2LCBrLCByZWFzb25dKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4ja2V5TWFwLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuI3ZhbExpc3QuZmlsbCh1bmRlZmluZWQpO1xuICAgICAgICB0aGlzLiNrZXlMaXN0LmZpbGwodW5kZWZpbmVkKTtcbiAgICAgICAgaWYgKHRoaXMuI3R0bHMgJiYgdGhpcy4jc3RhcnRzKSB7XG4gICAgICAgICAgICB0aGlzLiN0dGxzLmZpbGwoMCk7XG4gICAgICAgICAgICB0aGlzLiNzdGFydHMuZmlsbCgwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy4jc2l6ZXMpIHtcbiAgICAgICAgICAgIHRoaXMuI3NpemVzLmZpbGwoMCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jaGVhZCA9IDA7XG4gICAgICAgIHRoaXMuI3RhaWwgPSAwO1xuICAgICAgICB0aGlzLiNmcmVlLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuI2NhbGN1bGF0ZWRTaXplID0gMDtcbiAgICAgICAgdGhpcy4jc2l6ZSA9IDA7XG4gICAgICAgIGlmICh0aGlzLiNoYXNEaXNwb3NlQWZ0ZXIgJiYgdGhpcy4jZGlzcG9zZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGR0ID0gdGhpcy4jZGlzcG9zZWQ7XG4gICAgICAgICAgICBsZXQgdGFzaztcbiAgICAgICAgICAgIHdoaWxlICgodGFzayA9IGR0Py5zaGlmdCgpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuI2Rpc3Bvc2VBZnRlcj8uKC4uLnRhc2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/e2b/node_modules/lru-cache/dist/esm/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/e2b/node_modules/minimatch/dist/esm/assert-valid-pattern.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/e2b/node_modules/minimatch/dist/esm/assert-valid-pattern.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertValidPattern: () => (/* binding */ assertValidPattern)\n/* harmony export */ });\nconst MAX_PATTERN_LENGTH = 1024 * 64;\nconst assertValidPattern = (pattern) => {\n    if (typeof pattern !== 'string') {\n        throw new TypeError('invalid pattern');\n    }\n    if (pattern.length > MAX_PATTERN_LENGTH) {\n        throw new TypeError('pattern is too long');\n    }\n};\n//# sourceMappingURL=assert-valid-pattern.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZTJiL25vZGVfbW9kdWxlcy9taW5pbWF0Y2gvZGlzdC9lc20vYXNzZXJ0LXZhbGlkLXBhdHRlcm4uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdml2ZS12aWJlLWFpLW5leHQvLi9ub2RlX21vZHVsZXMvZTJiL25vZGVfbW9kdWxlcy9taW5pbWF0Y2gvZGlzdC9lc20vYXNzZXJ0LXZhbGlkLXBhdHRlcm4uanM/Nzk1YyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBNQVhfUEFUVEVSTl9MRU5HVEggPSAxMDI0ICogNjQ7XG5leHBvcnQgY29uc3QgYXNzZXJ0VmFsaWRQYXR0ZXJuID0gKHBhdHRlcm4pID0+IHtcbiAgICBpZiAodHlwZW9mIHBhdHRlcm4gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcGF0dGVybicpO1xuICAgIH1cbiAgICBpZiAocGF0dGVybi5sZW5ndGggPiBNQVhfUEFUVEVSTl9MRU5HVEgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGF0dGVybiBpcyB0b28gbG9uZycpO1xuICAgIH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3NlcnQtdmFsaWQtcGF0dGVybi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/e2b/node_modules/minimatch/dist/esm/assert-valid-pattern.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/e2b/node_modules/minimatch/dist/esm/ast.js":
/*!*****************************************************************!*\
  !*** ./node_modules/e2b/node_modules/minimatch/dist/esm/ast.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AST: () => (/* binding */ AST)\n/* harmony export */ });\n/* harmony import */ var _brace_expressions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./brace-expressions.js */ \"(rsc)/./node_modules/e2b/node_modules/minimatch/dist/esm/brace-expressions.js\");\n/* harmony import */ var _unescape_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./unescape.js */ \"(rsc)/./node_modules/e2b/node_modules/minimatch/dist/esm/unescape.js\");\n// parse a single path portion\n\n\nconst types = new Set(['!', '?', '+', '*', '@']);\nconst isExtglobType = (c) => types.has(c);\n// Patterns that get prepended to bind to the start of either the\n// entire string, or just a single path portion, to prevent dots\n// and/or traversal patterns, when needed.\n// Exts don't need the ^ or / bit, because the root binds that already.\nconst startNoTraversal = '(?!(?:^|/)\\\\.\\\\.?(?:$|/))';\nconst startNoDot = '(?!\\\\.)';\n// characters that indicate a start of pattern needs the \"no dots\" bit,\n// because a dot *might* be matched. ( is not in the list, because in\n// the case of a child extglob, it will handle the prevention itself.\nconst addPatternStart = new Set(['[', '.']);\n// cases where traversal is A-OK, no dot prevention needed\nconst justDots = new Set(['..', '.']);\nconst reSpecials = new Set('().*{}+?[]^$\\\\!');\nconst regExpEscape = (s) => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n// any single thing other than /\nconst qmark = '[^/]';\n// * => any number of characters\nconst star = qmark + '*?';\n// use + when we need to ensure that *something* matches, because the * is\n// the only thing in the path portion.\nconst starNoEmpty = qmark + '+?';\n// remove the \\ chars that we added if we end up doing a nonmagic compare\n// const deslash = (s: string) => s.replace(/\\\\(.)/g, '$1')\nclass AST {\n    type;\n    #root;\n    #hasMagic;\n    #uflag = false;\n    #parts = [];\n    #parent;\n    #parentIndex;\n    #negs;\n    #filledNegs = false;\n    #options;\n    #toString;\n    // set to true if it's an extglob with no children\n    // (which really means one child of '')\n    #emptyExt = false;\n    constructor(type, parent, options = {}) {\n        this.type = type;\n        // extglobs are inherently magical\n        if (type)\n            this.#hasMagic = true;\n        this.#parent = parent;\n        this.#root = this.#parent ? this.#parent.#root : this;\n        this.#options = this.#root === this ? options : this.#root.#options;\n        this.#negs = this.#root === this ? [] : this.#root.#negs;\n        if (type === '!' && !this.#root.#filledNegs)\n            this.#negs.push(this);\n        this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;\n    }\n    get hasMagic() {\n        /* c8 ignore start */\n        if (this.#hasMagic !== undefined)\n            return this.#hasMagic;\n        /* c8 ignore stop */\n        for (const p of this.#parts) {\n            if (typeof p === 'string')\n                continue;\n            if (p.type || p.hasMagic)\n                return (this.#hasMagic = true);\n        }\n        // note: will be undefined until we generate the regexp src and find out\n        return this.#hasMagic;\n    }\n    // reconstructs the pattern\n    toString() {\n        if (this.#toString !== undefined)\n            return this.#toString;\n        if (!this.type) {\n            return (this.#toString = this.#parts.map(p => String(p)).join(''));\n        }\n        else {\n            return (this.#toString =\n                this.type + '(' + this.#parts.map(p => String(p)).join('|') + ')');\n        }\n    }\n    #fillNegs() {\n        /* c8 ignore start */\n        if (this !== this.#root)\n            throw new Error('should only call on root');\n        if (this.#filledNegs)\n            return this;\n        /* c8 ignore stop */\n        // call toString() once to fill this out\n        this.toString();\n        this.#filledNegs = true;\n        let n;\n        while ((n = this.#negs.pop())) {\n            if (n.type !== '!')\n                continue;\n            // walk up the tree, appending everthing that comes AFTER parentIndex\n            let p = n;\n            let pp = p.#parent;\n            while (pp) {\n                for (let i = p.#parentIndex + 1; !pp.type && i < pp.#parts.length; i++) {\n                    for (const part of n.#parts) {\n                        /* c8 ignore start */\n                        if (typeof part === 'string') {\n                            throw new Error('string part in extglob AST??');\n                        }\n                        /* c8 ignore stop */\n                        part.copyIn(pp.#parts[i]);\n                    }\n                }\n                p = pp;\n                pp = p.#parent;\n            }\n        }\n        return this;\n    }\n    push(...parts) {\n        for (const p of parts) {\n            if (p === '')\n                continue;\n            /* c8 ignore start */\n            if (typeof p !== 'string' && !(p instanceof AST && p.#parent === this)) {\n                throw new Error('invalid part: ' + p);\n            }\n            /* c8 ignore stop */\n            this.#parts.push(p);\n        }\n    }\n    toJSON() {\n        const ret = this.type === null\n            ? this.#parts.slice().map(p => (typeof p === 'string' ? p : p.toJSON()))\n            : [this.type, ...this.#parts.map(p => p.toJSON())];\n        if (this.isStart() && !this.type)\n            ret.unshift([]);\n        if (this.isEnd() &&\n            (this === this.#root ||\n                (this.#root.#filledNegs && this.#parent?.type === '!'))) {\n            ret.push({});\n        }\n        return ret;\n    }\n    isStart() {\n        if (this.#root === this)\n            return true;\n        // if (this.type) return !!this.#parent?.isStart()\n        if (!this.#parent?.isStart())\n            return false;\n        if (this.#parentIndex === 0)\n            return true;\n        // if everything AHEAD of this is a negation, then it's still the \"start\"\n        const p = this.#parent;\n        for (let i = 0; i < this.#parentIndex; i++) {\n            const pp = p.#parts[i];\n            if (!(pp instanceof AST && pp.type === '!')) {\n                return false;\n            }\n        }\n        return true;\n    }\n    isEnd() {\n        if (this.#root === this)\n            return true;\n        if (this.#parent?.type === '!')\n            return true;\n        if (!this.#parent?.isEnd())\n            return false;\n        if (!this.type)\n            return this.#parent?.isEnd();\n        // if not root, it'll always have a parent\n        /* c8 ignore start */\n        const pl = this.#parent ? this.#parent.#parts.length : 0;\n        /* c8 ignore stop */\n        return this.#parentIndex === pl - 1;\n    }\n    copyIn(part) {\n        if (typeof part === 'string')\n            this.push(part);\n        else\n            this.push(part.clone(this));\n    }\n    clone(parent) {\n        const c = new AST(this.type, parent);\n        for (const p of this.#parts) {\n            c.copyIn(p);\n        }\n        return c;\n    }\n    static #parseAST(str, ast, pos, opt) {\n        let escaping = false;\n        let inBrace = false;\n        let braceStart = -1;\n        let braceNeg = false;\n        if (ast.type === null) {\n            // outside of a extglob, append until we find a start\n            let i = pos;\n            let acc = '';\n            while (i < str.length) {\n                const c = str.charAt(i++);\n                // still accumulate escapes at this point, but we do ignore\n                // starts that are escaped\n                if (escaping || c === '\\\\') {\n                    escaping = !escaping;\n                    acc += c;\n                    continue;\n                }\n                if (inBrace) {\n                    if (i === braceStart + 1) {\n                        if (c === '^' || c === '!') {\n                            braceNeg = true;\n                        }\n                    }\n                    else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n                        inBrace = false;\n                    }\n                    acc += c;\n                    continue;\n                }\n                else if (c === '[') {\n                    inBrace = true;\n                    braceStart = i;\n                    braceNeg = false;\n                    acc += c;\n                    continue;\n                }\n                if (!opt.noext && isExtglobType(c) && str.charAt(i) === '(') {\n                    ast.push(acc);\n                    acc = '';\n                    const ext = new AST(c, ast);\n                    i = AST.#parseAST(str, ext, i, opt);\n                    ast.push(ext);\n                    continue;\n                }\n                acc += c;\n            }\n            ast.push(acc);\n            return i;\n        }\n        // some kind of extglob, pos is at the (\n        // find the next | or )\n        let i = pos + 1;\n        let part = new AST(null, ast);\n        const parts = [];\n        let acc = '';\n        while (i < str.length) {\n            const c = str.charAt(i++);\n            // still accumulate escapes at this point, but we do ignore\n            // starts that are escaped\n            if (escaping || c === '\\\\') {\n                escaping = !escaping;\n                acc += c;\n                continue;\n            }\n            if (inBrace) {\n                if (i === braceStart + 1) {\n                    if (c === '^' || c === '!') {\n                        braceNeg = true;\n                    }\n                }\n                else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n                    inBrace = false;\n                }\n                acc += c;\n                continue;\n            }\n            else if (c === '[') {\n                inBrace = true;\n                braceStart = i;\n                braceNeg = false;\n                acc += c;\n                continue;\n            }\n            if (isExtglobType(c) && str.charAt(i) === '(') {\n                part.push(acc);\n                acc = '';\n                const ext = new AST(c, part);\n                part.push(ext);\n                i = AST.#parseAST(str, ext, i, opt);\n                continue;\n            }\n            if (c === '|') {\n                part.push(acc);\n                acc = '';\n                parts.push(part);\n                part = new AST(null, ast);\n                continue;\n            }\n            if (c === ')') {\n                if (acc === '' && ast.#parts.length === 0) {\n                    ast.#emptyExt = true;\n                }\n                part.push(acc);\n                acc = '';\n                ast.push(...parts, part);\n                return i;\n            }\n            acc += c;\n        }\n        // unfinished extglob\n        // if we got here, it was a malformed extglob! not an extglob, but\n        // maybe something else in there.\n        ast.type = null;\n        ast.#hasMagic = undefined;\n        ast.#parts = [str.substring(pos - 1)];\n        return i;\n    }\n    static fromGlob(pattern, options = {}) {\n        const ast = new AST(null, undefined, options);\n        AST.#parseAST(pattern, ast, 0, options);\n        return ast;\n    }\n    // returns the regular expression if there's magic, or the unescaped\n    // string if not.\n    toMMPattern() {\n        // should only be called on root\n        /* c8 ignore start */\n        if (this !== this.#root)\n            return this.#root.toMMPattern();\n        /* c8 ignore stop */\n        const glob = this.toString();\n        const [re, body, hasMagic, uflag] = this.toRegExpSource();\n        // if we're in nocase mode, and not nocaseMagicOnly, then we do\n        // still need a regular expression if we have to case-insensitively\n        // match capital/lowercase characters.\n        const anyMagic = hasMagic ||\n            this.#hasMagic ||\n            (this.#options.nocase &&\n                !this.#options.nocaseMagicOnly &&\n                glob.toUpperCase() !== glob.toLowerCase());\n        if (!anyMagic) {\n            return body;\n        }\n        const flags = (this.#options.nocase ? 'i' : '') + (uflag ? 'u' : '');\n        return Object.assign(new RegExp(`^${re}$`, flags), {\n            _src: re,\n            _glob: glob,\n        });\n    }\n    get options() {\n        return this.#options;\n    }\n    // returns the string match, the regexp source, whether there's magic\n    // in the regexp (so a regular expression is required) and whether or\n    // not the uflag is needed for the regular expression (for posix classes)\n    // TODO: instead of injecting the start/end at this point, just return\n    // the BODY of the regexp, along with the start/end portions suitable\n    // for binding the start/end in either a joined full-path makeRe context\n    // (where we bind to (^|/), or a standalone matchPart context (where\n    // we bind to ^, and not /).  Otherwise slashes get duped!\n    //\n    // In part-matching mode, the start is:\n    // - if not isStart: nothing\n    // - if traversal possible, but not allowed: ^(?!\\.\\.?$)\n    // - if dots allowed or not possible: ^\n    // - if dots possible and not allowed: ^(?!\\.)\n    // end is:\n    // - if not isEnd(): nothing\n    // - else: $\n    //\n    // In full-path matching mode, we put the slash at the START of the\n    // pattern, so start is:\n    // - if first pattern: same as part-matching mode\n    // - if not isStart(): nothing\n    // - if traversal possible, but not allowed: /(?!\\.\\.?(?:$|/))\n    // - if dots allowed or not possible: /\n    // - if dots possible and not allowed: /(?!\\.)\n    // end is:\n    // - if last pattern, same as part-matching mode\n    // - else nothing\n    //\n    // Always put the (?:$|/) on negated tails, though, because that has to be\n    // there to bind the end of the negated pattern portion, and it's easier to\n    // just stick it in now rather than try to inject it later in the middle of\n    // the pattern.\n    //\n    // We can just always return the same end, and leave it up to the caller\n    // to know whether it's going to be used joined or in parts.\n    // And, if the start is adjusted slightly, can do the same there:\n    // - if not isStart: nothing\n    // - if traversal possible, but not allowed: (?:/|^)(?!\\.\\.?$)\n    // - if dots allowed or not possible: (?:/|^)\n    // - if dots possible and not allowed: (?:/|^)(?!\\.)\n    //\n    // But it's better to have a simpler binding without a conditional, for\n    // performance, so probably better to return both start options.\n    //\n    // Then the caller just ignores the end if it's not the first pattern,\n    // and the start always gets applied.\n    //\n    // But that's always going to be $ if it's the ending pattern, or nothing,\n    // so the caller can just attach $ at the end of the pattern when building.\n    //\n    // So the todo is:\n    // - better detect what kind of start is needed\n    // - return both flavors of starting pattern\n    // - attach $ at the end of the pattern when creating the actual RegExp\n    //\n    // Ah, but wait, no, that all only applies to the root when the first pattern\n    // is not an extglob. If the first pattern IS an extglob, then we need all\n    // that dot prevention biz to live in the extglob portions, because eg\n    // +(*|.x*) can match .xy but not .yx.\n    //\n    // So, return the two flavors if it's #root and the first child is not an\n    // AST, otherwise leave it to the child AST to handle it, and there,\n    // use the (?:^|/) style of start binding.\n    //\n    // Even simplified further:\n    // - Since the start for a join is eg /(?!\\.) and the start for a part\n    // is ^(?!\\.), we can just prepend (?!\\.) to the pattern (either root\n    // or start or whatever) and prepend ^ or / at the Regexp construction.\n    toRegExpSource(allowDot) {\n        const dot = allowDot ?? !!this.#options.dot;\n        if (this.#root === this)\n            this.#fillNegs();\n        if (!this.type) {\n            const noEmpty = this.isStart() && this.isEnd();\n            const src = this.#parts\n                .map(p => {\n                const [re, _, hasMagic, uflag] = typeof p === 'string'\n                    ? AST.#parseGlob(p, this.#hasMagic, noEmpty)\n                    : p.toRegExpSource(allowDot);\n                this.#hasMagic = this.#hasMagic || hasMagic;\n                this.#uflag = this.#uflag || uflag;\n                return re;\n            })\n                .join('');\n            let start = '';\n            if (this.isStart()) {\n                if (typeof this.#parts[0] === 'string') {\n                    // this is the string that will match the start of the pattern,\n                    // so we need to protect against dots and such.\n                    // '.' and '..' cannot match unless the pattern is that exactly,\n                    // even if it starts with . or dot:true is set.\n                    const dotTravAllowed = this.#parts.length === 1 && justDots.has(this.#parts[0]);\n                    if (!dotTravAllowed) {\n                        const aps = addPatternStart;\n                        // check if we have a possibility of matching . or ..,\n                        // and prevent that.\n                        const needNoTrav = \n                        // dots are allowed, and the pattern starts with [ or .\n                        (dot && aps.has(src.charAt(0))) ||\n                            // the pattern starts with \\., and then [ or .\n                            (src.startsWith('\\\\.') && aps.has(src.charAt(2))) ||\n                            // the pattern starts with \\.\\., and then [ or .\n                            (src.startsWith('\\\\.\\\\.') && aps.has(src.charAt(4)));\n                        // no need to prevent dots if it can't match a dot, or if a\n                        // sub-pattern will be preventing it anyway.\n                        const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));\n                        start = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : '';\n                    }\n                }\n            }\n            // append the \"end of path portion\" pattern to negation tails\n            let end = '';\n            if (this.isEnd() &&\n                this.#root.#filledNegs &&\n                this.#parent?.type === '!') {\n                end = '(?:$|\\\\/)';\n            }\n            const final = start + src + end;\n            return [\n                final,\n                (0,_unescape_js__WEBPACK_IMPORTED_MODULE_1__.unescape)(src),\n                (this.#hasMagic = !!this.#hasMagic),\n                this.#uflag,\n            ];\n        }\n        // We need to calculate the body *twice* if it's a repeat pattern\n        // at the start, once in nodot mode, then again in dot mode, so a\n        // pattern like *(?) can match 'x.y'\n        const repeated = this.type === '*' || this.type === '+';\n        // some kind of extglob\n        const start = this.type === '!' ? '(?:(?!(?:' : '(?:';\n        let body = this.#partsToRegExp(dot);\n        if (this.isStart() && this.isEnd() && !body && this.type !== '!') {\n            // invalid extglob, has to at least be *something* present, if it's\n            // the entire path portion.\n            const s = this.toString();\n            this.#parts = [s];\n            this.type = null;\n            this.#hasMagic = undefined;\n            return [s, (0,_unescape_js__WEBPACK_IMPORTED_MODULE_1__.unescape)(this.toString()), false, false];\n        }\n        // XXX abstract out this map method\n        let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot\n            ? ''\n            : this.#partsToRegExp(true);\n        if (bodyDotAllowed === body) {\n            bodyDotAllowed = '';\n        }\n        if (bodyDotAllowed) {\n            body = `(?:${body})(?:${bodyDotAllowed})*?`;\n        }\n        // an empty !() is exactly equivalent to a starNoEmpty\n        let final = '';\n        if (this.type === '!' && this.#emptyExt) {\n            final = (this.isStart() && !dot ? startNoDot : '') + starNoEmpty;\n        }\n        else {\n            const close = this.type === '!'\n                ? // !() must match something,but !(x) can match ''\n                    '))' +\n                        (this.isStart() && !dot && !allowDot ? startNoDot : '') +\n                        star +\n                        ')'\n                : this.type === '@'\n                    ? ')'\n                    : this.type === '?'\n                        ? ')?'\n                        : this.type === '+' && bodyDotAllowed\n                            ? ')'\n                            : this.type === '*' && bodyDotAllowed\n                                ? `)?`\n                                : `)${this.type}`;\n            final = start + body + close;\n        }\n        return [\n            final,\n            (0,_unescape_js__WEBPACK_IMPORTED_MODULE_1__.unescape)(body),\n            (this.#hasMagic = !!this.#hasMagic),\n            this.#uflag,\n        ];\n    }\n    #partsToRegExp(dot) {\n        return this.#parts\n            .map(p => {\n            // extglob ASTs should only contain parent ASTs\n            /* c8 ignore start */\n            if (typeof p === 'string') {\n                throw new Error('string type in extglob ast??');\n            }\n            /* c8 ignore stop */\n            // can ignore hasMagic, because extglobs are already always magic\n            const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot);\n            this.#uflag = this.#uflag || uflag;\n            return re;\n        })\n            .filter(p => !(this.isStart() && this.isEnd()) || !!p)\n            .join('|');\n    }\n    static #parseGlob(glob, hasMagic, noEmpty = false) {\n        let escaping = false;\n        let re = '';\n        let uflag = false;\n        for (let i = 0; i < glob.length; i++) {\n            const c = glob.charAt(i);\n            if (escaping) {\n                escaping = false;\n                re += (reSpecials.has(c) ? '\\\\' : '') + c;\n                continue;\n            }\n            if (c === '\\\\') {\n                if (i === glob.length - 1) {\n                    re += '\\\\\\\\';\n                }\n                else {\n                    escaping = true;\n                }\n                continue;\n            }\n            if (c === '[') {\n                const [src, needUflag, consumed, magic] = (0,_brace_expressions_js__WEBPACK_IMPORTED_MODULE_0__.parseClass)(glob, i);\n                if (consumed) {\n                    re += src;\n                    uflag = uflag || needUflag;\n                    i += consumed - 1;\n                    hasMagic = hasMagic || magic;\n                    continue;\n                }\n            }\n            if (c === '*') {\n                if (noEmpty && glob === '*')\n                    re += starNoEmpty;\n                else\n                    re += star;\n                hasMagic = true;\n                continue;\n            }\n            if (c === '?') {\n                re += qmark;\n                hasMagic = true;\n                continue;\n            }\n            re += regExpEscape(c);\n        }\n        return [re, (0,_unescape_js__WEBPACK_IMPORTED_MODULE_1__.unescape)(glob), !!hasMagic, uflag];\n    }\n}\n//# sourceMappingURL=ast.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZTJiL25vZGVfbW9kdWxlcy9taW5pbWF0Y2gvZGlzdC9lc20vYXN0LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ29EO0FBQ1g7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsa0NBQWtDO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsR0FBRztBQUMvQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzREFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0RBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLEtBQUssTUFBTSxlQUFlO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxVQUFVO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzREFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxpRUFBVTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNEQUFRO0FBQzVCO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpdmUtdmliZS1haS1uZXh0Ly4vbm9kZV9tb2R1bGVzL2UyYi9ub2RlX21vZHVsZXMvbWluaW1hdGNoL2Rpc3QvZXNtL2FzdC5qcz80YzA0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHBhcnNlIGEgc2luZ2xlIHBhdGggcG9ydGlvblxuaW1wb3J0IHsgcGFyc2VDbGFzcyB9IGZyb20gJy4vYnJhY2UtZXhwcmVzc2lvbnMuanMnO1xuaW1wb3J0IHsgdW5lc2NhcGUgfSBmcm9tICcuL3VuZXNjYXBlLmpzJztcbmNvbnN0IHR5cGVzID0gbmV3IFNldChbJyEnLCAnPycsICcrJywgJyonLCAnQCddKTtcbmNvbnN0IGlzRXh0Z2xvYlR5cGUgPSAoYykgPT4gdHlwZXMuaGFzKGMpO1xuLy8gUGF0dGVybnMgdGhhdCBnZXQgcHJlcGVuZGVkIHRvIGJpbmQgdG8gdGhlIHN0YXJ0IG9mIGVpdGhlciB0aGVcbi8vIGVudGlyZSBzdHJpbmcsIG9yIGp1c3QgYSBzaW5nbGUgcGF0aCBwb3J0aW9uLCB0byBwcmV2ZW50IGRvdHNcbi8vIGFuZC9vciB0cmF2ZXJzYWwgcGF0dGVybnMsIHdoZW4gbmVlZGVkLlxuLy8gRXh0cyBkb24ndCBuZWVkIHRoZSBeIG9yIC8gYml0LCBiZWNhdXNlIHRoZSByb290IGJpbmRzIHRoYXQgYWxyZWFkeS5cbmNvbnN0IHN0YXJ0Tm9UcmF2ZXJzYWwgPSAnKD8hKD86XnwvKVxcXFwuXFxcXC4/KD86JHwvKSknO1xuY29uc3Qgc3RhcnROb0RvdCA9ICcoPyFcXFxcLiknO1xuLy8gY2hhcmFjdGVycyB0aGF0IGluZGljYXRlIGEgc3RhcnQgb2YgcGF0dGVybiBuZWVkcyB0aGUgXCJubyBkb3RzXCIgYml0LFxuLy8gYmVjYXVzZSBhIGRvdCAqbWlnaHQqIGJlIG1hdGNoZWQuICggaXMgbm90IGluIHRoZSBsaXN0LCBiZWNhdXNlIGluXG4vLyB0aGUgY2FzZSBvZiBhIGNoaWxkIGV4dGdsb2IsIGl0IHdpbGwgaGFuZGxlIHRoZSBwcmV2ZW50aW9uIGl0c2VsZi5cbmNvbnN0IGFkZFBhdHRlcm5TdGFydCA9IG5ldyBTZXQoWydbJywgJy4nXSk7XG4vLyBjYXNlcyB3aGVyZSB0cmF2ZXJzYWwgaXMgQS1PSywgbm8gZG90IHByZXZlbnRpb24gbmVlZGVkXG5jb25zdCBqdXN0RG90cyA9IG5ldyBTZXQoWycuLicsICcuJ10pO1xuY29uc3QgcmVTcGVjaWFscyA9IG5ldyBTZXQoJygpLip7fSs/W11eJFxcXFwhJyk7XG5jb25zdCByZWdFeHBFc2NhcGUgPSAocykgPT4gcy5yZXBsYWNlKC9bLVtcXF17fSgpKis/LixcXFxcXiR8I1xcc10vZywgJ1xcXFwkJicpO1xuLy8gYW55IHNpbmdsZSB0aGluZyBvdGhlciB0aGFuIC9cbmNvbnN0IHFtYXJrID0gJ1teL10nO1xuLy8gKiA9PiBhbnkgbnVtYmVyIG9mIGNoYXJhY3RlcnNcbmNvbnN0IHN0YXIgPSBxbWFyayArICcqPyc7XG4vLyB1c2UgKyB3aGVuIHdlIG5lZWQgdG8gZW5zdXJlIHRoYXQgKnNvbWV0aGluZyogbWF0Y2hlcywgYmVjYXVzZSB0aGUgKiBpc1xuLy8gdGhlIG9ubHkgdGhpbmcgaW4gdGhlIHBhdGggcG9ydGlvbi5cbmNvbnN0IHN0YXJOb0VtcHR5ID0gcW1hcmsgKyAnKz8nO1xuLy8gcmVtb3ZlIHRoZSBcXCBjaGFycyB0aGF0IHdlIGFkZGVkIGlmIHdlIGVuZCB1cCBkb2luZyBhIG5vbm1hZ2ljIGNvbXBhcmVcbi8vIGNvbnN0IGRlc2xhc2ggPSAoczogc3RyaW5nKSA9PiBzLnJlcGxhY2UoL1xcXFwoLikvZywgJyQxJylcbmV4cG9ydCBjbGFzcyBBU1Qge1xuICAgIHR5cGU7XG4gICAgI3Jvb3Q7XG4gICAgI2hhc01hZ2ljO1xuICAgICN1ZmxhZyA9IGZhbHNlO1xuICAgICNwYXJ0cyA9IFtdO1xuICAgICNwYXJlbnQ7XG4gICAgI3BhcmVudEluZGV4O1xuICAgICNuZWdzO1xuICAgICNmaWxsZWROZWdzID0gZmFsc2U7XG4gICAgI29wdGlvbnM7XG4gICAgI3RvU3RyaW5nO1xuICAgIC8vIHNldCB0byB0cnVlIGlmIGl0J3MgYW4gZXh0Z2xvYiB3aXRoIG5vIGNoaWxkcmVuXG4gICAgLy8gKHdoaWNoIHJlYWxseSBtZWFucyBvbmUgY2hpbGQgb2YgJycpXG4gICAgI2VtcHR5RXh0ID0gZmFsc2U7XG4gICAgY29uc3RydWN0b3IodHlwZSwgcGFyZW50LCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgLy8gZXh0Z2xvYnMgYXJlIGluaGVyZW50bHkgbWFnaWNhbFxuICAgICAgICBpZiAodHlwZSlcbiAgICAgICAgICAgIHRoaXMuI2hhc01hZ2ljID0gdHJ1ZTtcbiAgICAgICAgdGhpcy4jcGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLiNyb290ID0gdGhpcy4jcGFyZW50ID8gdGhpcy4jcGFyZW50LiNyb290IDogdGhpcztcbiAgICAgICAgdGhpcy4jb3B0aW9ucyA9IHRoaXMuI3Jvb3QgPT09IHRoaXMgPyBvcHRpb25zIDogdGhpcy4jcm9vdC4jb3B0aW9ucztcbiAgICAgICAgdGhpcy4jbmVncyA9IHRoaXMuI3Jvb3QgPT09IHRoaXMgPyBbXSA6IHRoaXMuI3Jvb3QuI25lZ3M7XG4gICAgICAgIGlmICh0eXBlID09PSAnIScgJiYgIXRoaXMuI3Jvb3QuI2ZpbGxlZE5lZ3MpXG4gICAgICAgICAgICB0aGlzLiNuZWdzLnB1c2godGhpcyk7XG4gICAgICAgIHRoaXMuI3BhcmVudEluZGV4ID0gdGhpcy4jcGFyZW50ID8gdGhpcy4jcGFyZW50LiNwYXJ0cy5sZW5ndGggOiAwO1xuICAgIH1cbiAgICBnZXQgaGFzTWFnaWMoKSB7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICBpZiAodGhpcy4jaGFzTWFnaWMgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNoYXNNYWdpYztcbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgZm9yIChjb25zdCBwIG9mIHRoaXMuI3BhcnRzKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHAgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHAudHlwZSB8fCBwLmhhc01hZ2ljKVxuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy4jaGFzTWFnaWMgPSB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBub3RlOiB3aWxsIGJlIHVuZGVmaW5lZCB1bnRpbCB3ZSBnZW5lcmF0ZSB0aGUgcmVnZXhwIHNyYyBhbmQgZmluZCBvdXRcbiAgICAgICAgcmV0dXJuIHRoaXMuI2hhc01hZ2ljO1xuICAgIH1cbiAgICAvLyByZWNvbnN0cnVjdHMgdGhlIHBhdHRlcm5cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgaWYgKHRoaXMuI3RvU3RyaW5nICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jdG9TdHJpbmc7XG4gICAgICAgIGlmICghdGhpcy50eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuI3RvU3RyaW5nID0gdGhpcy4jcGFydHMubWFwKHAgPT4gU3RyaW5nKHApKS5qb2luKCcnKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuI3RvU3RyaW5nID1cbiAgICAgICAgICAgICAgICB0aGlzLnR5cGUgKyAnKCcgKyB0aGlzLiNwYXJ0cy5tYXAocCA9PiBTdHJpbmcocCkpLmpvaW4oJ3wnKSArICcpJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgI2ZpbGxOZWdzKCkge1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgaWYgKHRoaXMgIT09IHRoaXMuI3Jvb3QpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Nob3VsZCBvbmx5IGNhbGwgb24gcm9vdCcpO1xuICAgICAgICBpZiAodGhpcy4jZmlsbGVkTmVncylcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAvLyBjYWxsIHRvU3RyaW5nKCkgb25jZSB0byBmaWxsIHRoaXMgb3V0XG4gICAgICAgIHRoaXMudG9TdHJpbmcoKTtcbiAgICAgICAgdGhpcy4jZmlsbGVkTmVncyA9IHRydWU7XG4gICAgICAgIGxldCBuO1xuICAgICAgICB3aGlsZSAoKG4gPSB0aGlzLiNuZWdzLnBvcCgpKSkge1xuICAgICAgICAgICAgaWYgKG4udHlwZSAhPT0gJyEnKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgLy8gd2FsayB1cCB0aGUgdHJlZSwgYXBwZW5kaW5nIGV2ZXJ0aGluZyB0aGF0IGNvbWVzIEFGVEVSIHBhcmVudEluZGV4XG4gICAgICAgICAgICBsZXQgcCA9IG47XG4gICAgICAgICAgICBsZXQgcHAgPSBwLiNwYXJlbnQ7XG4gICAgICAgICAgICB3aGlsZSAocHApIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gcC4jcGFyZW50SW5kZXggKyAxOyAhcHAudHlwZSAmJiBpIDwgcHAuI3BhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcGFydCBvZiBuLiNwYXJ0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdHJpbmcgcGFydCBpbiBleHRnbG9iIEFTVD8/Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFydC5jb3B5SW4ocHAuI3BhcnRzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwID0gcHA7XG4gICAgICAgICAgICAgICAgcHAgPSBwLiNwYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHB1c2goLi4ucGFydHMpIHtcbiAgICAgICAgZm9yIChjb25zdCBwIG9mIHBhcnRzKSB7XG4gICAgICAgICAgICBpZiAocCA9PT0gJycpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcCAhPT0gJ3N0cmluZycgJiYgIShwIGluc3RhbmNlb2YgQVNUICYmIHAuI3BhcmVudCA9PT0gdGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcGFydDogJyArIHApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgICAgIHRoaXMuI3BhcnRzLnB1c2gocCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCByZXQgPSB0aGlzLnR5cGUgPT09IG51bGxcbiAgICAgICAgICAgID8gdGhpcy4jcGFydHMuc2xpY2UoKS5tYXAocCA9PiAodHlwZW9mIHAgPT09ICdzdHJpbmcnID8gcCA6IHAudG9KU09OKCkpKVxuICAgICAgICAgICAgOiBbdGhpcy50eXBlLCAuLi50aGlzLiNwYXJ0cy5tYXAocCA9PiBwLnRvSlNPTigpKV07XG4gICAgICAgIGlmICh0aGlzLmlzU3RhcnQoKSAmJiAhdGhpcy50eXBlKVxuICAgICAgICAgICAgcmV0LnVuc2hpZnQoW10pO1xuICAgICAgICBpZiAodGhpcy5pc0VuZCgpICYmXG4gICAgICAgICAgICAodGhpcyA9PT0gdGhpcy4jcm9vdCB8fFxuICAgICAgICAgICAgICAgICh0aGlzLiNyb290LiNmaWxsZWROZWdzICYmIHRoaXMuI3BhcmVudD8udHlwZSA9PT0gJyEnKSkpIHtcbiAgICAgICAgICAgIHJldC5wdXNoKHt9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBpc1N0YXJ0KCkge1xuICAgICAgICBpZiAodGhpcy4jcm9vdCA9PT0gdGhpcylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvLyBpZiAodGhpcy50eXBlKSByZXR1cm4gISF0aGlzLiNwYXJlbnQ/LmlzU3RhcnQoKVxuICAgICAgICBpZiAoIXRoaXMuI3BhcmVudD8uaXNTdGFydCgpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodGhpcy4jcGFyZW50SW5kZXggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gaWYgZXZlcnl0aGluZyBBSEVBRCBvZiB0aGlzIGlzIGEgbmVnYXRpb24sIHRoZW4gaXQncyBzdGlsbCB0aGUgXCJzdGFydFwiXG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLiNwYXJlbnQ7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy4jcGFyZW50SW5kZXg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcHAgPSBwLiNwYXJ0c1tpXTtcbiAgICAgICAgICAgIGlmICghKHBwIGluc3RhbmNlb2YgQVNUICYmIHBwLnR5cGUgPT09ICchJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlzRW5kKCkge1xuICAgICAgICBpZiAodGhpcy4jcm9vdCA9PT0gdGhpcylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAodGhpcy4jcGFyZW50Py50eXBlID09PSAnIScpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKCF0aGlzLiNwYXJlbnQ/LmlzRW5kKCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghdGhpcy50eXBlKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3BhcmVudD8uaXNFbmQoKTtcbiAgICAgICAgLy8gaWYgbm90IHJvb3QsIGl0J2xsIGFsd2F5cyBoYXZlIGEgcGFyZW50XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICBjb25zdCBwbCA9IHRoaXMuI3BhcmVudCA/IHRoaXMuI3BhcmVudC4jcGFydHMubGVuZ3RoIDogMDtcbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgcmV0dXJuIHRoaXMuI3BhcmVudEluZGV4ID09PSBwbCAtIDE7XG4gICAgfVxuICAgIGNvcHlJbihwYXJ0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgcGFydCA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICB0aGlzLnB1c2gocGFydCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMucHVzaChwYXJ0LmNsb25lKHRoaXMpKTtcbiAgICB9XG4gICAgY2xvbmUocGFyZW50KSB7XG4gICAgICAgIGNvbnN0IGMgPSBuZXcgQVNUKHRoaXMudHlwZSwgcGFyZW50KTtcbiAgICAgICAgZm9yIChjb25zdCBwIG9mIHRoaXMuI3BhcnRzKSB7XG4gICAgICAgICAgICBjLmNvcHlJbihwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYztcbiAgICB9XG4gICAgc3RhdGljICNwYXJzZUFTVChzdHIsIGFzdCwgcG9zLCBvcHQpIHtcbiAgICAgICAgbGV0IGVzY2FwaW5nID0gZmFsc2U7XG4gICAgICAgIGxldCBpbkJyYWNlID0gZmFsc2U7XG4gICAgICAgIGxldCBicmFjZVN0YXJ0ID0gLTE7XG4gICAgICAgIGxldCBicmFjZU5lZyA9IGZhbHNlO1xuICAgICAgICBpZiAoYXN0LnR5cGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIG91dHNpZGUgb2YgYSBleHRnbG9iLCBhcHBlbmQgdW50aWwgd2UgZmluZCBhIHN0YXJ0XG4gICAgICAgICAgICBsZXQgaSA9IHBvcztcbiAgICAgICAgICAgIGxldCBhY2MgPSAnJztcbiAgICAgICAgICAgIHdoaWxlIChpIDwgc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGMgPSBzdHIuY2hhckF0KGkrKyk7XG4gICAgICAgICAgICAgICAgLy8gc3RpbGwgYWNjdW11bGF0ZSBlc2NhcGVzIGF0IHRoaXMgcG9pbnQsIGJ1dCB3ZSBkbyBpZ25vcmVcbiAgICAgICAgICAgICAgICAvLyBzdGFydHMgdGhhdCBhcmUgZXNjYXBlZFxuICAgICAgICAgICAgICAgIGlmIChlc2NhcGluZyB8fCBjID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZXNjYXBpbmcgPSAhZXNjYXBpbmc7XG4gICAgICAgICAgICAgICAgICAgIGFjYyArPSBjO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGluQnJhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IGJyYWNlU3RhcnQgKyAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gJ14nIHx8IGMgPT09ICchJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyYWNlTmVnID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjID09PSAnXScgJiYgIShpID09PSBicmFjZVN0YXJ0ICsgMiAmJiBicmFjZU5lZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluQnJhY2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhY2MgKz0gYztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09ICdbJykge1xuICAgICAgICAgICAgICAgICAgICBpbkJyYWNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJhY2VTdGFydCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGJyYWNlTmVnID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGFjYyArPSBjO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFvcHQubm9leHQgJiYgaXNFeHRnbG9iVHlwZShjKSAmJiBzdHIuY2hhckF0KGkpID09PSAnKCcpIHtcbiAgICAgICAgICAgICAgICAgICAgYXN0LnB1c2goYWNjKTtcbiAgICAgICAgICAgICAgICAgICAgYWNjID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4dCA9IG5ldyBBU1QoYywgYXN0KTtcbiAgICAgICAgICAgICAgICAgICAgaSA9IEFTVC4jcGFyc2VBU1Qoc3RyLCBleHQsIGksIG9wdCk7XG4gICAgICAgICAgICAgICAgICAgIGFzdC5wdXNoKGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhY2MgKz0gYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzdC5wdXNoKGFjYyk7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzb21lIGtpbmQgb2YgZXh0Z2xvYiwgcG9zIGlzIGF0IHRoZSAoXG4gICAgICAgIC8vIGZpbmQgdGhlIG5leHQgfCBvciApXG4gICAgICAgIGxldCBpID0gcG9zICsgMTtcbiAgICAgICAgbGV0IHBhcnQgPSBuZXcgQVNUKG51bGwsIGFzdCk7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gW107XG4gICAgICAgIGxldCBhY2MgPSAnJztcbiAgICAgICAgd2hpbGUgKGkgPCBzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBjID0gc3RyLmNoYXJBdChpKyspO1xuICAgICAgICAgICAgLy8gc3RpbGwgYWNjdW11bGF0ZSBlc2NhcGVzIGF0IHRoaXMgcG9pbnQsIGJ1dCB3ZSBkbyBpZ25vcmVcbiAgICAgICAgICAgIC8vIHN0YXJ0cyB0aGF0IGFyZSBlc2NhcGVkXG4gICAgICAgICAgICBpZiAoZXNjYXBpbmcgfHwgYyA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICAgICAgZXNjYXBpbmcgPSAhZXNjYXBpbmc7XG4gICAgICAgICAgICAgICAgYWNjICs9IGM7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5CcmFjZSkge1xuICAgICAgICAgICAgICAgIGlmIChpID09PSBicmFjZVN0YXJ0ICsgMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gJ14nIHx8IGMgPT09ICchJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJhY2VOZWcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09ICddJyAmJiAhKGkgPT09IGJyYWNlU3RhcnQgKyAyICYmIGJyYWNlTmVnKSkge1xuICAgICAgICAgICAgICAgICAgICBpbkJyYWNlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFjYyArPSBjO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gJ1snKSB7XG4gICAgICAgICAgICAgICAgaW5CcmFjZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJhY2VTdGFydCA9IGk7XG4gICAgICAgICAgICAgICAgYnJhY2VOZWcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBhY2MgKz0gYztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0V4dGdsb2JUeXBlKGMpICYmIHN0ci5jaGFyQXQoaSkgPT09ICcoJykge1xuICAgICAgICAgICAgICAgIHBhcnQucHVzaChhY2MpO1xuICAgICAgICAgICAgICAgIGFjYyA9ICcnO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4dCA9IG5ldyBBU1QoYywgcGFydCk7XG4gICAgICAgICAgICAgICAgcGFydC5wdXNoKGV4dCk7XG4gICAgICAgICAgICAgICAgaSA9IEFTVC4jcGFyc2VBU1Qoc3RyLCBleHQsIGksIG9wdCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYyA9PT0gJ3wnKSB7XG4gICAgICAgICAgICAgICAgcGFydC5wdXNoKGFjYyk7XG4gICAgICAgICAgICAgICAgYWNjID0gJyc7XG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChwYXJ0KTtcbiAgICAgICAgICAgICAgICBwYXJ0ID0gbmV3IEFTVChudWxsLCBhc3QpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGMgPT09ICcpJykge1xuICAgICAgICAgICAgICAgIGlmIChhY2MgPT09ICcnICYmIGFzdC4jcGFydHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzdC4jZW1wdHlFeHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJ0LnB1c2goYWNjKTtcbiAgICAgICAgICAgICAgICBhY2MgPSAnJztcbiAgICAgICAgICAgICAgICBhc3QucHVzaCguLi5wYXJ0cywgcGFydCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhY2MgKz0gYztcbiAgICAgICAgfVxuICAgICAgICAvLyB1bmZpbmlzaGVkIGV4dGdsb2JcbiAgICAgICAgLy8gaWYgd2UgZ290IGhlcmUsIGl0IHdhcyBhIG1hbGZvcm1lZCBleHRnbG9iISBub3QgYW4gZXh0Z2xvYiwgYnV0XG4gICAgICAgIC8vIG1heWJlIHNvbWV0aGluZyBlbHNlIGluIHRoZXJlLlxuICAgICAgICBhc3QudHlwZSA9IG51bGw7XG4gICAgICAgIGFzdC4jaGFzTWFnaWMgPSB1bmRlZmluZWQ7XG4gICAgICAgIGFzdC4jcGFydHMgPSBbc3RyLnN1YnN0cmluZyhwb3MgLSAxKV07XG4gICAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUdsb2IocGF0dGVybiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGFzdCA9IG5ldyBBU1QobnVsbCwgdW5kZWZpbmVkLCBvcHRpb25zKTtcbiAgICAgICAgQVNULiNwYXJzZUFTVChwYXR0ZXJuLCBhc3QsIDAsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH1cbiAgICAvLyByZXR1cm5zIHRoZSByZWd1bGFyIGV4cHJlc3Npb24gaWYgdGhlcmUncyBtYWdpYywgb3IgdGhlIHVuZXNjYXBlZFxuICAgIC8vIHN0cmluZyBpZiBub3QuXG4gICAgdG9NTVBhdHRlcm4oKSB7XG4gICAgICAgIC8vIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiByb290XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICBpZiAodGhpcyAhPT0gdGhpcy4jcm9vdClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNyb290LnRvTU1QYXR0ZXJuKCk7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgIGNvbnN0IGdsb2IgPSB0aGlzLnRvU3RyaW5nKCk7XG4gICAgICAgIGNvbnN0IFtyZSwgYm9keSwgaGFzTWFnaWMsIHVmbGFnXSA9IHRoaXMudG9SZWdFeHBTb3VyY2UoKTtcbiAgICAgICAgLy8gaWYgd2UncmUgaW4gbm9jYXNlIG1vZGUsIGFuZCBub3Qgbm9jYXNlTWFnaWNPbmx5LCB0aGVuIHdlIGRvXG4gICAgICAgIC8vIHN0aWxsIG5lZWQgYSByZWd1bGFyIGV4cHJlc3Npb24gaWYgd2UgaGF2ZSB0byBjYXNlLWluc2Vuc2l0aXZlbHlcbiAgICAgICAgLy8gbWF0Y2ggY2FwaXRhbC9sb3dlcmNhc2UgY2hhcmFjdGVycy5cbiAgICAgICAgY29uc3QgYW55TWFnaWMgPSBoYXNNYWdpYyB8fFxuICAgICAgICAgICAgdGhpcy4jaGFzTWFnaWMgfHxcbiAgICAgICAgICAgICh0aGlzLiNvcHRpb25zLm5vY2FzZSAmJlxuICAgICAgICAgICAgICAgICF0aGlzLiNvcHRpb25zLm5vY2FzZU1hZ2ljT25seSAmJlxuICAgICAgICAgICAgICAgIGdsb2IudG9VcHBlckNhc2UoKSAhPT0gZ2xvYi50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgaWYgKCFhbnlNYWdpYykge1xuICAgICAgICAgICAgcmV0dXJuIGJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmxhZ3MgPSAodGhpcy4jb3B0aW9ucy5ub2Nhc2UgPyAnaScgOiAnJykgKyAodWZsYWcgPyAndScgOiAnJyk7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBSZWdFeHAoYF4ke3JlfSRgLCBmbGFncyksIHtcbiAgICAgICAgICAgIF9zcmM6IHJlLFxuICAgICAgICAgICAgX2dsb2I6IGdsb2IsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgb3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI29wdGlvbnM7XG4gICAgfVxuICAgIC8vIHJldHVybnMgdGhlIHN0cmluZyBtYXRjaCwgdGhlIHJlZ2V4cCBzb3VyY2UsIHdoZXRoZXIgdGhlcmUncyBtYWdpY1xuICAgIC8vIGluIHRoZSByZWdleHAgKHNvIGEgcmVndWxhciBleHByZXNzaW9uIGlzIHJlcXVpcmVkKSBhbmQgd2hldGhlciBvclxuICAgIC8vIG5vdCB0aGUgdWZsYWcgaXMgbmVlZGVkIGZvciB0aGUgcmVndWxhciBleHByZXNzaW9uIChmb3IgcG9zaXggY2xhc3NlcylcbiAgICAvLyBUT0RPOiBpbnN0ZWFkIG9mIGluamVjdGluZyB0aGUgc3RhcnQvZW5kIGF0IHRoaXMgcG9pbnQsIGp1c3QgcmV0dXJuXG4gICAgLy8gdGhlIEJPRFkgb2YgdGhlIHJlZ2V4cCwgYWxvbmcgd2l0aCB0aGUgc3RhcnQvZW5kIHBvcnRpb25zIHN1aXRhYmxlXG4gICAgLy8gZm9yIGJpbmRpbmcgdGhlIHN0YXJ0L2VuZCBpbiBlaXRoZXIgYSBqb2luZWQgZnVsbC1wYXRoIG1ha2VSZSBjb250ZXh0XG4gICAgLy8gKHdoZXJlIHdlIGJpbmQgdG8gKF58LyksIG9yIGEgc3RhbmRhbG9uZSBtYXRjaFBhcnQgY29udGV4dCAod2hlcmVcbiAgICAvLyB3ZSBiaW5kIHRvIF4sIGFuZCBub3QgLykuICBPdGhlcndpc2Ugc2xhc2hlcyBnZXQgZHVwZWQhXG4gICAgLy9cbiAgICAvLyBJbiBwYXJ0LW1hdGNoaW5nIG1vZGUsIHRoZSBzdGFydCBpczpcbiAgICAvLyAtIGlmIG5vdCBpc1N0YXJ0OiBub3RoaW5nXG4gICAgLy8gLSBpZiB0cmF2ZXJzYWwgcG9zc2libGUsIGJ1dCBub3QgYWxsb3dlZDogXig/IVxcLlxcLj8kKVxuICAgIC8vIC0gaWYgZG90cyBhbGxvd2VkIG9yIG5vdCBwb3NzaWJsZTogXlxuICAgIC8vIC0gaWYgZG90cyBwb3NzaWJsZSBhbmQgbm90IGFsbG93ZWQ6IF4oPyFcXC4pXG4gICAgLy8gZW5kIGlzOlxuICAgIC8vIC0gaWYgbm90IGlzRW5kKCk6IG5vdGhpbmdcbiAgICAvLyAtIGVsc2U6ICRcbiAgICAvL1xuICAgIC8vIEluIGZ1bGwtcGF0aCBtYXRjaGluZyBtb2RlLCB3ZSBwdXQgdGhlIHNsYXNoIGF0IHRoZSBTVEFSVCBvZiB0aGVcbiAgICAvLyBwYXR0ZXJuLCBzbyBzdGFydCBpczpcbiAgICAvLyAtIGlmIGZpcnN0IHBhdHRlcm46IHNhbWUgYXMgcGFydC1tYXRjaGluZyBtb2RlXG4gICAgLy8gLSBpZiBub3QgaXNTdGFydCgpOiBub3RoaW5nXG4gICAgLy8gLSBpZiB0cmF2ZXJzYWwgcG9zc2libGUsIGJ1dCBub3QgYWxsb3dlZDogLyg/IVxcLlxcLj8oPzokfC8pKVxuICAgIC8vIC0gaWYgZG90cyBhbGxvd2VkIG9yIG5vdCBwb3NzaWJsZTogL1xuICAgIC8vIC0gaWYgZG90cyBwb3NzaWJsZSBhbmQgbm90IGFsbG93ZWQ6IC8oPyFcXC4pXG4gICAgLy8gZW5kIGlzOlxuICAgIC8vIC0gaWYgbGFzdCBwYXR0ZXJuLCBzYW1lIGFzIHBhcnQtbWF0Y2hpbmcgbW9kZVxuICAgIC8vIC0gZWxzZSBub3RoaW5nXG4gICAgLy9cbiAgICAvLyBBbHdheXMgcHV0IHRoZSAoPzokfC8pIG9uIG5lZ2F0ZWQgdGFpbHMsIHRob3VnaCwgYmVjYXVzZSB0aGF0IGhhcyB0byBiZVxuICAgIC8vIHRoZXJlIHRvIGJpbmQgdGhlIGVuZCBvZiB0aGUgbmVnYXRlZCBwYXR0ZXJuIHBvcnRpb24sIGFuZCBpdCdzIGVhc2llciB0b1xuICAgIC8vIGp1c3Qgc3RpY2sgaXQgaW4gbm93IHJhdGhlciB0aGFuIHRyeSB0byBpbmplY3QgaXQgbGF0ZXIgaW4gdGhlIG1pZGRsZSBvZlxuICAgIC8vIHRoZSBwYXR0ZXJuLlxuICAgIC8vXG4gICAgLy8gV2UgY2FuIGp1c3QgYWx3YXlzIHJldHVybiB0aGUgc2FtZSBlbmQsIGFuZCBsZWF2ZSBpdCB1cCB0byB0aGUgY2FsbGVyXG4gICAgLy8gdG8ga25vdyB3aGV0aGVyIGl0J3MgZ29pbmcgdG8gYmUgdXNlZCBqb2luZWQgb3IgaW4gcGFydHMuXG4gICAgLy8gQW5kLCBpZiB0aGUgc3RhcnQgaXMgYWRqdXN0ZWQgc2xpZ2h0bHksIGNhbiBkbyB0aGUgc2FtZSB0aGVyZTpcbiAgICAvLyAtIGlmIG5vdCBpc1N0YXJ0OiBub3RoaW5nXG4gICAgLy8gLSBpZiB0cmF2ZXJzYWwgcG9zc2libGUsIGJ1dCBub3QgYWxsb3dlZDogKD86L3xeKSg/IVxcLlxcLj8kKVxuICAgIC8vIC0gaWYgZG90cyBhbGxvd2VkIG9yIG5vdCBwb3NzaWJsZTogKD86L3xeKVxuICAgIC8vIC0gaWYgZG90cyBwb3NzaWJsZSBhbmQgbm90IGFsbG93ZWQ6ICg/Oi98XikoPyFcXC4pXG4gICAgLy9cbiAgICAvLyBCdXQgaXQncyBiZXR0ZXIgdG8gaGF2ZSBhIHNpbXBsZXIgYmluZGluZyB3aXRob3V0IGEgY29uZGl0aW9uYWwsIGZvclxuICAgIC8vIHBlcmZvcm1hbmNlLCBzbyBwcm9iYWJseSBiZXR0ZXIgdG8gcmV0dXJuIGJvdGggc3RhcnQgb3B0aW9ucy5cbiAgICAvL1xuICAgIC8vIFRoZW4gdGhlIGNhbGxlciBqdXN0IGlnbm9yZXMgdGhlIGVuZCBpZiBpdCdzIG5vdCB0aGUgZmlyc3QgcGF0dGVybixcbiAgICAvLyBhbmQgdGhlIHN0YXJ0IGFsd2F5cyBnZXRzIGFwcGxpZWQuXG4gICAgLy9cbiAgICAvLyBCdXQgdGhhdCdzIGFsd2F5cyBnb2luZyB0byBiZSAkIGlmIGl0J3MgdGhlIGVuZGluZyBwYXR0ZXJuLCBvciBub3RoaW5nLFxuICAgIC8vIHNvIHRoZSBjYWxsZXIgY2FuIGp1c3QgYXR0YWNoICQgYXQgdGhlIGVuZCBvZiB0aGUgcGF0dGVybiB3aGVuIGJ1aWxkaW5nLlxuICAgIC8vXG4gICAgLy8gU28gdGhlIHRvZG8gaXM6XG4gICAgLy8gLSBiZXR0ZXIgZGV0ZWN0IHdoYXQga2luZCBvZiBzdGFydCBpcyBuZWVkZWRcbiAgICAvLyAtIHJldHVybiBib3RoIGZsYXZvcnMgb2Ygc3RhcnRpbmcgcGF0dGVyblxuICAgIC8vIC0gYXR0YWNoICQgYXQgdGhlIGVuZCBvZiB0aGUgcGF0dGVybiB3aGVuIGNyZWF0aW5nIHRoZSBhY3R1YWwgUmVnRXhwXG4gICAgLy9cbiAgICAvLyBBaCwgYnV0IHdhaXQsIG5vLCB0aGF0IGFsbCBvbmx5IGFwcGxpZXMgdG8gdGhlIHJvb3Qgd2hlbiB0aGUgZmlyc3QgcGF0dGVyblxuICAgIC8vIGlzIG5vdCBhbiBleHRnbG9iLiBJZiB0aGUgZmlyc3QgcGF0dGVybiBJUyBhbiBleHRnbG9iLCB0aGVuIHdlIG5lZWQgYWxsXG4gICAgLy8gdGhhdCBkb3QgcHJldmVudGlvbiBiaXogdG8gbGl2ZSBpbiB0aGUgZXh0Z2xvYiBwb3J0aW9ucywgYmVjYXVzZSBlZ1xuICAgIC8vICsoKnwueCopIGNhbiBtYXRjaCAueHkgYnV0IG5vdCAueXguXG4gICAgLy9cbiAgICAvLyBTbywgcmV0dXJuIHRoZSB0d28gZmxhdm9ycyBpZiBpdCdzICNyb290IGFuZCB0aGUgZmlyc3QgY2hpbGQgaXMgbm90IGFuXG4gICAgLy8gQVNULCBvdGhlcndpc2UgbGVhdmUgaXQgdG8gdGhlIGNoaWxkIEFTVCB0byBoYW5kbGUgaXQsIGFuZCB0aGVyZSxcbiAgICAvLyB1c2UgdGhlICg/Ol58Lykgc3R5bGUgb2Ygc3RhcnQgYmluZGluZy5cbiAgICAvL1xuICAgIC8vIEV2ZW4gc2ltcGxpZmllZCBmdXJ0aGVyOlxuICAgIC8vIC0gU2luY2UgdGhlIHN0YXJ0IGZvciBhIGpvaW4gaXMgZWcgLyg/IVxcLikgYW5kIHRoZSBzdGFydCBmb3IgYSBwYXJ0XG4gICAgLy8gaXMgXig/IVxcLiksIHdlIGNhbiBqdXN0IHByZXBlbmQgKD8hXFwuKSB0byB0aGUgcGF0dGVybiAoZWl0aGVyIHJvb3RcbiAgICAvLyBvciBzdGFydCBvciB3aGF0ZXZlcikgYW5kIHByZXBlbmQgXiBvciAvIGF0IHRoZSBSZWdleHAgY29uc3RydWN0aW9uLlxuICAgIHRvUmVnRXhwU291cmNlKGFsbG93RG90KSB7XG4gICAgICAgIGNvbnN0IGRvdCA9IGFsbG93RG90ID8/ICEhdGhpcy4jb3B0aW9ucy5kb3Q7XG4gICAgICAgIGlmICh0aGlzLiNyb290ID09PSB0aGlzKVxuICAgICAgICAgICAgdGhpcy4jZmlsbE5lZ3MoKTtcbiAgICAgICAgaWYgKCF0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vRW1wdHkgPSB0aGlzLmlzU3RhcnQoKSAmJiB0aGlzLmlzRW5kKCk7XG4gICAgICAgICAgICBjb25zdCBzcmMgPSB0aGlzLiNwYXJ0c1xuICAgICAgICAgICAgICAgIC5tYXAocCA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgW3JlLCBfLCBoYXNNYWdpYywgdWZsYWddID0gdHlwZW9mIHAgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgICAgID8gQVNULiNwYXJzZUdsb2IocCwgdGhpcy4jaGFzTWFnaWMsIG5vRW1wdHkpXG4gICAgICAgICAgICAgICAgICAgIDogcC50b1JlZ0V4cFNvdXJjZShhbGxvd0RvdCk7XG4gICAgICAgICAgICAgICAgdGhpcy4jaGFzTWFnaWMgPSB0aGlzLiNoYXNNYWdpYyB8fCBoYXNNYWdpYztcbiAgICAgICAgICAgICAgICB0aGlzLiN1ZmxhZyA9IHRoaXMuI3VmbGFnIHx8IHVmbGFnO1xuICAgICAgICAgICAgICAgIHJldHVybiByZTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmpvaW4oJycpO1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gJyc7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1N0YXJ0KCkpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuI3BhcnRzWzBdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIHRoZSBzdHJpbmcgdGhhdCB3aWxsIG1hdGNoIHRoZSBzdGFydCBvZiB0aGUgcGF0dGVybixcbiAgICAgICAgICAgICAgICAgICAgLy8gc28gd2UgbmVlZCB0byBwcm90ZWN0IGFnYWluc3QgZG90cyBhbmQgc3VjaC5cbiAgICAgICAgICAgICAgICAgICAgLy8gJy4nIGFuZCAnLi4nIGNhbm5vdCBtYXRjaCB1bmxlc3MgdGhlIHBhdHRlcm4gaXMgdGhhdCBleGFjdGx5LFxuICAgICAgICAgICAgICAgICAgICAvLyBldmVuIGlmIGl0IHN0YXJ0cyB3aXRoIC4gb3IgZG90OnRydWUgaXMgc2V0LlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkb3RUcmF2QWxsb3dlZCA9IHRoaXMuI3BhcnRzLmxlbmd0aCA9PT0gMSAmJiBqdXN0RG90cy5oYXModGhpcy4jcGFydHNbMF0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWRvdFRyYXZBbGxvd2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhcHMgPSBhZGRQYXR0ZXJuU3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiB3ZSBoYXZlIGEgcG9zc2liaWxpdHkgb2YgbWF0Y2hpbmcgLiBvciAuLixcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCBwcmV2ZW50IHRoYXQuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZWVkTm9UcmF2ID0gXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkb3RzIGFyZSBhbGxvd2VkLCBhbmQgdGhlIHBhdHRlcm4gc3RhcnRzIHdpdGggWyBvciAuXG4gICAgICAgICAgICAgICAgICAgICAgICAoZG90ICYmIGFwcy5oYXMoc3JjLmNoYXJBdCgwKSkpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHBhdHRlcm4gc3RhcnRzIHdpdGggXFwuLCBhbmQgdGhlbiBbIG9yIC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoc3JjLnN0YXJ0c1dpdGgoJ1xcXFwuJykgJiYgYXBzLmhhcyhzcmMuY2hhckF0KDIpKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgcGF0dGVybiBzdGFydHMgd2l0aCBcXC5cXC4sIGFuZCB0aGVuIFsgb3IgLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzcmMuc3RhcnRzV2l0aCgnXFxcXC5cXFxcLicpICYmIGFwcy5oYXMoc3JjLmNoYXJBdCg0KSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm8gbmVlZCB0byBwcmV2ZW50IGRvdHMgaWYgaXQgY2FuJ3QgbWF0Y2ggYSBkb3QsIG9yIGlmIGFcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN1Yi1wYXR0ZXJuIHdpbGwgYmUgcHJldmVudGluZyBpdCBhbnl3YXkuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZWVkTm9Eb3QgPSAhZG90ICYmICFhbGxvd0RvdCAmJiBhcHMuaGFzKHNyYy5jaGFyQXQoMCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBuZWVkTm9UcmF2ID8gc3RhcnROb1RyYXZlcnNhbCA6IG5lZWROb0RvdCA/IHN0YXJ0Tm9Eb3QgOiAnJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFwcGVuZCB0aGUgXCJlbmQgb2YgcGF0aCBwb3J0aW9uXCIgcGF0dGVybiB0byBuZWdhdGlvbiB0YWlsc1xuICAgICAgICAgICAgbGV0IGVuZCA9ICcnO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNFbmQoKSAmJlxuICAgICAgICAgICAgICAgIHRoaXMuI3Jvb3QuI2ZpbGxlZE5lZ3MgJiZcbiAgICAgICAgICAgICAgICB0aGlzLiNwYXJlbnQ/LnR5cGUgPT09ICchJykge1xuICAgICAgICAgICAgICAgIGVuZCA9ICcoPzokfFxcXFwvKSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBmaW5hbCA9IHN0YXJ0ICsgc3JjICsgZW5kO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBmaW5hbCxcbiAgICAgICAgICAgICAgICB1bmVzY2FwZShzcmMpLFxuICAgICAgICAgICAgICAgICh0aGlzLiNoYXNNYWdpYyA9ICEhdGhpcy4jaGFzTWFnaWMpLFxuICAgICAgICAgICAgICAgIHRoaXMuI3VmbGFnLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBuZWVkIHRvIGNhbGN1bGF0ZSB0aGUgYm9keSAqdHdpY2UqIGlmIGl0J3MgYSByZXBlYXQgcGF0dGVyblxuICAgICAgICAvLyBhdCB0aGUgc3RhcnQsIG9uY2UgaW4gbm9kb3QgbW9kZSwgdGhlbiBhZ2FpbiBpbiBkb3QgbW9kZSwgc28gYVxuICAgICAgICAvLyBwYXR0ZXJuIGxpa2UgKig/KSBjYW4gbWF0Y2ggJ3gueSdcbiAgICAgICAgY29uc3QgcmVwZWF0ZWQgPSB0aGlzLnR5cGUgPT09ICcqJyB8fCB0aGlzLnR5cGUgPT09ICcrJztcbiAgICAgICAgLy8gc29tZSBraW5kIG9mIGV4dGdsb2JcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLnR5cGUgPT09ICchJyA/ICcoPzooPyEoPzonIDogJyg/Oic7XG4gICAgICAgIGxldCBib2R5ID0gdGhpcy4jcGFydHNUb1JlZ0V4cChkb3QpO1xuICAgICAgICBpZiAodGhpcy5pc1N0YXJ0KCkgJiYgdGhpcy5pc0VuZCgpICYmICFib2R5ICYmIHRoaXMudHlwZSAhPT0gJyEnKSB7XG4gICAgICAgICAgICAvLyBpbnZhbGlkIGV4dGdsb2IsIGhhcyB0byBhdCBsZWFzdCBiZSAqc29tZXRoaW5nKiBwcmVzZW50LCBpZiBpdCdzXG4gICAgICAgICAgICAvLyB0aGUgZW50aXJlIHBhdGggcG9ydGlvbi5cbiAgICAgICAgICAgIGNvbnN0IHMgPSB0aGlzLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB0aGlzLiNwYXJ0cyA9IFtzXTtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLiNoYXNNYWdpYyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHJldHVybiBbcywgdW5lc2NhcGUodGhpcy50b1N0cmluZygpKSwgZmFsc2UsIGZhbHNlXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBYWFggYWJzdHJhY3Qgb3V0IHRoaXMgbWFwIG1ldGhvZFxuICAgICAgICBsZXQgYm9keURvdEFsbG93ZWQgPSAhcmVwZWF0ZWQgfHwgYWxsb3dEb3QgfHwgZG90IHx8ICFzdGFydE5vRG90XG4gICAgICAgICAgICA/ICcnXG4gICAgICAgICAgICA6IHRoaXMuI3BhcnRzVG9SZWdFeHAodHJ1ZSk7XG4gICAgICAgIGlmIChib2R5RG90QWxsb3dlZCA9PT0gYm9keSkge1xuICAgICAgICAgICAgYm9keURvdEFsbG93ZWQgPSAnJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYm9keURvdEFsbG93ZWQpIHtcbiAgICAgICAgICAgIGJvZHkgPSBgKD86JHtib2R5fSkoPzoke2JvZHlEb3RBbGxvd2VkfSkqP2A7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYW4gZW1wdHkgISgpIGlzIGV4YWN0bHkgZXF1aXZhbGVudCB0byBhIHN0YXJOb0VtcHR5XG4gICAgICAgIGxldCBmaW5hbCA9ICcnO1xuICAgICAgICBpZiAodGhpcy50eXBlID09PSAnIScgJiYgdGhpcy4jZW1wdHlFeHQpIHtcbiAgICAgICAgICAgIGZpbmFsID0gKHRoaXMuaXNTdGFydCgpICYmICFkb3QgPyBzdGFydE5vRG90IDogJycpICsgc3Rhck5vRW1wdHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjbG9zZSA9IHRoaXMudHlwZSA9PT0gJyEnXG4gICAgICAgICAgICAgICAgPyAvLyAhKCkgbXVzdCBtYXRjaCBzb21ldGhpbmcsYnV0ICEoeCkgY2FuIG1hdGNoICcnXG4gICAgICAgICAgICAgICAgICAgICcpKScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMuaXNTdGFydCgpICYmICFkb3QgJiYgIWFsbG93RG90ID8gc3RhcnROb0RvdCA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFyICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcpJ1xuICAgICAgICAgICAgICAgIDogdGhpcy50eXBlID09PSAnQCdcbiAgICAgICAgICAgICAgICAgICAgPyAnKSdcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLnR5cGUgPT09ICc/J1xuICAgICAgICAgICAgICAgICAgICAgICAgPyAnKT8nXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMudHlwZSA9PT0gJysnICYmIGJvZHlEb3RBbGxvd2VkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAnKSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMudHlwZSA9PT0gJyonICYmIGJvZHlEb3RBbGxvd2VkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gYCk/YFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGApJHt0aGlzLnR5cGV9YDtcbiAgICAgICAgICAgIGZpbmFsID0gc3RhcnQgKyBib2R5ICsgY2xvc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGZpbmFsLFxuICAgICAgICAgICAgdW5lc2NhcGUoYm9keSksXG4gICAgICAgICAgICAodGhpcy4jaGFzTWFnaWMgPSAhIXRoaXMuI2hhc01hZ2ljKSxcbiAgICAgICAgICAgIHRoaXMuI3VmbGFnLFxuICAgICAgICBdO1xuICAgIH1cbiAgICAjcGFydHNUb1JlZ0V4cChkb3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3BhcnRzXG4gICAgICAgICAgICAubWFwKHAgPT4ge1xuICAgICAgICAgICAgLy8gZXh0Z2xvYiBBU1RzIHNob3VsZCBvbmx5IGNvbnRhaW4gcGFyZW50IEFTVHNcbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc3RyaW5nIHR5cGUgaW4gZXh0Z2xvYiBhc3Q/PycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgICAgIC8vIGNhbiBpZ25vcmUgaGFzTWFnaWMsIGJlY2F1c2UgZXh0Z2xvYnMgYXJlIGFscmVhZHkgYWx3YXlzIG1hZ2ljXG4gICAgICAgICAgICBjb25zdCBbcmUsIF8sIF9oYXNNYWdpYywgdWZsYWddID0gcC50b1JlZ0V4cFNvdXJjZShkb3QpO1xuICAgICAgICAgICAgdGhpcy4jdWZsYWcgPSB0aGlzLiN1ZmxhZyB8fCB1ZmxhZztcbiAgICAgICAgICAgIHJldHVybiByZTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5maWx0ZXIocCA9PiAhKHRoaXMuaXNTdGFydCgpICYmIHRoaXMuaXNFbmQoKSkgfHwgISFwKVxuICAgICAgICAgICAgLmpvaW4oJ3wnKTtcbiAgICB9XG4gICAgc3RhdGljICNwYXJzZUdsb2IoZ2xvYiwgaGFzTWFnaWMsIG5vRW1wdHkgPSBmYWxzZSkge1xuICAgICAgICBsZXQgZXNjYXBpbmcgPSBmYWxzZTtcbiAgICAgICAgbGV0IHJlID0gJyc7XG4gICAgICAgIGxldCB1ZmxhZyA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdsb2IubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGMgPSBnbG9iLmNoYXJBdChpKTtcbiAgICAgICAgICAgIGlmIChlc2NhcGluZykge1xuICAgICAgICAgICAgICAgIGVzY2FwaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmUgKz0gKHJlU3BlY2lhbHMuaGFzKGMpID8gJ1xcXFwnIDogJycpICsgYztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gZ2xvYi5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlICs9ICdcXFxcXFxcXCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlc2NhcGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGMgPT09ICdbJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtzcmMsIG5lZWRVZmxhZywgY29uc3VtZWQsIG1hZ2ljXSA9IHBhcnNlQ2xhc3MoZ2xvYiwgaSk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnN1bWVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlICs9IHNyYztcbiAgICAgICAgICAgICAgICAgICAgdWZsYWcgPSB1ZmxhZyB8fCBuZWVkVWZsYWc7XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gY29uc3VtZWQgLSAxO1xuICAgICAgICAgICAgICAgICAgICBoYXNNYWdpYyA9IGhhc01hZ2ljIHx8IG1hZ2ljO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYyA9PT0gJyonKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vRW1wdHkgJiYgZ2xvYiA9PT0gJyonKVxuICAgICAgICAgICAgICAgICAgICByZSArPSBzdGFyTm9FbXB0eTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHJlICs9IHN0YXI7XG4gICAgICAgICAgICAgICAgaGFzTWFnaWMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGMgPT09ICc/Jykge1xuICAgICAgICAgICAgICAgIHJlICs9IHFtYXJrO1xuICAgICAgICAgICAgICAgIGhhc01hZ2ljID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlICs9IHJlZ0V4cEVzY2FwZShjKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3JlLCB1bmVzY2FwZShnbG9iKSwgISFoYXNNYWdpYywgdWZsYWddO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzdC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/e2b/node_modules/minimatch/dist/esm/ast.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/e2b/node_modules/minimatch/dist/esm/brace-expressions.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/e2b/node_modules/minimatch/dist/esm/brace-expressions.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parseClass: () => (/* binding */ parseClass)\n/* harmony export */ });\n// translate the various posix character classes into unicode properties\n// this works across all unicode locales\n// { <posix class>: [<translation>, /u flag required, negated]\nconst posixClasses = {\n    '[:alnum:]': ['\\\\p{L}\\\\p{Nl}\\\\p{Nd}', true],\n    '[:alpha:]': ['\\\\p{L}\\\\p{Nl}', true],\n    '[:ascii:]': ['\\\\x' + '00-\\\\x' + '7f', false],\n    '[:blank:]': ['\\\\p{Zs}\\\\t', true],\n    '[:cntrl:]': ['\\\\p{Cc}', true],\n    '[:digit:]': ['\\\\p{Nd}', true],\n    '[:graph:]': ['\\\\p{Z}\\\\p{C}', true, true],\n    '[:lower:]': ['\\\\p{Ll}', true],\n    '[:print:]': ['\\\\p{C}', true],\n    '[:punct:]': ['\\\\p{P}', true],\n    '[:space:]': ['\\\\p{Z}\\\\t\\\\r\\\\n\\\\v\\\\f', true],\n    '[:upper:]': ['\\\\p{Lu}', true],\n    '[:word:]': ['\\\\p{L}\\\\p{Nl}\\\\p{Nd}\\\\p{Pc}', true],\n    '[:xdigit:]': ['A-Fa-f0-9', false],\n};\n// only need to escape a few things inside of brace expressions\n// escapes: [ \\ ] -\nconst braceEscape = (s) => s.replace(/[[\\]\\\\-]/g, '\\\\$&');\n// escape all regexp magic characters\nconst regexpEscape = (s) => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n// everything has already been escaped, we just have to join\nconst rangesToString = (ranges) => ranges.join('');\n// takes a glob string at a posix brace expression, and returns\n// an equivalent regular expression source, and boolean indicating\n// whether the /u flag needs to be applied, and the number of chars\n// consumed to parse the character class.\n// This also removes out of order ranges, and returns ($.) if the\n// entire class just no good.\nconst parseClass = (glob, position) => {\n    const pos = position;\n    /* c8 ignore start */\n    if (glob.charAt(pos) !== '[') {\n        throw new Error('not in a brace expression');\n    }\n    /* c8 ignore stop */\n    const ranges = [];\n    const negs = [];\n    let i = pos + 1;\n    let sawStart = false;\n    let uflag = false;\n    let escaping = false;\n    let negate = false;\n    let endPos = pos;\n    let rangeStart = '';\n    WHILE: while (i < glob.length) {\n        const c = glob.charAt(i);\n        if ((c === '!' || c === '^') && i === pos + 1) {\n            negate = true;\n            i++;\n            continue;\n        }\n        if (c === ']' && sawStart && !escaping) {\n            endPos = i + 1;\n            break;\n        }\n        sawStart = true;\n        if (c === '\\\\') {\n            if (!escaping) {\n                escaping = true;\n                i++;\n                continue;\n            }\n            // escaped \\ char, fall through and treat like normal char\n        }\n        if (c === '[' && !escaping) {\n            // either a posix class, a collation equivalent, or just a [\n            for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {\n                if (glob.startsWith(cls, i)) {\n                    // invalid, [a-[] is fine, but not [a-[:alpha]]\n                    if (rangeStart) {\n                        return ['$.', false, glob.length - pos, true];\n                    }\n                    i += cls.length;\n                    if (neg)\n                        negs.push(unip);\n                    else\n                        ranges.push(unip);\n                    uflag = uflag || u;\n                    continue WHILE;\n                }\n            }\n        }\n        // now it's just a normal character, effectively\n        escaping = false;\n        if (rangeStart) {\n            // throw this range away if it's not valid, but others\n            // can still match.\n            if (c > rangeStart) {\n                ranges.push(braceEscape(rangeStart) + '-' + braceEscape(c));\n            }\n            else if (c === rangeStart) {\n                ranges.push(braceEscape(c));\n            }\n            rangeStart = '';\n            i++;\n            continue;\n        }\n        // now might be the start of a range.\n        // can be either c-d or c-] or c<more...>] or c] at this point\n        if (glob.startsWith('-]', i + 1)) {\n            ranges.push(braceEscape(c + '-'));\n            i += 2;\n            continue;\n        }\n        if (glob.startsWith('-', i + 1)) {\n            rangeStart = c;\n            i += 2;\n            continue;\n        }\n        // not the start of a range, just a single character\n        ranges.push(braceEscape(c));\n        i++;\n    }\n    if (endPos < i) {\n        // didn't see the end of the class, not a valid class,\n        // but might still be valid as a literal match.\n        return ['', false, 0, false];\n    }\n    // if we got no ranges and no negates, then we have a range that\n    // cannot possibly match anything, and that poisons the whole glob\n    if (!ranges.length && !negs.length) {\n        return ['$.', false, glob.length - pos, true];\n    }\n    // if we got one positive range, and it's a single character, then that's\n    // not actually a magic pattern, it's just that one literal character.\n    // we should not treat that as \"magic\", we should just return the literal\n    // character. [_] is a perfectly valid way to escape glob magic chars.\n    if (negs.length === 0 &&\n        ranges.length === 1 &&\n        /^\\\\?.$/.test(ranges[0]) &&\n        !negate) {\n        const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];\n        return [regexpEscape(r), false, endPos - pos, false];\n    }\n    const sranges = '[' + (negate ? '^' : '') + rangesToString(ranges) + ']';\n    const snegs = '[' + (negate ? '' : '^') + rangesToString(negs) + ']';\n    const comb = ranges.length && negs.length\n        ? '(' + sranges + '|' + snegs + ')'\n        : ranges.length\n            ? sranges\n            : snegs;\n    return [comb, uflag, endPos - pos, true];\n};\n//# sourceMappingURL=brace-expressions.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZTJiL25vZGVfbW9kdWxlcy9taW5pbWF0Y2gvZGlzdC9lc20vYnJhY2UtZXhwcmVzc2lvbnMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx1QkFBdUIsRUFBRSxJQUFJLEdBQUcsSUFBSSxHQUFHO0FBQ3ZDLHVCQUF1QixFQUFFLElBQUksR0FBRztBQUNoQztBQUNBLHVCQUF1QixHQUFHO0FBQzFCLHVCQUF1QixHQUFHO0FBQzFCLHVCQUF1QixHQUFHO0FBQzFCLHVCQUF1QixFQUFFLElBQUksRUFBRTtBQUMvQix1QkFBdUIsR0FBRztBQUMxQix1QkFBdUIsRUFBRTtBQUN6Qix1QkFBdUIsRUFBRTtBQUN6Qix1QkFBdUIsRUFBRTtBQUN6Qix1QkFBdUIsR0FBRztBQUMxQixzQkFBc0IsRUFBRSxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUksR0FBRztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aXZlLXZpYmUtYWktbmV4dC8uL25vZGVfbW9kdWxlcy9lMmIvbm9kZV9tb2R1bGVzL21pbmltYXRjaC9kaXN0L2VzbS9icmFjZS1leHByZXNzaW9ucy5qcz9jYjRhIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHRyYW5zbGF0ZSB0aGUgdmFyaW91cyBwb3NpeCBjaGFyYWN0ZXIgY2xhc3NlcyBpbnRvIHVuaWNvZGUgcHJvcGVydGllc1xuLy8gdGhpcyB3b3JrcyBhY3Jvc3MgYWxsIHVuaWNvZGUgbG9jYWxlc1xuLy8geyA8cG9zaXggY2xhc3M+OiBbPHRyYW5zbGF0aW9uPiwgL3UgZmxhZyByZXF1aXJlZCwgbmVnYXRlZF1cbmNvbnN0IHBvc2l4Q2xhc3NlcyA9IHtcbiAgICAnWzphbG51bTpdJzogWydcXFxccHtMfVxcXFxwe05sfVxcXFxwe05kfScsIHRydWVdLFxuICAgICdbOmFscGhhOl0nOiBbJ1xcXFxwe0x9XFxcXHB7Tmx9JywgdHJ1ZV0sXG4gICAgJ1s6YXNjaWk6XSc6IFsnXFxcXHgnICsgJzAwLVxcXFx4JyArICc3ZicsIGZhbHNlXSxcbiAgICAnWzpibGFuazpdJzogWydcXFxccHtac31cXFxcdCcsIHRydWVdLFxuICAgICdbOmNudHJsOl0nOiBbJ1xcXFxwe0NjfScsIHRydWVdLFxuICAgICdbOmRpZ2l0Ol0nOiBbJ1xcXFxwe05kfScsIHRydWVdLFxuICAgICdbOmdyYXBoOl0nOiBbJ1xcXFxwe1p9XFxcXHB7Q30nLCB0cnVlLCB0cnVlXSxcbiAgICAnWzpsb3dlcjpdJzogWydcXFxccHtMbH0nLCB0cnVlXSxcbiAgICAnWzpwcmludDpdJzogWydcXFxccHtDfScsIHRydWVdLFxuICAgICdbOnB1bmN0Ol0nOiBbJ1xcXFxwe1B9JywgdHJ1ZV0sXG4gICAgJ1s6c3BhY2U6XSc6IFsnXFxcXHB7Wn1cXFxcdFxcXFxyXFxcXG5cXFxcdlxcXFxmJywgdHJ1ZV0sXG4gICAgJ1s6dXBwZXI6XSc6IFsnXFxcXHB7THV9JywgdHJ1ZV0sXG4gICAgJ1s6d29yZDpdJzogWydcXFxccHtMfVxcXFxwe05sfVxcXFxwe05kfVxcXFxwe1BjfScsIHRydWVdLFxuICAgICdbOnhkaWdpdDpdJzogWydBLUZhLWYwLTknLCBmYWxzZV0sXG59O1xuLy8gb25seSBuZWVkIHRvIGVzY2FwZSBhIGZldyB0aGluZ3MgaW5zaWRlIG9mIGJyYWNlIGV4cHJlc3Npb25zXG4vLyBlc2NhcGVzOiBbIFxcIF0gLVxuY29uc3QgYnJhY2VFc2NhcGUgPSAocykgPT4gcy5yZXBsYWNlKC9bW1xcXVxcXFwtXS9nLCAnXFxcXCQmJyk7XG4vLyBlc2NhcGUgYWxsIHJlZ2V4cCBtYWdpYyBjaGFyYWN0ZXJzXG5jb25zdCByZWdleHBFc2NhcGUgPSAocykgPT4gcy5yZXBsYWNlKC9bLVtcXF17fSgpKis/LixcXFxcXiR8I1xcc10vZywgJ1xcXFwkJicpO1xuLy8gZXZlcnl0aGluZyBoYXMgYWxyZWFkeSBiZWVuIGVzY2FwZWQsIHdlIGp1c3QgaGF2ZSB0byBqb2luXG5jb25zdCByYW5nZXNUb1N0cmluZyA9IChyYW5nZXMpID0+IHJhbmdlcy5qb2luKCcnKTtcbi8vIHRha2VzIGEgZ2xvYiBzdHJpbmcgYXQgYSBwb3NpeCBicmFjZSBleHByZXNzaW9uLCBhbmQgcmV0dXJuc1xuLy8gYW4gZXF1aXZhbGVudCByZWd1bGFyIGV4cHJlc3Npb24gc291cmNlLCBhbmQgYm9vbGVhbiBpbmRpY2F0aW5nXG4vLyB3aGV0aGVyIHRoZSAvdSBmbGFnIG5lZWRzIHRvIGJlIGFwcGxpZWQsIGFuZCB0aGUgbnVtYmVyIG9mIGNoYXJzXG4vLyBjb25zdW1lZCB0byBwYXJzZSB0aGUgY2hhcmFjdGVyIGNsYXNzLlxuLy8gVGhpcyBhbHNvIHJlbW92ZXMgb3V0IG9mIG9yZGVyIHJhbmdlcywgYW5kIHJldHVybnMgKCQuKSBpZiB0aGVcbi8vIGVudGlyZSBjbGFzcyBqdXN0IG5vIGdvb2QuXG5leHBvcnQgY29uc3QgcGFyc2VDbGFzcyA9IChnbG9iLCBwb3NpdGlvbikgPT4ge1xuICAgIGNvbnN0IHBvcyA9IHBvc2l0aW9uO1xuICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgIGlmIChnbG9iLmNoYXJBdChwb3MpICE9PSAnWycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW4gYSBicmFjZSBleHByZXNzaW9uJyk7XG4gICAgfVxuICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgY29uc3QgcmFuZ2VzID0gW107XG4gICAgY29uc3QgbmVncyA9IFtdO1xuICAgIGxldCBpID0gcG9zICsgMTtcbiAgICBsZXQgc2F3U3RhcnQgPSBmYWxzZTtcbiAgICBsZXQgdWZsYWcgPSBmYWxzZTtcbiAgICBsZXQgZXNjYXBpbmcgPSBmYWxzZTtcbiAgICBsZXQgbmVnYXRlID0gZmFsc2U7XG4gICAgbGV0IGVuZFBvcyA9IHBvcztcbiAgICBsZXQgcmFuZ2VTdGFydCA9ICcnO1xuICAgIFdISUxFOiB3aGlsZSAoaSA8IGdsb2IubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGMgPSBnbG9iLmNoYXJBdChpKTtcbiAgICAgICAgaWYgKChjID09PSAnIScgfHwgYyA9PT0gJ14nKSAmJiBpID09PSBwb3MgKyAxKSB7XG4gICAgICAgICAgICBuZWdhdGUgPSB0cnVlO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMgPT09ICddJyAmJiBzYXdTdGFydCAmJiAhZXNjYXBpbmcpIHtcbiAgICAgICAgICAgIGVuZFBvcyA9IGkgKyAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc2F3U3RhcnQgPSB0cnVlO1xuICAgICAgICBpZiAoYyA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICBpZiAoIWVzY2FwaW5nKSB7XG4gICAgICAgICAgICAgICAgZXNjYXBpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVzY2FwZWQgXFwgY2hhciwgZmFsbCB0aHJvdWdoIGFuZCB0cmVhdCBsaWtlIG5vcm1hbCBjaGFyXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMgPT09ICdbJyAmJiAhZXNjYXBpbmcpIHtcbiAgICAgICAgICAgIC8vIGVpdGhlciBhIHBvc2l4IGNsYXNzLCBhIGNvbGxhdGlvbiBlcXVpdmFsZW50LCBvciBqdXN0IGEgW1xuICAgICAgICAgICAgZm9yIChjb25zdCBbY2xzLCBbdW5pcCwgdSwgbmVnXV0gb2YgT2JqZWN0LmVudHJpZXMocG9zaXhDbGFzc2VzKSkge1xuICAgICAgICAgICAgICAgIGlmIChnbG9iLnN0YXJ0c1dpdGgoY2xzLCBpKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpbnZhbGlkLCBbYS1bXSBpcyBmaW5lLCBidXQgbm90IFthLVs6YWxwaGFdXVxuICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2VTdGFydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsnJC4nLCBmYWxzZSwgZ2xvYi5sZW5ndGggLSBwb3MsIHRydWVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gY2xzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5lZylcbiAgICAgICAgICAgICAgICAgICAgICAgIG5lZ3MucHVzaCh1bmlwKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2godW5pcCk7XG4gICAgICAgICAgICAgICAgICAgIHVmbGFnID0gdWZsYWcgfHwgdTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWUgV0hJTEU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIG5vdyBpdCdzIGp1c3QgYSBub3JtYWwgY2hhcmFjdGVyLCBlZmZlY3RpdmVseVxuICAgICAgICBlc2NhcGluZyA9IGZhbHNlO1xuICAgICAgICBpZiAocmFuZ2VTdGFydCkge1xuICAgICAgICAgICAgLy8gdGhyb3cgdGhpcyByYW5nZSBhd2F5IGlmIGl0J3Mgbm90IHZhbGlkLCBidXQgb3RoZXJzXG4gICAgICAgICAgICAvLyBjYW4gc3RpbGwgbWF0Y2guXG4gICAgICAgICAgICBpZiAoYyA+IHJhbmdlU3RhcnQpIHtcbiAgICAgICAgICAgICAgICByYW5nZXMucHVzaChicmFjZUVzY2FwZShyYW5nZVN0YXJ0KSArICctJyArIGJyYWNlRXNjYXBlKGMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09IHJhbmdlU3RhcnQpIHtcbiAgICAgICAgICAgICAgICByYW5nZXMucHVzaChicmFjZUVzY2FwZShjKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByYW5nZVN0YXJ0ID0gJyc7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBub3cgbWlnaHQgYmUgdGhlIHN0YXJ0IG9mIGEgcmFuZ2UuXG4gICAgICAgIC8vIGNhbiBiZSBlaXRoZXIgYy1kIG9yIGMtXSBvciBjPG1vcmUuLi4+XSBvciBjXSBhdCB0aGlzIHBvaW50XG4gICAgICAgIGlmIChnbG9iLnN0YXJ0c1dpdGgoJy1dJywgaSArIDEpKSB7XG4gICAgICAgICAgICByYW5nZXMucHVzaChicmFjZUVzY2FwZShjICsgJy0nKSk7XG4gICAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ2xvYi5zdGFydHNXaXRoKCctJywgaSArIDEpKSB7XG4gICAgICAgICAgICByYW5nZVN0YXJ0ID0gYztcbiAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5vdCB0aGUgc3RhcnQgb2YgYSByYW5nZSwganVzdCBhIHNpbmdsZSBjaGFyYWN0ZXJcbiAgICAgICAgcmFuZ2VzLnB1c2goYnJhY2VFc2NhcGUoYykpO1xuICAgICAgICBpKys7XG4gICAgfVxuICAgIGlmIChlbmRQb3MgPCBpKSB7XG4gICAgICAgIC8vIGRpZG4ndCBzZWUgdGhlIGVuZCBvZiB0aGUgY2xhc3MsIG5vdCBhIHZhbGlkIGNsYXNzLFxuICAgICAgICAvLyBidXQgbWlnaHQgc3RpbGwgYmUgdmFsaWQgYXMgYSBsaXRlcmFsIG1hdGNoLlxuICAgICAgICByZXR1cm4gWycnLCBmYWxzZSwgMCwgZmFsc2VdO1xuICAgIH1cbiAgICAvLyBpZiB3ZSBnb3Qgbm8gcmFuZ2VzIGFuZCBubyBuZWdhdGVzLCB0aGVuIHdlIGhhdmUgYSByYW5nZSB0aGF0XG4gICAgLy8gY2Fubm90IHBvc3NpYmx5IG1hdGNoIGFueXRoaW5nLCBhbmQgdGhhdCBwb2lzb25zIHRoZSB3aG9sZSBnbG9iXG4gICAgaWYgKCFyYW5nZXMubGVuZ3RoICYmICFuZWdzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gWyckLicsIGZhbHNlLCBnbG9iLmxlbmd0aCAtIHBvcywgdHJ1ZV07XG4gICAgfVxuICAgIC8vIGlmIHdlIGdvdCBvbmUgcG9zaXRpdmUgcmFuZ2UsIGFuZCBpdCdzIGEgc2luZ2xlIGNoYXJhY3RlciwgdGhlbiB0aGF0J3NcbiAgICAvLyBub3QgYWN0dWFsbHkgYSBtYWdpYyBwYXR0ZXJuLCBpdCdzIGp1c3QgdGhhdCBvbmUgbGl0ZXJhbCBjaGFyYWN0ZXIuXG4gICAgLy8gd2Ugc2hvdWxkIG5vdCB0cmVhdCB0aGF0IGFzIFwibWFnaWNcIiwgd2Ugc2hvdWxkIGp1c3QgcmV0dXJuIHRoZSBsaXRlcmFsXG4gICAgLy8gY2hhcmFjdGVyLiBbX10gaXMgYSBwZXJmZWN0bHkgdmFsaWQgd2F5IHRvIGVzY2FwZSBnbG9iIG1hZ2ljIGNoYXJzLlxuICAgIGlmIChuZWdzLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICByYW5nZXMubGVuZ3RoID09PSAxICYmXG4gICAgICAgIC9eXFxcXD8uJC8udGVzdChyYW5nZXNbMF0pICYmXG4gICAgICAgICFuZWdhdGUpIHtcbiAgICAgICAgY29uc3QgciA9IHJhbmdlc1swXS5sZW5ndGggPT09IDIgPyByYW5nZXNbMF0uc2xpY2UoLTEpIDogcmFuZ2VzWzBdO1xuICAgICAgICByZXR1cm4gW3JlZ2V4cEVzY2FwZShyKSwgZmFsc2UsIGVuZFBvcyAtIHBvcywgZmFsc2VdO1xuICAgIH1cbiAgICBjb25zdCBzcmFuZ2VzID0gJ1snICsgKG5lZ2F0ZSA/ICdeJyA6ICcnKSArIHJhbmdlc1RvU3RyaW5nKHJhbmdlcykgKyAnXSc7XG4gICAgY29uc3Qgc25lZ3MgPSAnWycgKyAobmVnYXRlID8gJycgOiAnXicpICsgcmFuZ2VzVG9TdHJpbmcobmVncykgKyAnXSc7XG4gICAgY29uc3QgY29tYiA9IHJhbmdlcy5sZW5ndGggJiYgbmVncy5sZW5ndGhcbiAgICAgICAgPyAnKCcgKyBzcmFuZ2VzICsgJ3wnICsgc25lZ3MgKyAnKSdcbiAgICAgICAgOiByYW5nZXMubGVuZ3RoXG4gICAgICAgICAgICA/IHNyYW5nZXNcbiAgICAgICAgICAgIDogc25lZ3M7XG4gICAgcmV0dXJuIFtjb21iLCB1ZmxhZywgZW5kUG9zIC0gcG9zLCB0cnVlXTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1icmFjZS1leHByZXNzaW9ucy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/e2b/node_modules/minimatch/dist/esm/brace-expressions.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/e2b/node_modules/minimatch/dist/esm/escape.js":
/*!********************************************************************!*\
  !*** ./node_modules/e2b/node_modules/minimatch/dist/esm/escape.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   escape: () => (/* binding */ escape)\n/* harmony export */ });\n/**\n * Escape all magic characters in a glob pattern.\n *\n * If the {@link windowsPathsNoEscape | GlobOptions.windowsPathsNoEscape}\n * option is used, then characters are escaped by wrapping in `[]`, because\n * a magic character wrapped in a character class can only be satisfied by\n * that exact character.  In this mode, `\\` is _not_ escaped, because it is\n * not interpreted as a magic character, but instead as a path separator.\n */\nconst escape = (s, { windowsPathsNoEscape = false, } = {}) => {\n    // don't need to escape +@! because we escape the parens\n    // that make those magic, and escaping ! as [!] isn't valid,\n    // because [!]] is a valid glob class meaning not ']'.\n    return windowsPathsNoEscape\n        ? s.replace(/[?*()[\\]]/g, '[$&]')\n        : s.replace(/[?*()[\\]\\\\]/g, '\\\\$&');\n};\n//# sourceMappingURL=escape.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZTJiL25vZGVfbW9kdWxlcy9taW5pbWF0Y2gvZGlzdC9lc20vZXNjYXBlLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHFCQUFxQixnQ0FBZ0MsSUFBSTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdml2ZS12aWJlLWFpLW5leHQvLi9ub2RlX21vZHVsZXMvZTJiL25vZGVfbW9kdWxlcy9taW5pbWF0Y2gvZGlzdC9lc20vZXNjYXBlLmpzPzhiMDEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBFc2NhcGUgYWxsIG1hZ2ljIGNoYXJhY3RlcnMgaW4gYSBnbG9iIHBhdHRlcm4uXG4gKlxuICogSWYgdGhlIHtAbGluayB3aW5kb3dzUGF0aHNOb0VzY2FwZSB8IEdsb2JPcHRpb25zLndpbmRvd3NQYXRoc05vRXNjYXBlfVxuICogb3B0aW9uIGlzIHVzZWQsIHRoZW4gY2hhcmFjdGVycyBhcmUgZXNjYXBlZCBieSB3cmFwcGluZyBpbiBgW11gLCBiZWNhdXNlXG4gKiBhIG1hZ2ljIGNoYXJhY3RlciB3cmFwcGVkIGluIGEgY2hhcmFjdGVyIGNsYXNzIGNhbiBvbmx5IGJlIHNhdGlzZmllZCBieVxuICogdGhhdCBleGFjdCBjaGFyYWN0ZXIuICBJbiB0aGlzIG1vZGUsIGBcXGAgaXMgX25vdF8gZXNjYXBlZCwgYmVjYXVzZSBpdCBpc1xuICogbm90IGludGVycHJldGVkIGFzIGEgbWFnaWMgY2hhcmFjdGVyLCBidXQgaW5zdGVhZCBhcyBhIHBhdGggc2VwYXJhdG9yLlxuICovXG5leHBvcnQgY29uc3QgZXNjYXBlID0gKHMsIHsgd2luZG93c1BhdGhzTm9Fc2NhcGUgPSBmYWxzZSwgfSA9IHt9KSA9PiB7XG4gICAgLy8gZG9uJ3QgbmVlZCB0byBlc2NhcGUgK0AhIGJlY2F1c2Ugd2UgZXNjYXBlIHRoZSBwYXJlbnNcbiAgICAvLyB0aGF0IG1ha2UgdGhvc2UgbWFnaWMsIGFuZCBlc2NhcGluZyAhIGFzIFshXSBpc24ndCB2YWxpZCxcbiAgICAvLyBiZWNhdXNlIFshXV0gaXMgYSB2YWxpZCBnbG9iIGNsYXNzIG1lYW5pbmcgbm90ICddJy5cbiAgICByZXR1cm4gd2luZG93c1BhdGhzTm9Fc2NhcGVcbiAgICAgICAgPyBzLnJlcGxhY2UoL1s/KigpW1xcXV0vZywgJ1skJl0nKVxuICAgICAgICA6IHMucmVwbGFjZSgvWz8qKClbXFxdXFxcXF0vZywgJ1xcXFwkJicpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVzY2FwZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/e2b/node_modules/minimatch/dist/esm/escape.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/e2b/node_modules/minimatch/dist/esm/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/e2b/node_modules/minimatch/dist/esm/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AST: () => (/* reexport safe */ _ast_js__WEBPACK_IMPORTED_MODULE_2__.AST),\n/* harmony export */   GLOBSTAR: () => (/* binding */ GLOBSTAR),\n/* harmony export */   Minimatch: () => (/* binding */ Minimatch),\n/* harmony export */   braceExpand: () => (/* binding */ braceExpand),\n/* harmony export */   defaults: () => (/* binding */ defaults),\n/* harmony export */   escape: () => (/* reexport safe */ _escape_js__WEBPACK_IMPORTED_MODULE_3__.escape),\n/* harmony export */   filter: () => (/* binding */ filter),\n/* harmony export */   makeRe: () => (/* binding */ makeRe),\n/* harmony export */   match: () => (/* binding */ match),\n/* harmony export */   minimatch: () => (/* binding */ minimatch),\n/* harmony export */   sep: () => (/* binding */ sep),\n/* harmony export */   unescape: () => (/* reexport safe */ _unescape_js__WEBPACK_IMPORTED_MODULE_4__.unescape)\n/* harmony export */ });\n/* harmony import */ var _isaacs_brace_expansion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @isaacs/brace-expansion */ \"(rsc)/./node_modules/@isaacs/brace-expansion/dist/esm/index.js\");\n/* harmony import */ var _assert_valid_pattern_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./assert-valid-pattern.js */ \"(rsc)/./node_modules/e2b/node_modules/minimatch/dist/esm/assert-valid-pattern.js\");\n/* harmony import */ var _ast_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ast.js */ \"(rsc)/./node_modules/e2b/node_modules/minimatch/dist/esm/ast.js\");\n/* harmony import */ var _escape_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./escape.js */ \"(rsc)/./node_modules/e2b/node_modules/minimatch/dist/esm/escape.js\");\n/* harmony import */ var _unescape_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./unescape.js */ \"(rsc)/./node_modules/e2b/node_modules/minimatch/dist/esm/unescape.js\");\n\n\n\n\n\nconst minimatch = (p, pattern, options = {}) => {\n    (0,_assert_valid_pattern_js__WEBPACK_IMPORTED_MODULE_1__.assertValidPattern)(pattern);\n    // shortcut: comments match nothing.\n    if (!options.nocomment && pattern.charAt(0) === '#') {\n        return false;\n    }\n    return new Minimatch(pattern, options).match(p);\n};\n// Optimized checking for the most common glob patterns.\nconst starDotExtRE = /^\\*+([^+@!?\\*\\[\\(]*)$/;\nconst starDotExtTest = (ext) => (f) => !f.startsWith('.') && f.endsWith(ext);\nconst starDotExtTestDot = (ext) => (f) => f.endsWith(ext);\nconst starDotExtTestNocase = (ext) => {\n    ext = ext.toLowerCase();\n    return (f) => !f.startsWith('.') && f.toLowerCase().endsWith(ext);\n};\nconst starDotExtTestNocaseDot = (ext) => {\n    ext = ext.toLowerCase();\n    return (f) => f.toLowerCase().endsWith(ext);\n};\nconst starDotStarRE = /^\\*+\\.\\*+$/;\nconst starDotStarTest = (f) => !f.startsWith('.') && f.includes('.');\nconst starDotStarTestDot = (f) => f !== '.' && f !== '..' && f.includes('.');\nconst dotStarRE = /^\\.\\*+$/;\nconst dotStarTest = (f) => f !== '.' && f !== '..' && f.startsWith('.');\nconst starRE = /^\\*+$/;\nconst starTest = (f) => f.length !== 0 && !f.startsWith('.');\nconst starTestDot = (f) => f.length !== 0 && f !== '.' && f !== '..';\nconst qmarksRE = /^\\?+([^+@!?\\*\\[\\(]*)?$/;\nconst qmarksTestNocase = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExt([$0]);\n    if (!ext)\n        return noext;\n    ext = ext.toLowerCase();\n    return (f) => noext(f) && f.toLowerCase().endsWith(ext);\n};\nconst qmarksTestNocaseDot = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExtDot([$0]);\n    if (!ext)\n        return noext;\n    ext = ext.toLowerCase();\n    return (f) => noext(f) && f.toLowerCase().endsWith(ext);\n};\nconst qmarksTestDot = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExtDot([$0]);\n    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);\n};\nconst qmarksTest = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExt([$0]);\n    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);\n};\nconst qmarksTestNoExt = ([$0]) => {\n    const len = $0.length;\n    return (f) => f.length === len && !f.startsWith('.');\n};\nconst qmarksTestNoExtDot = ([$0]) => {\n    const len = $0.length;\n    return (f) => f.length === len && f !== '.' && f !== '..';\n};\n/* c8 ignore start */\nconst defaultPlatform = (typeof process === 'object' && process\n    ? (typeof process.env === 'object' &&\n        process.env &&\n        process.env.__MINIMATCH_TESTING_PLATFORM__) ||\n        process.platform\n    : 'posix');\nconst path = {\n    win32: { sep: '\\\\' },\n    posix: { sep: '/' },\n};\n/* c8 ignore stop */\nconst sep = defaultPlatform === 'win32' ? path.win32.sep : path.posix.sep;\nminimatch.sep = sep;\nconst GLOBSTAR = Symbol('globstar **');\nminimatch.GLOBSTAR = GLOBSTAR;\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nconst qmark = '[^/]';\n// * => any number of characters\nconst star = qmark + '*?';\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nconst twoStarDot = '(?:(?!(?:\\\\/|^)(?:\\\\.{1,2})($|\\\\/)).)*?';\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nconst twoStarNoDot = '(?:(?!(?:\\\\/|^)\\\\.).)*?';\nconst filter = (pattern, options = {}) => (p) => minimatch(p, pattern, options);\nminimatch.filter = filter;\nconst ext = (a, b = {}) => Object.assign({}, a, b);\nconst defaults = (def) => {\n    if (!def || typeof def !== 'object' || !Object.keys(def).length) {\n        return minimatch;\n    }\n    const orig = minimatch;\n    const m = (p, pattern, options = {}) => orig(p, pattern, ext(def, options));\n    return Object.assign(m, {\n        Minimatch: class Minimatch extends orig.Minimatch {\n            constructor(pattern, options = {}) {\n                super(pattern, ext(def, options));\n            }\n            static defaults(options) {\n                return orig.defaults(ext(def, options)).Minimatch;\n            }\n        },\n        AST: class AST extends orig.AST {\n            /* c8 ignore start */\n            constructor(type, parent, options = {}) {\n                super(type, parent, ext(def, options));\n            }\n            /* c8 ignore stop */\n            static fromGlob(pattern, options = {}) {\n                return orig.AST.fromGlob(pattern, ext(def, options));\n            }\n        },\n        unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),\n        escape: (s, options = {}) => orig.escape(s, ext(def, options)),\n        filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),\n        defaults: (options) => orig.defaults(ext(def, options)),\n        makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),\n        braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),\n        match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),\n        sep: orig.sep,\n        GLOBSTAR: GLOBSTAR,\n    });\n};\nminimatch.defaults = defaults;\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nconst braceExpand = (pattern, options = {}) => {\n    (0,_assert_valid_pattern_js__WEBPACK_IMPORTED_MODULE_1__.assertValidPattern)(pattern);\n    // Thanks to Yeting Li <https://github.com/yetingli> for\n    // improving this regexp to avoid a ReDOS vulnerability.\n    if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {\n        // shortcut. no need to expand.\n        return [pattern];\n    }\n    return (0,_isaacs_brace_expansion__WEBPACK_IMPORTED_MODULE_0__.expand)(pattern);\n};\nminimatch.braceExpand = braceExpand;\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nconst makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();\nminimatch.makeRe = makeRe;\nconst match = (list, pattern, options = {}) => {\n    const mm = new Minimatch(pattern, options);\n    list = list.filter(f => mm.match(f));\n    if (mm.options.nonull && !list.length) {\n        list.push(pattern);\n    }\n    return list;\n};\nminimatch.match = match;\n// replace stuff like \\* with *\nconst globMagic = /[?*]|[+@!]\\(.*?\\)|\\[|\\]/;\nconst regExpEscape = (s) => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\nclass Minimatch {\n    options;\n    set;\n    pattern;\n    windowsPathsNoEscape;\n    nonegate;\n    negate;\n    comment;\n    empty;\n    preserveMultipleSlashes;\n    partial;\n    globSet;\n    globParts;\n    nocase;\n    isWindows;\n    platform;\n    windowsNoMagicRoot;\n    regexp;\n    constructor(pattern, options = {}) {\n        (0,_assert_valid_pattern_js__WEBPACK_IMPORTED_MODULE_1__.assertValidPattern)(pattern);\n        options = options || {};\n        this.options = options;\n        this.pattern = pattern;\n        this.platform = options.platform || defaultPlatform;\n        this.isWindows = this.platform === 'win32';\n        this.windowsPathsNoEscape =\n            !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;\n        if (this.windowsPathsNoEscape) {\n            this.pattern = this.pattern.replace(/\\\\/g, '/');\n        }\n        this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;\n        this.regexp = null;\n        this.negate = false;\n        this.nonegate = !!options.nonegate;\n        this.comment = false;\n        this.empty = false;\n        this.partial = !!options.partial;\n        this.nocase = !!this.options.nocase;\n        this.windowsNoMagicRoot =\n            options.windowsNoMagicRoot !== undefined\n                ? options.windowsNoMagicRoot\n                : !!(this.isWindows && this.nocase);\n        this.globSet = [];\n        this.globParts = [];\n        this.set = [];\n        // make the set of regexps etc.\n        this.make();\n    }\n    hasMagic() {\n        if (this.options.magicalBraces && this.set.length > 1) {\n            return true;\n        }\n        for (const pattern of this.set) {\n            for (const part of pattern) {\n                if (typeof part !== 'string')\n                    return true;\n            }\n        }\n        return false;\n    }\n    debug(..._) { }\n    make() {\n        const pattern = this.pattern;\n        const options = this.options;\n        // empty patterns and comments match nothing.\n        if (!options.nocomment && pattern.charAt(0) === '#') {\n            this.comment = true;\n            return;\n        }\n        if (!pattern) {\n            this.empty = true;\n            return;\n        }\n        // step 1: figure out negation, etc.\n        this.parseNegate();\n        // step 2: expand braces\n        this.globSet = [...new Set(this.braceExpand())];\n        if (options.debug) {\n            this.debug = (...args) => console.error(...args);\n        }\n        this.debug(this.pattern, this.globSet);\n        // step 3: now we have a set, so turn each one into a series of\n        // path-portion matching patterns.\n        // These will be regexps, except in the case of \"**\", which is\n        // set to the GLOBSTAR object for globstar behavior,\n        // and will not contain any / characters\n        //\n        // First, we preprocess to make the glob pattern sets a bit simpler\n        // and deduped.  There are some perf-killing patterns that can cause\n        // problems with a glob walk, but we can simplify them down a bit.\n        const rawGlobParts = this.globSet.map(s => this.slashSplit(s));\n        this.globParts = this.preprocess(rawGlobParts);\n        this.debug(this.pattern, this.globParts);\n        // glob --> regexps\n        let set = this.globParts.map((s, _, __) => {\n            if (this.isWindows && this.windowsNoMagicRoot) {\n                // check if it's a drive or unc path.\n                const isUNC = s[0] === '' &&\n                    s[1] === '' &&\n                    (s[2] === '?' || !globMagic.test(s[2])) &&\n                    !globMagic.test(s[3]);\n                const isDrive = /^[a-z]:/i.test(s[0]);\n                if (isUNC) {\n                    return [...s.slice(0, 4), ...s.slice(4).map(ss => this.parse(ss))];\n                }\n                else if (isDrive) {\n                    return [s[0], ...s.slice(1).map(ss => this.parse(ss))];\n                }\n            }\n            return s.map(ss => this.parse(ss));\n        });\n        this.debug(this.pattern, set);\n        // filter out everything that didn't compile properly.\n        this.set = set.filter(s => s.indexOf(false) === -1);\n        // do not treat the ? in UNC paths as magic\n        if (this.isWindows) {\n            for (let i = 0; i < this.set.length; i++) {\n                const p = this.set[i];\n                if (p[0] === '' &&\n                    p[1] === '' &&\n                    this.globParts[i][2] === '?' &&\n                    typeof p[3] === 'string' &&\n                    /^[a-z]:$/i.test(p[3])) {\n                    p[2] = '?';\n                }\n            }\n        }\n        this.debug(this.pattern, this.set);\n    }\n    // various transforms to equivalent pattern sets that are\n    // faster to process in a filesystem walk.  The goal is to\n    // eliminate what we can, and push all ** patterns as far\n    // to the right as possible, even if it increases the number\n    // of patterns that we have to process.\n    preprocess(globParts) {\n        // if we're not in globstar mode, then turn all ** into *\n        if (this.options.noglobstar) {\n            for (let i = 0; i < globParts.length; i++) {\n                for (let j = 0; j < globParts[i].length; j++) {\n                    if (globParts[i][j] === '**') {\n                        globParts[i][j] = '*';\n                    }\n                }\n            }\n        }\n        const { optimizationLevel = 1 } = this.options;\n        if (optimizationLevel >= 2) {\n            // aggressive optimization for the purpose of fs walking\n            globParts = this.firstPhasePreProcess(globParts);\n            globParts = this.secondPhasePreProcess(globParts);\n        }\n        else if (optimizationLevel >= 1) {\n            // just basic optimizations to remove some .. parts\n            globParts = this.levelOneOptimize(globParts);\n        }\n        else {\n            // just collapse multiple ** portions into one\n            globParts = this.adjascentGlobstarOptimize(globParts);\n        }\n        return globParts;\n    }\n    // just get rid of adjascent ** portions\n    adjascentGlobstarOptimize(globParts) {\n        return globParts.map(parts => {\n            let gs = -1;\n            while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n                let i = gs;\n                while (parts[i + 1] === '**') {\n                    i++;\n                }\n                if (i !== gs) {\n                    parts.splice(gs, i - gs);\n                }\n            }\n            return parts;\n        });\n    }\n    // get rid of adjascent ** and resolve .. portions\n    levelOneOptimize(globParts) {\n        return globParts.map(parts => {\n            parts = parts.reduce((set, part) => {\n                const prev = set[set.length - 1];\n                if (part === '**' && prev === '**') {\n                    return set;\n                }\n                if (part === '..') {\n                    if (prev && prev !== '..' && prev !== '.' && prev !== '**') {\n                        set.pop();\n                        return set;\n                    }\n                }\n                set.push(part);\n                return set;\n            }, []);\n            return parts.length === 0 ? [''] : parts;\n        });\n    }\n    levelTwoFileOptimize(parts) {\n        if (!Array.isArray(parts)) {\n            parts = this.slashSplit(parts);\n        }\n        let didSomething = false;\n        do {\n            didSomething = false;\n            // <pre>/<e>/<rest> -> <pre>/<rest>\n            if (!this.preserveMultipleSlashes) {\n                for (let i = 1; i < parts.length - 1; i++) {\n                    const p = parts[i];\n                    // don't squeeze out UNC patterns\n                    if (i === 1 && p === '' && parts[0] === '')\n                        continue;\n                    if (p === '.' || p === '') {\n                        didSomething = true;\n                        parts.splice(i, 1);\n                        i--;\n                    }\n                }\n                if (parts[0] === '.' &&\n                    parts.length === 2 &&\n                    (parts[1] === '.' || parts[1] === '')) {\n                    didSomething = true;\n                    parts.pop();\n                }\n            }\n            // <pre>/<p>/../<rest> -> <pre>/<rest>\n            let dd = 0;\n            while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n                const p = parts[dd - 1];\n                if (p && p !== '.' && p !== '..' && p !== '**') {\n                    didSomething = true;\n                    parts.splice(dd - 1, 2);\n                    dd -= 2;\n                }\n            }\n        } while (didSomething);\n        return parts.length === 0 ? [''] : parts;\n    }\n    // First phase: single-pattern processing\n    // <pre> is 1 or more portions\n    // <rest> is 1 or more portions\n    // <p> is any portion other than ., .., '', or **\n    // <e> is . or ''\n    //\n    // **/.. is *brutal* for filesystem walking performance, because\n    // it effectively resets the recursive walk each time it occurs,\n    // and ** cannot be reduced out by a .. pattern part like a regexp\n    // or most strings (other than .., ., and '') can be.\n    //\n    // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n    // <pre>/<e>/<rest> -> <pre>/<rest>\n    // <pre>/<p>/../<rest> -> <pre>/<rest>\n    // **/**/<rest> -> **/<rest>\n    //\n    // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow\n    // this WOULD be allowed if ** did follow symlinks, or * didn't\n    firstPhasePreProcess(globParts) {\n        let didSomething = false;\n        do {\n            didSomething = false;\n            // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n            for (let parts of globParts) {\n                let gs = -1;\n                while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n                    let gss = gs;\n                    while (parts[gss + 1] === '**') {\n                        // <pre>/**/**/<rest> -> <pre>/**/<rest>\n                        gss++;\n                    }\n                    // eg, if gs is 2 and gss is 4, that means we have 3 **\n                    // parts, and can remove 2 of them.\n                    if (gss > gs) {\n                        parts.splice(gs + 1, gss - gs);\n                    }\n                    let next = parts[gs + 1];\n                    const p = parts[gs + 2];\n                    const p2 = parts[gs + 3];\n                    if (next !== '..')\n                        continue;\n                    if (!p ||\n                        p === '.' ||\n                        p === '..' ||\n                        !p2 ||\n                        p2 === '.' ||\n                        p2 === '..') {\n                        continue;\n                    }\n                    didSomething = true;\n                    // edit parts in place, and push the new one\n                    parts.splice(gs, 1);\n                    const other = parts.slice(0);\n                    other[gs] = '**';\n                    globParts.push(other);\n                    gs--;\n                }\n                // <pre>/<e>/<rest> -> <pre>/<rest>\n                if (!this.preserveMultipleSlashes) {\n                    for (let i = 1; i < parts.length - 1; i++) {\n                        const p = parts[i];\n                        // don't squeeze out UNC patterns\n                        if (i === 1 && p === '' && parts[0] === '')\n                            continue;\n                        if (p === '.' || p === '') {\n                            didSomething = true;\n                            parts.splice(i, 1);\n                            i--;\n                        }\n                    }\n                    if (parts[0] === '.' &&\n                        parts.length === 2 &&\n                        (parts[1] === '.' || parts[1] === '')) {\n                        didSomething = true;\n                        parts.pop();\n                    }\n                }\n                // <pre>/<p>/../<rest> -> <pre>/<rest>\n                let dd = 0;\n                while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n                    const p = parts[dd - 1];\n                    if (p && p !== '.' && p !== '..' && p !== '**') {\n                        didSomething = true;\n                        const needDot = dd === 1 && parts[dd + 1] === '**';\n                        const splin = needDot ? ['.'] : [];\n                        parts.splice(dd - 1, 2, ...splin);\n                        if (parts.length === 0)\n                            parts.push('');\n                        dd -= 2;\n                    }\n                }\n            }\n        } while (didSomething);\n        return globParts;\n    }\n    // second phase: multi-pattern dedupes\n    // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>\n    // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>\n    // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>\n    //\n    // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>\n    // ^-- not valid because ** doens't follow symlinks\n    secondPhasePreProcess(globParts) {\n        for (let i = 0; i < globParts.length - 1; i++) {\n            for (let j = i + 1; j < globParts.length; j++) {\n                const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);\n                if (matched) {\n                    globParts[i] = [];\n                    globParts[j] = matched;\n                    break;\n                }\n            }\n        }\n        return globParts.filter(gs => gs.length);\n    }\n    partsMatch(a, b, emptyGSMatch = false) {\n        let ai = 0;\n        let bi = 0;\n        let result = [];\n        let which = '';\n        while (ai < a.length && bi < b.length) {\n            if (a[ai] === b[bi]) {\n                result.push(which === 'b' ? b[bi] : a[ai]);\n                ai++;\n                bi++;\n            }\n            else if (emptyGSMatch && a[ai] === '**' && b[bi] === a[ai + 1]) {\n                result.push(a[ai]);\n                ai++;\n            }\n            else if (emptyGSMatch && b[bi] === '**' && a[ai] === b[bi + 1]) {\n                result.push(b[bi]);\n                bi++;\n            }\n            else if (a[ai] === '*' &&\n                b[bi] &&\n                (this.options.dot || !b[bi].startsWith('.')) &&\n                b[bi] !== '**') {\n                if (which === 'b')\n                    return false;\n                which = 'a';\n                result.push(a[ai]);\n                ai++;\n                bi++;\n            }\n            else if (b[bi] === '*' &&\n                a[ai] &&\n                (this.options.dot || !a[ai].startsWith('.')) &&\n                a[ai] !== '**') {\n                if (which === 'a')\n                    return false;\n                which = 'b';\n                result.push(b[bi]);\n                ai++;\n                bi++;\n            }\n            else {\n                return false;\n            }\n        }\n        // if we fall out of the loop, it means they two are identical\n        // as long as their lengths match\n        return a.length === b.length && result;\n    }\n    parseNegate() {\n        if (this.nonegate)\n            return;\n        const pattern = this.pattern;\n        let negate = false;\n        let negateOffset = 0;\n        for (let i = 0; i < pattern.length && pattern.charAt(i) === '!'; i++) {\n            negate = !negate;\n            negateOffset++;\n        }\n        if (negateOffset)\n            this.pattern = pattern.slice(negateOffset);\n        this.negate = negate;\n    }\n    // set partial to true to test if, for example,\n    // \"/a/b\" matches the start of \"/*/b/*/d\"\n    // Partial means, if you run out of file before you run\n    // out of pattern, then that's fine, as long as all\n    // the parts match.\n    matchOne(file, pattern, partial = false) {\n        const options = this.options;\n        // UNC paths like //?/X:/... can match X:/... and vice versa\n        // Drive letters in absolute drive or unc paths are always compared\n        // case-insensitively.\n        if (this.isWindows) {\n            const fileDrive = typeof file[0] === 'string' && /^[a-z]:$/i.test(file[0]);\n            const fileUNC = !fileDrive &&\n                file[0] === '' &&\n                file[1] === '' &&\n                file[2] === '?' &&\n                /^[a-z]:$/i.test(file[3]);\n            const patternDrive = typeof pattern[0] === 'string' && /^[a-z]:$/i.test(pattern[0]);\n            const patternUNC = !patternDrive &&\n                pattern[0] === '' &&\n                pattern[1] === '' &&\n                pattern[2] === '?' &&\n                typeof pattern[3] === 'string' &&\n                /^[a-z]:$/i.test(pattern[3]);\n            const fdi = fileUNC ? 3 : fileDrive ? 0 : undefined;\n            const pdi = patternUNC ? 3 : patternDrive ? 0 : undefined;\n            if (typeof fdi === 'number' && typeof pdi === 'number') {\n                const [fd, pd] = [file[fdi], pattern[pdi]];\n                if (fd.toLowerCase() === pd.toLowerCase()) {\n                    pattern[pdi] = fd;\n                    if (pdi > fdi) {\n                        pattern = pattern.slice(pdi);\n                    }\n                    else if (fdi > pdi) {\n                        file = file.slice(fdi);\n                    }\n                }\n            }\n        }\n        // resolve and reduce . and .. portions in the file as well.\n        // dont' need to do the second phase, because it's only one string[]\n        const { optimizationLevel = 1 } = this.options;\n        if (optimizationLevel >= 2) {\n            file = this.levelTwoFileOptimize(file);\n        }\n        this.debug('matchOne', this, { file, pattern });\n        this.debug('matchOne', file.length, pattern.length);\n        for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {\n            this.debug('matchOne loop');\n            var p = pattern[pi];\n            var f = file[fi];\n            this.debug(pattern, p, f);\n            // should be impossible.\n            // some invalid regexp stuff in the set.\n            /* c8 ignore start */\n            if (p === false) {\n                return false;\n            }\n            /* c8 ignore stop */\n            if (p === GLOBSTAR) {\n                this.debug('GLOBSTAR', [pattern, p, f]);\n                // \"**\"\n                // a/**/b/**/c would match the following:\n                // a/b/x/y/z/c\n                // a/x/y/z/b/c\n                // a/b/x/b/x/c\n                // a/b/c\n                // To do this, take the rest of the pattern after\n                // the **, and see if it would match the file remainder.\n                // If so, return success.\n                // If not, the ** \"swallows\" a segment, and try again.\n                // This is recursively awful.\n                //\n                // a/**/b/**/c matching a/b/x/y/z/c\n                // - a matches a\n                // - doublestar\n                //   - matchOne(b/x/y/z/c, b/**/c)\n                //     - b matches b\n                //     - doublestar\n                //       - matchOne(x/y/z/c, c) -> no\n                //       - matchOne(y/z/c, c) -> no\n                //       - matchOne(z/c, c) -> no\n                //       - matchOne(c, c) yes, hit\n                var fr = fi;\n                var pr = pi + 1;\n                if (pr === pl) {\n                    this.debug('** at the end');\n                    // a ** at the end will just swallow the rest.\n                    // We have found a match.\n                    // however, it will not swallow /.x, unless\n                    // options.dot is set.\n                    // . and .. are *never* matched by **, for explosively\n                    // exponential reasons.\n                    for (; fi < fl; fi++) {\n                        if (file[fi] === '.' ||\n                            file[fi] === '..' ||\n                            (!options.dot && file[fi].charAt(0) === '.'))\n                            return false;\n                    }\n                    return true;\n                }\n                // ok, let's see if we can swallow whatever we can.\n                while (fr < fl) {\n                    var swallowee = file[fr];\n                    this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee);\n                    // XXX remove this slice.  Just pass the start index.\n                    if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n                        this.debug('globstar found match!', fr, fl, swallowee);\n                        // found a match.\n                        return true;\n                    }\n                    else {\n                        // can't swallow \".\" or \"..\" ever.\n                        // can only swallow \".foo\" when explicitly asked.\n                        if (swallowee === '.' ||\n                            swallowee === '..' ||\n                            (!options.dot && swallowee.charAt(0) === '.')) {\n                            this.debug('dot detected!', file, fr, pattern, pr);\n                            break;\n                        }\n                        // ** swallows a segment, and continue.\n                        this.debug('globstar swallow a segment, and continue');\n                        fr++;\n                    }\n                }\n                // no match was found.\n                // However, in partial mode, we can't say this is necessarily over.\n                /* c8 ignore start */\n                if (partial) {\n                    // ran out of file\n                    this.debug('\\n>>> no match, partial?', file, fr, pattern, pr);\n                    if (fr === fl) {\n                        return true;\n                    }\n                }\n                /* c8 ignore stop */\n                return false;\n            }\n            // something other than **\n            // non-magic patterns just have to match exactly\n            // patterns with magic have been turned into regexps.\n            let hit;\n            if (typeof p === 'string') {\n                hit = f === p;\n                this.debug('string match', p, f, hit);\n            }\n            else {\n                hit = p.test(f);\n                this.debug('pattern match', p, f, hit);\n            }\n            if (!hit)\n                return false;\n        }\n        // Note: ending in / means that we'll get a final \"\"\n        // at the end of the pattern.  This can only match a\n        // corresponding \"\" at the end of the file.\n        // If the file ends in /, then it can only match a\n        // a pattern that ends in /, unless the pattern just\n        // doesn't have any more for it. But, a/b/ should *not*\n        // match \"a/b/*\", even though \"\" matches against the\n        // [^/]*? pattern, except in partial mode, where it might\n        // simply not be reached yet.\n        // However, a/b/ should still satisfy a/*\n        // now either we fell off the end of the pattern, or we're done.\n        if (fi === fl && pi === pl) {\n            // ran out of pattern and filename at the same time.\n            // an exact hit!\n            return true;\n        }\n        else if (fi === fl) {\n            // ran out of file, but still had pattern left.\n            // this is ok if we're doing the match as part of\n            // a glob fs traversal.\n            return partial;\n        }\n        else if (pi === pl) {\n            // ran out of pattern, still have file left.\n            // this is only acceptable if we're on the very last\n            // empty segment of a file with a trailing slash.\n            // a/* should match a/b/\n            return fi === fl - 1 && file[fi] === '';\n            /* c8 ignore start */\n        }\n        else {\n            // should be unreachable.\n            throw new Error('wtf?');\n        }\n        /* c8 ignore stop */\n    }\n    braceExpand() {\n        return braceExpand(this.pattern, this.options);\n    }\n    parse(pattern) {\n        (0,_assert_valid_pattern_js__WEBPACK_IMPORTED_MODULE_1__.assertValidPattern)(pattern);\n        const options = this.options;\n        // shortcuts\n        if (pattern === '**')\n            return GLOBSTAR;\n        if (pattern === '')\n            return '';\n        // far and away, the most common glob pattern parts are\n        // *, *.*, and *.<ext>  Add a fast check method for those.\n        let m;\n        let fastTest = null;\n        if ((m = pattern.match(starRE))) {\n            fastTest = options.dot ? starTestDot : starTest;\n        }\n        else if ((m = pattern.match(starDotExtRE))) {\n            fastTest = (options.nocase\n                ? options.dot\n                    ? starDotExtTestNocaseDot\n                    : starDotExtTestNocase\n                : options.dot\n                    ? starDotExtTestDot\n                    : starDotExtTest)(m[1]);\n        }\n        else if ((m = pattern.match(qmarksRE))) {\n            fastTest = (options.nocase\n                ? options.dot\n                    ? qmarksTestNocaseDot\n                    : qmarksTestNocase\n                : options.dot\n                    ? qmarksTestDot\n                    : qmarksTest)(m);\n        }\n        else if ((m = pattern.match(starDotStarRE))) {\n            fastTest = options.dot ? starDotStarTestDot : starDotStarTest;\n        }\n        else if ((m = pattern.match(dotStarRE))) {\n            fastTest = dotStarTest;\n        }\n        const re = _ast_js__WEBPACK_IMPORTED_MODULE_2__.AST.fromGlob(pattern, this.options).toMMPattern();\n        if (fastTest && typeof re === 'object') {\n            // Avoids overriding in frozen environments\n            Reflect.defineProperty(re, 'test', { value: fastTest });\n        }\n        return re;\n    }\n    makeRe() {\n        if (this.regexp || this.regexp === false)\n            return this.regexp;\n        // at this point, this.set is a 2d array of partial\n        // pattern strings, or \"**\".\n        //\n        // It's better to use .match().  This function shouldn't\n        // be used, really, but it's pretty convenient sometimes,\n        // when you just want to work with a regex.\n        const set = this.set;\n        if (!set.length) {\n            this.regexp = false;\n            return this.regexp;\n        }\n        const options = this.options;\n        const twoStar = options.noglobstar\n            ? star\n            : options.dot\n                ? twoStarDot\n                : twoStarNoDot;\n        const flags = new Set(options.nocase ? ['i'] : []);\n        // regexpify non-globstar patterns\n        // if ** is only item, then we just do one twoStar\n        // if ** is first, and there are more, prepend (\\/|twoStar\\/)? to next\n        // if ** is last, append (\\/twoStar|) to previous\n        // if ** is in the middle, append (\\/|\\/twoStar\\/) to previous\n        // then filter out GLOBSTAR symbols\n        let re = set\n            .map(pattern => {\n            const pp = pattern.map(p => {\n                if (p instanceof RegExp) {\n                    for (const f of p.flags.split(''))\n                        flags.add(f);\n                }\n                return typeof p === 'string'\n                    ? regExpEscape(p)\n                    : p === GLOBSTAR\n                        ? GLOBSTAR\n                        : p._src;\n            });\n            pp.forEach((p, i) => {\n                const next = pp[i + 1];\n                const prev = pp[i - 1];\n                if (p !== GLOBSTAR || prev === GLOBSTAR) {\n                    return;\n                }\n                if (prev === undefined) {\n                    if (next !== undefined && next !== GLOBSTAR) {\n                        pp[i + 1] = '(?:\\\\/|' + twoStar + '\\\\/)?' + next;\n                    }\n                    else {\n                        pp[i] = twoStar;\n                    }\n                }\n                else if (next === undefined) {\n                    pp[i - 1] = prev + '(?:\\\\/|' + twoStar + ')?';\n                }\n                else if (next !== GLOBSTAR) {\n                    pp[i - 1] = prev + '(?:\\\\/|\\\\/' + twoStar + '\\\\/)' + next;\n                    pp[i + 1] = GLOBSTAR;\n                }\n            });\n            return pp.filter(p => p !== GLOBSTAR).join('/');\n        })\n            .join('|');\n        // need to wrap in parens if we had more than one thing with |,\n        // otherwise only the first will be anchored to ^ and the last to $\n        const [open, close] = set.length > 1 ? ['(?:', ')'] : ['', ''];\n        // must match entire pattern\n        // ending in a * or ** will make it less strict.\n        re = '^' + open + re + close + '$';\n        // can match anything, as long as it's not this.\n        if (this.negate)\n            re = '^(?!' + re + ').+$';\n        try {\n            this.regexp = new RegExp(re, [...flags].join(''));\n            /* c8 ignore start */\n        }\n        catch (ex) {\n            // should be impossible\n            this.regexp = false;\n        }\n        /* c8 ignore stop */\n        return this.regexp;\n    }\n    slashSplit(p) {\n        // if p starts with // on windows, we preserve that\n        // so that UNC paths aren't broken.  Otherwise, any number of\n        // / characters are coalesced into one, unless\n        // preserveMultipleSlashes is set to true.\n        if (this.preserveMultipleSlashes) {\n            return p.split('/');\n        }\n        else if (this.isWindows && /^\\/\\/[^\\/]+/.test(p)) {\n            // add an extra '' for the one we lose\n            return ['', ...p.split(/\\/+/)];\n        }\n        else {\n            return p.split(/\\/+/);\n        }\n    }\n    match(f, partial = this.partial) {\n        this.debug('match', f, this.pattern);\n        // short-circuit in the case of busted things.\n        // comments, etc.\n        if (this.comment) {\n            return false;\n        }\n        if (this.empty) {\n            return f === '';\n        }\n        if (f === '/' && partial) {\n            return true;\n        }\n        const options = this.options;\n        // windows: need to use /, not \\\n        if (this.isWindows) {\n            f = f.split('\\\\').join('/');\n        }\n        // treat the test path as a set of pathparts.\n        const ff = this.slashSplit(f);\n        this.debug(this.pattern, 'split', ff);\n        // just ONE of the pattern sets in this.set needs to match\n        // in order for it to be valid.  If negating, then just one\n        // match means that we have failed.\n        // Either way, return on the first hit.\n        const set = this.set;\n        this.debug(this.pattern, 'set', set);\n        // Find the basename of the path by looking for the last non-empty segment\n        let filename = ff[ff.length - 1];\n        if (!filename) {\n            for (let i = ff.length - 2; !filename && i >= 0; i--) {\n                filename = ff[i];\n            }\n        }\n        for (let i = 0; i < set.length; i++) {\n            const pattern = set[i];\n            let file = ff;\n            if (options.matchBase && pattern.length === 1) {\n                file = [filename];\n            }\n            const hit = this.matchOne(file, pattern, partial);\n            if (hit) {\n                if (options.flipNegate) {\n                    return true;\n                }\n                return !this.negate;\n            }\n        }\n        // didn't get any hits.  this is success if it's a negative\n        // pattern, failure otherwise.\n        if (options.flipNegate) {\n            return false;\n        }\n        return this.negate;\n    }\n    static defaults(def) {\n        return minimatch.defaults(def).Minimatch;\n    }\n}\n/* c8 ignore start */\n\n\n\n/* c8 ignore stop */\nminimatch.AST = _ast_js__WEBPACK_IMPORTED_MODULE_2__.AST;\nminimatch.Minimatch = Minimatch;\nminimatch.escape = _escape_js__WEBPACK_IMPORTED_MODULE_3__.escape;\nminimatch.unescape = _unescape_js__WEBPACK_IMPORTED_MODULE_4__.unescape;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZTJiL25vZGVfbW9kdWxlcy9taW5pbWF0Y2gvZGlzdC9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBaUQ7QUFDYztBQUNoQztBQUNNO0FBQ0k7QUFDbEMsMkNBQTJDO0FBQ2xELElBQUksNEVBQWtCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsSUFBSTtBQUM5QztBQUNBO0FBQ0E7QUFDTyxxQ0FBcUM7QUFDNUM7QUFDQSxzQkFBc0IscUJBQXFCO0FBQ3BDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsa0NBQWtDO0FBQ2xDLGdDQUFnQztBQUNoQyxzQ0FBc0M7QUFDdEM7QUFDQSxzQ0FBc0M7QUFDdEMsMkNBQTJDO0FBQzNDLDJDQUEyQztBQUMzQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNULEtBQUssR0FBRztBQUNSLEtBQUssS0FBSztBQUNWLEtBQUssSUFBSSxJQUFJLEVBQUU7QUFDZixLQUFLLElBQUksRUFBRSxJQUFJO0FBQ2Y7QUFDQTtBQUNBLEtBQUssSUFBSSxPQUFPLElBQUk7QUFDcEIsS0FBSyxFQUFFLE9BQU8sRUFBRTtBQUNULDBDQUEwQztBQUNqRCxJQUFJLDRFQUFrQjtBQUN0QjtBQUNBO0FBQ0EsK0JBQStCLFFBQVEsTUFBTTtBQUM3QztBQUNBO0FBQ0E7QUFDQSxXQUFXLCtEQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08scUNBQXFDO0FBQzVDO0FBQ08sMENBQTBDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQ3ZDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyxRQUFRLDRFQUFrQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixxQkFBcUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixzQkFBc0I7QUFDbEQsZ0NBQWdDLHlCQUF5QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isd0JBQXdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxzQkFBc0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxzQkFBc0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlDQUFpQztBQUN6QyxRQUFRLDJCQUEyQjtBQUNuQyxRQUFRLDhCQUE4QjtBQUN0QztBQUNBLFFBQVEscUNBQXFDO0FBQzdDO0FBQ0E7QUFDQSx3QkFBd0IsMEJBQTBCO0FBQ2xELGdDQUFnQyxzQkFBc0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpREFBaUQ7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHdCQUF3QjtBQUN4QztBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsZUFBZTtBQUN0RDtBQUNBLHdFQUF3RSxvQkFBb0I7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw0RUFBa0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0NBQUc7QUFDdEI7QUFDQTtBQUNBLGlEQUFpRCxpQkFBaUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxxQkFBcUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUMrQjtBQUNNO0FBQ0k7QUFDekM7QUFDQSxnQkFBZ0Isd0NBQUc7QUFDbkI7QUFDQSxtQkFBbUIsOENBQU07QUFDekIscUJBQXFCLGtEQUFRO0FBQzdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdml2ZS12aWJlLWFpLW5leHQvLi9ub2RlX21vZHVsZXMvZTJiL25vZGVfbW9kdWxlcy9taW5pbWF0Y2gvZGlzdC9lc20vaW5kZXguanM/MTI0MSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBleHBhbmQgfSBmcm9tICdAaXNhYWNzL2JyYWNlLWV4cGFuc2lvbic7XG5pbXBvcnQgeyBhc3NlcnRWYWxpZFBhdHRlcm4gfSBmcm9tICcuL2Fzc2VydC12YWxpZC1wYXR0ZXJuLmpzJztcbmltcG9ydCB7IEFTVCB9IGZyb20gJy4vYXN0LmpzJztcbmltcG9ydCB7IGVzY2FwZSB9IGZyb20gJy4vZXNjYXBlLmpzJztcbmltcG9ydCB7IHVuZXNjYXBlIH0gZnJvbSAnLi91bmVzY2FwZS5qcyc7XG5leHBvcnQgY29uc3QgbWluaW1hdGNoID0gKHAsIHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIGFzc2VydFZhbGlkUGF0dGVybihwYXR0ZXJuKTtcbiAgICAvLyBzaG9ydGN1dDogY29tbWVudHMgbWF0Y2ggbm90aGluZy5cbiAgICBpZiAoIW9wdGlvbnMubm9jb21tZW50ICYmIHBhdHRlcm4uY2hhckF0KDApID09PSAnIycpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IE1pbmltYXRjaChwYXR0ZXJuLCBvcHRpb25zKS5tYXRjaChwKTtcbn07XG4vLyBPcHRpbWl6ZWQgY2hlY2tpbmcgZm9yIHRoZSBtb3N0IGNvbW1vbiBnbG9iIHBhdHRlcm5zLlxuY29uc3Qgc3RhckRvdEV4dFJFID0gL15cXCorKFteK0AhP1xcKlxcW1xcKF0qKSQvO1xuY29uc3Qgc3RhckRvdEV4dFRlc3QgPSAoZXh0KSA9PiAoZikgPT4gIWYuc3RhcnRzV2l0aCgnLicpICYmIGYuZW5kc1dpdGgoZXh0KTtcbmNvbnN0IHN0YXJEb3RFeHRUZXN0RG90ID0gKGV4dCkgPT4gKGYpID0+IGYuZW5kc1dpdGgoZXh0KTtcbmNvbnN0IHN0YXJEb3RFeHRUZXN0Tm9jYXNlID0gKGV4dCkgPT4ge1xuICAgIGV4dCA9IGV4dC50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiAoZikgPT4gIWYuc3RhcnRzV2l0aCgnLicpICYmIGYudG9Mb3dlckNhc2UoKS5lbmRzV2l0aChleHQpO1xufTtcbmNvbnN0IHN0YXJEb3RFeHRUZXN0Tm9jYXNlRG90ID0gKGV4dCkgPT4ge1xuICAgIGV4dCA9IGV4dC50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiAoZikgPT4gZi50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKGV4dCk7XG59O1xuY29uc3Qgc3RhckRvdFN0YXJSRSA9IC9eXFwqK1xcLlxcKiskLztcbmNvbnN0IHN0YXJEb3RTdGFyVGVzdCA9IChmKSA9PiAhZi5zdGFydHNXaXRoKCcuJykgJiYgZi5pbmNsdWRlcygnLicpO1xuY29uc3Qgc3RhckRvdFN0YXJUZXN0RG90ID0gKGYpID0+IGYgIT09ICcuJyAmJiBmICE9PSAnLi4nICYmIGYuaW5jbHVkZXMoJy4nKTtcbmNvbnN0IGRvdFN0YXJSRSA9IC9eXFwuXFwqKyQvO1xuY29uc3QgZG90U3RhclRlc3QgPSAoZikgPT4gZiAhPT0gJy4nICYmIGYgIT09ICcuLicgJiYgZi5zdGFydHNXaXRoKCcuJyk7XG5jb25zdCBzdGFyUkUgPSAvXlxcKiskLztcbmNvbnN0IHN0YXJUZXN0ID0gKGYpID0+IGYubGVuZ3RoICE9PSAwICYmICFmLnN0YXJ0c1dpdGgoJy4nKTtcbmNvbnN0IHN0YXJUZXN0RG90ID0gKGYpID0+IGYubGVuZ3RoICE9PSAwICYmIGYgIT09ICcuJyAmJiBmICE9PSAnLi4nO1xuY29uc3QgcW1hcmtzUkUgPSAvXlxcPysoW14rQCE/XFwqXFxbXFwoXSopPyQvO1xuY29uc3QgcW1hcmtzVGVzdE5vY2FzZSA9IChbJDAsIGV4dCA9ICcnXSkgPT4ge1xuICAgIGNvbnN0IG5vZXh0ID0gcW1hcmtzVGVzdE5vRXh0KFskMF0pO1xuICAgIGlmICghZXh0KVxuICAgICAgICByZXR1cm4gbm9leHQ7XG4gICAgZXh0ID0gZXh0LnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIChmKSA9PiBub2V4dChmKSAmJiBmLnRvTG93ZXJDYXNlKCkuZW5kc1dpdGgoZXh0KTtcbn07XG5jb25zdCBxbWFya3NUZXN0Tm9jYXNlRG90ID0gKFskMCwgZXh0ID0gJyddKSA9PiB7XG4gICAgY29uc3Qgbm9leHQgPSBxbWFya3NUZXN0Tm9FeHREb3QoWyQwXSk7XG4gICAgaWYgKCFleHQpXG4gICAgICAgIHJldHVybiBub2V4dDtcbiAgICBleHQgPSBleHQudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gKGYpID0+IG5vZXh0KGYpICYmIGYudG9Mb3dlckNhc2UoKS5lbmRzV2l0aChleHQpO1xufTtcbmNvbnN0IHFtYXJrc1Rlc3REb3QgPSAoWyQwLCBleHQgPSAnJ10pID0+IHtcbiAgICBjb25zdCBub2V4dCA9IHFtYXJrc1Rlc3ROb0V4dERvdChbJDBdKTtcbiAgICByZXR1cm4gIWV4dCA/IG5vZXh0IDogKGYpID0+IG5vZXh0KGYpICYmIGYuZW5kc1dpdGgoZXh0KTtcbn07XG5jb25zdCBxbWFya3NUZXN0ID0gKFskMCwgZXh0ID0gJyddKSA9PiB7XG4gICAgY29uc3Qgbm9leHQgPSBxbWFya3NUZXN0Tm9FeHQoWyQwXSk7XG4gICAgcmV0dXJuICFleHQgPyBub2V4dCA6IChmKSA9PiBub2V4dChmKSAmJiBmLmVuZHNXaXRoKGV4dCk7XG59O1xuY29uc3QgcW1hcmtzVGVzdE5vRXh0ID0gKFskMF0pID0+IHtcbiAgICBjb25zdCBsZW4gPSAkMC5sZW5ndGg7XG4gICAgcmV0dXJuIChmKSA9PiBmLmxlbmd0aCA9PT0gbGVuICYmICFmLnN0YXJ0c1dpdGgoJy4nKTtcbn07XG5jb25zdCBxbWFya3NUZXN0Tm9FeHREb3QgPSAoWyQwXSkgPT4ge1xuICAgIGNvbnN0IGxlbiA9ICQwLmxlbmd0aDtcbiAgICByZXR1cm4gKGYpID0+IGYubGVuZ3RoID09PSBsZW4gJiYgZiAhPT0gJy4nICYmIGYgIT09ICcuLic7XG59O1xuLyogYzggaWdub3JlIHN0YXJ0ICovXG5jb25zdCBkZWZhdWx0UGxhdGZvcm0gPSAodHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmIHByb2Nlc3NcbiAgICA/ICh0eXBlb2YgcHJvY2Vzcy5lbnYgPT09ICdvYmplY3QnICYmXG4gICAgICAgIHByb2Nlc3MuZW52ICYmXG4gICAgICAgIHByb2Nlc3MuZW52Ll9fTUlOSU1BVENIX1RFU1RJTkdfUExBVEZPUk1fXykgfHxcbiAgICAgICAgcHJvY2Vzcy5wbGF0Zm9ybVxuICAgIDogJ3Bvc2l4Jyk7XG5jb25zdCBwYXRoID0ge1xuICAgIHdpbjMyOiB7IHNlcDogJ1xcXFwnIH0sXG4gICAgcG9zaXg6IHsgc2VwOiAnLycgfSxcbn07XG4vKiBjOCBpZ25vcmUgc3RvcCAqL1xuZXhwb3J0IGNvbnN0IHNlcCA9IGRlZmF1bHRQbGF0Zm9ybSA9PT0gJ3dpbjMyJyA/IHBhdGgud2luMzIuc2VwIDogcGF0aC5wb3NpeC5zZXA7XG5taW5pbWF0Y2guc2VwID0gc2VwO1xuZXhwb3J0IGNvbnN0IEdMT0JTVEFSID0gU3ltYm9sKCdnbG9ic3RhciAqKicpO1xubWluaW1hdGNoLkdMT0JTVEFSID0gR0xPQlNUQVI7XG4vLyBhbnkgc2luZ2xlIHRoaW5nIG90aGVyIHRoYW4gL1xuLy8gZG9uJ3QgbmVlZCB0byBlc2NhcGUgLyB3aGVuIHVzaW5nIG5ldyBSZWdFeHAoKVxuY29uc3QgcW1hcmsgPSAnW14vXSc7XG4vLyAqID0+IGFueSBudW1iZXIgb2YgY2hhcmFjdGVyc1xuY29uc3Qgc3RhciA9IHFtYXJrICsgJyo/Jztcbi8vICoqIHdoZW4gZG90cyBhcmUgYWxsb3dlZC4gIEFueXRoaW5nIGdvZXMsIGV4Y2VwdCAuLiBhbmQgLlxuLy8gbm90ICheIG9yIC8gZm9sbG93ZWQgYnkgb25lIG9yIHR3byBkb3RzIGZvbGxvd2VkIGJ5ICQgb3IgLyksXG4vLyBmb2xsb3dlZCBieSBhbnl0aGluZywgYW55IG51bWJlciBvZiB0aW1lcy5cbmNvbnN0IHR3b1N0YXJEb3QgPSAnKD86KD8hKD86XFxcXC98XikoPzpcXFxcLnsxLDJ9KSgkfFxcXFwvKSkuKSo/Jztcbi8vIG5vdCBhIF4gb3IgLyBmb2xsb3dlZCBieSBhIGRvdCxcbi8vIGZvbGxvd2VkIGJ5IGFueXRoaW5nLCBhbnkgbnVtYmVyIG9mIHRpbWVzLlxuY29uc3QgdHdvU3Rhck5vRG90ID0gJyg/Oig/ISg/OlxcXFwvfF4pXFxcXC4pLikqPyc7XG5leHBvcnQgY29uc3QgZmlsdGVyID0gKHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkgPT4gKHApID0+IG1pbmltYXRjaChwLCBwYXR0ZXJuLCBvcHRpb25zKTtcbm1pbmltYXRjaC5maWx0ZXIgPSBmaWx0ZXI7XG5jb25zdCBleHQgPSAoYSwgYiA9IHt9KSA9PiBPYmplY3QuYXNzaWduKHt9LCBhLCBiKTtcbmV4cG9ydCBjb25zdCBkZWZhdWx0cyA9IChkZWYpID0+IHtcbiAgICBpZiAoIWRlZiB8fCB0eXBlb2YgZGVmICE9PSAnb2JqZWN0JyB8fCAhT2JqZWN0LmtleXMoZGVmKS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG1pbmltYXRjaDtcbiAgICB9XG4gICAgY29uc3Qgb3JpZyA9IG1pbmltYXRjaDtcbiAgICBjb25zdCBtID0gKHAsIHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkgPT4gb3JpZyhwLCBwYXR0ZXJuLCBleHQoZGVmLCBvcHRpb25zKSk7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obSwge1xuICAgICAgICBNaW5pbWF0Y2g6IGNsYXNzIE1pbmltYXRjaCBleHRlbmRzIG9yaWcuTWluaW1hdGNoIHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAgICAgICAgIHN1cGVyKHBhdHRlcm4sIGV4dChkZWYsIG9wdGlvbnMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXRpYyBkZWZhdWx0cyhvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9yaWcuZGVmYXVsdHMoZXh0KGRlZiwgb3B0aW9ucykpLk1pbmltYXRjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgQVNUOiBjbGFzcyBBU1QgZXh0ZW5kcyBvcmlnLkFTVCB7XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKHR5cGUsIHBhcmVudCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgICAgICAgICAgc3VwZXIodHlwZSwgcGFyZW50LCBleHQoZGVmLCBvcHRpb25zKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgc3RhdGljIGZyb21HbG9iKHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcmlnLkFTVC5mcm9tR2xvYihwYXR0ZXJuLCBleHQoZGVmLCBvcHRpb25zKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHVuZXNjYXBlOiAocywgb3B0aW9ucyA9IHt9KSA9PiBvcmlnLnVuZXNjYXBlKHMsIGV4dChkZWYsIG9wdGlvbnMpKSxcbiAgICAgICAgZXNjYXBlOiAocywgb3B0aW9ucyA9IHt9KSA9PiBvcmlnLmVzY2FwZShzLCBleHQoZGVmLCBvcHRpb25zKSksXG4gICAgICAgIGZpbHRlcjogKHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkgPT4gb3JpZy5maWx0ZXIocGF0dGVybiwgZXh0KGRlZiwgb3B0aW9ucykpLFxuICAgICAgICBkZWZhdWx0czogKG9wdGlvbnMpID0+IG9yaWcuZGVmYXVsdHMoZXh0KGRlZiwgb3B0aW9ucykpLFxuICAgICAgICBtYWtlUmU6IChwYXR0ZXJuLCBvcHRpb25zID0ge30pID0+IG9yaWcubWFrZVJlKHBhdHRlcm4sIGV4dChkZWYsIG9wdGlvbnMpKSxcbiAgICAgICAgYnJhY2VFeHBhbmQ6IChwYXR0ZXJuLCBvcHRpb25zID0ge30pID0+IG9yaWcuYnJhY2VFeHBhbmQocGF0dGVybiwgZXh0KGRlZiwgb3B0aW9ucykpLFxuICAgICAgICBtYXRjaDogKGxpc3QsIHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkgPT4gb3JpZy5tYXRjaChsaXN0LCBwYXR0ZXJuLCBleHQoZGVmLCBvcHRpb25zKSksXG4gICAgICAgIHNlcDogb3JpZy5zZXAsXG4gICAgICAgIEdMT0JTVEFSOiBHTE9CU1RBUixcbiAgICB9KTtcbn07XG5taW5pbWF0Y2guZGVmYXVsdHMgPSBkZWZhdWx0cztcbi8vIEJyYWNlIGV4cGFuc2lvbjpcbi8vIGF7YixjfWQgLT4gYWJkIGFjZFxuLy8gYXtiLH1jIC0+IGFiYyBhY1xuLy8gYXswLi4zfWQgLT4gYTBkIGExZCBhMmQgYTNkXG4vLyBhe2IsY3tkLGV9Zn1nIC0+IGFiZyBhY2RmZyBhY2VmZ1xuLy8gYXtiLGN9ZHtlLGZ9ZyAtPiBhYmRlZyBhY2RlZyBhYmRlZyBhYmRmZ1xuLy9cbi8vIEludmFsaWQgc2V0cyBhcmUgbm90IGV4cGFuZGVkLlxuLy8gYXsyLi59YiAtPiBhezIuLn1iXG4vLyBhe2J9YyAtPiBhe2J9Y1xuZXhwb3J0IGNvbnN0IGJyYWNlRXhwYW5kID0gKHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIGFzc2VydFZhbGlkUGF0dGVybihwYXR0ZXJuKTtcbiAgICAvLyBUaGFua3MgdG8gWWV0aW5nIExpIDxodHRwczovL2dpdGh1Yi5jb20veWV0aW5nbGk+IGZvclxuICAgIC8vIGltcHJvdmluZyB0aGlzIHJlZ2V4cCB0byBhdm9pZCBhIFJlRE9TIHZ1bG5lcmFiaWxpdHkuXG4gICAgaWYgKG9wdGlvbnMubm9icmFjZSB8fCAhL1xceyg/Oig/IVxceykuKSpcXH0vLnRlc3QocGF0dGVybikpIHtcbiAgICAgICAgLy8gc2hvcnRjdXQuIG5vIG5lZWQgdG8gZXhwYW5kLlxuICAgICAgICByZXR1cm4gW3BhdHRlcm5dO1xuICAgIH1cbiAgICByZXR1cm4gZXhwYW5kKHBhdHRlcm4pO1xufTtcbm1pbmltYXRjaC5icmFjZUV4cGFuZCA9IGJyYWNlRXhwYW5kO1xuLy8gcGFyc2UgYSBjb21wb25lbnQgb2YgdGhlIGV4cGFuZGVkIHNldC5cbi8vIEF0IHRoaXMgcG9pbnQsIG5vIHBhdHRlcm4gbWF5IGNvbnRhaW4gXCIvXCIgaW4gaXRcbi8vIHNvIHdlJ3JlIGdvaW5nIHRvIHJldHVybiBhIDJkIGFycmF5LCB3aGVyZSBlYWNoIGVudHJ5IGlzIHRoZSBmdWxsXG4vLyBwYXR0ZXJuLCBzcGxpdCBvbiAnLycsIGFuZCB0aGVuIHR1cm5lZCBpbnRvIGEgcmVndWxhciBleHByZXNzaW9uLlxuLy8gQSByZWdleHAgaXMgbWFkZSBhdCB0aGUgZW5kIHdoaWNoIGpvaW5zIGVhY2ggYXJyYXkgd2l0aCBhblxuLy8gZXNjYXBlZCAvLCBhbmQgYW5vdGhlciBmdWxsIG9uZSB3aGljaCBqb2lucyBlYWNoIHJlZ2V4cCB3aXRoIHwuXG4vL1xuLy8gRm9sbG93aW5nIHRoZSBsZWFkIG9mIEJhc2ggNC4xLCBub3RlIHRoYXQgXCIqKlwiIG9ubHkgaGFzIHNwZWNpYWwgbWVhbmluZ1xuLy8gd2hlbiBpdCBpcyB0aGUgKm9ubHkqIHRoaW5nIGluIGEgcGF0aCBwb3J0aW9uLiAgT3RoZXJ3aXNlLCBhbnkgc2VyaWVzXG4vLyBvZiAqIGlzIGVxdWl2YWxlbnQgdG8gYSBzaW5nbGUgKi4gIEdsb2JzdGFyIGJlaGF2aW9yIGlzIGVuYWJsZWQgYnlcbi8vIGRlZmF1bHQsIGFuZCBjYW4gYmUgZGlzYWJsZWQgYnkgc2V0dGluZyBvcHRpb25zLm5vZ2xvYnN0YXIuXG5leHBvcnQgY29uc3QgbWFrZVJlID0gKHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkgPT4gbmV3IE1pbmltYXRjaChwYXR0ZXJuLCBvcHRpb25zKS5tYWtlUmUoKTtcbm1pbmltYXRjaC5tYWtlUmUgPSBtYWtlUmU7XG5leHBvcnQgY29uc3QgbWF0Y2ggPSAobGlzdCwgcGF0dGVybiwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgY29uc3QgbW0gPSBuZXcgTWluaW1hdGNoKHBhdHRlcm4sIG9wdGlvbnMpO1xuICAgIGxpc3QgPSBsaXN0LmZpbHRlcihmID0+IG1tLm1hdGNoKGYpKTtcbiAgICBpZiAobW0ub3B0aW9ucy5ub251bGwgJiYgIWxpc3QubGVuZ3RoKSB7XG4gICAgICAgIGxpc3QucHVzaChwYXR0ZXJuKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpc3Q7XG59O1xubWluaW1hdGNoLm1hdGNoID0gbWF0Y2g7XG4vLyByZXBsYWNlIHN0dWZmIGxpa2UgXFwqIHdpdGggKlxuY29uc3QgZ2xvYk1hZ2ljID0gL1s/Kl18WytAIV1cXCguKj9cXCl8XFxbfFxcXS87XG5jb25zdCByZWdFeHBFc2NhcGUgPSAocykgPT4gcy5yZXBsYWNlKC9bLVtcXF17fSgpKis/LixcXFxcXiR8I1xcc10vZywgJ1xcXFwkJicpO1xuZXhwb3J0IGNsYXNzIE1pbmltYXRjaCB7XG4gICAgb3B0aW9ucztcbiAgICBzZXQ7XG4gICAgcGF0dGVybjtcbiAgICB3aW5kb3dzUGF0aHNOb0VzY2FwZTtcbiAgICBub25lZ2F0ZTtcbiAgICBuZWdhdGU7XG4gICAgY29tbWVudDtcbiAgICBlbXB0eTtcbiAgICBwcmVzZXJ2ZU11bHRpcGxlU2xhc2hlcztcbiAgICBwYXJ0aWFsO1xuICAgIGdsb2JTZXQ7XG4gICAgZ2xvYlBhcnRzO1xuICAgIG5vY2FzZTtcbiAgICBpc1dpbmRvd3M7XG4gICAgcGxhdGZvcm07XG4gICAgd2luZG93c05vTWFnaWNSb290O1xuICAgIHJlZ2V4cDtcbiAgICBjb25zdHJ1Y3RvcihwYXR0ZXJuLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgYXNzZXJ0VmFsaWRQYXR0ZXJuKHBhdHRlcm4pO1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5wYXR0ZXJuID0gcGF0dGVybjtcbiAgICAgICAgdGhpcy5wbGF0Zm9ybSA9IG9wdGlvbnMucGxhdGZvcm0gfHwgZGVmYXVsdFBsYXRmb3JtO1xuICAgICAgICB0aGlzLmlzV2luZG93cyA9IHRoaXMucGxhdGZvcm0gPT09ICd3aW4zMic7XG4gICAgICAgIHRoaXMud2luZG93c1BhdGhzTm9Fc2NhcGUgPVxuICAgICAgICAgICAgISFvcHRpb25zLndpbmRvd3NQYXRoc05vRXNjYXBlIHx8IG9wdGlvbnMuYWxsb3dXaW5kb3dzRXNjYXBlID09PSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMud2luZG93c1BhdGhzTm9Fc2NhcGUpIHtcbiAgICAgICAgICAgIHRoaXMucGF0dGVybiA9IHRoaXMucGF0dGVybi5yZXBsYWNlKC9cXFxcL2csICcvJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmVzZXJ2ZU11bHRpcGxlU2xhc2hlcyA9ICEhb3B0aW9ucy5wcmVzZXJ2ZU11bHRpcGxlU2xhc2hlcztcbiAgICAgICAgdGhpcy5yZWdleHAgPSBudWxsO1xuICAgICAgICB0aGlzLm5lZ2F0ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLm5vbmVnYXRlID0gISFvcHRpb25zLm5vbmVnYXRlO1xuICAgICAgICB0aGlzLmNvbW1lbnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lbXB0eSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBhcnRpYWwgPSAhIW9wdGlvbnMucGFydGlhbDtcbiAgICAgICAgdGhpcy5ub2Nhc2UgPSAhIXRoaXMub3B0aW9ucy5ub2Nhc2U7XG4gICAgICAgIHRoaXMud2luZG93c05vTWFnaWNSb290ID1cbiAgICAgICAgICAgIG9wdGlvbnMud2luZG93c05vTWFnaWNSb290ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IG9wdGlvbnMud2luZG93c05vTWFnaWNSb290XG4gICAgICAgICAgICAgICAgOiAhISh0aGlzLmlzV2luZG93cyAmJiB0aGlzLm5vY2FzZSk7XG4gICAgICAgIHRoaXMuZ2xvYlNldCA9IFtdO1xuICAgICAgICB0aGlzLmdsb2JQYXJ0cyA9IFtdO1xuICAgICAgICB0aGlzLnNldCA9IFtdO1xuICAgICAgICAvLyBtYWtlIHRoZSBzZXQgb2YgcmVnZXhwcyBldGMuXG4gICAgICAgIHRoaXMubWFrZSgpO1xuICAgIH1cbiAgICBoYXNNYWdpYygpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5tYWdpY2FsQnJhY2VzICYmIHRoaXMuc2V0Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgcGF0dGVybiBvZiB0aGlzLnNldCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIHBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBhcnQgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGRlYnVnKC4uLl8pIHsgfVxuICAgIG1ha2UoKSB7XG4gICAgICAgIGNvbnN0IHBhdHRlcm4gPSB0aGlzLnBhdHRlcm47XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIC8vIGVtcHR5IHBhdHRlcm5zIGFuZCBjb21tZW50cyBtYXRjaCBub3RoaW5nLlxuICAgICAgICBpZiAoIW9wdGlvbnMubm9jb21tZW50ICYmIHBhdHRlcm4uY2hhckF0KDApID09PSAnIycpIHtcbiAgICAgICAgICAgIHRoaXMuY29tbWVudCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXR0ZXJuKSB7XG4gICAgICAgICAgICB0aGlzLmVtcHR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBzdGVwIDE6IGZpZ3VyZSBvdXQgbmVnYXRpb24sIGV0Yy5cbiAgICAgICAgdGhpcy5wYXJzZU5lZ2F0ZSgpO1xuICAgICAgICAvLyBzdGVwIDI6IGV4cGFuZCBicmFjZXNcbiAgICAgICAgdGhpcy5nbG9iU2V0ID0gWy4uLm5ldyBTZXQodGhpcy5icmFjZUV4cGFuZCgpKV07XG4gICAgICAgIGlmIChvcHRpb25zLmRlYnVnKSB7XG4gICAgICAgICAgICB0aGlzLmRlYnVnID0gKC4uLmFyZ3MpID0+IGNvbnNvbGUuZXJyb3IoLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZWJ1Zyh0aGlzLnBhdHRlcm4sIHRoaXMuZ2xvYlNldCk7XG4gICAgICAgIC8vIHN0ZXAgMzogbm93IHdlIGhhdmUgYSBzZXQsIHNvIHR1cm4gZWFjaCBvbmUgaW50byBhIHNlcmllcyBvZlxuICAgICAgICAvLyBwYXRoLXBvcnRpb24gbWF0Y2hpbmcgcGF0dGVybnMuXG4gICAgICAgIC8vIFRoZXNlIHdpbGwgYmUgcmVnZXhwcywgZXhjZXB0IGluIHRoZSBjYXNlIG9mIFwiKipcIiwgd2hpY2ggaXNcbiAgICAgICAgLy8gc2V0IHRvIHRoZSBHTE9CU1RBUiBvYmplY3QgZm9yIGdsb2JzdGFyIGJlaGF2aW9yLFxuICAgICAgICAvLyBhbmQgd2lsbCBub3QgY29udGFpbiBhbnkgLyBjaGFyYWN0ZXJzXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEZpcnN0LCB3ZSBwcmVwcm9jZXNzIHRvIG1ha2UgdGhlIGdsb2IgcGF0dGVybiBzZXRzIGEgYml0IHNpbXBsZXJcbiAgICAgICAgLy8gYW5kIGRlZHVwZWQuICBUaGVyZSBhcmUgc29tZSBwZXJmLWtpbGxpbmcgcGF0dGVybnMgdGhhdCBjYW4gY2F1c2VcbiAgICAgICAgLy8gcHJvYmxlbXMgd2l0aCBhIGdsb2Igd2FsaywgYnV0IHdlIGNhbiBzaW1wbGlmeSB0aGVtIGRvd24gYSBiaXQuXG4gICAgICAgIGNvbnN0IHJhd0dsb2JQYXJ0cyA9IHRoaXMuZ2xvYlNldC5tYXAocyA9PiB0aGlzLnNsYXNoU3BsaXQocykpO1xuICAgICAgICB0aGlzLmdsb2JQYXJ0cyA9IHRoaXMucHJlcHJvY2VzcyhyYXdHbG9iUGFydHMpO1xuICAgICAgICB0aGlzLmRlYnVnKHRoaXMucGF0dGVybiwgdGhpcy5nbG9iUGFydHMpO1xuICAgICAgICAvLyBnbG9iIC0tPiByZWdleHBzXG4gICAgICAgIGxldCBzZXQgPSB0aGlzLmdsb2JQYXJ0cy5tYXAoKHMsIF8sIF9fKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1dpbmRvd3MgJiYgdGhpcy53aW5kb3dzTm9NYWdpY1Jvb3QpIHtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiBpdCdzIGEgZHJpdmUgb3IgdW5jIHBhdGguXG4gICAgICAgICAgICAgICAgY29uc3QgaXNVTkMgPSBzWzBdID09PSAnJyAmJlxuICAgICAgICAgICAgICAgICAgICBzWzFdID09PSAnJyAmJlxuICAgICAgICAgICAgICAgICAgICAoc1syXSA9PT0gJz8nIHx8ICFnbG9iTWFnaWMudGVzdChzWzJdKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgIWdsb2JNYWdpYy50ZXN0KHNbM10pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzRHJpdmUgPSAvXlthLXpdOi9pLnRlc3Qoc1swXSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzVU5DKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbLi4ucy5zbGljZSgwLCA0KSwgLi4ucy5zbGljZSg0KS5tYXAoc3MgPT4gdGhpcy5wYXJzZShzcykpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNEcml2ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3NbMF0sIC4uLnMuc2xpY2UoMSkubWFwKHNzID0+IHRoaXMucGFyc2Uoc3MpKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHMubWFwKHNzID0+IHRoaXMucGFyc2Uoc3MpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZGVidWcodGhpcy5wYXR0ZXJuLCBzZXQpO1xuICAgICAgICAvLyBmaWx0ZXIgb3V0IGV2ZXJ5dGhpbmcgdGhhdCBkaWRuJ3QgY29tcGlsZSBwcm9wZXJseS5cbiAgICAgICAgdGhpcy5zZXQgPSBzZXQuZmlsdGVyKHMgPT4gcy5pbmRleE9mKGZhbHNlKSA9PT0gLTEpO1xuICAgICAgICAvLyBkbyBub3QgdHJlYXQgdGhlID8gaW4gVU5DIHBhdGhzIGFzIG1hZ2ljXG4gICAgICAgIGlmICh0aGlzLmlzV2luZG93cykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNldC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHAgPSB0aGlzLnNldFtpXTtcbiAgICAgICAgICAgICAgICBpZiAocFswXSA9PT0gJycgJiZcbiAgICAgICAgICAgICAgICAgICAgcFsxXSA9PT0gJycgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nbG9iUGFydHNbaV1bMl0gPT09ICc/JyAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgcFszXSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgICAgICAgICAgL15bYS16XTokL2kudGVzdChwWzNdKSkge1xuICAgICAgICAgICAgICAgICAgICBwWzJdID0gJz8nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlYnVnKHRoaXMucGF0dGVybiwgdGhpcy5zZXQpO1xuICAgIH1cbiAgICAvLyB2YXJpb3VzIHRyYW5zZm9ybXMgdG8gZXF1aXZhbGVudCBwYXR0ZXJuIHNldHMgdGhhdCBhcmVcbiAgICAvLyBmYXN0ZXIgdG8gcHJvY2VzcyBpbiBhIGZpbGVzeXN0ZW0gd2Fsay4gIFRoZSBnb2FsIGlzIHRvXG4gICAgLy8gZWxpbWluYXRlIHdoYXQgd2UgY2FuLCBhbmQgcHVzaCBhbGwgKiogcGF0dGVybnMgYXMgZmFyXG4gICAgLy8gdG8gdGhlIHJpZ2h0IGFzIHBvc3NpYmxlLCBldmVuIGlmIGl0IGluY3JlYXNlcyB0aGUgbnVtYmVyXG4gICAgLy8gb2YgcGF0dGVybnMgdGhhdCB3ZSBoYXZlIHRvIHByb2Nlc3MuXG4gICAgcHJlcHJvY2VzcyhnbG9iUGFydHMpIHtcbiAgICAgICAgLy8gaWYgd2UncmUgbm90IGluIGdsb2JzdGFyIG1vZGUsIHRoZW4gdHVybiBhbGwgKiogaW50byAqXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubm9nbG9ic3Rhcikge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBnbG9iUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGdsb2JQYXJ0c1tpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ2xvYlBhcnRzW2ldW2pdID09PSAnKionKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnbG9iUGFydHNbaV1bal0gPSAnKic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBvcHRpbWl6YXRpb25MZXZlbCA9IDEgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgaWYgKG9wdGltaXphdGlvbkxldmVsID49IDIpIHtcbiAgICAgICAgICAgIC8vIGFnZ3Jlc3NpdmUgb3B0aW1pemF0aW9uIGZvciB0aGUgcHVycG9zZSBvZiBmcyB3YWxraW5nXG4gICAgICAgICAgICBnbG9iUGFydHMgPSB0aGlzLmZpcnN0UGhhc2VQcmVQcm9jZXNzKGdsb2JQYXJ0cyk7XG4gICAgICAgICAgICBnbG9iUGFydHMgPSB0aGlzLnNlY29uZFBoYXNlUHJlUHJvY2VzcyhnbG9iUGFydHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdGltaXphdGlvbkxldmVsID49IDEpIHtcbiAgICAgICAgICAgIC8vIGp1c3QgYmFzaWMgb3B0aW1pemF0aW9ucyB0byByZW1vdmUgc29tZSAuLiBwYXJ0c1xuICAgICAgICAgICAgZ2xvYlBhcnRzID0gdGhpcy5sZXZlbE9uZU9wdGltaXplKGdsb2JQYXJ0cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBqdXN0IGNvbGxhcHNlIG11bHRpcGxlICoqIHBvcnRpb25zIGludG8gb25lXG4gICAgICAgICAgICBnbG9iUGFydHMgPSB0aGlzLmFkamFzY2VudEdsb2JzdGFyT3B0aW1pemUoZ2xvYlBhcnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2xvYlBhcnRzO1xuICAgIH1cbiAgICAvLyBqdXN0IGdldCByaWQgb2YgYWRqYXNjZW50ICoqIHBvcnRpb25zXG4gICAgYWRqYXNjZW50R2xvYnN0YXJPcHRpbWl6ZShnbG9iUGFydHMpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JQYXJ0cy5tYXAocGFydHMgPT4ge1xuICAgICAgICAgICAgbGV0IGdzID0gLTE7XG4gICAgICAgICAgICB3aGlsZSAoLTEgIT09IChncyA9IHBhcnRzLmluZGV4T2YoJyoqJywgZ3MgKyAxKSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgaSA9IGdzO1xuICAgICAgICAgICAgICAgIHdoaWxlIChwYXJ0c1tpICsgMV0gPT09ICcqKicpIHtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaSAhPT0gZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydHMuc3BsaWNlKGdzLCBpIC0gZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXJ0cztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIGdldCByaWQgb2YgYWRqYXNjZW50ICoqIGFuZCByZXNvbHZlIC4uIHBvcnRpb25zXG4gICAgbGV2ZWxPbmVPcHRpbWl6ZShnbG9iUGFydHMpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JQYXJ0cy5tYXAocGFydHMgPT4ge1xuICAgICAgICAgICAgcGFydHMgPSBwYXJ0cy5yZWR1Y2UoKHNldCwgcGFydCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZXYgPSBzZXRbc2V0Lmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0ID09PSAnKionICYmIHByZXYgPT09ICcqKicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBhcnQgPT09ICcuLicpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXYgJiYgcHJldiAhPT0gJy4uJyAmJiBwcmV2ICE9PSAnLicgJiYgcHJldiAhPT0gJyoqJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0LnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNldDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXQucHVzaChwYXJ0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0O1xuICAgICAgICAgICAgfSwgW10pO1xuICAgICAgICAgICAgcmV0dXJuIHBhcnRzLmxlbmd0aCA9PT0gMCA/IFsnJ10gOiBwYXJ0cztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxldmVsVHdvRmlsZU9wdGltaXplKHBhcnRzKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShwYXJ0cykpIHtcbiAgICAgICAgICAgIHBhcnRzID0gdGhpcy5zbGFzaFNwbGl0KHBhcnRzKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGlkU29tZXRoaW5nID0gZmFsc2U7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGRpZFNvbWV0aGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gPHByZT4vPGU+LzxyZXN0PiAtPiA8cHJlPi88cmVzdD5cbiAgICAgICAgICAgIGlmICghdGhpcy5wcmVzZXJ2ZU11bHRpcGxlU2xhc2hlcykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcGFydHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBwYXJ0c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZG9uJ3Qgc3F1ZWV6ZSBvdXQgVU5DIHBhdHRlcm5zXG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09PSAxICYmIHAgPT09ICcnICYmIHBhcnRzWzBdID09PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAocCA9PT0gJy4nIHx8IHAgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaWRTb21ldGhpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYXJ0c1swXSA9PT0gJy4nICYmXG4gICAgICAgICAgICAgICAgICAgIHBhcnRzLmxlbmd0aCA9PT0gMiAmJlxuICAgICAgICAgICAgICAgICAgICAocGFydHNbMV0gPT09ICcuJyB8fCBwYXJ0c1sxXSA9PT0gJycpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpZFNvbWV0aGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRzLnBvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIDxwcmU+LzxwPi8uLi88cmVzdD4gLT4gPHByZT4vPHJlc3Q+XG4gICAgICAgICAgICBsZXQgZGQgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKC0xICE9PSAoZGQgPSBwYXJ0cy5pbmRleE9mKCcuLicsIGRkICsgMSkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcCA9IHBhcnRzW2RkIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKHAgJiYgcCAhPT0gJy4nICYmIHAgIT09ICcuLicgJiYgcCAhPT0gJyoqJykge1xuICAgICAgICAgICAgICAgICAgICBkaWRTb21ldGhpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBwYXJ0cy5zcGxpY2UoZGQgLSAxLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgZGQgLT0gMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKGRpZFNvbWV0aGluZyk7XG4gICAgICAgIHJldHVybiBwYXJ0cy5sZW5ndGggPT09IDAgPyBbJyddIDogcGFydHM7XG4gICAgfVxuICAgIC8vIEZpcnN0IHBoYXNlOiBzaW5nbGUtcGF0dGVybiBwcm9jZXNzaW5nXG4gICAgLy8gPHByZT4gaXMgMSBvciBtb3JlIHBvcnRpb25zXG4gICAgLy8gPHJlc3Q+IGlzIDEgb3IgbW9yZSBwb3J0aW9uc1xuICAgIC8vIDxwPiBpcyBhbnkgcG9ydGlvbiBvdGhlciB0aGFuIC4sIC4uLCAnJywgb3IgKipcbiAgICAvLyA8ZT4gaXMgLiBvciAnJ1xuICAgIC8vXG4gICAgLy8gKiovLi4gaXMgKmJydXRhbCogZm9yIGZpbGVzeXN0ZW0gd2Fsa2luZyBwZXJmb3JtYW5jZSwgYmVjYXVzZVxuICAgIC8vIGl0IGVmZmVjdGl2ZWx5IHJlc2V0cyB0aGUgcmVjdXJzaXZlIHdhbGsgZWFjaCB0aW1lIGl0IG9jY3VycyxcbiAgICAvLyBhbmQgKiogY2Fubm90IGJlIHJlZHVjZWQgb3V0IGJ5IGEgLi4gcGF0dGVybiBwYXJ0IGxpa2UgYSByZWdleHBcbiAgICAvLyBvciBtb3N0IHN0cmluZ3MgKG90aGVyIHRoYW4gLi4sIC4sIGFuZCAnJykgY2FuIGJlLlxuICAgIC8vXG4gICAgLy8gPHByZT4vKiovLi4vPHA+LzxwPi88cmVzdD4gLT4gezxwcmU+Ly4uLzxwPi88cD4vPHJlc3Q+LDxwcmU+LyoqLzxwPi88cD4vPHJlc3Q+fVxuICAgIC8vIDxwcmU+LzxlPi88cmVzdD4gLT4gPHByZT4vPHJlc3Q+XG4gICAgLy8gPHByZT4vPHA+Ly4uLzxyZXN0PiAtPiA8cHJlPi88cmVzdD5cbiAgICAvLyAqKi8qKi88cmVzdD4gLT4gKiovPHJlc3Q+XG4gICAgLy9cbiAgICAvLyAqKi8qLzxyZXN0PiAtPiAqLyoqLzxyZXN0PiA8PT0gbm90IHZhbGlkIGJlY2F1c2UgKiogZG9lc24ndCBmb2xsb3dcbiAgICAvLyB0aGlzIFdPVUxEIGJlIGFsbG93ZWQgaWYgKiogZGlkIGZvbGxvdyBzeW1saW5rcywgb3IgKiBkaWRuJ3RcbiAgICBmaXJzdFBoYXNlUHJlUHJvY2VzcyhnbG9iUGFydHMpIHtcbiAgICAgICAgbGV0IGRpZFNvbWV0aGluZyA9IGZhbHNlO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBkaWRTb21ldGhpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIDxwcmU+LyoqLy4uLzxwPi88cD4vPHJlc3Q+IC0+IHs8cHJlPi8uLi88cD4vPHA+LzxyZXN0Piw8cHJlPi8qKi88cD4vPHA+LzxyZXN0Pn1cbiAgICAgICAgICAgIGZvciAobGV0IHBhcnRzIG9mIGdsb2JQYXJ0cykge1xuICAgICAgICAgICAgICAgIGxldCBncyA9IC0xO1xuICAgICAgICAgICAgICAgIHdoaWxlICgtMSAhPT0gKGdzID0gcGFydHMuaW5kZXhPZignKionLCBncyArIDEpKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZ3NzID0gZ3M7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChwYXJ0c1tnc3MgKyAxXSA9PT0gJyoqJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gPHByZT4vKiovKiovPHJlc3Q+IC0+IDxwcmU+LyoqLzxyZXN0PlxuICAgICAgICAgICAgICAgICAgICAgICAgZ3NzKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gZWcsIGlmIGdzIGlzIDIgYW5kIGdzcyBpcyA0LCB0aGF0IG1lYW5zIHdlIGhhdmUgMyAqKlxuICAgICAgICAgICAgICAgICAgICAvLyBwYXJ0cywgYW5kIGNhbiByZW1vdmUgMiBvZiB0aGVtLlxuICAgICAgICAgICAgICAgICAgICBpZiAoZ3NzID4gZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzLnNwbGljZShncyArIDEsIGdzcyAtIGdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHBhcnRzW2dzICsgMV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBwYXJ0c1tncyArIDJdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwMiA9IHBhcnRzW2dzICsgM107XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ICE9PSAnLi4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgcCA9PT0gJy4nIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBwID09PSAnLi4nIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAhcDIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHAyID09PSAnLicgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHAyID09PSAnLi4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkaWRTb21ldGhpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAvLyBlZGl0IHBhcnRzIGluIHBsYWNlLCBhbmQgcHVzaCB0aGUgbmV3IG9uZVxuICAgICAgICAgICAgICAgICAgICBwYXJ0cy5zcGxpY2UoZ3MsIDEpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvdGhlciA9IHBhcnRzLnNsaWNlKDApO1xuICAgICAgICAgICAgICAgICAgICBvdGhlcltnc10gPSAnKionO1xuICAgICAgICAgICAgICAgICAgICBnbG9iUGFydHMucHVzaChvdGhlcik7XG4gICAgICAgICAgICAgICAgICAgIGdzLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIDxwcmU+LzxlPi88cmVzdD4gLT4gPHByZT4vPHJlc3Q+XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnByZXNlcnZlTXVsdGlwbGVTbGFzaGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcGFydHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwID0gcGFydHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCBzcXVlZXplIG91dCBVTkMgcGF0dGVybnNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID09PSAxICYmIHAgPT09ICcnICYmIHBhcnRzWzBdID09PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwID09PSAnLicgfHwgcCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWRTb21ldGhpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnRzWzBdID09PSAnLicgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzLmxlbmd0aCA9PT0gMiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKHBhcnRzWzFdID09PSAnLicgfHwgcGFydHNbMV0gPT09ICcnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlkU29tZXRoaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIDxwcmU+LzxwPi8uLi88cmVzdD4gLT4gPHByZT4vPHJlc3Q+XG4gICAgICAgICAgICAgICAgbGV0IGRkID0gMDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoLTEgIT09IChkZCA9IHBhcnRzLmluZGV4T2YoJy4uJywgZGQgKyAxKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcCA9IHBhcnRzW2RkIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChwICYmIHAgIT09ICcuJyAmJiBwICE9PSAnLi4nICYmIHAgIT09ICcqKicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZFNvbWV0aGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZWVkRG90ID0gZGQgPT09IDEgJiYgcGFydHNbZGQgKyAxXSA9PT0gJyoqJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNwbGluID0gbmVlZERvdCA/IFsnLiddIDogW107XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0cy5zcGxpY2UoZGQgLSAxLCAyLCAuLi5zcGxpbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGQgLT0gMjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoZGlkU29tZXRoaW5nKTtcbiAgICAgICAgcmV0dXJuIGdsb2JQYXJ0cztcbiAgICB9XG4gICAgLy8gc2Vjb25kIHBoYXNlOiBtdWx0aS1wYXR0ZXJuIGRlZHVwZXNcbiAgICAvLyB7PHByZT4vKi88cmVzdD4sPHByZT4vPHA+LzxyZXN0Pn0gLT4gPHByZT4vKi88cmVzdD5cbiAgICAvLyB7PHByZT4vPHJlc3Q+LDxwcmU+LzxyZXN0Pn0gLT4gPHByZT4vPHJlc3Q+XG4gICAgLy8gezxwcmU+LyoqLzxyZXN0Piw8cHJlPi88cmVzdD59IC0+IDxwcmU+LyoqLzxyZXN0PlxuICAgIC8vXG4gICAgLy8gezxwcmU+LyoqLzxyZXN0Piw8cHJlPi8qKi88cD4vPHJlc3Q+fSAtPiA8cHJlPi8qKi88cmVzdD5cbiAgICAvLyBeLS0gbm90IHZhbGlkIGJlY2F1c2UgKiogZG9lbnMndCBmb2xsb3cgc3ltbGlua3NcbiAgICBzZWNvbmRQaGFzZVByZVByb2Nlc3MoZ2xvYlBhcnRzKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ2xvYlBhcnRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgZ2xvYlBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hlZCA9IHRoaXMucGFydHNNYXRjaChnbG9iUGFydHNbaV0sIGdsb2JQYXJ0c1tqXSwgIXRoaXMucHJlc2VydmVNdWx0aXBsZVNsYXNoZXMpO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGdsb2JQYXJ0c1tpXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBnbG9iUGFydHNbal0gPSBtYXRjaGVkO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdsb2JQYXJ0cy5maWx0ZXIoZ3MgPT4gZ3MubGVuZ3RoKTtcbiAgICB9XG4gICAgcGFydHNNYXRjaChhLCBiLCBlbXB0eUdTTWF0Y2ggPSBmYWxzZSkge1xuICAgICAgICBsZXQgYWkgPSAwO1xuICAgICAgICBsZXQgYmkgPSAwO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGxldCB3aGljaCA9ICcnO1xuICAgICAgICB3aGlsZSAoYWkgPCBhLmxlbmd0aCAmJiBiaSA8IGIubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoYVthaV0gPT09IGJbYmldKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2god2hpY2ggPT09ICdiJyA/IGJbYmldIDogYVthaV0pO1xuICAgICAgICAgICAgICAgIGFpKys7XG4gICAgICAgICAgICAgICAgYmkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVtcHR5R1NNYXRjaCAmJiBhW2FpXSA9PT0gJyoqJyAmJiBiW2JpXSA9PT0gYVthaSArIDFdKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYVthaV0pO1xuICAgICAgICAgICAgICAgIGFpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlbXB0eUdTTWF0Y2ggJiYgYltiaV0gPT09ICcqKicgJiYgYVthaV0gPT09IGJbYmkgKyAxXSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGJbYmldKTtcbiAgICAgICAgICAgICAgICBiaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYVthaV0gPT09ICcqJyAmJlxuICAgICAgICAgICAgICAgIGJbYmldICYmXG4gICAgICAgICAgICAgICAgKHRoaXMub3B0aW9ucy5kb3QgfHwgIWJbYmldLnN0YXJ0c1dpdGgoJy4nKSkgJiZcbiAgICAgICAgICAgICAgICBiW2JpXSAhPT0gJyoqJykge1xuICAgICAgICAgICAgICAgIGlmICh3aGljaCA9PT0gJ2InKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgd2hpY2ggPSAnYSc7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYVthaV0pO1xuICAgICAgICAgICAgICAgIGFpKys7XG4gICAgICAgICAgICAgICAgYmkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJbYmldID09PSAnKicgJiZcbiAgICAgICAgICAgICAgICBhW2FpXSAmJlxuICAgICAgICAgICAgICAgICh0aGlzLm9wdGlvbnMuZG90IHx8ICFhW2FpXS5zdGFydHNXaXRoKCcuJykpICYmXG4gICAgICAgICAgICAgICAgYVthaV0gIT09ICcqKicpIHtcbiAgICAgICAgICAgICAgICBpZiAod2hpY2ggPT09ICdhJylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIHdoaWNoID0gJ2InO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGJbYmldKTtcbiAgICAgICAgICAgICAgICBhaSsrO1xuICAgICAgICAgICAgICAgIGJpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgd2UgZmFsbCBvdXQgb2YgdGhlIGxvb3AsIGl0IG1lYW5zIHRoZXkgdHdvIGFyZSBpZGVudGljYWxcbiAgICAgICAgLy8gYXMgbG9uZyBhcyB0aGVpciBsZW5ndGhzIG1hdGNoXG4gICAgICAgIHJldHVybiBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgcmVzdWx0O1xuICAgIH1cbiAgICBwYXJzZU5lZ2F0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMubm9uZWdhdGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHBhdHRlcm4gPSB0aGlzLnBhdHRlcm47XG4gICAgICAgIGxldCBuZWdhdGUgPSBmYWxzZTtcbiAgICAgICAgbGV0IG5lZ2F0ZU9mZnNldCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0dGVybi5sZW5ndGggJiYgcGF0dGVybi5jaGFyQXQoaSkgPT09ICchJzsgaSsrKSB7XG4gICAgICAgICAgICBuZWdhdGUgPSAhbmVnYXRlO1xuICAgICAgICAgICAgbmVnYXRlT2Zmc2V0Kys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5lZ2F0ZU9mZnNldClcbiAgICAgICAgICAgIHRoaXMucGF0dGVybiA9IHBhdHRlcm4uc2xpY2UobmVnYXRlT2Zmc2V0KTtcbiAgICAgICAgdGhpcy5uZWdhdGUgPSBuZWdhdGU7XG4gICAgfVxuICAgIC8vIHNldCBwYXJ0aWFsIHRvIHRydWUgdG8gdGVzdCBpZiwgZm9yIGV4YW1wbGUsXG4gICAgLy8gXCIvYS9iXCIgbWF0Y2hlcyB0aGUgc3RhcnQgb2YgXCIvKi9iLyovZFwiXG4gICAgLy8gUGFydGlhbCBtZWFucywgaWYgeW91IHJ1biBvdXQgb2YgZmlsZSBiZWZvcmUgeW91IHJ1blxuICAgIC8vIG91dCBvZiBwYXR0ZXJuLCB0aGVuIHRoYXQncyBmaW5lLCBhcyBsb25nIGFzIGFsbFxuICAgIC8vIHRoZSBwYXJ0cyBtYXRjaC5cbiAgICBtYXRjaE9uZShmaWxlLCBwYXR0ZXJuLCBwYXJ0aWFsID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgLy8gVU5DIHBhdGhzIGxpa2UgLy8/L1g6Ly4uLiBjYW4gbWF0Y2ggWDovLi4uIGFuZCB2aWNlIHZlcnNhXG4gICAgICAgIC8vIERyaXZlIGxldHRlcnMgaW4gYWJzb2x1dGUgZHJpdmUgb3IgdW5jIHBhdGhzIGFyZSBhbHdheXMgY29tcGFyZWRcbiAgICAgICAgLy8gY2FzZS1pbnNlbnNpdGl2ZWx5LlxuICAgICAgICBpZiAodGhpcy5pc1dpbmRvd3MpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbGVEcml2ZSA9IHR5cGVvZiBmaWxlWzBdID09PSAnc3RyaW5nJyAmJiAvXlthLXpdOiQvaS50ZXN0KGZpbGVbMF0pO1xuICAgICAgICAgICAgY29uc3QgZmlsZVVOQyA9ICFmaWxlRHJpdmUgJiZcbiAgICAgICAgICAgICAgICBmaWxlWzBdID09PSAnJyAmJlxuICAgICAgICAgICAgICAgIGZpbGVbMV0gPT09ICcnICYmXG4gICAgICAgICAgICAgICAgZmlsZVsyXSA9PT0gJz8nICYmXG4gICAgICAgICAgICAgICAgL15bYS16XTokL2kudGVzdChmaWxlWzNdKTtcbiAgICAgICAgICAgIGNvbnN0IHBhdHRlcm5Ecml2ZSA9IHR5cGVvZiBwYXR0ZXJuWzBdID09PSAnc3RyaW5nJyAmJiAvXlthLXpdOiQvaS50ZXN0KHBhdHRlcm5bMF0pO1xuICAgICAgICAgICAgY29uc3QgcGF0dGVyblVOQyA9ICFwYXR0ZXJuRHJpdmUgJiZcbiAgICAgICAgICAgICAgICBwYXR0ZXJuWzBdID09PSAnJyAmJlxuICAgICAgICAgICAgICAgIHBhdHRlcm5bMV0gPT09ICcnICYmXG4gICAgICAgICAgICAgICAgcGF0dGVyblsyXSA9PT0gJz8nICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIHBhdHRlcm5bM10gPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgL15bYS16XTokL2kudGVzdChwYXR0ZXJuWzNdKTtcbiAgICAgICAgICAgIGNvbnN0IGZkaSA9IGZpbGVVTkMgPyAzIDogZmlsZURyaXZlID8gMCA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnN0IHBkaSA9IHBhdHRlcm5VTkMgPyAzIDogcGF0dGVybkRyaXZlID8gMCA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZmRpID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgcGRpID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtmZCwgcGRdID0gW2ZpbGVbZmRpXSwgcGF0dGVybltwZGldXTtcbiAgICAgICAgICAgICAgICBpZiAoZmQudG9Mb3dlckNhc2UoKSA9PT0gcGQudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuW3BkaV0gPSBmZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBkaSA+IGZkaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0dGVybiA9IHBhdHRlcm4uc2xpY2UocGRpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChmZGkgPiBwZGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGUgPSBmaWxlLnNsaWNlKGZkaSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVzb2x2ZSBhbmQgcmVkdWNlIC4gYW5kIC4uIHBvcnRpb25zIGluIHRoZSBmaWxlIGFzIHdlbGwuXG4gICAgICAgIC8vIGRvbnQnIG5lZWQgdG8gZG8gdGhlIHNlY29uZCBwaGFzZSwgYmVjYXVzZSBpdCdzIG9ubHkgb25lIHN0cmluZ1tdXG4gICAgICAgIGNvbnN0IHsgb3B0aW1pemF0aW9uTGV2ZWwgPSAxIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGlmIChvcHRpbWl6YXRpb25MZXZlbCA+PSAyKSB7XG4gICAgICAgICAgICBmaWxlID0gdGhpcy5sZXZlbFR3b0ZpbGVPcHRpbWl6ZShmaWxlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlYnVnKCdtYXRjaE9uZScsIHRoaXMsIHsgZmlsZSwgcGF0dGVybiB9KTtcbiAgICAgICAgdGhpcy5kZWJ1ZygnbWF0Y2hPbmUnLCBmaWxlLmxlbmd0aCwgcGF0dGVybi5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBmaSA9IDAsIHBpID0gMCwgZmwgPSBmaWxlLmxlbmd0aCwgcGwgPSBwYXR0ZXJuLmxlbmd0aDsgZmkgPCBmbCAmJiBwaSA8IHBsOyBmaSsrLCBwaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmRlYnVnKCdtYXRjaE9uZSBsb29wJyk7XG4gICAgICAgICAgICB2YXIgcCA9IHBhdHRlcm5bcGldO1xuICAgICAgICAgICAgdmFyIGYgPSBmaWxlW2ZpXTtcbiAgICAgICAgICAgIHRoaXMuZGVidWcocGF0dGVybiwgcCwgZik7XG4gICAgICAgICAgICAvLyBzaG91bGQgYmUgaW1wb3NzaWJsZS5cbiAgICAgICAgICAgIC8vIHNvbWUgaW52YWxpZCByZWdleHAgc3R1ZmYgaW4gdGhlIHNldC5cbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgaWYgKHAgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgICAgIGlmIChwID09PSBHTE9CU1RBUikge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVidWcoJ0dMT0JTVEFSJywgW3BhdHRlcm4sIHAsIGZdKTtcbiAgICAgICAgICAgICAgICAvLyBcIioqXCJcbiAgICAgICAgICAgICAgICAvLyBhLyoqL2IvKiovYyB3b3VsZCBtYXRjaCB0aGUgZm9sbG93aW5nOlxuICAgICAgICAgICAgICAgIC8vIGEvYi94L3kvei9jXG4gICAgICAgICAgICAgICAgLy8gYS94L3kvei9iL2NcbiAgICAgICAgICAgICAgICAvLyBhL2IveC9iL3gvY1xuICAgICAgICAgICAgICAgIC8vIGEvYi9jXG4gICAgICAgICAgICAgICAgLy8gVG8gZG8gdGhpcywgdGFrZSB0aGUgcmVzdCBvZiB0aGUgcGF0dGVybiBhZnRlclxuICAgICAgICAgICAgICAgIC8vIHRoZSAqKiwgYW5kIHNlZSBpZiBpdCB3b3VsZCBtYXRjaCB0aGUgZmlsZSByZW1haW5kZXIuXG4gICAgICAgICAgICAgICAgLy8gSWYgc28sIHJldHVybiBzdWNjZXNzLlxuICAgICAgICAgICAgICAgIC8vIElmIG5vdCwgdGhlICoqIFwic3dhbGxvd3NcIiBhIHNlZ21lbnQsIGFuZCB0cnkgYWdhaW4uXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyByZWN1cnNpdmVseSBhd2Z1bC5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIGEvKiovYi8qKi9jIG1hdGNoaW5nIGEvYi94L3kvei9jXG4gICAgICAgICAgICAgICAgLy8gLSBhIG1hdGNoZXMgYVxuICAgICAgICAgICAgICAgIC8vIC0gZG91Ymxlc3RhclxuICAgICAgICAgICAgICAgIC8vICAgLSBtYXRjaE9uZShiL3gveS96L2MsIGIvKiovYylcbiAgICAgICAgICAgICAgICAvLyAgICAgLSBiIG1hdGNoZXMgYlxuICAgICAgICAgICAgICAgIC8vICAgICAtIGRvdWJsZXN0YXJcbiAgICAgICAgICAgICAgICAvLyAgICAgICAtIG1hdGNoT25lKHgveS96L2MsIGMpIC0+IG5vXG4gICAgICAgICAgICAgICAgLy8gICAgICAgLSBtYXRjaE9uZSh5L3ovYywgYykgLT4gbm9cbiAgICAgICAgICAgICAgICAvLyAgICAgICAtIG1hdGNoT25lKHovYywgYykgLT4gbm9cbiAgICAgICAgICAgICAgICAvLyAgICAgICAtIG1hdGNoT25lKGMsIGMpIHllcywgaGl0XG4gICAgICAgICAgICAgICAgdmFyIGZyID0gZmk7XG4gICAgICAgICAgICAgICAgdmFyIHByID0gcGkgKyAxO1xuICAgICAgICAgICAgICAgIGlmIChwciA9PT0gcGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWJ1ZygnKiogYXQgdGhlIGVuZCcpO1xuICAgICAgICAgICAgICAgICAgICAvLyBhICoqIGF0IHRoZSBlbmQgd2lsbCBqdXN0IHN3YWxsb3cgdGhlIHJlc3QuXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgZm91bmQgYSBtYXRjaC5cbiAgICAgICAgICAgICAgICAgICAgLy8gaG93ZXZlciwgaXQgd2lsbCBub3Qgc3dhbGxvdyAvLngsIHVubGVzc1xuICAgICAgICAgICAgICAgICAgICAvLyBvcHRpb25zLmRvdCBpcyBzZXQuXG4gICAgICAgICAgICAgICAgICAgIC8vIC4gYW5kIC4uIGFyZSAqbmV2ZXIqIG1hdGNoZWQgYnkgKiosIGZvciBleHBsb3NpdmVseVxuICAgICAgICAgICAgICAgICAgICAvLyBleHBvbmVudGlhbCByZWFzb25zLlxuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgZmkgPCBmbDsgZmkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGVbZmldID09PSAnLicgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlW2ZpXSA9PT0gJy4uJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICghb3B0aW9ucy5kb3QgJiYgZmlsZVtmaV0uY2hhckF0KDApID09PSAnLicpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gb2ssIGxldCdzIHNlZSBpZiB3ZSBjYW4gc3dhbGxvdyB3aGF0ZXZlciB3ZSBjYW4uXG4gICAgICAgICAgICAgICAgd2hpbGUgKGZyIDwgZmwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN3YWxsb3dlZSA9IGZpbGVbZnJdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYnVnKCdcXG5nbG9ic3RhciB3aGlsZScsIGZpbGUsIGZyLCBwYXR0ZXJuLCBwciwgc3dhbGxvd2VlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gWFhYIHJlbW92ZSB0aGlzIHNsaWNlLiAgSnVzdCBwYXNzIHRoZSBzdGFydCBpbmRleC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2hPbmUoZmlsZS5zbGljZShmciksIHBhdHRlcm4uc2xpY2UocHIpLCBwYXJ0aWFsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWJ1ZygnZ2xvYnN0YXIgZm91bmQgbWF0Y2ghJywgZnIsIGZsLCBzd2FsbG93ZWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm91bmQgYSBtYXRjaC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FuJ3Qgc3dhbGxvdyBcIi5cIiBvciBcIi4uXCIgZXZlci5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbiBvbmx5IHN3YWxsb3cgXCIuZm9vXCIgd2hlbiBleHBsaWNpdGx5IGFza2VkLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN3YWxsb3dlZSA9PT0gJy4nIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dhbGxvd2VlID09PSAnLi4nIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCFvcHRpb25zLmRvdCAmJiBzd2FsbG93ZWUuY2hhckF0KDApID09PSAnLicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWJ1ZygnZG90IGRldGVjdGVkIScsIGZpbGUsIGZyLCBwYXR0ZXJuLCBwcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAqKiBzd2FsbG93cyBhIHNlZ21lbnQsIGFuZCBjb250aW51ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVidWcoJ2dsb2JzdGFyIHN3YWxsb3cgYSBzZWdtZW50LCBhbmQgY29udGludWUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gbm8gbWF0Y2ggd2FzIGZvdW5kLlxuICAgICAgICAgICAgICAgIC8vIEhvd2V2ZXIsIGluIHBhcnRpYWwgbW9kZSwgd2UgY2FuJ3Qgc2F5IHRoaXMgaXMgbmVjZXNzYXJpbHkgb3Zlci5cbiAgICAgICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgICAgICAgICBpZiAocGFydGlhbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyByYW4gb3V0IG9mIGZpbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWJ1ZygnXFxuPj4+IG5vIG1hdGNoLCBwYXJ0aWFsPycsIGZpbGUsIGZyLCBwYXR0ZXJuLCBwcik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmciA9PT0gZmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc29tZXRoaW5nIG90aGVyIHRoYW4gKipcbiAgICAgICAgICAgIC8vIG5vbi1tYWdpYyBwYXR0ZXJucyBqdXN0IGhhdmUgdG8gbWF0Y2ggZXhhY3RseVxuICAgICAgICAgICAgLy8gcGF0dGVybnMgd2l0aCBtYWdpYyBoYXZlIGJlZW4gdHVybmVkIGludG8gcmVnZXhwcy5cbiAgICAgICAgICAgIGxldCBoaXQ7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHAgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaGl0ID0gZiA9PT0gcDtcbiAgICAgICAgICAgICAgICB0aGlzLmRlYnVnKCdzdHJpbmcgbWF0Y2gnLCBwLCBmLCBoaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaGl0ID0gcC50ZXN0KGYpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVidWcoJ3BhdHRlcm4gbWF0Y2gnLCBwLCBmLCBoaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFoaXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdGU6IGVuZGluZyBpbiAvIG1lYW5zIHRoYXQgd2UnbGwgZ2V0IGEgZmluYWwgXCJcIlxuICAgICAgICAvLyBhdCB0aGUgZW5kIG9mIHRoZSBwYXR0ZXJuLiAgVGhpcyBjYW4gb25seSBtYXRjaCBhXG4gICAgICAgIC8vIGNvcnJlc3BvbmRpbmcgXCJcIiBhdCB0aGUgZW5kIG9mIHRoZSBmaWxlLlxuICAgICAgICAvLyBJZiB0aGUgZmlsZSBlbmRzIGluIC8sIHRoZW4gaXQgY2FuIG9ubHkgbWF0Y2ggYVxuICAgICAgICAvLyBhIHBhdHRlcm4gdGhhdCBlbmRzIGluIC8sIHVubGVzcyB0aGUgcGF0dGVybiBqdXN0XG4gICAgICAgIC8vIGRvZXNuJ3QgaGF2ZSBhbnkgbW9yZSBmb3IgaXQuIEJ1dCwgYS9iLyBzaG91bGQgKm5vdCpcbiAgICAgICAgLy8gbWF0Y2ggXCJhL2IvKlwiLCBldmVuIHRob3VnaCBcIlwiIG1hdGNoZXMgYWdhaW5zdCB0aGVcbiAgICAgICAgLy8gW14vXSo/IHBhdHRlcm4sIGV4Y2VwdCBpbiBwYXJ0aWFsIG1vZGUsIHdoZXJlIGl0IG1pZ2h0XG4gICAgICAgIC8vIHNpbXBseSBub3QgYmUgcmVhY2hlZCB5ZXQuXG4gICAgICAgIC8vIEhvd2V2ZXIsIGEvYi8gc2hvdWxkIHN0aWxsIHNhdGlzZnkgYS8qXG4gICAgICAgIC8vIG5vdyBlaXRoZXIgd2UgZmVsbCBvZmYgdGhlIGVuZCBvZiB0aGUgcGF0dGVybiwgb3Igd2UncmUgZG9uZS5cbiAgICAgICAgaWYgKGZpID09PSBmbCAmJiBwaSA9PT0gcGwpIHtcbiAgICAgICAgICAgIC8vIHJhbiBvdXQgb2YgcGF0dGVybiBhbmQgZmlsZW5hbWUgYXQgdGhlIHNhbWUgdGltZS5cbiAgICAgICAgICAgIC8vIGFuIGV4YWN0IGhpdCFcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZpID09PSBmbCkge1xuICAgICAgICAgICAgLy8gcmFuIG91dCBvZiBmaWxlLCBidXQgc3RpbGwgaGFkIHBhdHRlcm4gbGVmdC5cbiAgICAgICAgICAgIC8vIHRoaXMgaXMgb2sgaWYgd2UncmUgZG9pbmcgdGhlIG1hdGNoIGFzIHBhcnQgb2ZcbiAgICAgICAgICAgIC8vIGEgZ2xvYiBmcyB0cmF2ZXJzYWwuXG4gICAgICAgICAgICByZXR1cm4gcGFydGlhbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwaSA9PT0gcGwpIHtcbiAgICAgICAgICAgIC8vIHJhbiBvdXQgb2YgcGF0dGVybiwgc3RpbGwgaGF2ZSBmaWxlIGxlZnQuXG4gICAgICAgICAgICAvLyB0aGlzIGlzIG9ubHkgYWNjZXB0YWJsZSBpZiB3ZSdyZSBvbiB0aGUgdmVyeSBsYXN0XG4gICAgICAgICAgICAvLyBlbXB0eSBzZWdtZW50IG9mIGEgZmlsZSB3aXRoIGEgdHJhaWxpbmcgc2xhc2guXG4gICAgICAgICAgICAvLyBhLyogc2hvdWxkIG1hdGNoIGEvYi9cbiAgICAgICAgICAgIHJldHVybiBmaSA9PT0gZmwgLSAxICYmIGZpbGVbZmldID09PSAnJztcbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gc2hvdWxkIGJlIHVucmVhY2hhYmxlLlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd3dGY/Jyk7XG4gICAgICAgIH1cbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICB9XG4gICAgYnJhY2VFeHBhbmQoKSB7XG4gICAgICAgIHJldHVybiBicmFjZUV4cGFuZCh0aGlzLnBhdHRlcm4sIHRoaXMub3B0aW9ucyk7XG4gICAgfVxuICAgIHBhcnNlKHBhdHRlcm4pIHtcbiAgICAgICAgYXNzZXJ0VmFsaWRQYXR0ZXJuKHBhdHRlcm4pO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICAvLyBzaG9ydGN1dHNcbiAgICAgICAgaWYgKHBhdHRlcm4gPT09ICcqKicpXG4gICAgICAgICAgICByZXR1cm4gR0xPQlNUQVI7XG4gICAgICAgIGlmIChwYXR0ZXJuID09PSAnJylcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgLy8gZmFyIGFuZCBhd2F5LCB0aGUgbW9zdCBjb21tb24gZ2xvYiBwYXR0ZXJuIHBhcnRzIGFyZVxuICAgICAgICAvLyAqLCAqLiosIGFuZCAqLjxleHQ+ICBBZGQgYSBmYXN0IGNoZWNrIG1ldGhvZCBmb3IgdGhvc2UuXG4gICAgICAgIGxldCBtO1xuICAgICAgICBsZXQgZmFzdFRlc3QgPSBudWxsO1xuICAgICAgICBpZiAoKG0gPSBwYXR0ZXJuLm1hdGNoKHN0YXJSRSkpKSB7XG4gICAgICAgICAgICBmYXN0VGVzdCA9IG9wdGlvbnMuZG90ID8gc3RhclRlc3REb3QgOiBzdGFyVGVzdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgobSA9IHBhdHRlcm4ubWF0Y2goc3RhckRvdEV4dFJFKSkpIHtcbiAgICAgICAgICAgIGZhc3RUZXN0ID0gKG9wdGlvbnMubm9jYXNlXG4gICAgICAgICAgICAgICAgPyBvcHRpb25zLmRvdFxuICAgICAgICAgICAgICAgICAgICA/IHN0YXJEb3RFeHRUZXN0Tm9jYXNlRG90XG4gICAgICAgICAgICAgICAgICAgIDogc3RhckRvdEV4dFRlc3ROb2Nhc2VcbiAgICAgICAgICAgICAgICA6IG9wdGlvbnMuZG90XG4gICAgICAgICAgICAgICAgICAgID8gc3RhckRvdEV4dFRlc3REb3RcbiAgICAgICAgICAgICAgICAgICAgOiBzdGFyRG90RXh0VGVzdCkobVsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKG0gPSBwYXR0ZXJuLm1hdGNoKHFtYXJrc1JFKSkpIHtcbiAgICAgICAgICAgIGZhc3RUZXN0ID0gKG9wdGlvbnMubm9jYXNlXG4gICAgICAgICAgICAgICAgPyBvcHRpb25zLmRvdFxuICAgICAgICAgICAgICAgICAgICA/IHFtYXJrc1Rlc3ROb2Nhc2VEb3RcbiAgICAgICAgICAgICAgICAgICAgOiBxbWFya3NUZXN0Tm9jYXNlXG4gICAgICAgICAgICAgICAgOiBvcHRpb25zLmRvdFxuICAgICAgICAgICAgICAgICAgICA/IHFtYXJrc1Rlc3REb3RcbiAgICAgICAgICAgICAgICAgICAgOiBxbWFya3NUZXN0KShtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgobSA9IHBhdHRlcm4ubWF0Y2goc3RhckRvdFN0YXJSRSkpKSB7XG4gICAgICAgICAgICBmYXN0VGVzdCA9IG9wdGlvbnMuZG90ID8gc3RhckRvdFN0YXJUZXN0RG90IDogc3RhckRvdFN0YXJUZXN0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChtID0gcGF0dGVybi5tYXRjaChkb3RTdGFyUkUpKSkge1xuICAgICAgICAgICAgZmFzdFRlc3QgPSBkb3RTdGFyVGVzdDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZSA9IEFTVC5mcm9tR2xvYihwYXR0ZXJuLCB0aGlzLm9wdGlvbnMpLnRvTU1QYXR0ZXJuKCk7XG4gICAgICAgIGlmIChmYXN0VGVzdCAmJiB0eXBlb2YgcmUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAvLyBBdm9pZHMgb3ZlcnJpZGluZyBpbiBmcm96ZW4gZW52aXJvbm1lbnRzXG4gICAgICAgICAgICBSZWZsZWN0LmRlZmluZVByb3BlcnR5KHJlLCAndGVzdCcsIHsgdmFsdWU6IGZhc3RUZXN0IH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZTtcbiAgICB9XG4gICAgbWFrZVJlKCkge1xuICAgICAgICBpZiAodGhpcy5yZWdleHAgfHwgdGhpcy5yZWdleHAgPT09IGZhbHNlKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVnZXhwO1xuICAgICAgICAvLyBhdCB0aGlzIHBvaW50LCB0aGlzLnNldCBpcyBhIDJkIGFycmF5IG9mIHBhcnRpYWxcbiAgICAgICAgLy8gcGF0dGVybiBzdHJpbmdzLCBvciBcIioqXCIuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEl0J3MgYmV0dGVyIHRvIHVzZSAubWF0Y2goKS4gIFRoaXMgZnVuY3Rpb24gc2hvdWxkbid0XG4gICAgICAgIC8vIGJlIHVzZWQsIHJlYWxseSwgYnV0IGl0J3MgcHJldHR5IGNvbnZlbmllbnQgc29tZXRpbWVzLFxuICAgICAgICAvLyB3aGVuIHlvdSBqdXN0IHdhbnQgdG8gd29yayB3aXRoIGEgcmVnZXguXG4gICAgICAgIGNvbnN0IHNldCA9IHRoaXMuc2V0O1xuICAgICAgICBpZiAoIXNldC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMucmVnZXhwID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWdleHA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgY29uc3QgdHdvU3RhciA9IG9wdGlvbnMubm9nbG9ic3RhclxuICAgICAgICAgICAgPyBzdGFyXG4gICAgICAgICAgICA6IG9wdGlvbnMuZG90XG4gICAgICAgICAgICAgICAgPyB0d29TdGFyRG90XG4gICAgICAgICAgICAgICAgOiB0d29TdGFyTm9Eb3Q7XG4gICAgICAgIGNvbnN0IGZsYWdzID0gbmV3IFNldChvcHRpb25zLm5vY2FzZSA/IFsnaSddIDogW10pO1xuICAgICAgICAvLyByZWdleHBpZnkgbm9uLWdsb2JzdGFyIHBhdHRlcm5zXG4gICAgICAgIC8vIGlmICoqIGlzIG9ubHkgaXRlbSwgdGhlbiB3ZSBqdXN0IGRvIG9uZSB0d29TdGFyXG4gICAgICAgIC8vIGlmICoqIGlzIGZpcnN0LCBhbmQgdGhlcmUgYXJlIG1vcmUsIHByZXBlbmQgKFxcL3x0d29TdGFyXFwvKT8gdG8gbmV4dFxuICAgICAgICAvLyBpZiAqKiBpcyBsYXN0LCBhcHBlbmQgKFxcL3R3b1N0YXJ8KSB0byBwcmV2aW91c1xuICAgICAgICAvLyBpZiAqKiBpcyBpbiB0aGUgbWlkZGxlLCBhcHBlbmQgKFxcL3xcXC90d29TdGFyXFwvKSB0byBwcmV2aW91c1xuICAgICAgICAvLyB0aGVuIGZpbHRlciBvdXQgR0xPQlNUQVIgc3ltYm9sc1xuICAgICAgICBsZXQgcmUgPSBzZXRcbiAgICAgICAgICAgIC5tYXAocGF0dGVybiA9PiB7XG4gICAgICAgICAgICBjb25zdCBwcCA9IHBhdHRlcm4ubWFwKHAgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZiBvZiBwLmZsYWdzLnNwbGl0KCcnKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsYWdzLmFkZChmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBwID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgICAgICA/IHJlZ0V4cEVzY2FwZShwKVxuICAgICAgICAgICAgICAgICAgICA6IHAgPT09IEdMT0JTVEFSXG4gICAgICAgICAgICAgICAgICAgICAgICA/IEdMT0JTVEFSXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHAuX3NyYztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcHAuZm9yRWFjaCgocCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSBwcFtpICsgMV07XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldiA9IHBwW2kgLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAocCAhPT0gR0xPQlNUQVIgfHwgcHJldiA9PT0gR0xPQlNUQVIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocHJldiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ICE9PSB1bmRlZmluZWQgJiYgbmV4dCAhPT0gR0xPQlNUQVIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBwW2kgKyAxXSA9ICcoPzpcXFxcL3wnICsgdHdvU3RhciArICdcXFxcLyk/JyArIG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcFtpXSA9IHR3b1N0YXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobmV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHBwW2kgLSAxXSA9IHByZXYgKyAnKD86XFxcXC98JyArIHR3b1N0YXIgKyAnKT8nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChuZXh0ICE9PSBHTE9CU1RBUikge1xuICAgICAgICAgICAgICAgICAgICBwcFtpIC0gMV0gPSBwcmV2ICsgJyg/OlxcXFwvfFxcXFwvJyArIHR3b1N0YXIgKyAnXFxcXC8pJyArIG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIHBwW2kgKyAxXSA9IEdMT0JTVEFSO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHBwLmZpbHRlcihwID0+IHAgIT09IEdMT0JTVEFSKS5qb2luKCcvJyk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuam9pbignfCcpO1xuICAgICAgICAvLyBuZWVkIHRvIHdyYXAgaW4gcGFyZW5zIGlmIHdlIGhhZCBtb3JlIHRoYW4gb25lIHRoaW5nIHdpdGggfCxcbiAgICAgICAgLy8gb3RoZXJ3aXNlIG9ubHkgdGhlIGZpcnN0IHdpbGwgYmUgYW5jaG9yZWQgdG8gXiBhbmQgdGhlIGxhc3QgdG8gJFxuICAgICAgICBjb25zdCBbb3BlbiwgY2xvc2VdID0gc2V0Lmxlbmd0aCA+IDEgPyBbJyg/OicsICcpJ10gOiBbJycsICcnXTtcbiAgICAgICAgLy8gbXVzdCBtYXRjaCBlbnRpcmUgcGF0dGVyblxuICAgICAgICAvLyBlbmRpbmcgaW4gYSAqIG9yICoqIHdpbGwgbWFrZSBpdCBsZXNzIHN0cmljdC5cbiAgICAgICAgcmUgPSAnXicgKyBvcGVuICsgcmUgKyBjbG9zZSArICckJztcbiAgICAgICAgLy8gY2FuIG1hdGNoIGFueXRoaW5nLCBhcyBsb25nIGFzIGl0J3Mgbm90IHRoaXMuXG4gICAgICAgIGlmICh0aGlzLm5lZ2F0ZSlcbiAgICAgICAgICAgIHJlID0gJ14oPyEnICsgcmUgKyAnKS4rJCc7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnJlZ2V4cCA9IG5ldyBSZWdFeHAocmUsIFsuLi5mbGFnc10uam9pbignJykpO1xuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAvLyBzaG91bGQgYmUgaW1wb3NzaWJsZVxuICAgICAgICAgICAgdGhpcy5yZWdleHAgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICByZXR1cm4gdGhpcy5yZWdleHA7XG4gICAgfVxuICAgIHNsYXNoU3BsaXQocCkge1xuICAgICAgICAvLyBpZiBwIHN0YXJ0cyB3aXRoIC8vIG9uIHdpbmRvd3MsIHdlIHByZXNlcnZlIHRoYXRcbiAgICAgICAgLy8gc28gdGhhdCBVTkMgcGF0aHMgYXJlbid0IGJyb2tlbi4gIE90aGVyd2lzZSwgYW55IG51bWJlciBvZlxuICAgICAgICAvLyAvIGNoYXJhY3RlcnMgYXJlIGNvYWxlc2NlZCBpbnRvIG9uZSwgdW5sZXNzXG4gICAgICAgIC8vIHByZXNlcnZlTXVsdGlwbGVTbGFzaGVzIGlzIHNldCB0byB0cnVlLlxuICAgICAgICBpZiAodGhpcy5wcmVzZXJ2ZU11bHRpcGxlU2xhc2hlcykge1xuICAgICAgICAgICAgcmV0dXJuIHAuc3BsaXQoJy8nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmlzV2luZG93cyAmJiAvXlxcL1xcL1teXFwvXSsvLnRlc3QocCkpIHtcbiAgICAgICAgICAgIC8vIGFkZCBhbiBleHRyYSAnJyBmb3IgdGhlIG9uZSB3ZSBsb3NlXG4gICAgICAgICAgICByZXR1cm4gWycnLCAuLi5wLnNwbGl0KC9cXC8rLyldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHAuc3BsaXQoL1xcLysvKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtYXRjaChmLCBwYXJ0aWFsID0gdGhpcy5wYXJ0aWFsKSB7XG4gICAgICAgIHRoaXMuZGVidWcoJ21hdGNoJywgZiwgdGhpcy5wYXR0ZXJuKTtcbiAgICAgICAgLy8gc2hvcnQtY2lyY3VpdCBpbiB0aGUgY2FzZSBvZiBidXN0ZWQgdGhpbmdzLlxuICAgICAgICAvLyBjb21tZW50cywgZXRjLlxuICAgICAgICBpZiAodGhpcy5jb21tZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZW1wdHkpIHtcbiAgICAgICAgICAgIHJldHVybiBmID09PSAnJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZiA9PT0gJy8nICYmIHBhcnRpYWwpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIC8vIHdpbmRvd3M6IG5lZWQgdG8gdXNlIC8sIG5vdCBcXFxuICAgICAgICBpZiAodGhpcy5pc1dpbmRvd3MpIHtcbiAgICAgICAgICAgIGYgPSBmLnNwbGl0KCdcXFxcJykuam9pbignLycpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRyZWF0IHRoZSB0ZXN0IHBhdGggYXMgYSBzZXQgb2YgcGF0aHBhcnRzLlxuICAgICAgICBjb25zdCBmZiA9IHRoaXMuc2xhc2hTcGxpdChmKTtcbiAgICAgICAgdGhpcy5kZWJ1Zyh0aGlzLnBhdHRlcm4sICdzcGxpdCcsIGZmKTtcbiAgICAgICAgLy8ganVzdCBPTkUgb2YgdGhlIHBhdHRlcm4gc2V0cyBpbiB0aGlzLnNldCBuZWVkcyB0byBtYXRjaFxuICAgICAgICAvLyBpbiBvcmRlciBmb3IgaXQgdG8gYmUgdmFsaWQuICBJZiBuZWdhdGluZywgdGhlbiBqdXN0IG9uZVxuICAgICAgICAvLyBtYXRjaCBtZWFucyB0aGF0IHdlIGhhdmUgZmFpbGVkLlxuICAgICAgICAvLyBFaXRoZXIgd2F5LCByZXR1cm4gb24gdGhlIGZpcnN0IGhpdC5cbiAgICAgICAgY29uc3Qgc2V0ID0gdGhpcy5zZXQ7XG4gICAgICAgIHRoaXMuZGVidWcodGhpcy5wYXR0ZXJuLCAnc2V0Jywgc2V0KTtcbiAgICAgICAgLy8gRmluZCB0aGUgYmFzZW5hbWUgb2YgdGhlIHBhdGggYnkgbG9va2luZyBmb3IgdGhlIGxhc3Qgbm9uLWVtcHR5IHNlZ21lbnRcbiAgICAgICAgbGV0IGZpbGVuYW1lID0gZmZbZmYubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmICghZmlsZW5hbWUpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBmZi5sZW5ndGggLSAyOyAhZmlsZW5hbWUgJiYgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBmaWxlbmFtZSA9IGZmW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwYXR0ZXJuID0gc2V0W2ldO1xuICAgICAgICAgICAgbGV0IGZpbGUgPSBmZjtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm1hdGNoQmFzZSAmJiBwYXR0ZXJuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGZpbGUgPSBbZmlsZW5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGl0ID0gdGhpcy5tYXRjaE9uZShmaWxlLCBwYXR0ZXJuLCBwYXJ0aWFsKTtcbiAgICAgICAgICAgIGlmIChoaXQpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5mbGlwTmVnYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gIXRoaXMubmVnYXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGRpZG4ndCBnZXQgYW55IGhpdHMuICB0aGlzIGlzIHN1Y2Nlc3MgaWYgaXQncyBhIG5lZ2F0aXZlXG4gICAgICAgIC8vIHBhdHRlcm4sIGZhaWx1cmUgb3RoZXJ3aXNlLlxuICAgICAgICBpZiAob3B0aW9ucy5mbGlwTmVnYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubmVnYXRlO1xuICAgIH1cbiAgICBzdGF0aWMgZGVmYXVsdHMoZGVmKSB7XG4gICAgICAgIHJldHVybiBtaW5pbWF0Y2guZGVmYXVsdHMoZGVmKS5NaW5pbWF0Y2g7XG4gICAgfVxufVxuLyogYzggaWdub3JlIHN0YXJ0ICovXG5leHBvcnQgeyBBU1QgfSBmcm9tICcuL2FzdC5qcyc7XG5leHBvcnQgeyBlc2NhcGUgfSBmcm9tICcuL2VzY2FwZS5qcyc7XG5leHBvcnQgeyB1bmVzY2FwZSB9IGZyb20gJy4vdW5lc2NhcGUuanMnO1xuLyogYzggaWdub3JlIHN0b3AgKi9cbm1pbmltYXRjaC5BU1QgPSBBU1Q7XG5taW5pbWF0Y2guTWluaW1hdGNoID0gTWluaW1hdGNoO1xubWluaW1hdGNoLmVzY2FwZSA9IGVzY2FwZTtcbm1pbmltYXRjaC51bmVzY2FwZSA9IHVuZXNjYXBlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/e2b/node_modules/minimatch/dist/esm/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/e2b/node_modules/minimatch/dist/esm/unescape.js":
/*!**********************************************************************!*\
  !*** ./node_modules/e2b/node_modules/minimatch/dist/esm/unescape.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   unescape: () => (/* binding */ unescape)\n/* harmony export */ });\n/**\n * Un-escape a string that has been escaped with {@link escape}.\n *\n * If the {@link windowsPathsNoEscape} option is used, then square-brace\n * escapes are removed, but not backslash escapes.  For example, it will turn\n * the string `'[*]'` into `*`, but it will not turn `'\\\\*'` into `'*'`,\n * becuase `\\` is a path separator in `windowsPathsNoEscape` mode.\n *\n * When `windowsPathsNoEscape` is not set, then both brace escapes and\n * backslash escapes are removed.\n *\n * Slashes (and backslashes in `windowsPathsNoEscape` mode) cannot be escaped\n * or unescaped.\n */\nconst unescape = (s, { windowsPathsNoEscape = false, } = {}) => {\n    return windowsPathsNoEscape\n        ? s.replace(/\\[([^\\/\\\\])\\]/g, '$1')\n        : s.replace(/((?!\\\\).|^)\\[([^\\/\\\\])\\]/g, '$1$2').replace(/\\\\([^\\/])/g, '$1');\n};\n//# sourceMappingURL=unescape.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZTJiL25vZGVfbW9kdWxlcy9taW5pbWF0Y2gvZGlzdC9lc20vdW5lc2NhcGUuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0Esa0RBQWtELGFBQWE7QUFDL0Q7QUFDQSxXQUFXLDRCQUE0QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHVCQUF1QixnQ0FBZ0MsSUFBSTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdml2ZS12aWJlLWFpLW5leHQvLi9ub2RlX21vZHVsZXMvZTJiL25vZGVfbW9kdWxlcy9taW5pbWF0Y2gvZGlzdC9lc20vdW5lc2NhcGUuanM/MmQyNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFVuLWVzY2FwZSBhIHN0cmluZyB0aGF0IGhhcyBiZWVuIGVzY2FwZWQgd2l0aCB7QGxpbmsgZXNjYXBlfS5cbiAqXG4gKiBJZiB0aGUge0BsaW5rIHdpbmRvd3NQYXRoc05vRXNjYXBlfSBvcHRpb24gaXMgdXNlZCwgdGhlbiBzcXVhcmUtYnJhY2VcbiAqIGVzY2FwZXMgYXJlIHJlbW92ZWQsIGJ1dCBub3QgYmFja3NsYXNoIGVzY2FwZXMuICBGb3IgZXhhbXBsZSwgaXQgd2lsbCB0dXJuXG4gKiB0aGUgc3RyaW5nIGAnWypdJ2AgaW50byBgKmAsIGJ1dCBpdCB3aWxsIG5vdCB0dXJuIGAnXFxcXConYCBpbnRvIGAnKidgLFxuICogYmVjdWFzZSBgXFxgIGlzIGEgcGF0aCBzZXBhcmF0b3IgaW4gYHdpbmRvd3NQYXRoc05vRXNjYXBlYCBtb2RlLlxuICpcbiAqIFdoZW4gYHdpbmRvd3NQYXRoc05vRXNjYXBlYCBpcyBub3Qgc2V0LCB0aGVuIGJvdGggYnJhY2UgZXNjYXBlcyBhbmRcbiAqIGJhY2tzbGFzaCBlc2NhcGVzIGFyZSByZW1vdmVkLlxuICpcbiAqIFNsYXNoZXMgKGFuZCBiYWNrc2xhc2hlcyBpbiBgd2luZG93c1BhdGhzTm9Fc2NhcGVgIG1vZGUpIGNhbm5vdCBiZSBlc2NhcGVkXG4gKiBvciB1bmVzY2FwZWQuXG4gKi9cbmV4cG9ydCBjb25zdCB1bmVzY2FwZSA9IChzLCB7IHdpbmRvd3NQYXRoc05vRXNjYXBlID0gZmFsc2UsIH0gPSB7fSkgPT4ge1xuICAgIHJldHVybiB3aW5kb3dzUGF0aHNOb0VzY2FwZVxuICAgICAgICA/IHMucmVwbGFjZSgvXFxbKFteXFwvXFxcXF0pXFxdL2csICckMScpXG4gICAgICAgIDogcy5yZXBsYWNlKC8oKD8hXFxcXCkufF4pXFxbKFteXFwvXFxcXF0pXFxdL2csICckMSQyJykucmVwbGFjZSgvXFxcXChbXlxcL10pL2csICckMScpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVuZXNjYXBlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/e2b/node_modules/minimatch/dist/esm/unescape.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/e2b/node_modules/path-scurry/dist/esm/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/e2b/node_modules/path-scurry/dist/esm/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var node_fs__WEBPACK_IMPORTED_MODULE_4___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChildrenCache: () => (/* binding */ ChildrenCache),\n/* harmony export */   Path: () => (/* binding */ Path),\n/* harmony export */   PathBase: () => (/* binding */ PathBase),\n/* harmony export */   PathPosix: () => (/* binding */ PathPosix),\n/* harmony export */   PathScurry: () => (/* binding */ PathScurry),\n/* harmony export */   PathScurryBase: () => (/* binding */ PathScurryBase),\n/* harmony export */   PathScurryDarwin: () => (/* binding */ PathScurryDarwin),\n/* harmony export */   PathScurryPosix: () => (/* binding */ PathScurryPosix),\n/* harmony export */   PathScurryWin32: () => (/* binding */ PathScurryWin32),\n/* harmony export */   PathWin32: () => (/* binding */ PathWin32),\n/* harmony export */   ResolveCache: () => (/* binding */ ResolveCache)\n/* harmony export */ });\n/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lru-cache */ \"(rsc)/./node_modules/e2b/node_modules/lru-cache/dist/esm/index.js\");\n/* harmony import */ var node_path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:path */ \"node:path\");\n/* harmony import */ var node_url__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! node:url */ \"node:url\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var node_fs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! node:fs */ \"node:fs\");\n/* harmony import */ var node_fs_promises__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! node:fs/promises */ \"node:fs/promises\");\n/* harmony import */ var minipass__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! minipass */ \"(rsc)/./node_modules/minipass/dist/esm/index.js\");\n\n\n\n\n\nconst realpathSync = fs__WEBPACK_IMPORTED_MODULE_3__.realpathSync.native;\n// TODO: test perf of fs/promises realpath vs realpathCB,\n// since the promises one uses realpath.native\n\n\nconst defaultFS = {\n    lstatSync: fs__WEBPACK_IMPORTED_MODULE_3__.lstatSync,\n    readdir: fs__WEBPACK_IMPORTED_MODULE_3__.readdir,\n    readdirSync: fs__WEBPACK_IMPORTED_MODULE_3__.readdirSync,\n    readlinkSync: fs__WEBPACK_IMPORTED_MODULE_3__.readlinkSync,\n    realpathSync,\n    promises: {\n        lstat: node_fs_promises__WEBPACK_IMPORTED_MODULE_5__.lstat,\n        readdir: node_fs_promises__WEBPACK_IMPORTED_MODULE_5__.readdir,\n        readlink: node_fs_promises__WEBPACK_IMPORTED_MODULE_5__.readlink,\n        realpath: node_fs_promises__WEBPACK_IMPORTED_MODULE_5__.realpath,\n    },\n};\n// if they just gave us require('fs') then use our default\nconst fsFromOption = (fsOption) => !fsOption || fsOption === defaultFS || fsOption === /*#__PURE__*/ (node_fs__WEBPACK_IMPORTED_MODULE_4___namespace_cache || (node_fs__WEBPACK_IMPORTED_MODULE_4___namespace_cache = __webpack_require__.t(node_fs__WEBPACK_IMPORTED_MODULE_4__, 2))) ?\n    defaultFS\n    : {\n        ...defaultFS,\n        ...fsOption,\n        promises: {\n            ...defaultFS.promises,\n            ...(fsOption.promises || {}),\n        },\n    };\n// turn something like //?/c:/ into c:\\\nconst uncDriveRegexp = /^\\\\\\\\\\?\\\\([a-z]:)\\\\?$/i;\nconst uncToDrive = (rootPath) => rootPath.replace(/\\//g, '\\\\').replace(uncDriveRegexp, '$1\\\\');\n// windows paths are separated by either / or \\\nconst eitherSep = /[\\\\\\/]/;\nconst UNKNOWN = 0; // may not even exist, for all we know\nconst IFIFO = 0b0001;\nconst IFCHR = 0b0010;\nconst IFDIR = 0b0100;\nconst IFBLK = 0b0110;\nconst IFREG = 0b1000;\nconst IFLNK = 0b1010;\nconst IFSOCK = 0b1100;\nconst IFMT = 0b1111;\n// mask to unset low 4 bits\nconst IFMT_UNKNOWN = ~IFMT;\n// set after successfully calling readdir() and getting entries.\nconst READDIR_CALLED = 0b0000_0001_0000;\n// set after a successful lstat()\nconst LSTAT_CALLED = 0b0000_0010_0000;\n// set if an entry (or one of its parents) is definitely not a dir\nconst ENOTDIR = 0b0000_0100_0000;\n// set if an entry (or one of its parents) does not exist\n// (can also be set on lstat errors like EACCES or ENAMETOOLONG)\nconst ENOENT = 0b0000_1000_0000;\n// cannot have child entries -- also verify &IFMT is either IFDIR or IFLNK\n// set if we fail to readlink\nconst ENOREADLINK = 0b0001_0000_0000;\n// set if we know realpath() will fail\nconst ENOREALPATH = 0b0010_0000_0000;\nconst ENOCHILD = ENOTDIR | ENOENT | ENOREALPATH;\nconst TYPEMASK = 0b0011_1111_1111;\nconst entToType = (s) => s.isFile() ? IFREG\n    : s.isDirectory() ? IFDIR\n        : s.isSymbolicLink() ? IFLNK\n            : s.isCharacterDevice() ? IFCHR\n                : s.isBlockDevice() ? IFBLK\n                    : s.isSocket() ? IFSOCK\n                        : s.isFIFO() ? IFIFO\n                            : UNKNOWN;\n// normalize unicode path names\nconst normalizeCache = new Map();\nconst normalize = (s) => {\n    const c = normalizeCache.get(s);\n    if (c)\n        return c;\n    const n = s.normalize('NFKD');\n    normalizeCache.set(s, n);\n    return n;\n};\nconst normalizeNocaseCache = new Map();\nconst normalizeNocase = (s) => {\n    const c = normalizeNocaseCache.get(s);\n    if (c)\n        return c;\n    const n = normalize(s.toLowerCase());\n    normalizeNocaseCache.set(s, n);\n    return n;\n};\n/**\n * An LRUCache for storing resolved path strings or Path objects.\n * @internal\n */\nclass ResolveCache extends lru_cache__WEBPACK_IMPORTED_MODULE_0__.LRUCache {\n    constructor() {\n        super({ max: 256 });\n    }\n}\n// In order to prevent blowing out the js heap by allocating hundreds of\n// thousands of Path entries when walking extremely large trees, the \"children\"\n// in this tree are represented by storing an array of Path entries in an\n// LRUCache, indexed by the parent.  At any time, Path.children() may return an\n// empty array, indicating that it doesn't know about any of its children, and\n// thus has to rebuild that cache.  This is fine, it just means that we don't\n// benefit as much from having the cached entries, but huge directory walks\n// don't blow out the stack, and smaller ones are still as fast as possible.\n//\n//It does impose some complexity when building up the readdir data, because we\n//need to pass a reference to the children array that we started with.\n/**\n * an LRUCache for storing child entries.\n * @internal\n */\nclass ChildrenCache extends lru_cache__WEBPACK_IMPORTED_MODULE_0__.LRUCache {\n    constructor(maxSize = 16 * 1024) {\n        super({\n            maxSize,\n            // parent + children\n            sizeCalculation: a => a.length + 1,\n        });\n    }\n}\nconst setAsCwd = Symbol('PathScurry setAsCwd');\n/**\n * Path objects are sort of like a super-powered\n * {@link https://nodejs.org/docs/latest/api/fs.html#class-fsdirent fs.Dirent}\n *\n * Each one represents a single filesystem entry on disk, which may or may not\n * exist. It includes methods for reading various types of information via\n * lstat, readlink, and readdir, and caches all information to the greatest\n * degree possible.\n *\n * Note that fs operations that would normally throw will instead return an\n * \"empty\" value. This is in order to prevent excessive overhead from error\n * stack traces.\n */\nclass PathBase {\n    /**\n     * the basename of this path\n     *\n     * **Important**: *always* test the path name against any test string\n     * usingthe {@link isNamed} method, and not by directly comparing this\n     * string. Otherwise, unicode path strings that the system sees as identical\n     * will not be properly treated as the same path, leading to incorrect\n     * behavior and possible security issues.\n     */\n    name;\n    /**\n     * the Path entry corresponding to the path root.\n     *\n     * @internal\n     */\n    root;\n    /**\n     * All roots found within the current PathScurry family\n     *\n     * @internal\n     */\n    roots;\n    /**\n     * a reference to the parent path, or undefined in the case of root entries\n     *\n     * @internal\n     */\n    parent;\n    /**\n     * boolean indicating whether paths are compared case-insensitively\n     * @internal\n     */\n    nocase;\n    /**\n     * boolean indicating that this path is the current working directory\n     * of the PathScurry collection that contains it.\n     */\n    isCWD = false;\n    // potential default fs override\n    #fs;\n    // Stats fields\n    #dev;\n    get dev() {\n        return this.#dev;\n    }\n    #mode;\n    get mode() {\n        return this.#mode;\n    }\n    #nlink;\n    get nlink() {\n        return this.#nlink;\n    }\n    #uid;\n    get uid() {\n        return this.#uid;\n    }\n    #gid;\n    get gid() {\n        return this.#gid;\n    }\n    #rdev;\n    get rdev() {\n        return this.#rdev;\n    }\n    #blksize;\n    get blksize() {\n        return this.#blksize;\n    }\n    #ino;\n    get ino() {\n        return this.#ino;\n    }\n    #size;\n    get size() {\n        return this.#size;\n    }\n    #blocks;\n    get blocks() {\n        return this.#blocks;\n    }\n    #atimeMs;\n    get atimeMs() {\n        return this.#atimeMs;\n    }\n    #mtimeMs;\n    get mtimeMs() {\n        return this.#mtimeMs;\n    }\n    #ctimeMs;\n    get ctimeMs() {\n        return this.#ctimeMs;\n    }\n    #birthtimeMs;\n    get birthtimeMs() {\n        return this.#birthtimeMs;\n    }\n    #atime;\n    get atime() {\n        return this.#atime;\n    }\n    #mtime;\n    get mtime() {\n        return this.#mtime;\n    }\n    #ctime;\n    get ctime() {\n        return this.#ctime;\n    }\n    #birthtime;\n    get birthtime() {\n        return this.#birthtime;\n    }\n    #matchName;\n    #depth;\n    #fullpath;\n    #fullpathPosix;\n    #relative;\n    #relativePosix;\n    #type;\n    #children;\n    #linkTarget;\n    #realpath;\n    /**\n     * This property is for compatibility with the Dirent class as of\n     * Node v20, where Dirent['parentPath'] refers to the path of the\n     * directory that was passed to readdir. For root entries, it's the path\n     * to the entry itself.\n     */\n    get parentPath() {\n        return (this.parent || this).fullpath();\n    }\n    /**\n     * Deprecated alias for Dirent['parentPath'] Somewhat counterintuitively,\n     * this property refers to the *parent* path, not the path object itself.\n     *\n     * @deprecated\n     */\n    get path() {\n        return this.parentPath;\n    }\n    /**\n     * Do not create new Path objects directly.  They should always be accessed\n     * via the PathScurry class or other methods on the Path class.\n     *\n     * @internal\n     */\n    constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {\n        this.name = name;\n        this.#matchName = nocase ? normalizeNocase(name) : normalize(name);\n        this.#type = type & TYPEMASK;\n        this.nocase = nocase;\n        this.roots = roots;\n        this.root = root || this;\n        this.#children = children;\n        this.#fullpath = opts.fullpath;\n        this.#relative = opts.relative;\n        this.#relativePosix = opts.relativePosix;\n        this.parent = opts.parent;\n        if (this.parent) {\n            this.#fs = this.parent.#fs;\n        }\n        else {\n            this.#fs = fsFromOption(opts.fs);\n        }\n    }\n    /**\n     * Returns the depth of the Path object from its root.\n     *\n     * For example, a path at `/foo/bar` would have a depth of 2.\n     */\n    depth() {\n        if (this.#depth !== undefined)\n            return this.#depth;\n        if (!this.parent)\n            return (this.#depth = 0);\n        return (this.#depth = this.parent.depth() + 1);\n    }\n    /**\n     * @internal\n     */\n    childrenCache() {\n        return this.#children;\n    }\n    /**\n     * Get the Path object referenced by the string path, resolved from this Path\n     */\n    resolve(path) {\n        if (!path) {\n            return this;\n        }\n        const rootPath = this.getRootString(path);\n        const dir = path.substring(rootPath.length);\n        const dirParts = dir.split(this.splitSep);\n        const result = rootPath ?\n            this.getRoot(rootPath).#resolveParts(dirParts)\n            : this.#resolveParts(dirParts);\n        return result;\n    }\n    #resolveParts(dirParts) {\n        let p = this;\n        for (const part of dirParts) {\n            p = p.child(part);\n        }\n        return p;\n    }\n    /**\n     * Returns the cached children Path objects, if still available.  If they\n     * have fallen out of the cache, then returns an empty array, and resets the\n     * READDIR_CALLED bit, so that future calls to readdir() will require an fs\n     * lookup.\n     *\n     * @internal\n     */\n    children() {\n        const cached = this.#children.get(this);\n        if (cached) {\n            return cached;\n        }\n        const children = Object.assign([], { provisional: 0 });\n        this.#children.set(this, children);\n        this.#type &= ~READDIR_CALLED;\n        return children;\n    }\n    /**\n     * Resolves a path portion and returns or creates the child Path.\n     *\n     * Returns `this` if pathPart is `''` or `'.'`, or `parent` if pathPart is\n     * `'..'`.\n     *\n     * This should not be called directly.  If `pathPart` contains any path\n     * separators, it will lead to unsafe undefined behavior.\n     *\n     * Use `Path.resolve()` instead.\n     *\n     * @internal\n     */\n    child(pathPart, opts) {\n        if (pathPart === '' || pathPart === '.') {\n            return this;\n        }\n        if (pathPart === '..') {\n            return this.parent || this;\n        }\n        // find the child\n        const children = this.children();\n        const name = this.nocase ? normalizeNocase(pathPart) : normalize(pathPart);\n        for (const p of children) {\n            if (p.#matchName === name) {\n                return p;\n            }\n        }\n        // didn't find it, create provisional child, since it might not\n        // actually exist.  If we know the parent isn't a dir, then\n        // in fact it CAN'T exist.\n        const s = this.parent ? this.sep : '';\n        const fullpath = this.#fullpath ? this.#fullpath + s + pathPart : undefined;\n        const pchild = this.newChild(pathPart, UNKNOWN, {\n            ...opts,\n            parent: this,\n            fullpath,\n        });\n        if (!this.canReaddir()) {\n            pchild.#type |= ENOENT;\n        }\n        // don't have to update provisional, because if we have real children,\n        // then provisional is set to children.length, otherwise a lower number\n        children.push(pchild);\n        return pchild;\n    }\n    /**\n     * The relative path from the cwd. If it does not share an ancestor with\n     * the cwd, then this ends up being equivalent to the fullpath()\n     */\n    relative() {\n        if (this.isCWD)\n            return '';\n        if (this.#relative !== undefined) {\n            return this.#relative;\n        }\n        const name = this.name;\n        const p = this.parent;\n        if (!p) {\n            return (this.#relative = this.name);\n        }\n        const pv = p.relative();\n        return pv + (!pv || !p.parent ? '' : this.sep) + name;\n    }\n    /**\n     * The relative path from the cwd, using / as the path separator.\n     * If it does not share an ancestor with\n     * the cwd, then this ends up being equivalent to the fullpathPosix()\n     * On posix systems, this is identical to relative().\n     */\n    relativePosix() {\n        if (this.sep === '/')\n            return this.relative();\n        if (this.isCWD)\n            return '';\n        if (this.#relativePosix !== undefined)\n            return this.#relativePosix;\n        const name = this.name;\n        const p = this.parent;\n        if (!p) {\n            return (this.#relativePosix = this.fullpathPosix());\n        }\n        const pv = p.relativePosix();\n        return pv + (!pv || !p.parent ? '' : '/') + name;\n    }\n    /**\n     * The fully resolved path string for this Path entry\n     */\n    fullpath() {\n        if (this.#fullpath !== undefined) {\n            return this.#fullpath;\n        }\n        const name = this.name;\n        const p = this.parent;\n        if (!p) {\n            return (this.#fullpath = this.name);\n        }\n        const pv = p.fullpath();\n        const fp = pv + (!p.parent ? '' : this.sep) + name;\n        return (this.#fullpath = fp);\n    }\n    /**\n     * On platforms other than windows, this is identical to fullpath.\n     *\n     * On windows, this is overridden to return the forward-slash form of the\n     * full UNC path.\n     */\n    fullpathPosix() {\n        if (this.#fullpathPosix !== undefined)\n            return this.#fullpathPosix;\n        if (this.sep === '/')\n            return (this.#fullpathPosix = this.fullpath());\n        if (!this.parent) {\n            const p = this.fullpath().replace(/\\\\/g, '/');\n            if (/^[a-z]:\\//i.test(p)) {\n                return (this.#fullpathPosix = `//?/${p}`);\n            }\n            else {\n                return (this.#fullpathPosix = p);\n            }\n        }\n        const p = this.parent;\n        const pfpp = p.fullpathPosix();\n        const fpp = pfpp + (!pfpp || !p.parent ? '' : '/') + this.name;\n        return (this.#fullpathPosix = fpp);\n    }\n    /**\n     * Is the Path of an unknown type?\n     *\n     * Note that we might know *something* about it if there has been a previous\n     * filesystem operation, for example that it does not exist, or is not a\n     * link, or whether it has child entries.\n     */\n    isUnknown() {\n        return (this.#type & IFMT) === UNKNOWN;\n    }\n    isType(type) {\n        return this[`is${type}`]();\n    }\n    getType() {\n        return (this.isUnknown() ? 'Unknown'\n            : this.isDirectory() ? 'Directory'\n                : this.isFile() ? 'File'\n                    : this.isSymbolicLink() ? 'SymbolicLink'\n                        : this.isFIFO() ? 'FIFO'\n                            : this.isCharacterDevice() ? 'CharacterDevice'\n                                : this.isBlockDevice() ? 'BlockDevice'\n                                    : /* c8 ignore start */ this.isSocket() ? 'Socket'\n                                        : 'Unknown');\n        /* c8 ignore stop */\n    }\n    /**\n     * Is the Path a regular file?\n     */\n    isFile() {\n        return (this.#type & IFMT) === IFREG;\n    }\n    /**\n     * Is the Path a directory?\n     */\n    isDirectory() {\n        return (this.#type & IFMT) === IFDIR;\n    }\n    /**\n     * Is the path a character device?\n     */\n    isCharacterDevice() {\n        return (this.#type & IFMT) === IFCHR;\n    }\n    /**\n     * Is the path a block device?\n     */\n    isBlockDevice() {\n        return (this.#type & IFMT) === IFBLK;\n    }\n    /**\n     * Is the path a FIFO pipe?\n     */\n    isFIFO() {\n        return (this.#type & IFMT) === IFIFO;\n    }\n    /**\n     * Is the path a socket?\n     */\n    isSocket() {\n        return (this.#type & IFMT) === IFSOCK;\n    }\n    /**\n     * Is the path a symbolic link?\n     */\n    isSymbolicLink() {\n        return (this.#type & IFLNK) === IFLNK;\n    }\n    /**\n     * Return the entry if it has been subject of a successful lstat, or\n     * undefined otherwise.\n     *\n     * Does not read the filesystem, so an undefined result *could* simply\n     * mean that we haven't called lstat on it.\n     */\n    lstatCached() {\n        return this.#type & LSTAT_CALLED ? this : undefined;\n    }\n    /**\n     * Return the cached link target if the entry has been the subject of a\n     * successful readlink, or undefined otherwise.\n     *\n     * Does not read the filesystem, so an undefined result *could* just mean we\n     * don't have any cached data. Only use it if you are very sure that a\n     * readlink() has been called at some point.\n     */\n    readlinkCached() {\n        return this.#linkTarget;\n    }\n    /**\n     * Returns the cached realpath target if the entry has been the subject\n     * of a successful realpath, or undefined otherwise.\n     *\n     * Does not read the filesystem, so an undefined result *could* just mean we\n     * don't have any cached data. Only use it if you are very sure that a\n     * realpath() has been called at some point.\n     */\n    realpathCached() {\n        return this.#realpath;\n    }\n    /**\n     * Returns the cached child Path entries array if the entry has been the\n     * subject of a successful readdir(), or [] otherwise.\n     *\n     * Does not read the filesystem, so an empty array *could* just mean we\n     * don't have any cached data. Only use it if you are very sure that a\n     * readdir() has been called recently enough to still be valid.\n     */\n    readdirCached() {\n        const children = this.children();\n        return children.slice(0, children.provisional);\n    }\n    /**\n     * Return true if it's worth trying to readlink.  Ie, we don't (yet) have\n     * any indication that readlink will definitely fail.\n     *\n     * Returns false if the path is known to not be a symlink, if a previous\n     * readlink failed, or if the entry does not exist.\n     */\n    canReadlink() {\n        if (this.#linkTarget)\n            return true;\n        if (!this.parent)\n            return false;\n        // cases where it cannot possibly succeed\n        const ifmt = this.#type & IFMT;\n        return !((ifmt !== UNKNOWN && ifmt !== IFLNK) ||\n            this.#type & ENOREADLINK ||\n            this.#type & ENOENT);\n    }\n    /**\n     * Return true if readdir has previously been successfully called on this\n     * path, indicating that cachedReaddir() is likely valid.\n     */\n    calledReaddir() {\n        return !!(this.#type & READDIR_CALLED);\n    }\n    /**\n     * Returns true if the path is known to not exist. That is, a previous lstat\n     * or readdir failed to verify its existence when that would have been\n     * expected, or a parent entry was marked either enoent or enotdir.\n     */\n    isENOENT() {\n        return !!(this.#type & ENOENT);\n    }\n    /**\n     * Return true if the path is a match for the given path name.  This handles\n     * case sensitivity and unicode normalization.\n     *\n     * Note: even on case-sensitive systems, it is **not** safe to test the\n     * equality of the `.name` property to determine whether a given pathname\n     * matches, due to unicode normalization mismatches.\n     *\n     * Always use this method instead of testing the `path.name` property\n     * directly.\n     */\n    isNamed(n) {\n        return !this.nocase ?\n            this.#matchName === normalize(n)\n            : this.#matchName === normalizeNocase(n);\n    }\n    /**\n     * Return the Path object corresponding to the target of a symbolic link.\n     *\n     * If the Path is not a symbolic link, or if the readlink call fails for any\n     * reason, `undefined` is returned.\n     *\n     * Result is cached, and thus may be outdated if the filesystem is mutated.\n     */\n    async readlink() {\n        const target = this.#linkTarget;\n        if (target) {\n            return target;\n        }\n        if (!this.canReadlink()) {\n            return undefined;\n        }\n        /* c8 ignore start */\n        // already covered by the canReadlink test, here for ts grumples\n        if (!this.parent) {\n            return undefined;\n        }\n        /* c8 ignore stop */\n        try {\n            const read = await this.#fs.promises.readlink(this.fullpath());\n            const linkTarget = (await this.parent.realpath())?.resolve(read);\n            if (linkTarget) {\n                return (this.#linkTarget = linkTarget);\n            }\n        }\n        catch (er) {\n            this.#readlinkFail(er.code);\n            return undefined;\n        }\n    }\n    /**\n     * Synchronous {@link PathBase.readlink}\n     */\n    readlinkSync() {\n        const target = this.#linkTarget;\n        if (target) {\n            return target;\n        }\n        if (!this.canReadlink()) {\n            return undefined;\n        }\n        /* c8 ignore start */\n        // already covered by the canReadlink test, here for ts grumples\n        if (!this.parent) {\n            return undefined;\n        }\n        /* c8 ignore stop */\n        try {\n            const read = this.#fs.readlinkSync(this.fullpath());\n            const linkTarget = this.parent.realpathSync()?.resolve(read);\n            if (linkTarget) {\n                return (this.#linkTarget = linkTarget);\n            }\n        }\n        catch (er) {\n            this.#readlinkFail(er.code);\n            return undefined;\n        }\n    }\n    #readdirSuccess(children) {\n        // succeeded, mark readdir called bit\n        this.#type |= READDIR_CALLED;\n        // mark all remaining provisional children as ENOENT\n        for (let p = children.provisional; p < children.length; p++) {\n            const c = children[p];\n            if (c)\n                c.#markENOENT();\n        }\n    }\n    #markENOENT() {\n        // mark as UNKNOWN and ENOENT\n        if (this.#type & ENOENT)\n            return;\n        this.#type = (this.#type | ENOENT) & IFMT_UNKNOWN;\n        this.#markChildrenENOENT();\n    }\n    #markChildrenENOENT() {\n        // all children are provisional and do not exist\n        const children = this.children();\n        children.provisional = 0;\n        for (const p of children) {\n            p.#markENOENT();\n        }\n    }\n    #markENOREALPATH() {\n        this.#type |= ENOREALPATH;\n        this.#markENOTDIR();\n    }\n    // save the information when we know the entry is not a dir\n    #markENOTDIR() {\n        // entry is not a directory, so any children can't exist.\n        // this *should* be impossible, since any children created\n        // after it's been marked ENOTDIR should be marked ENOENT,\n        // so it won't even get to this point.\n        /* c8 ignore start */\n        if (this.#type & ENOTDIR)\n            return;\n        /* c8 ignore stop */\n        let t = this.#type;\n        // this could happen if we stat a dir, then delete it,\n        // then try to read it or one of its children.\n        if ((t & IFMT) === IFDIR)\n            t &= IFMT_UNKNOWN;\n        this.#type = t | ENOTDIR;\n        this.#markChildrenENOENT();\n    }\n    #readdirFail(code = '') {\n        // markENOTDIR and markENOENT also set provisional=0\n        if (code === 'ENOTDIR' || code === 'EPERM') {\n            this.#markENOTDIR();\n        }\n        else if (code === 'ENOENT') {\n            this.#markENOENT();\n        }\n        else {\n            this.children().provisional = 0;\n        }\n    }\n    #lstatFail(code = '') {\n        // Windows just raises ENOENT in this case, disable for win CI\n        /* c8 ignore start */\n        if (code === 'ENOTDIR') {\n            // already know it has a parent by this point\n            const p = this.parent;\n            p.#markENOTDIR();\n        }\n        else if (code === 'ENOENT') {\n            /* c8 ignore stop */\n            this.#markENOENT();\n        }\n    }\n    #readlinkFail(code = '') {\n        let ter = this.#type;\n        ter |= ENOREADLINK;\n        if (code === 'ENOENT')\n            ter |= ENOENT;\n        // windows gets a weird error when you try to readlink a file\n        if (code === 'EINVAL' || code === 'UNKNOWN') {\n            // exists, but not a symlink, we don't know WHAT it is, so remove\n            // all IFMT bits.\n            ter &= IFMT_UNKNOWN;\n        }\n        this.#type = ter;\n        // windows just gets ENOENT in this case.  We do cover the case,\n        // just disabled because it's impossible on Windows CI\n        /* c8 ignore start */\n        if (code === 'ENOTDIR' && this.parent) {\n            this.parent.#markENOTDIR();\n        }\n        /* c8 ignore stop */\n    }\n    #readdirAddChild(e, c) {\n        return (this.#readdirMaybePromoteChild(e, c) ||\n            this.#readdirAddNewChild(e, c));\n    }\n    #readdirAddNewChild(e, c) {\n        // alloc new entry at head, so it's never provisional\n        const type = entToType(e);\n        const child = this.newChild(e.name, type, { parent: this });\n        const ifmt = child.#type & IFMT;\n        if (ifmt !== IFDIR && ifmt !== IFLNK && ifmt !== UNKNOWN) {\n            child.#type |= ENOTDIR;\n        }\n        c.unshift(child);\n        c.provisional++;\n        return child;\n    }\n    #readdirMaybePromoteChild(e, c) {\n        for (let p = c.provisional; p < c.length; p++) {\n            const pchild = c[p];\n            const name = this.nocase ? normalizeNocase(e.name) : normalize(e.name);\n            if (name !== pchild.#matchName) {\n                continue;\n            }\n            return this.#readdirPromoteChild(e, pchild, p, c);\n        }\n    }\n    #readdirPromoteChild(e, p, index, c) {\n        const v = p.name;\n        // retain any other flags, but set ifmt from dirent\n        p.#type = (p.#type & IFMT_UNKNOWN) | entToType(e);\n        // case sensitivity fixing when we learn the true name.\n        if (v !== e.name)\n            p.name = e.name;\n        // just advance provisional index (potentially off the list),\n        // otherwise we have to splice/pop it out and re-insert at head\n        if (index !== c.provisional) {\n            if (index === c.length - 1)\n                c.pop();\n            else\n                c.splice(index, 1);\n            c.unshift(p);\n        }\n        c.provisional++;\n        return p;\n    }\n    /**\n     * Call lstat() on this Path, and update all known information that can be\n     * determined.\n     *\n     * Note that unlike `fs.lstat()`, the returned value does not contain some\n     * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that\n     * information is required, you will need to call `fs.lstat` yourself.\n     *\n     * If the Path refers to a nonexistent file, or if the lstat call fails for\n     * any reason, `undefined` is returned.  Otherwise the updated Path object is\n     * returned.\n     *\n     * Results are cached, and thus may be out of date if the filesystem is\n     * mutated.\n     */\n    async lstat() {\n        if ((this.#type & ENOENT) === 0) {\n            try {\n                this.#applyStat(await this.#fs.promises.lstat(this.fullpath()));\n                return this;\n            }\n            catch (er) {\n                this.#lstatFail(er.code);\n            }\n        }\n    }\n    /**\n     * synchronous {@link PathBase.lstat}\n     */\n    lstatSync() {\n        if ((this.#type & ENOENT) === 0) {\n            try {\n                this.#applyStat(this.#fs.lstatSync(this.fullpath()));\n                return this;\n            }\n            catch (er) {\n                this.#lstatFail(er.code);\n            }\n        }\n    }\n    #applyStat(st) {\n        const { atime, atimeMs, birthtime, birthtimeMs, blksize, blocks, ctime, ctimeMs, dev, gid, ino, mode, mtime, mtimeMs, nlink, rdev, size, uid, } = st;\n        this.#atime = atime;\n        this.#atimeMs = atimeMs;\n        this.#birthtime = birthtime;\n        this.#birthtimeMs = birthtimeMs;\n        this.#blksize = blksize;\n        this.#blocks = blocks;\n        this.#ctime = ctime;\n        this.#ctimeMs = ctimeMs;\n        this.#dev = dev;\n        this.#gid = gid;\n        this.#ino = ino;\n        this.#mode = mode;\n        this.#mtime = mtime;\n        this.#mtimeMs = mtimeMs;\n        this.#nlink = nlink;\n        this.#rdev = rdev;\n        this.#size = size;\n        this.#uid = uid;\n        const ifmt = entToType(st);\n        // retain any other flags, but set the ifmt\n        this.#type = (this.#type & IFMT_UNKNOWN) | ifmt | LSTAT_CALLED;\n        if (ifmt !== UNKNOWN && ifmt !== IFDIR && ifmt !== IFLNK) {\n            this.#type |= ENOTDIR;\n        }\n    }\n    #onReaddirCB = [];\n    #readdirCBInFlight = false;\n    #callOnReaddirCB(children) {\n        this.#readdirCBInFlight = false;\n        const cbs = this.#onReaddirCB.slice();\n        this.#onReaddirCB.length = 0;\n        cbs.forEach(cb => cb(null, children));\n    }\n    /**\n     * Standard node-style callback interface to get list of directory entries.\n     *\n     * If the Path cannot or does not contain any children, then an empty array\n     * is returned.\n     *\n     * Results are cached, and thus may be out of date if the filesystem is\n     * mutated.\n     *\n     * @param cb The callback called with (er, entries).  Note that the `er`\n     * param is somewhat extraneous, as all readdir() errors are handled and\n     * simply result in an empty set of entries being returned.\n     * @param allowZalgo Boolean indicating that immediately known results should\n     * *not* be deferred with `queueMicrotask`. Defaults to `false`. Release\n     * zalgo at your peril, the dark pony lord is devious and unforgiving.\n     */\n    readdirCB(cb, allowZalgo = false) {\n        if (!this.canReaddir()) {\n            if (allowZalgo)\n                cb(null, []);\n            else\n                queueMicrotask(() => cb(null, []));\n            return;\n        }\n        const children = this.children();\n        if (this.calledReaddir()) {\n            const c = children.slice(0, children.provisional);\n            if (allowZalgo)\n                cb(null, c);\n            else\n                queueMicrotask(() => cb(null, c));\n            return;\n        }\n        // don't have to worry about zalgo at this point.\n        this.#onReaddirCB.push(cb);\n        if (this.#readdirCBInFlight) {\n            return;\n        }\n        this.#readdirCBInFlight = true;\n        // else read the directory, fill up children\n        // de-provisionalize any provisional children.\n        const fullpath = this.fullpath();\n        this.#fs.readdir(fullpath, { withFileTypes: true }, (er, entries) => {\n            if (er) {\n                this.#readdirFail(er.code);\n                children.provisional = 0;\n            }\n            else {\n                // if we didn't get an error, we always get entries.\n                //@ts-ignore\n                for (const e of entries) {\n                    this.#readdirAddChild(e, children);\n                }\n                this.#readdirSuccess(children);\n            }\n            this.#callOnReaddirCB(children.slice(0, children.provisional));\n            return;\n        });\n    }\n    #asyncReaddirInFlight;\n    /**\n     * Return an array of known child entries.\n     *\n     * If the Path cannot or does not contain any children, then an empty array\n     * is returned.\n     *\n     * Results are cached, and thus may be out of date if the filesystem is\n     * mutated.\n     */\n    async readdir() {\n        if (!this.canReaddir()) {\n            return [];\n        }\n        const children = this.children();\n        if (this.calledReaddir()) {\n            return children.slice(0, children.provisional);\n        }\n        // else read the directory, fill up children\n        // de-provisionalize any provisional children.\n        const fullpath = this.fullpath();\n        if (this.#asyncReaddirInFlight) {\n            await this.#asyncReaddirInFlight;\n        }\n        else {\n            /* c8 ignore start */\n            let resolve = () => { };\n            /* c8 ignore stop */\n            this.#asyncReaddirInFlight = new Promise(res => (resolve = res));\n            try {\n                for (const e of await this.#fs.promises.readdir(fullpath, {\n                    withFileTypes: true,\n                })) {\n                    this.#readdirAddChild(e, children);\n                }\n                this.#readdirSuccess(children);\n            }\n            catch (er) {\n                this.#readdirFail(er.code);\n                children.provisional = 0;\n            }\n            this.#asyncReaddirInFlight = undefined;\n            resolve();\n        }\n        return children.slice(0, children.provisional);\n    }\n    /**\n     * synchronous {@link PathBase.readdir}\n     */\n    readdirSync() {\n        if (!this.canReaddir()) {\n            return [];\n        }\n        const children = this.children();\n        if (this.calledReaddir()) {\n            return children.slice(0, children.provisional);\n        }\n        // else read the directory, fill up children\n        // de-provisionalize any provisional children.\n        const fullpath = this.fullpath();\n        try {\n            for (const e of this.#fs.readdirSync(fullpath, {\n                withFileTypes: true,\n            })) {\n                this.#readdirAddChild(e, children);\n            }\n            this.#readdirSuccess(children);\n        }\n        catch (er) {\n            this.#readdirFail(er.code);\n            children.provisional = 0;\n        }\n        return children.slice(0, children.provisional);\n    }\n    canReaddir() {\n        if (this.#type & ENOCHILD)\n            return false;\n        const ifmt = IFMT & this.#type;\n        // we always set ENOTDIR when setting IFMT, so should be impossible\n        /* c8 ignore start */\n        if (!(ifmt === UNKNOWN || ifmt === IFDIR || ifmt === IFLNK)) {\n            return false;\n        }\n        /* c8 ignore stop */\n        return true;\n    }\n    shouldWalk(dirs, walkFilter) {\n        return ((this.#type & IFDIR) === IFDIR &&\n            !(this.#type & ENOCHILD) &&\n            !dirs.has(this) &&\n            (!walkFilter || walkFilter(this)));\n    }\n    /**\n     * Return the Path object corresponding to path as resolved\n     * by realpath(3).\n     *\n     * If the realpath call fails for any reason, `undefined` is returned.\n     *\n     * Result is cached, and thus may be outdated if the filesystem is mutated.\n     * On success, returns a Path object.\n     */\n    async realpath() {\n        if (this.#realpath)\n            return this.#realpath;\n        if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)\n            return undefined;\n        try {\n            const rp = await this.#fs.promises.realpath(this.fullpath());\n            return (this.#realpath = this.resolve(rp));\n        }\n        catch (_) {\n            this.#markENOREALPATH();\n        }\n    }\n    /**\n     * Synchronous {@link realpath}\n     */\n    realpathSync() {\n        if (this.#realpath)\n            return this.#realpath;\n        if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)\n            return undefined;\n        try {\n            const rp = this.#fs.realpathSync(this.fullpath());\n            return (this.#realpath = this.resolve(rp));\n        }\n        catch (_) {\n            this.#markENOREALPATH();\n        }\n    }\n    /**\n     * Internal method to mark this Path object as the scurry cwd,\n     * called by {@link PathScurry#chdir}\n     *\n     * @internal\n     */\n    [setAsCwd](oldCwd) {\n        if (oldCwd === this)\n            return;\n        oldCwd.isCWD = false;\n        this.isCWD = true;\n        const changed = new Set([]);\n        let rp = [];\n        let p = this;\n        while (p && p.parent) {\n            changed.add(p);\n            p.#relative = rp.join(this.sep);\n            p.#relativePosix = rp.join('/');\n            p = p.parent;\n            rp.push('..');\n        }\n        // now un-memoize parents of old cwd\n        p = oldCwd;\n        while (p && p.parent && !changed.has(p)) {\n            p.#relative = undefined;\n            p.#relativePosix = undefined;\n            p = p.parent;\n        }\n    }\n}\n/**\n * Path class used on win32 systems\n *\n * Uses `'\\\\'` as the path separator for returned paths, either `'\\\\'` or `'/'`\n * as the path separator for parsing paths.\n */\nclass PathWin32 extends PathBase {\n    /**\n     * Separator for generating path strings.\n     */\n    sep = '\\\\';\n    /**\n     * Separator for parsing path strings.\n     */\n    splitSep = eitherSep;\n    /**\n     * Do not create new Path objects directly.  They should always be accessed\n     * via the PathScurry class or other methods on the Path class.\n     *\n     * @internal\n     */\n    constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {\n        super(name, type, root, roots, nocase, children, opts);\n    }\n    /**\n     * @internal\n     */\n    newChild(name, type = UNKNOWN, opts = {}) {\n        return new PathWin32(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);\n    }\n    /**\n     * @internal\n     */\n    getRootString(path) {\n        return node_path__WEBPACK_IMPORTED_MODULE_1__.win32.parse(path).root;\n    }\n    /**\n     * @internal\n     */\n    getRoot(rootPath) {\n        rootPath = uncToDrive(rootPath.toUpperCase());\n        if (rootPath === this.root.name) {\n            return this.root;\n        }\n        // ok, not that one, check if it matches another we know about\n        for (const [compare, root] of Object.entries(this.roots)) {\n            if (this.sameRoot(rootPath, compare)) {\n                return (this.roots[rootPath] = root);\n            }\n        }\n        // otherwise, have to create a new one.\n        return (this.roots[rootPath] = new PathScurryWin32(rootPath, this).root);\n    }\n    /**\n     * @internal\n     */\n    sameRoot(rootPath, compare = this.root.name) {\n        // windows can (rarely) have case-sensitive filesystem, but\n        // UNC and drive letters are always case-insensitive, and canonically\n        // represented uppercase.\n        rootPath = rootPath\n            .toUpperCase()\n            .replace(/\\//g, '\\\\')\n            .replace(uncDriveRegexp, '$1\\\\');\n        return rootPath === compare;\n    }\n}\n/**\n * Path class used on all posix systems.\n *\n * Uses `'/'` as the path separator.\n */\nclass PathPosix extends PathBase {\n    /**\n     * separator for parsing path strings\n     */\n    splitSep = '/';\n    /**\n     * separator for generating path strings\n     */\n    sep = '/';\n    /**\n     * Do not create new Path objects directly.  They should always be accessed\n     * via the PathScurry class or other methods on the Path class.\n     *\n     * @internal\n     */\n    constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {\n        super(name, type, root, roots, nocase, children, opts);\n    }\n    /**\n     * @internal\n     */\n    getRootString(path) {\n        return path.startsWith('/') ? '/' : '';\n    }\n    /**\n     * @internal\n     */\n    getRoot(_rootPath) {\n        return this.root;\n    }\n    /**\n     * @internal\n     */\n    newChild(name, type = UNKNOWN, opts = {}) {\n        return new PathPosix(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);\n    }\n}\n/**\n * The base class for all PathScurry classes, providing the interface for path\n * resolution and filesystem operations.\n *\n * Typically, you should *not* instantiate this class directly, but rather one\n * of the platform-specific classes, or the exported {@link PathScurry} which\n * defaults to the current platform.\n */\nclass PathScurryBase {\n    /**\n     * The root Path entry for the current working directory of this Scurry\n     */\n    root;\n    /**\n     * The string path for the root of this Scurry's current working directory\n     */\n    rootPath;\n    /**\n     * A collection of all roots encountered, referenced by rootPath\n     */\n    roots;\n    /**\n     * The Path entry corresponding to this PathScurry's current working directory.\n     */\n    cwd;\n    #resolveCache;\n    #resolvePosixCache;\n    #children;\n    /**\n     * Perform path comparisons case-insensitively.\n     *\n     * Defaults true on Darwin and Windows systems, false elsewhere.\n     */\n    nocase;\n    #fs;\n    /**\n     * This class should not be instantiated directly.\n     *\n     * Use PathScurryWin32, PathScurryDarwin, PathScurryPosix, or PathScurry\n     *\n     * @internal\n     */\n    constructor(cwd = process.cwd(), pathImpl, sep, { nocase, childrenCacheSize = 16 * 1024, fs = defaultFS, } = {}) {\n        this.#fs = fsFromOption(fs);\n        if (cwd instanceof URL || cwd.startsWith('file://')) {\n            cwd = (0,node_url__WEBPACK_IMPORTED_MODULE_2__.fileURLToPath)(cwd);\n        }\n        // resolve and split root, and then add to the store.\n        // this is the only time we call path.resolve()\n        const cwdPath = pathImpl.resolve(cwd);\n        this.roots = Object.create(null);\n        this.rootPath = this.parseRootPath(cwdPath);\n        this.#resolveCache = new ResolveCache();\n        this.#resolvePosixCache = new ResolveCache();\n        this.#children = new ChildrenCache(childrenCacheSize);\n        const split = cwdPath.substring(this.rootPath.length).split(sep);\n        // resolve('/') leaves '', splits to [''], we don't want that.\n        if (split.length === 1 && !split[0]) {\n            split.pop();\n        }\n        /* c8 ignore start */\n        if (nocase === undefined) {\n            throw new TypeError('must provide nocase setting to PathScurryBase ctor');\n        }\n        /* c8 ignore stop */\n        this.nocase = nocase;\n        this.root = this.newRoot(this.#fs);\n        this.roots[this.rootPath] = this.root;\n        let prev = this.root;\n        let len = split.length - 1;\n        const joinSep = pathImpl.sep;\n        let abs = this.rootPath;\n        let sawFirst = false;\n        for (const part of split) {\n            const l = len--;\n            prev = prev.child(part, {\n                relative: new Array(l).fill('..').join(joinSep),\n                relativePosix: new Array(l).fill('..').join('/'),\n                fullpath: (abs += (sawFirst ? '' : joinSep) + part),\n            });\n            sawFirst = true;\n        }\n        this.cwd = prev;\n    }\n    /**\n     * Get the depth of a provided path, string, or the cwd\n     */\n    depth(path = this.cwd) {\n        if (typeof path === 'string') {\n            path = this.cwd.resolve(path);\n        }\n        return path.depth();\n    }\n    /**\n     * Return the cache of child entries.  Exposed so subclasses can create\n     * child Path objects in a platform-specific way.\n     *\n     * @internal\n     */\n    childrenCache() {\n        return this.#children;\n    }\n    /**\n     * Resolve one or more path strings to a resolved string\n     *\n     * Same interface as require('path').resolve.\n     *\n     * Much faster than path.resolve() when called multiple times for the same\n     * path, because the resolved Path objects are cached.  Much slower\n     * otherwise.\n     */\n    resolve(...paths) {\n        // first figure out the minimum number of paths we have to test\n        // we always start at cwd, but any absolutes will bump the start\n        let r = '';\n        for (let i = paths.length - 1; i >= 0; i--) {\n            const p = paths[i];\n            if (!p || p === '.')\n                continue;\n            r = r ? `${p}/${r}` : p;\n            if (this.isAbsolute(p)) {\n                break;\n            }\n        }\n        const cached = this.#resolveCache.get(r);\n        if (cached !== undefined) {\n            return cached;\n        }\n        const result = this.cwd.resolve(r).fullpath();\n        this.#resolveCache.set(r, result);\n        return result;\n    }\n    /**\n     * Resolve one or more path strings to a resolved string, returning\n     * the posix path.  Identical to .resolve() on posix systems, but on\n     * windows will return a forward-slash separated UNC path.\n     *\n     * Same interface as require('path').resolve.\n     *\n     * Much faster than path.resolve() when called multiple times for the same\n     * path, because the resolved Path objects are cached.  Much slower\n     * otherwise.\n     */\n    resolvePosix(...paths) {\n        // first figure out the minimum number of paths we have to test\n        // we always start at cwd, but any absolutes will bump the start\n        let r = '';\n        for (let i = paths.length - 1; i >= 0; i--) {\n            const p = paths[i];\n            if (!p || p === '.')\n                continue;\n            r = r ? `${p}/${r}` : p;\n            if (this.isAbsolute(p)) {\n                break;\n            }\n        }\n        const cached = this.#resolvePosixCache.get(r);\n        if (cached !== undefined) {\n            return cached;\n        }\n        const result = this.cwd.resolve(r).fullpathPosix();\n        this.#resolvePosixCache.set(r, result);\n        return result;\n    }\n    /**\n     * find the relative path from the cwd to the supplied path string or entry\n     */\n    relative(entry = this.cwd) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        return entry.relative();\n    }\n    /**\n     * find the relative path from the cwd to the supplied path string or\n     * entry, using / as the path delimiter, even on Windows.\n     */\n    relativePosix(entry = this.cwd) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        return entry.relativePosix();\n    }\n    /**\n     * Return the basename for the provided string or Path object\n     */\n    basename(entry = this.cwd) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        return entry.name;\n    }\n    /**\n     * Return the dirname for the provided string or Path object\n     */\n    dirname(entry = this.cwd) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        return (entry.parent || entry).fullpath();\n    }\n    async readdir(entry = this.cwd, opts = {\n        withFileTypes: true,\n    }) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        else if (!(entry instanceof PathBase)) {\n            opts = entry;\n            entry = this.cwd;\n        }\n        const { withFileTypes } = opts;\n        if (!entry.canReaddir()) {\n            return [];\n        }\n        else {\n            const p = await entry.readdir();\n            return withFileTypes ? p : p.map(e => e.name);\n        }\n    }\n    readdirSync(entry = this.cwd, opts = {\n        withFileTypes: true,\n    }) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        else if (!(entry instanceof PathBase)) {\n            opts = entry;\n            entry = this.cwd;\n        }\n        const { withFileTypes = true } = opts;\n        if (!entry.canReaddir()) {\n            return [];\n        }\n        else if (withFileTypes) {\n            return entry.readdirSync();\n        }\n        else {\n            return entry.readdirSync().map(e => e.name);\n        }\n    }\n    /**\n     * Call lstat() on the string or Path object, and update all known\n     * information that can be determined.\n     *\n     * Note that unlike `fs.lstat()`, the returned value does not contain some\n     * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that\n     * information is required, you will need to call `fs.lstat` yourself.\n     *\n     * If the Path refers to a nonexistent file, or if the lstat call fails for\n     * any reason, `undefined` is returned.  Otherwise the updated Path object is\n     * returned.\n     *\n     * Results are cached, and thus may be out of date if the filesystem is\n     * mutated.\n     */\n    async lstat(entry = this.cwd) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        return entry.lstat();\n    }\n    /**\n     * synchronous {@link PathScurryBase.lstat}\n     */\n    lstatSync(entry = this.cwd) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        return entry.lstatSync();\n    }\n    async readlink(entry = this.cwd, { withFileTypes } = {\n        withFileTypes: false,\n    }) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        else if (!(entry instanceof PathBase)) {\n            withFileTypes = entry.withFileTypes;\n            entry = this.cwd;\n        }\n        const e = await entry.readlink();\n        return withFileTypes ? e : e?.fullpath();\n    }\n    readlinkSync(entry = this.cwd, { withFileTypes } = {\n        withFileTypes: false,\n    }) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        else if (!(entry instanceof PathBase)) {\n            withFileTypes = entry.withFileTypes;\n            entry = this.cwd;\n        }\n        const e = entry.readlinkSync();\n        return withFileTypes ? e : e?.fullpath();\n    }\n    async realpath(entry = this.cwd, { withFileTypes } = {\n        withFileTypes: false,\n    }) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        else if (!(entry instanceof PathBase)) {\n            withFileTypes = entry.withFileTypes;\n            entry = this.cwd;\n        }\n        const e = await entry.realpath();\n        return withFileTypes ? e : e?.fullpath();\n    }\n    realpathSync(entry = this.cwd, { withFileTypes } = {\n        withFileTypes: false,\n    }) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        else if (!(entry instanceof PathBase)) {\n            withFileTypes = entry.withFileTypes;\n            entry = this.cwd;\n        }\n        const e = entry.realpathSync();\n        return withFileTypes ? e : e?.fullpath();\n    }\n    async walk(entry = this.cwd, opts = {}) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        else if (!(entry instanceof PathBase)) {\n            opts = entry;\n            entry = this.cwd;\n        }\n        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;\n        const results = [];\n        if (!filter || filter(entry)) {\n            results.push(withFileTypes ? entry : entry.fullpath());\n        }\n        const dirs = new Set();\n        const walk = (dir, cb) => {\n            dirs.add(dir);\n            dir.readdirCB((er, entries) => {\n                /* c8 ignore start */\n                if (er) {\n                    return cb(er);\n                }\n                /* c8 ignore stop */\n                let len = entries.length;\n                if (!len)\n                    return cb();\n                const next = () => {\n                    if (--len === 0) {\n                        cb();\n                    }\n                };\n                for (const e of entries) {\n                    if (!filter || filter(e)) {\n                        results.push(withFileTypes ? e : e.fullpath());\n                    }\n                    if (follow && e.isSymbolicLink()) {\n                        e.realpath()\n                            .then(r => (r?.isUnknown() ? r.lstat() : r))\n                            .then(r => r?.shouldWalk(dirs, walkFilter) ? walk(r, next) : next());\n                    }\n                    else {\n                        if (e.shouldWalk(dirs, walkFilter)) {\n                            walk(e, next);\n                        }\n                        else {\n                            next();\n                        }\n                    }\n                }\n            }, true); // zalgooooooo\n        };\n        const start = entry;\n        return new Promise((res, rej) => {\n            walk(start, er => {\n                /* c8 ignore start */\n                if (er)\n                    return rej(er);\n                /* c8 ignore stop */\n                res(results);\n            });\n        });\n    }\n    walkSync(entry = this.cwd, opts = {}) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        else if (!(entry instanceof PathBase)) {\n            opts = entry;\n            entry = this.cwd;\n        }\n        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;\n        const results = [];\n        if (!filter || filter(entry)) {\n            results.push(withFileTypes ? entry : entry.fullpath());\n        }\n        const dirs = new Set([entry]);\n        for (const dir of dirs) {\n            const entries = dir.readdirSync();\n            for (const e of entries) {\n                if (!filter || filter(e)) {\n                    results.push(withFileTypes ? e : e.fullpath());\n                }\n                let r = e;\n                if (e.isSymbolicLink()) {\n                    if (!(follow && (r = e.realpathSync())))\n                        continue;\n                    if (r.isUnknown())\n                        r.lstatSync();\n                }\n                if (r.shouldWalk(dirs, walkFilter)) {\n                    dirs.add(r);\n                }\n            }\n        }\n        return results;\n    }\n    /**\n     * Support for `for await`\n     *\n     * Alias for {@link PathScurryBase.iterate}\n     *\n     * Note: As of Node 19, this is very slow, compared to other methods of\n     * walking.  Consider using {@link PathScurryBase.stream} if memory overhead\n     * and backpressure are concerns, or {@link PathScurryBase.walk} if not.\n     */\n    [Symbol.asyncIterator]() {\n        return this.iterate();\n    }\n    iterate(entry = this.cwd, options = {}) {\n        // iterating async over the stream is significantly more performant,\n        // especially in the warm-cache scenario, because it buffers up directory\n        // entries in the background instead of waiting for a yield for each one.\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        else if (!(entry instanceof PathBase)) {\n            options = entry;\n            entry = this.cwd;\n        }\n        return this.stream(entry, options)[Symbol.asyncIterator]();\n    }\n    /**\n     * Iterating over a PathScurry performs a synchronous walk.\n     *\n     * Alias for {@link PathScurryBase.iterateSync}\n     */\n    [Symbol.iterator]() {\n        return this.iterateSync();\n    }\n    *iterateSync(entry = this.cwd, opts = {}) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        else if (!(entry instanceof PathBase)) {\n            opts = entry;\n            entry = this.cwd;\n        }\n        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;\n        if (!filter || filter(entry)) {\n            yield withFileTypes ? entry : entry.fullpath();\n        }\n        const dirs = new Set([entry]);\n        for (const dir of dirs) {\n            const entries = dir.readdirSync();\n            for (const e of entries) {\n                if (!filter || filter(e)) {\n                    yield withFileTypes ? e : e.fullpath();\n                }\n                let r = e;\n                if (e.isSymbolicLink()) {\n                    if (!(follow && (r = e.realpathSync())))\n                        continue;\n                    if (r.isUnknown())\n                        r.lstatSync();\n                }\n                if (r.shouldWalk(dirs, walkFilter)) {\n                    dirs.add(r);\n                }\n            }\n        }\n    }\n    stream(entry = this.cwd, opts = {}) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        else if (!(entry instanceof PathBase)) {\n            opts = entry;\n            entry = this.cwd;\n        }\n        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;\n        const results = new minipass__WEBPACK_IMPORTED_MODULE_6__.Minipass({ objectMode: true });\n        if (!filter || filter(entry)) {\n            results.write(withFileTypes ? entry : entry.fullpath());\n        }\n        const dirs = new Set();\n        const queue = [entry];\n        let processing = 0;\n        const process = () => {\n            let paused = false;\n            while (!paused) {\n                const dir = queue.shift();\n                if (!dir) {\n                    if (processing === 0)\n                        results.end();\n                    return;\n                }\n                processing++;\n                dirs.add(dir);\n                const onReaddir = (er, entries, didRealpaths = false) => {\n                    /* c8 ignore start */\n                    if (er)\n                        return results.emit('error', er);\n                    /* c8 ignore stop */\n                    if (follow && !didRealpaths) {\n                        const promises = [];\n                        for (const e of entries) {\n                            if (e.isSymbolicLink()) {\n                                promises.push(e\n                                    .realpath()\n                                    .then((r) => r?.isUnknown() ? r.lstat() : r));\n                            }\n                        }\n                        if (promises.length) {\n                            Promise.all(promises).then(() => onReaddir(null, entries, true));\n                            return;\n                        }\n                    }\n                    for (const e of entries) {\n                        if (e && (!filter || filter(e))) {\n                            if (!results.write(withFileTypes ? e : e.fullpath())) {\n                                paused = true;\n                            }\n                        }\n                    }\n                    processing--;\n                    for (const e of entries) {\n                        const r = e.realpathCached() || e;\n                        if (r.shouldWalk(dirs, walkFilter)) {\n                            queue.push(r);\n                        }\n                    }\n                    if (paused && !results.flowing) {\n                        results.once('drain', process);\n                    }\n                    else if (!sync) {\n                        process();\n                    }\n                };\n                // zalgo containment\n                let sync = true;\n                dir.readdirCB(onReaddir, true);\n                sync = false;\n            }\n        };\n        process();\n        return results;\n    }\n    streamSync(entry = this.cwd, opts = {}) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        else if (!(entry instanceof PathBase)) {\n            opts = entry;\n            entry = this.cwd;\n        }\n        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;\n        const results = new minipass__WEBPACK_IMPORTED_MODULE_6__.Minipass({ objectMode: true });\n        const dirs = new Set();\n        if (!filter || filter(entry)) {\n            results.write(withFileTypes ? entry : entry.fullpath());\n        }\n        const queue = [entry];\n        let processing = 0;\n        const process = () => {\n            let paused = false;\n            while (!paused) {\n                const dir = queue.shift();\n                if (!dir) {\n                    if (processing === 0)\n                        results.end();\n                    return;\n                }\n                processing++;\n                dirs.add(dir);\n                const entries = dir.readdirSync();\n                for (const e of entries) {\n                    if (!filter || filter(e)) {\n                        if (!results.write(withFileTypes ? e : e.fullpath())) {\n                            paused = true;\n                        }\n                    }\n                }\n                processing--;\n                for (const e of entries) {\n                    let r = e;\n                    if (e.isSymbolicLink()) {\n                        if (!(follow && (r = e.realpathSync())))\n                            continue;\n                        if (r.isUnknown())\n                            r.lstatSync();\n                    }\n                    if (r.shouldWalk(dirs, walkFilter)) {\n                        queue.push(r);\n                    }\n                }\n            }\n            if (paused && !results.flowing)\n                results.once('drain', process);\n        };\n        process();\n        return results;\n    }\n    chdir(path = this.cwd) {\n        const oldCwd = this.cwd;\n        this.cwd = typeof path === 'string' ? this.cwd.resolve(path) : path;\n        this.cwd[setAsCwd](oldCwd);\n    }\n}\n/**\n * Windows implementation of {@link PathScurryBase}\n *\n * Defaults to case insensitve, uses `'\\\\'` to generate path strings.  Uses\n * {@link PathWin32} for Path objects.\n */\nclass PathScurryWin32 extends PathScurryBase {\n    /**\n     * separator for generating path strings\n     */\n    sep = '\\\\';\n    constructor(cwd = process.cwd(), opts = {}) {\n        const { nocase = true } = opts;\n        super(cwd, node_path__WEBPACK_IMPORTED_MODULE_1__.win32, '\\\\', { ...opts, nocase });\n        this.nocase = nocase;\n        for (let p = this.cwd; p; p = p.parent) {\n            p.nocase = this.nocase;\n        }\n    }\n    /**\n     * @internal\n     */\n    parseRootPath(dir) {\n        // if the path starts with a single separator, it's not a UNC, and we'll\n        // just get separator as the root, and driveFromUNC will return \\\n        // In that case, mount \\ on the root from the cwd.\n        return node_path__WEBPACK_IMPORTED_MODULE_1__.win32.parse(dir).root.toUpperCase();\n    }\n    /**\n     * @internal\n     */\n    newRoot(fs) {\n        return new PathWin32(this.rootPath, IFDIR, undefined, this.roots, this.nocase, this.childrenCache(), { fs });\n    }\n    /**\n     * Return true if the provided path string is an absolute path\n     */\n    isAbsolute(p) {\n        return (p.startsWith('/') || p.startsWith('\\\\') || /^[a-z]:(\\/|\\\\)/i.test(p));\n    }\n}\n/**\n * {@link PathScurryBase} implementation for all posix systems other than Darwin.\n *\n * Defaults to case-sensitive matching, uses `'/'` to generate path strings.\n *\n * Uses {@link PathPosix} for Path objects.\n */\nclass PathScurryPosix extends PathScurryBase {\n    /**\n     * separator for generating path strings\n     */\n    sep = '/';\n    constructor(cwd = process.cwd(), opts = {}) {\n        const { nocase = false } = opts;\n        super(cwd, node_path__WEBPACK_IMPORTED_MODULE_1__.posix, '/', { ...opts, nocase });\n        this.nocase = nocase;\n    }\n    /**\n     * @internal\n     */\n    parseRootPath(_dir) {\n        return '/';\n    }\n    /**\n     * @internal\n     */\n    newRoot(fs) {\n        return new PathPosix(this.rootPath, IFDIR, undefined, this.roots, this.nocase, this.childrenCache(), { fs });\n    }\n    /**\n     * Return true if the provided path string is an absolute path\n     */\n    isAbsolute(p) {\n        return p.startsWith('/');\n    }\n}\n/**\n * {@link PathScurryBase} implementation for Darwin (macOS) systems.\n *\n * Defaults to case-insensitive matching, uses `'/'` for generating path\n * strings.\n *\n * Uses {@link PathPosix} for Path objects.\n */\nclass PathScurryDarwin extends PathScurryPosix {\n    constructor(cwd = process.cwd(), opts = {}) {\n        const { nocase = true } = opts;\n        super(cwd, { ...opts, nocase });\n    }\n}\n/**\n * Default {@link PathBase} implementation for the current platform.\n *\n * {@link PathWin32} on Windows systems, {@link PathPosix} on all others.\n */\nconst Path = process.platform === 'win32' ? PathWin32 : PathPosix;\n/**\n * Default {@link PathScurryBase} implementation for the current platform.\n *\n * {@link PathScurryWin32} on Windows systems, {@link PathScurryDarwin} on\n * Darwin (macOS) systems, {@link PathScurryPosix} on all others.\n */\nconst PathScurry = process.platform === 'win32' ? PathScurryWin32\n    : process.platform === 'darwin' ? PathScurryDarwin\n        : PathScurryPosix;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZTJiL25vZGVfbW9kdWxlcy9wYXRoLXNjdXJyeS9kaXN0L2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXFDO0FBQ0k7QUFDQTtBQUM2RDtBQUNsRTtBQUNwQyxxQkFBcUIsNENBQUc7QUFDeEI7QUFDQTtBQUNzRTtBQUNsQztBQUNwQztBQUNBLGFBQWE7QUFDYixhQUFhLHVDQUFTO0FBQ3RCLGVBQWU7QUFDZixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGFBQWE7QUFDYixlQUFlO0FBQ2YsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixLQUFLO0FBQ0w7QUFDQTtBQUNBLHVGQUF1RiwrTEFBUTtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywyQkFBMkIsK0NBQVE7QUFDMUM7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sNEJBQTRCLCtDQUFRO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZUFBZTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxnQkFBZ0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELEVBQUU7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLEtBQUs7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHFCQUFxQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxjQUFjO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix3SUFBd0k7QUFDeEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHFCQUFxQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNENBQUs7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxrQkFBa0I7QUFDeEU7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELHlEQUF5RCxJQUFJO0FBQ25IO0FBQ0E7QUFDQSxrQkFBa0IsdURBQWE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsUUFBUTtBQUMvQztBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsRUFBRSxHQUFHLEVBQUU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFFBQVE7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLEVBQUUsR0FBRyxFQUFFO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUJBQXVCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsZ0JBQWdCO0FBQ3ZEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGdCQUFnQjtBQUNyRDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxnQkFBZ0I7QUFDdkQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsZ0JBQWdCO0FBQ3JEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDREQUE0RDtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw0REFBNEQ7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGlDQUFpQyw2QkFBNkI7QUFDOUQsMENBQTBDLDJCQUEyQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNERBQTREO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNERBQTREO0FBQzVFLDRCQUE0Qiw4Q0FBUSxHQUFHLGtCQUFrQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNERBQTREO0FBQzVFLDRCQUE0Qiw4Q0FBUSxHQUFHLGtCQUFrQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsSUFBSSxpQkFBaUI7QUFDckI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDLGdCQUFnQixnQkFBZ0I7QUFDaEMsbUJBQW1CLDRDQUFLLFVBQVUsaUJBQWlCO0FBQ25EO0FBQ0EsK0JBQStCLEdBQUc7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDRDQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrR0FBK0csSUFBSTtBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHNCQUFzQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxTQUFTLGlCQUFpQjtBQUMxQjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUMsZ0JBQWdCLGlCQUFpQjtBQUNqQyxtQkFBbUIsNENBQUssU0FBUyxpQkFBaUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0dBQStHLElBQUk7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxzQkFBc0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGlCQUFpQjtBQUMxQjtBQUNPO0FBQ1AsOENBQThDO0FBQzlDLGdCQUFnQixnQkFBZ0I7QUFDaEMscUJBQXFCLGlCQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBLElBQUksaUJBQWlCLHFCQUFxQixpQkFBaUI7QUFDM0Q7QUFDTztBQUNQO0FBQ0EsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQSxJQUFJLHVCQUF1QixxQkFBcUIsd0JBQXdCO0FBQ3hFLDRCQUE0Qix1QkFBdUI7QUFDbkQ7QUFDTztBQUNQO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpdmUtdmliZS1haS1uZXh0Ly4vbm9kZV9tb2R1bGVzL2UyYi9ub2RlX21vZHVsZXMvcGF0aC1zY3VycnkvZGlzdC9lc20vaW5kZXguanM/M2JkMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBMUlVDYWNoZSB9IGZyb20gJ2xydS1jYWNoZSc7XG5pbXBvcnQgeyBwb3NpeCwgd2luMzIgfSBmcm9tICdub2RlOnBhdGgnO1xuaW1wb3J0IHsgZmlsZVVSTFRvUGF0aCB9IGZyb20gJ25vZGU6dXJsJztcbmltcG9ydCB7IGxzdGF0U3luYywgcmVhZGRpciBhcyByZWFkZGlyQ0IsIHJlYWRkaXJTeW5jLCByZWFkbGlua1N5bmMsIHJlYWxwYXRoU3luYyBhcyBycHMsIH0gZnJvbSAnZnMnO1xuaW1wb3J0ICogYXMgYWN0dWFsRlMgZnJvbSAnbm9kZTpmcyc7XG5jb25zdCByZWFscGF0aFN5bmMgPSBycHMubmF0aXZlO1xuLy8gVE9ETzogdGVzdCBwZXJmIG9mIGZzL3Byb21pc2VzIHJlYWxwYXRoIHZzIHJlYWxwYXRoQ0IsXG4vLyBzaW5jZSB0aGUgcHJvbWlzZXMgb25lIHVzZXMgcmVhbHBhdGgubmF0aXZlXG5pbXBvcnQgeyBsc3RhdCwgcmVhZGRpciwgcmVhZGxpbmssIHJlYWxwYXRoIH0gZnJvbSAnbm9kZTpmcy9wcm9taXNlcyc7XG5pbXBvcnQgeyBNaW5pcGFzcyB9IGZyb20gJ21pbmlwYXNzJztcbmNvbnN0IGRlZmF1bHRGUyA9IHtcbiAgICBsc3RhdFN5bmMsXG4gICAgcmVhZGRpcjogcmVhZGRpckNCLFxuICAgIHJlYWRkaXJTeW5jLFxuICAgIHJlYWRsaW5rU3luYyxcbiAgICByZWFscGF0aFN5bmMsXG4gICAgcHJvbWlzZXM6IHtcbiAgICAgICAgbHN0YXQsXG4gICAgICAgIHJlYWRkaXIsXG4gICAgICAgIHJlYWRsaW5rLFxuICAgICAgICByZWFscGF0aCxcbiAgICB9LFxufTtcbi8vIGlmIHRoZXkganVzdCBnYXZlIHVzIHJlcXVpcmUoJ2ZzJykgdGhlbiB1c2Ugb3VyIGRlZmF1bHRcbmNvbnN0IGZzRnJvbU9wdGlvbiA9IChmc09wdGlvbikgPT4gIWZzT3B0aW9uIHx8IGZzT3B0aW9uID09PSBkZWZhdWx0RlMgfHwgZnNPcHRpb24gPT09IGFjdHVhbEZTID9cbiAgICBkZWZhdWx0RlNcbiAgICA6IHtcbiAgICAgICAgLi4uZGVmYXVsdEZTLFxuICAgICAgICAuLi5mc09wdGlvbixcbiAgICAgICAgcHJvbWlzZXM6IHtcbiAgICAgICAgICAgIC4uLmRlZmF1bHRGUy5wcm9taXNlcyxcbiAgICAgICAgICAgIC4uLihmc09wdGlvbi5wcm9taXNlcyB8fCB7fSksXG4gICAgICAgIH0sXG4gICAgfTtcbi8vIHR1cm4gc29tZXRoaW5nIGxpa2UgLy8/L2M6LyBpbnRvIGM6XFxcbmNvbnN0IHVuY0RyaXZlUmVnZXhwID0gL15cXFxcXFxcXFxcP1xcXFwoW2Etel06KVxcXFw/JC9pO1xuY29uc3QgdW5jVG9Ecml2ZSA9IChyb290UGF0aCkgPT4gcm9vdFBhdGgucmVwbGFjZSgvXFwvL2csICdcXFxcJykucmVwbGFjZSh1bmNEcml2ZVJlZ2V4cCwgJyQxXFxcXCcpO1xuLy8gd2luZG93cyBwYXRocyBhcmUgc2VwYXJhdGVkIGJ5IGVpdGhlciAvIG9yIFxcXG5jb25zdCBlaXRoZXJTZXAgPSAvW1xcXFxcXC9dLztcbmNvbnN0IFVOS05PV04gPSAwOyAvLyBtYXkgbm90IGV2ZW4gZXhpc3QsIGZvciBhbGwgd2Uga25vd1xuY29uc3QgSUZJRk8gPSAwYjAwMDE7XG5jb25zdCBJRkNIUiA9IDBiMDAxMDtcbmNvbnN0IElGRElSID0gMGIwMTAwO1xuY29uc3QgSUZCTEsgPSAwYjAxMTA7XG5jb25zdCBJRlJFRyA9IDBiMTAwMDtcbmNvbnN0IElGTE5LID0gMGIxMDEwO1xuY29uc3QgSUZTT0NLID0gMGIxMTAwO1xuY29uc3QgSUZNVCA9IDBiMTExMTtcbi8vIG1hc2sgdG8gdW5zZXQgbG93IDQgYml0c1xuY29uc3QgSUZNVF9VTktOT1dOID0gfklGTVQ7XG4vLyBzZXQgYWZ0ZXIgc3VjY2Vzc2Z1bGx5IGNhbGxpbmcgcmVhZGRpcigpIGFuZCBnZXR0aW5nIGVudHJpZXMuXG5jb25zdCBSRUFERElSX0NBTExFRCA9IDBiMDAwMF8wMDAxXzAwMDA7XG4vLyBzZXQgYWZ0ZXIgYSBzdWNjZXNzZnVsIGxzdGF0KClcbmNvbnN0IExTVEFUX0NBTExFRCA9IDBiMDAwMF8wMDEwXzAwMDA7XG4vLyBzZXQgaWYgYW4gZW50cnkgKG9yIG9uZSBvZiBpdHMgcGFyZW50cykgaXMgZGVmaW5pdGVseSBub3QgYSBkaXJcbmNvbnN0IEVOT1RESVIgPSAwYjAwMDBfMDEwMF8wMDAwO1xuLy8gc2V0IGlmIGFuIGVudHJ5IChvciBvbmUgb2YgaXRzIHBhcmVudHMpIGRvZXMgbm90IGV4aXN0XG4vLyAoY2FuIGFsc28gYmUgc2V0IG9uIGxzdGF0IGVycm9ycyBsaWtlIEVBQ0NFUyBvciBFTkFNRVRPT0xPTkcpXG5jb25zdCBFTk9FTlQgPSAwYjAwMDBfMTAwMF8wMDAwO1xuLy8gY2Fubm90IGhhdmUgY2hpbGQgZW50cmllcyAtLSBhbHNvIHZlcmlmeSAmSUZNVCBpcyBlaXRoZXIgSUZESVIgb3IgSUZMTktcbi8vIHNldCBpZiB3ZSBmYWlsIHRvIHJlYWRsaW5rXG5jb25zdCBFTk9SRUFETElOSyA9IDBiMDAwMV8wMDAwXzAwMDA7XG4vLyBzZXQgaWYgd2Uga25vdyByZWFscGF0aCgpIHdpbGwgZmFpbFxuY29uc3QgRU5PUkVBTFBBVEggPSAwYjAwMTBfMDAwMF8wMDAwO1xuY29uc3QgRU5PQ0hJTEQgPSBFTk9URElSIHwgRU5PRU5UIHwgRU5PUkVBTFBBVEg7XG5jb25zdCBUWVBFTUFTSyA9IDBiMDAxMV8xMTExXzExMTE7XG5jb25zdCBlbnRUb1R5cGUgPSAocykgPT4gcy5pc0ZpbGUoKSA/IElGUkVHXG4gICAgOiBzLmlzRGlyZWN0b3J5KCkgPyBJRkRJUlxuICAgICAgICA6IHMuaXNTeW1ib2xpY0xpbmsoKSA/IElGTE5LXG4gICAgICAgICAgICA6IHMuaXNDaGFyYWN0ZXJEZXZpY2UoKSA/IElGQ0hSXG4gICAgICAgICAgICAgICAgOiBzLmlzQmxvY2tEZXZpY2UoKSA/IElGQkxLXG4gICAgICAgICAgICAgICAgICAgIDogcy5pc1NvY2tldCgpID8gSUZTT0NLXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHMuaXNGSUZPKCkgPyBJRklGT1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogVU5LTk9XTjtcbi8vIG5vcm1hbGl6ZSB1bmljb2RlIHBhdGggbmFtZXNcbmNvbnN0IG5vcm1hbGl6ZUNhY2hlID0gbmV3IE1hcCgpO1xuY29uc3Qgbm9ybWFsaXplID0gKHMpID0+IHtcbiAgICBjb25zdCBjID0gbm9ybWFsaXplQ2FjaGUuZ2V0KHMpO1xuICAgIGlmIChjKVxuICAgICAgICByZXR1cm4gYztcbiAgICBjb25zdCBuID0gcy5ub3JtYWxpemUoJ05GS0QnKTtcbiAgICBub3JtYWxpemVDYWNoZS5zZXQocywgbik7XG4gICAgcmV0dXJuIG47XG59O1xuY29uc3Qgbm9ybWFsaXplTm9jYXNlQ2FjaGUgPSBuZXcgTWFwKCk7XG5jb25zdCBub3JtYWxpemVOb2Nhc2UgPSAocykgPT4ge1xuICAgIGNvbnN0IGMgPSBub3JtYWxpemVOb2Nhc2VDYWNoZS5nZXQocyk7XG4gICAgaWYgKGMpXG4gICAgICAgIHJldHVybiBjO1xuICAgIGNvbnN0IG4gPSBub3JtYWxpemUocy50b0xvd2VyQ2FzZSgpKTtcbiAgICBub3JtYWxpemVOb2Nhc2VDYWNoZS5zZXQocywgbik7XG4gICAgcmV0dXJuIG47XG59O1xuLyoqXG4gKiBBbiBMUlVDYWNoZSBmb3Igc3RvcmluZyByZXNvbHZlZCBwYXRoIHN0cmluZ3Mgb3IgUGF0aCBvYmplY3RzLlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjbGFzcyBSZXNvbHZlQ2FjaGUgZXh0ZW5kcyBMUlVDYWNoZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKHsgbWF4OiAyNTYgfSk7XG4gICAgfVxufVxuLy8gSW4gb3JkZXIgdG8gcHJldmVudCBibG93aW5nIG91dCB0aGUganMgaGVhcCBieSBhbGxvY2F0aW5nIGh1bmRyZWRzIG9mXG4vLyB0aG91c2FuZHMgb2YgUGF0aCBlbnRyaWVzIHdoZW4gd2Fsa2luZyBleHRyZW1lbHkgbGFyZ2UgdHJlZXMsIHRoZSBcImNoaWxkcmVuXCJcbi8vIGluIHRoaXMgdHJlZSBhcmUgcmVwcmVzZW50ZWQgYnkgc3RvcmluZyBhbiBhcnJheSBvZiBQYXRoIGVudHJpZXMgaW4gYW5cbi8vIExSVUNhY2hlLCBpbmRleGVkIGJ5IHRoZSBwYXJlbnQuICBBdCBhbnkgdGltZSwgUGF0aC5jaGlsZHJlbigpIG1heSByZXR1cm4gYW5cbi8vIGVtcHR5IGFycmF5LCBpbmRpY2F0aW5nIHRoYXQgaXQgZG9lc24ndCBrbm93IGFib3V0IGFueSBvZiBpdHMgY2hpbGRyZW4sIGFuZFxuLy8gdGh1cyBoYXMgdG8gcmVidWlsZCB0aGF0IGNhY2hlLiAgVGhpcyBpcyBmaW5lLCBpdCBqdXN0IG1lYW5zIHRoYXQgd2UgZG9uJ3Rcbi8vIGJlbmVmaXQgYXMgbXVjaCBmcm9tIGhhdmluZyB0aGUgY2FjaGVkIGVudHJpZXMsIGJ1dCBodWdlIGRpcmVjdG9yeSB3YWxrc1xuLy8gZG9uJ3QgYmxvdyBvdXQgdGhlIHN0YWNrLCBhbmQgc21hbGxlciBvbmVzIGFyZSBzdGlsbCBhcyBmYXN0IGFzIHBvc3NpYmxlLlxuLy9cbi8vSXQgZG9lcyBpbXBvc2Ugc29tZSBjb21wbGV4aXR5IHdoZW4gYnVpbGRpbmcgdXAgdGhlIHJlYWRkaXIgZGF0YSwgYmVjYXVzZSB3ZVxuLy9uZWVkIHRvIHBhc3MgYSByZWZlcmVuY2UgdG8gdGhlIGNoaWxkcmVuIGFycmF5IHRoYXQgd2Ugc3RhcnRlZCB3aXRoLlxuLyoqXG4gKiBhbiBMUlVDYWNoZSBmb3Igc3RvcmluZyBjaGlsZCBlbnRyaWVzLlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjbGFzcyBDaGlsZHJlbkNhY2hlIGV4dGVuZHMgTFJVQ2FjaGUge1xuICAgIGNvbnN0cnVjdG9yKG1heFNpemUgPSAxNiAqIDEwMjQpIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgbWF4U2l6ZSxcbiAgICAgICAgICAgIC8vIHBhcmVudCArIGNoaWxkcmVuXG4gICAgICAgICAgICBzaXplQ2FsY3VsYXRpb246IGEgPT4gYS5sZW5ndGggKyAxLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5jb25zdCBzZXRBc0N3ZCA9IFN5bWJvbCgnUGF0aFNjdXJyeSBzZXRBc0N3ZCcpO1xuLyoqXG4gKiBQYXRoIG9iamVjdHMgYXJlIHNvcnQgb2YgbGlrZSBhIHN1cGVyLXBvd2VyZWRcbiAqIHtAbGluayBodHRwczovL25vZGVqcy5vcmcvZG9jcy9sYXRlc3QvYXBpL2ZzLmh0bWwjY2xhc3MtZnNkaXJlbnQgZnMuRGlyZW50fVxuICpcbiAqIEVhY2ggb25lIHJlcHJlc2VudHMgYSBzaW5nbGUgZmlsZXN5c3RlbSBlbnRyeSBvbiBkaXNrLCB3aGljaCBtYXkgb3IgbWF5IG5vdFxuICogZXhpc3QuIEl0IGluY2x1ZGVzIG1ldGhvZHMgZm9yIHJlYWRpbmcgdmFyaW91cyB0eXBlcyBvZiBpbmZvcm1hdGlvbiB2aWFcbiAqIGxzdGF0LCByZWFkbGluaywgYW5kIHJlYWRkaXIsIGFuZCBjYWNoZXMgYWxsIGluZm9ybWF0aW9uIHRvIHRoZSBncmVhdGVzdFxuICogZGVncmVlIHBvc3NpYmxlLlxuICpcbiAqIE5vdGUgdGhhdCBmcyBvcGVyYXRpb25zIHRoYXQgd291bGQgbm9ybWFsbHkgdGhyb3cgd2lsbCBpbnN0ZWFkIHJldHVybiBhblxuICogXCJlbXB0eVwiIHZhbHVlLiBUaGlzIGlzIGluIG9yZGVyIHRvIHByZXZlbnQgZXhjZXNzaXZlIG92ZXJoZWFkIGZyb20gZXJyb3JcbiAqIHN0YWNrIHRyYWNlcy5cbiAqL1xuZXhwb3J0IGNsYXNzIFBhdGhCYXNlIHtcbiAgICAvKipcbiAgICAgKiB0aGUgYmFzZW5hbWUgb2YgdGhpcyBwYXRoXG4gICAgICpcbiAgICAgKiAqKkltcG9ydGFudCoqOiAqYWx3YXlzKiB0ZXN0IHRoZSBwYXRoIG5hbWUgYWdhaW5zdCBhbnkgdGVzdCBzdHJpbmdcbiAgICAgKiB1c2luZ3RoZSB7QGxpbmsgaXNOYW1lZH0gbWV0aG9kLCBhbmQgbm90IGJ5IGRpcmVjdGx5IGNvbXBhcmluZyB0aGlzXG4gICAgICogc3RyaW5nLiBPdGhlcndpc2UsIHVuaWNvZGUgcGF0aCBzdHJpbmdzIHRoYXQgdGhlIHN5c3RlbSBzZWVzIGFzIGlkZW50aWNhbFxuICAgICAqIHdpbGwgbm90IGJlIHByb3Blcmx5IHRyZWF0ZWQgYXMgdGhlIHNhbWUgcGF0aCwgbGVhZGluZyB0byBpbmNvcnJlY3RcbiAgICAgKiBiZWhhdmlvciBhbmQgcG9zc2libGUgc2VjdXJpdHkgaXNzdWVzLlxuICAgICAqL1xuICAgIG5hbWU7XG4gICAgLyoqXG4gICAgICogdGhlIFBhdGggZW50cnkgY29ycmVzcG9uZGluZyB0byB0aGUgcGF0aCByb290LlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcm9vdDtcbiAgICAvKipcbiAgICAgKiBBbGwgcm9vdHMgZm91bmQgd2l0aGluIHRoZSBjdXJyZW50IFBhdGhTY3VycnkgZmFtaWx5XG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICByb290cztcbiAgICAvKipcbiAgICAgKiBhIHJlZmVyZW5jZSB0byB0aGUgcGFyZW50IHBhdGgsIG9yIHVuZGVmaW5lZCBpbiB0aGUgY2FzZSBvZiByb290IGVudHJpZXNcbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHBhcmVudDtcbiAgICAvKipcbiAgICAgKiBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBwYXRocyBhcmUgY29tcGFyZWQgY2FzZS1pbnNlbnNpdGl2ZWx5XG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgbm9jYXNlO1xuICAgIC8qKlxuICAgICAqIGJvb2xlYW4gaW5kaWNhdGluZyB0aGF0IHRoaXMgcGF0aCBpcyB0aGUgY3VycmVudCB3b3JraW5nIGRpcmVjdG9yeVxuICAgICAqIG9mIHRoZSBQYXRoU2N1cnJ5IGNvbGxlY3Rpb24gdGhhdCBjb250YWlucyBpdC5cbiAgICAgKi9cbiAgICBpc0NXRCA9IGZhbHNlO1xuICAgIC8vIHBvdGVudGlhbCBkZWZhdWx0IGZzIG92ZXJyaWRlXG4gICAgI2ZzO1xuICAgIC8vIFN0YXRzIGZpZWxkc1xuICAgICNkZXY7XG4gICAgZ2V0IGRldigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2RldjtcbiAgICB9XG4gICAgI21vZGU7XG4gICAgZ2V0IG1vZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNtb2RlO1xuICAgIH1cbiAgICAjbmxpbms7XG4gICAgZ2V0IG5saW5rKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jbmxpbms7XG4gICAgfVxuICAgICN1aWQ7XG4gICAgZ2V0IHVpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3VpZDtcbiAgICB9XG4gICAgI2dpZDtcbiAgICBnZXQgZ2lkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jZ2lkO1xuICAgIH1cbiAgICAjcmRldjtcbiAgICBnZXQgcmRldigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3JkZXY7XG4gICAgfVxuICAgICNibGtzaXplO1xuICAgIGdldCBibGtzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jYmxrc2l6ZTtcbiAgICB9XG4gICAgI2lubztcbiAgICBnZXQgaW5vKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jaW5vO1xuICAgIH1cbiAgICAjc2l6ZTtcbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3NpemU7XG4gICAgfVxuICAgICNibG9ja3M7XG4gICAgZ2V0IGJsb2NrcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2Jsb2NrcztcbiAgICB9XG4gICAgI2F0aW1lTXM7XG4gICAgZ2V0IGF0aW1lTXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNhdGltZU1zO1xuICAgIH1cbiAgICAjbXRpbWVNcztcbiAgICBnZXQgbXRpbWVNcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI210aW1lTXM7XG4gICAgfVxuICAgICNjdGltZU1zO1xuICAgIGdldCBjdGltZU1zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jY3RpbWVNcztcbiAgICB9XG4gICAgI2JpcnRodGltZU1zO1xuICAgIGdldCBiaXJ0aHRpbWVNcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2JpcnRodGltZU1zO1xuICAgIH1cbiAgICAjYXRpbWU7XG4gICAgZ2V0IGF0aW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jYXRpbWU7XG4gICAgfVxuICAgICNtdGltZTtcbiAgICBnZXQgbXRpbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNtdGltZTtcbiAgICB9XG4gICAgI2N0aW1lO1xuICAgIGdldCBjdGltZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2N0aW1lO1xuICAgIH1cbiAgICAjYmlydGh0aW1lO1xuICAgIGdldCBiaXJ0aHRpbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNiaXJ0aHRpbWU7XG4gICAgfVxuICAgICNtYXRjaE5hbWU7XG4gICAgI2RlcHRoO1xuICAgICNmdWxscGF0aDtcbiAgICAjZnVsbHBhdGhQb3NpeDtcbiAgICAjcmVsYXRpdmU7XG4gICAgI3JlbGF0aXZlUG9zaXg7XG4gICAgI3R5cGU7XG4gICAgI2NoaWxkcmVuO1xuICAgICNsaW5rVGFyZ2V0O1xuICAgICNyZWFscGF0aDtcbiAgICAvKipcbiAgICAgKiBUaGlzIHByb3BlcnR5IGlzIGZvciBjb21wYXRpYmlsaXR5IHdpdGggdGhlIERpcmVudCBjbGFzcyBhcyBvZlxuICAgICAqIE5vZGUgdjIwLCB3aGVyZSBEaXJlbnRbJ3BhcmVudFBhdGgnXSByZWZlcnMgdG8gdGhlIHBhdGggb2YgdGhlXG4gICAgICogZGlyZWN0b3J5IHRoYXQgd2FzIHBhc3NlZCB0byByZWFkZGlyLiBGb3Igcm9vdCBlbnRyaWVzLCBpdCdzIHRoZSBwYXRoXG4gICAgICogdG8gdGhlIGVudHJ5IGl0c2VsZi5cbiAgICAgKi9cbiAgICBnZXQgcGFyZW50UGF0aCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnBhcmVudCB8fCB0aGlzKS5mdWxscGF0aCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXByZWNhdGVkIGFsaWFzIGZvciBEaXJlbnRbJ3BhcmVudFBhdGgnXSBTb21ld2hhdCBjb3VudGVyaW50dWl0aXZlbHksXG4gICAgICogdGhpcyBwcm9wZXJ0eSByZWZlcnMgdG8gdGhlICpwYXJlbnQqIHBhdGgsIG5vdCB0aGUgcGF0aCBvYmplY3QgaXRzZWxmLlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICBnZXQgcGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50UGF0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRG8gbm90IGNyZWF0ZSBuZXcgUGF0aCBvYmplY3RzIGRpcmVjdGx5LiAgVGhleSBzaG91bGQgYWx3YXlzIGJlIGFjY2Vzc2VkXG4gICAgICogdmlhIHRoZSBQYXRoU2N1cnJ5IGNsYXNzIG9yIG90aGVyIG1ldGhvZHMgb24gdGhlIFBhdGggY2xhc3MuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihuYW1lLCB0eXBlID0gVU5LTk9XTiwgcm9vdCwgcm9vdHMsIG5vY2FzZSwgY2hpbGRyZW4sIG9wdHMpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy4jbWF0Y2hOYW1lID0gbm9jYXNlID8gbm9ybWFsaXplTm9jYXNlKG5hbWUpIDogbm9ybWFsaXplKG5hbWUpO1xuICAgICAgICB0aGlzLiN0eXBlID0gdHlwZSAmIFRZUEVNQVNLO1xuICAgICAgICB0aGlzLm5vY2FzZSA9IG5vY2FzZTtcbiAgICAgICAgdGhpcy5yb290cyA9IHJvb3RzO1xuICAgICAgICB0aGlzLnJvb3QgPSByb290IHx8IHRoaXM7XG4gICAgICAgIHRoaXMuI2NoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMuI2Z1bGxwYXRoID0gb3B0cy5mdWxscGF0aDtcbiAgICAgICAgdGhpcy4jcmVsYXRpdmUgPSBvcHRzLnJlbGF0aXZlO1xuICAgICAgICB0aGlzLiNyZWxhdGl2ZVBvc2l4ID0gb3B0cy5yZWxhdGl2ZVBvc2l4O1xuICAgICAgICB0aGlzLnBhcmVudCA9IG9wdHMucGFyZW50O1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuI2ZzID0gdGhpcy5wYXJlbnQuI2ZzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4jZnMgPSBmc0Zyb21PcHRpb24ob3B0cy5mcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZGVwdGggb2YgdGhlIFBhdGggb2JqZWN0IGZyb20gaXRzIHJvb3QuXG4gICAgICpcbiAgICAgKiBGb3IgZXhhbXBsZSwgYSBwYXRoIGF0IGAvZm9vL2JhcmAgd291bGQgaGF2ZSBhIGRlcHRoIG9mIDIuXG4gICAgICovXG4gICAgZGVwdGgoKSB7XG4gICAgICAgIGlmICh0aGlzLiNkZXB0aCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI2RlcHRoO1xuICAgICAgICBpZiAoIXRoaXMucGFyZW50KVxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLiNkZXB0aCA9IDApO1xuICAgICAgICByZXR1cm4gKHRoaXMuI2RlcHRoID0gdGhpcy5wYXJlbnQuZGVwdGgoKSArIDEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBjaGlsZHJlbkNhY2hlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jY2hpbGRyZW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgUGF0aCBvYmplY3QgcmVmZXJlbmNlZCBieSB0aGUgc3RyaW5nIHBhdGgsIHJlc29sdmVkIGZyb20gdGhpcyBQYXRoXG4gICAgICovXG4gICAgcmVzb2x2ZShwYXRoKSB7XG4gICAgICAgIGlmICghcGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgcm9vdFBhdGggPSB0aGlzLmdldFJvb3RTdHJpbmcocGF0aCk7XG4gICAgICAgIGNvbnN0IGRpciA9IHBhdGguc3Vic3RyaW5nKHJvb3RQYXRoLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IGRpclBhcnRzID0gZGlyLnNwbGl0KHRoaXMuc3BsaXRTZXApO1xuICAgICAgICBjb25zdCByZXN1bHQgPSByb290UGF0aCA/XG4gICAgICAgICAgICB0aGlzLmdldFJvb3Qocm9vdFBhdGgpLiNyZXNvbHZlUGFydHMoZGlyUGFydHMpXG4gICAgICAgICAgICA6IHRoaXMuI3Jlc29sdmVQYXJ0cyhkaXJQYXJ0cyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgICNyZXNvbHZlUGFydHMoZGlyUGFydHMpIHtcbiAgICAgICAgbGV0IHAgPSB0aGlzO1xuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgZGlyUGFydHMpIHtcbiAgICAgICAgICAgIHAgPSBwLmNoaWxkKHBhcnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjYWNoZWQgY2hpbGRyZW4gUGF0aCBvYmplY3RzLCBpZiBzdGlsbCBhdmFpbGFibGUuICBJZiB0aGV5XG4gICAgICogaGF2ZSBmYWxsZW4gb3V0IG9mIHRoZSBjYWNoZSwgdGhlbiByZXR1cm5zIGFuIGVtcHR5IGFycmF5LCBhbmQgcmVzZXRzIHRoZVxuICAgICAqIFJFQURESVJfQ0FMTEVEIGJpdCwgc28gdGhhdCBmdXR1cmUgY2FsbHMgdG8gcmVhZGRpcigpIHdpbGwgcmVxdWlyZSBhbiBmc1xuICAgICAqIGxvb2t1cC5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGNoaWxkcmVuKCkge1xuICAgICAgICBjb25zdCBjYWNoZWQgPSB0aGlzLiNjaGlsZHJlbi5nZXQodGhpcyk7XG4gICAgICAgIGlmIChjYWNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBPYmplY3QuYXNzaWduKFtdLCB7IHByb3Zpc2lvbmFsOiAwIH0pO1xuICAgICAgICB0aGlzLiNjaGlsZHJlbi5zZXQodGhpcywgY2hpbGRyZW4pO1xuICAgICAgICB0aGlzLiN0eXBlICY9IH5SRUFERElSX0NBTExFRDtcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlcyBhIHBhdGggcG9ydGlvbiBhbmQgcmV0dXJucyBvciBjcmVhdGVzIHRoZSBjaGlsZCBQYXRoLlxuICAgICAqXG4gICAgICogUmV0dXJucyBgdGhpc2AgaWYgcGF0aFBhcnQgaXMgYCcnYCBvciBgJy4nYCwgb3IgYHBhcmVudGAgaWYgcGF0aFBhcnQgaXNcbiAgICAgKiBgJy4uJ2AuXG4gICAgICpcbiAgICAgKiBUaGlzIHNob3VsZCBub3QgYmUgY2FsbGVkIGRpcmVjdGx5LiAgSWYgYHBhdGhQYXJ0YCBjb250YWlucyBhbnkgcGF0aFxuICAgICAqIHNlcGFyYXRvcnMsIGl0IHdpbGwgbGVhZCB0byB1bnNhZmUgdW5kZWZpbmVkIGJlaGF2aW9yLlxuICAgICAqXG4gICAgICogVXNlIGBQYXRoLnJlc29sdmUoKWAgaW5zdGVhZC5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGNoaWxkKHBhdGhQYXJ0LCBvcHRzKSB7XG4gICAgICAgIGlmIChwYXRoUGFydCA9PT0gJycgfHwgcGF0aFBhcnQgPT09ICcuJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdGhQYXJ0ID09PSAnLi4nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQgfHwgdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBmaW5kIHRoZSBjaGlsZFxuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4oKTtcbiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMubm9jYXNlID8gbm9ybWFsaXplTm9jYXNlKHBhdGhQYXJ0KSA6IG5vcm1hbGl6ZShwYXRoUGFydCk7XG4gICAgICAgIGZvciAoY29uc3QgcCBvZiBjaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKHAuI21hdGNoTmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGRpZG4ndCBmaW5kIGl0LCBjcmVhdGUgcHJvdmlzaW9uYWwgY2hpbGQsIHNpbmNlIGl0IG1pZ2h0IG5vdFxuICAgICAgICAvLyBhY3R1YWxseSBleGlzdC4gIElmIHdlIGtub3cgdGhlIHBhcmVudCBpc24ndCBhIGRpciwgdGhlblxuICAgICAgICAvLyBpbiBmYWN0IGl0IENBTidUIGV4aXN0LlxuICAgICAgICBjb25zdCBzID0gdGhpcy5wYXJlbnQgPyB0aGlzLnNlcCA6ICcnO1xuICAgICAgICBjb25zdCBmdWxscGF0aCA9IHRoaXMuI2Z1bGxwYXRoID8gdGhpcy4jZnVsbHBhdGggKyBzICsgcGF0aFBhcnQgOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHBjaGlsZCA9IHRoaXMubmV3Q2hpbGQocGF0aFBhcnQsIFVOS05PV04sIHtcbiAgICAgICAgICAgIC4uLm9wdHMsXG4gICAgICAgICAgICBwYXJlbnQ6IHRoaXMsXG4gICAgICAgICAgICBmdWxscGF0aCxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghdGhpcy5jYW5SZWFkZGlyKCkpIHtcbiAgICAgICAgICAgIHBjaGlsZC4jdHlwZSB8PSBFTk9FTlQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZG9uJ3QgaGF2ZSB0byB1cGRhdGUgcHJvdmlzaW9uYWwsIGJlY2F1c2UgaWYgd2UgaGF2ZSByZWFsIGNoaWxkcmVuLFxuICAgICAgICAvLyB0aGVuIHByb3Zpc2lvbmFsIGlzIHNldCB0byBjaGlsZHJlbi5sZW5ndGgsIG90aGVyd2lzZSBhIGxvd2VyIG51bWJlclxuICAgICAgICBjaGlsZHJlbi5wdXNoKHBjaGlsZCk7XG4gICAgICAgIHJldHVybiBwY2hpbGQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSByZWxhdGl2ZSBwYXRoIGZyb20gdGhlIGN3ZC4gSWYgaXQgZG9lcyBub3Qgc2hhcmUgYW4gYW5jZXN0b3Igd2l0aFxuICAgICAqIHRoZSBjd2QsIHRoZW4gdGhpcyBlbmRzIHVwIGJlaW5nIGVxdWl2YWxlbnQgdG8gdGhlIGZ1bGxwYXRoKClcbiAgICAgKi9cbiAgICByZWxhdGl2ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNDV0QpXG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIGlmICh0aGlzLiNyZWxhdGl2ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jcmVsYXRpdmU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMubmFtZTtcbiAgICAgICAgY29uc3QgcCA9IHRoaXMucGFyZW50O1xuICAgICAgICBpZiAoIXApIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy4jcmVsYXRpdmUgPSB0aGlzLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHB2ID0gcC5yZWxhdGl2ZSgpO1xuICAgICAgICByZXR1cm4gcHYgKyAoIXB2IHx8ICFwLnBhcmVudCA/ICcnIDogdGhpcy5zZXApICsgbmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHJlbGF0aXZlIHBhdGggZnJvbSB0aGUgY3dkLCB1c2luZyAvIGFzIHRoZSBwYXRoIHNlcGFyYXRvci5cbiAgICAgKiBJZiBpdCBkb2VzIG5vdCBzaGFyZSBhbiBhbmNlc3RvciB3aXRoXG4gICAgICogdGhlIGN3ZCwgdGhlbiB0aGlzIGVuZHMgdXAgYmVpbmcgZXF1aXZhbGVudCB0byB0aGUgZnVsbHBhdGhQb3NpeCgpXG4gICAgICogT24gcG9zaXggc3lzdGVtcywgdGhpcyBpcyBpZGVudGljYWwgdG8gcmVsYXRpdmUoKS5cbiAgICAgKi9cbiAgICByZWxhdGl2ZVBvc2l4KCkge1xuICAgICAgICBpZiAodGhpcy5zZXAgPT09ICcvJylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbGF0aXZlKCk7XG4gICAgICAgIGlmICh0aGlzLmlzQ1dEKVxuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICBpZiAodGhpcy4jcmVsYXRpdmVQb3NpeCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3JlbGF0aXZlUG9zaXg7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLm5hbWU7XG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgaWYgKCFwKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuI3JlbGF0aXZlUG9zaXggPSB0aGlzLmZ1bGxwYXRoUG9zaXgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHYgPSBwLnJlbGF0aXZlUG9zaXgoKTtcbiAgICAgICAgcmV0dXJuIHB2ICsgKCFwdiB8fCAhcC5wYXJlbnQgPyAnJyA6ICcvJykgKyBuYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgZnVsbHkgcmVzb2x2ZWQgcGF0aCBzdHJpbmcgZm9yIHRoaXMgUGF0aCBlbnRyeVxuICAgICAqL1xuICAgIGZ1bGxwYXRoKCkge1xuICAgICAgICBpZiAodGhpcy4jZnVsbHBhdGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI2Z1bGxwYXRoO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLm5hbWU7XG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgaWYgKCFwKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuI2Z1bGxwYXRoID0gdGhpcy5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwdiA9IHAuZnVsbHBhdGgoKTtcbiAgICAgICAgY29uc3QgZnAgPSBwdiArICghcC5wYXJlbnQgPyAnJyA6IHRoaXMuc2VwKSArIG5hbWU7XG4gICAgICAgIHJldHVybiAodGhpcy4jZnVsbHBhdGggPSBmcCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9uIHBsYXRmb3JtcyBvdGhlciB0aGFuIHdpbmRvd3MsIHRoaXMgaXMgaWRlbnRpY2FsIHRvIGZ1bGxwYXRoLlxuICAgICAqXG4gICAgICogT24gd2luZG93cywgdGhpcyBpcyBvdmVycmlkZGVuIHRvIHJldHVybiB0aGUgZm9yd2FyZC1zbGFzaCBmb3JtIG9mIHRoZVxuICAgICAqIGZ1bGwgVU5DIHBhdGguXG4gICAgICovXG4gICAgZnVsbHBhdGhQb3NpeCgpIHtcbiAgICAgICAgaWYgKHRoaXMuI2Z1bGxwYXRoUG9zaXggIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNmdWxscGF0aFBvc2l4O1xuICAgICAgICBpZiAodGhpcy5zZXAgPT09ICcvJylcbiAgICAgICAgICAgIHJldHVybiAodGhpcy4jZnVsbHBhdGhQb3NpeCA9IHRoaXMuZnVsbHBhdGgoKSk7XG4gICAgICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHAgPSB0aGlzLmZ1bGxwYXRoKCkucmVwbGFjZSgvXFxcXC9nLCAnLycpO1xuICAgICAgICAgICAgaWYgKC9eW2Etel06XFwvL2kudGVzdChwKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy4jZnVsbHBhdGhQb3NpeCA9IGAvLz8vJHtwfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLiNmdWxscGF0aFBvc2l4ID0gcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcCA9IHRoaXMucGFyZW50O1xuICAgICAgICBjb25zdCBwZnBwID0gcC5mdWxscGF0aFBvc2l4KCk7XG4gICAgICAgIGNvbnN0IGZwcCA9IHBmcHAgKyAoIXBmcHAgfHwgIXAucGFyZW50ID8gJycgOiAnLycpICsgdGhpcy5uYW1lO1xuICAgICAgICByZXR1cm4gKHRoaXMuI2Z1bGxwYXRoUG9zaXggPSBmcHApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJcyB0aGUgUGF0aCBvZiBhbiB1bmtub3duIHR5cGU/XG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgd2UgbWlnaHQga25vdyAqc29tZXRoaW5nKiBhYm91dCBpdCBpZiB0aGVyZSBoYXMgYmVlbiBhIHByZXZpb3VzXG4gICAgICogZmlsZXN5c3RlbSBvcGVyYXRpb24sIGZvciBleGFtcGxlIHRoYXQgaXQgZG9lcyBub3QgZXhpc3QsIG9yIGlzIG5vdCBhXG4gICAgICogbGluaywgb3Igd2hldGhlciBpdCBoYXMgY2hpbGQgZW50cmllcy5cbiAgICAgKi9cbiAgICBpc1Vua25vd24oKSB7XG4gICAgICAgIHJldHVybiAodGhpcy4jdHlwZSAmIElGTVQpID09PSBVTktOT1dOO1xuICAgIH1cbiAgICBpc1R5cGUodHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpc1tgaXMke3R5cGV9YF0oKTtcbiAgICB9XG4gICAgZ2V0VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmlzVW5rbm93bigpID8gJ1Vua25vd24nXG4gICAgICAgICAgICA6IHRoaXMuaXNEaXJlY3RvcnkoKSA/ICdEaXJlY3RvcnknXG4gICAgICAgICAgICAgICAgOiB0aGlzLmlzRmlsZSgpID8gJ0ZpbGUnXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5pc1N5bWJvbGljTGluaygpID8gJ1N5bWJvbGljTGluaydcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy5pc0ZJRk8oKSA/ICdGSUZPJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy5pc0NoYXJhY3RlckRldmljZSgpID8gJ0NoYXJhY3RlckRldmljZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLmlzQmxvY2tEZXZpY2UoKSA/ICdCbG9ja0RldmljZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogLyogYzggaWdub3JlIHN0YXJ0ICovIHRoaXMuaXNTb2NrZXQoKSA/ICdTb2NrZXQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnVW5rbm93bicpO1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJcyB0aGUgUGF0aCBhIHJlZ3VsYXIgZmlsZT9cbiAgICAgKi9cbiAgICBpc0ZpbGUoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy4jdHlwZSAmIElGTVQpID09PSBJRlJFRztcbiAgICB9XG4gICAgLyoqXG4gICAgICogSXMgdGhlIFBhdGggYSBkaXJlY3Rvcnk/XG4gICAgICovXG4gICAgaXNEaXJlY3RvcnkoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy4jdHlwZSAmIElGTVQpID09PSBJRkRJUjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSXMgdGhlIHBhdGggYSBjaGFyYWN0ZXIgZGV2aWNlP1xuICAgICAqL1xuICAgIGlzQ2hhcmFjdGVyRGV2aWNlKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuI3R5cGUgJiBJRk1UKSA9PT0gSUZDSFI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElzIHRoZSBwYXRoIGEgYmxvY2sgZGV2aWNlP1xuICAgICAqL1xuICAgIGlzQmxvY2tEZXZpY2UoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy4jdHlwZSAmIElGTVQpID09PSBJRkJMSztcbiAgICB9XG4gICAgLyoqXG4gICAgICogSXMgdGhlIHBhdGggYSBGSUZPIHBpcGU/XG4gICAgICovXG4gICAgaXNGSUZPKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuI3R5cGUgJiBJRk1UKSA9PT0gSUZJRk87XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElzIHRoZSBwYXRoIGEgc29ja2V0P1xuICAgICAqL1xuICAgIGlzU29ja2V0KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuI3R5cGUgJiBJRk1UKSA9PT0gSUZTT0NLO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJcyB0aGUgcGF0aCBhIHN5bWJvbGljIGxpbms/XG4gICAgICovXG4gICAgaXNTeW1ib2xpY0xpbmsoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy4jdHlwZSAmIElGTE5LKSA9PT0gSUZMTks7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgZW50cnkgaWYgaXQgaGFzIGJlZW4gc3ViamVjdCBvZiBhIHN1Y2Nlc3NmdWwgbHN0YXQsIG9yXG4gICAgICogdW5kZWZpbmVkIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqIERvZXMgbm90IHJlYWQgdGhlIGZpbGVzeXN0ZW0sIHNvIGFuIHVuZGVmaW5lZCByZXN1bHQgKmNvdWxkKiBzaW1wbHlcbiAgICAgKiBtZWFuIHRoYXQgd2UgaGF2ZW4ndCBjYWxsZWQgbHN0YXQgb24gaXQuXG4gICAgICovXG4gICAgbHN0YXRDYWNoZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiN0eXBlICYgTFNUQVRfQ0FMTEVEID8gdGhpcyA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBjYWNoZWQgbGluayB0YXJnZXQgaWYgdGhlIGVudHJ5IGhhcyBiZWVuIHRoZSBzdWJqZWN0IG9mIGFcbiAgICAgKiBzdWNjZXNzZnVsIHJlYWRsaW5rLCBvciB1bmRlZmluZWQgb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICogRG9lcyBub3QgcmVhZCB0aGUgZmlsZXN5c3RlbSwgc28gYW4gdW5kZWZpbmVkIHJlc3VsdCAqY291bGQqIGp1c3QgbWVhbiB3ZVxuICAgICAqIGRvbid0IGhhdmUgYW55IGNhY2hlZCBkYXRhLiBPbmx5IHVzZSBpdCBpZiB5b3UgYXJlIHZlcnkgc3VyZSB0aGF0IGFcbiAgICAgKiByZWFkbGluaygpIGhhcyBiZWVuIGNhbGxlZCBhdCBzb21lIHBvaW50LlxuICAgICAqL1xuICAgIHJlYWRsaW5rQ2FjaGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jbGlua1RhcmdldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY2FjaGVkIHJlYWxwYXRoIHRhcmdldCBpZiB0aGUgZW50cnkgaGFzIGJlZW4gdGhlIHN1YmplY3RcbiAgICAgKiBvZiBhIHN1Y2Nlc3NmdWwgcmVhbHBhdGgsIG9yIHVuZGVmaW5lZCBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBEb2VzIG5vdCByZWFkIHRoZSBmaWxlc3lzdGVtLCBzbyBhbiB1bmRlZmluZWQgcmVzdWx0ICpjb3VsZCoganVzdCBtZWFuIHdlXG4gICAgICogZG9uJ3QgaGF2ZSBhbnkgY2FjaGVkIGRhdGEuIE9ubHkgdXNlIGl0IGlmIHlvdSBhcmUgdmVyeSBzdXJlIHRoYXQgYVxuICAgICAqIHJlYWxwYXRoKCkgaGFzIGJlZW4gY2FsbGVkIGF0IHNvbWUgcG9pbnQuXG4gICAgICovXG4gICAgcmVhbHBhdGhDYWNoZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNyZWFscGF0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY2FjaGVkIGNoaWxkIFBhdGggZW50cmllcyBhcnJheSBpZiB0aGUgZW50cnkgaGFzIGJlZW4gdGhlXG4gICAgICogc3ViamVjdCBvZiBhIHN1Y2Nlc3NmdWwgcmVhZGRpcigpLCBvciBbXSBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBEb2VzIG5vdCByZWFkIHRoZSBmaWxlc3lzdGVtLCBzbyBhbiBlbXB0eSBhcnJheSAqY291bGQqIGp1c3QgbWVhbiB3ZVxuICAgICAqIGRvbid0IGhhdmUgYW55IGNhY2hlZCBkYXRhLiBPbmx5IHVzZSBpdCBpZiB5b3UgYXJlIHZlcnkgc3VyZSB0aGF0IGFcbiAgICAgKiByZWFkZGlyKCkgaGFzIGJlZW4gY2FsbGVkIHJlY2VudGx5IGVub3VnaCB0byBzdGlsbCBiZSB2YWxpZC5cbiAgICAgKi9cbiAgICByZWFkZGlyQ2FjaGVkKCkge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4oKTtcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuLnNsaWNlKDAsIGNoaWxkcmVuLnByb3Zpc2lvbmFsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRydWUgaWYgaXQncyB3b3J0aCB0cnlpbmcgdG8gcmVhZGxpbmsuICBJZSwgd2UgZG9uJ3QgKHlldCkgaGF2ZVxuICAgICAqIGFueSBpbmRpY2F0aW9uIHRoYXQgcmVhZGxpbmsgd2lsbCBkZWZpbml0ZWx5IGZhaWwuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGZhbHNlIGlmIHRoZSBwYXRoIGlzIGtub3duIHRvIG5vdCBiZSBhIHN5bWxpbmssIGlmIGEgcHJldmlvdXNcbiAgICAgKiByZWFkbGluayBmYWlsZWQsIG9yIGlmIHRoZSBlbnRyeSBkb2VzIG5vdCBleGlzdC5cbiAgICAgKi9cbiAgICBjYW5SZWFkbGluaygpIHtcbiAgICAgICAgaWYgKHRoaXMuI2xpbmtUYXJnZXQpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKCF0aGlzLnBhcmVudClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy8gY2FzZXMgd2hlcmUgaXQgY2Fubm90IHBvc3NpYmx5IHN1Y2NlZWRcbiAgICAgICAgY29uc3QgaWZtdCA9IHRoaXMuI3R5cGUgJiBJRk1UO1xuICAgICAgICByZXR1cm4gISgoaWZtdCAhPT0gVU5LTk9XTiAmJiBpZm10ICE9PSBJRkxOSykgfHxcbiAgICAgICAgICAgIHRoaXMuI3R5cGUgJiBFTk9SRUFETElOSyB8fFxuICAgICAgICAgICAgdGhpcy4jdHlwZSAmIEVOT0VOVCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0cnVlIGlmIHJlYWRkaXIgaGFzIHByZXZpb3VzbHkgYmVlbiBzdWNjZXNzZnVsbHkgY2FsbGVkIG9uIHRoaXNcbiAgICAgKiBwYXRoLCBpbmRpY2F0aW5nIHRoYXQgY2FjaGVkUmVhZGRpcigpIGlzIGxpa2VseSB2YWxpZC5cbiAgICAgKi9cbiAgICBjYWxsZWRSZWFkZGlyKCkge1xuICAgICAgICByZXR1cm4gISEodGhpcy4jdHlwZSAmIFJFQURESVJfQ0FMTEVEKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBwYXRoIGlzIGtub3duIHRvIG5vdCBleGlzdC4gVGhhdCBpcywgYSBwcmV2aW91cyBsc3RhdFxuICAgICAqIG9yIHJlYWRkaXIgZmFpbGVkIHRvIHZlcmlmeSBpdHMgZXhpc3RlbmNlIHdoZW4gdGhhdCB3b3VsZCBoYXZlIGJlZW5cbiAgICAgKiBleHBlY3RlZCwgb3IgYSBwYXJlbnQgZW50cnkgd2FzIG1hcmtlZCBlaXRoZXIgZW5vZW50IG9yIGVub3RkaXIuXG4gICAgICovXG4gICAgaXNFTk9FTlQoKSB7XG4gICAgICAgIHJldHVybiAhISh0aGlzLiN0eXBlICYgRU5PRU5UKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHBhdGggaXMgYSBtYXRjaCBmb3IgdGhlIGdpdmVuIHBhdGggbmFtZS4gIFRoaXMgaGFuZGxlc1xuICAgICAqIGNhc2Ugc2Vuc2l0aXZpdHkgYW5kIHVuaWNvZGUgbm9ybWFsaXphdGlvbi5cbiAgICAgKlxuICAgICAqIE5vdGU6IGV2ZW4gb24gY2FzZS1zZW5zaXRpdmUgc3lzdGVtcywgaXQgaXMgKipub3QqKiBzYWZlIHRvIHRlc3QgdGhlXG4gICAgICogZXF1YWxpdHkgb2YgdGhlIGAubmFtZWAgcHJvcGVydHkgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYSBnaXZlbiBwYXRobmFtZVxuICAgICAqIG1hdGNoZXMsIGR1ZSB0byB1bmljb2RlIG5vcm1hbGl6YXRpb24gbWlzbWF0Y2hlcy5cbiAgICAgKlxuICAgICAqIEFsd2F5cyB1c2UgdGhpcyBtZXRob2QgaW5zdGVhZCBvZiB0ZXN0aW5nIHRoZSBgcGF0aC5uYW1lYCBwcm9wZXJ0eVxuICAgICAqIGRpcmVjdGx5LlxuICAgICAqL1xuICAgIGlzTmFtZWQobikge1xuICAgICAgICByZXR1cm4gIXRoaXMubm9jYXNlID9cbiAgICAgICAgICAgIHRoaXMuI21hdGNoTmFtZSA9PT0gbm9ybWFsaXplKG4pXG4gICAgICAgICAgICA6IHRoaXMuI21hdGNoTmFtZSA9PT0gbm9ybWFsaXplTm9jYXNlKG4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIFBhdGggb2JqZWN0IGNvcnJlc3BvbmRpbmcgdG8gdGhlIHRhcmdldCBvZiBhIHN5bWJvbGljIGxpbmsuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgUGF0aCBpcyBub3QgYSBzeW1ib2xpYyBsaW5rLCBvciBpZiB0aGUgcmVhZGxpbmsgY2FsbCBmYWlscyBmb3IgYW55XG4gICAgICogcmVhc29uLCBgdW5kZWZpbmVkYCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIFJlc3VsdCBpcyBjYWNoZWQsIGFuZCB0aHVzIG1heSBiZSBvdXRkYXRlZCBpZiB0aGUgZmlsZXN5c3RlbSBpcyBtdXRhdGVkLlxuICAgICAqL1xuICAgIGFzeW5jIHJlYWRsaW5rKCkge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLiNsaW5rVGFyZ2V0O1xuICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5jYW5SZWFkbGluaygpKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAvLyBhbHJlYWR5IGNvdmVyZWQgYnkgdGhlIGNhblJlYWRsaW5rIHRlc3QsIGhlcmUgZm9yIHRzIGdydW1wbGVzXG4gICAgICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlYWQgPSBhd2FpdCB0aGlzLiNmcy5wcm9taXNlcy5yZWFkbGluayh0aGlzLmZ1bGxwYXRoKCkpO1xuICAgICAgICAgICAgY29uc3QgbGlua1RhcmdldCA9IChhd2FpdCB0aGlzLnBhcmVudC5yZWFscGF0aCgpKT8ucmVzb2x2ZShyZWFkKTtcbiAgICAgICAgICAgIGlmIChsaW5rVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLiNsaW5rVGFyZ2V0ID0gbGlua1RhcmdldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVyKSB7XG4gICAgICAgICAgICB0aGlzLiNyZWFkbGlua0ZhaWwoZXIuY29kZSk7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN5bmNocm9ub3VzIHtAbGluayBQYXRoQmFzZS5yZWFkbGlua31cbiAgICAgKi9cbiAgICByZWFkbGlua1N5bmMoKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuI2xpbmtUYXJnZXQ7XG4gICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmNhblJlYWRsaW5rKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIC8vIGFscmVhZHkgY292ZXJlZCBieSB0aGUgY2FuUmVhZGxpbmsgdGVzdCwgaGVyZSBmb3IgdHMgZ3J1bXBsZXNcbiAgICAgICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVhZCA9IHRoaXMuI2ZzLnJlYWRsaW5rU3luYyh0aGlzLmZ1bGxwYXRoKCkpO1xuICAgICAgICAgICAgY29uc3QgbGlua1RhcmdldCA9IHRoaXMucGFyZW50LnJlYWxwYXRoU3luYygpPy5yZXNvbHZlKHJlYWQpO1xuICAgICAgICAgICAgaWYgKGxpbmtUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuI2xpbmtUYXJnZXQgPSBsaW5rVGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXIpIHtcbiAgICAgICAgICAgIHRoaXMuI3JlYWRsaW5rRmFpbChlci5jb2RlKTtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgI3JlYWRkaXJTdWNjZXNzKGNoaWxkcmVuKSB7XG4gICAgICAgIC8vIHN1Y2NlZWRlZCwgbWFyayByZWFkZGlyIGNhbGxlZCBiaXRcbiAgICAgICAgdGhpcy4jdHlwZSB8PSBSRUFERElSX0NBTExFRDtcbiAgICAgICAgLy8gbWFyayBhbGwgcmVtYWluaW5nIHByb3Zpc2lvbmFsIGNoaWxkcmVuIGFzIEVOT0VOVFxuICAgICAgICBmb3IgKGxldCBwID0gY2hpbGRyZW4ucHJvdmlzaW9uYWw7IHAgPCBjaGlsZHJlbi5sZW5ndGg7IHArKykge1xuICAgICAgICAgICAgY29uc3QgYyA9IGNoaWxkcmVuW3BdO1xuICAgICAgICAgICAgaWYgKGMpXG4gICAgICAgICAgICAgICAgYy4jbWFya0VOT0VOVCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgICNtYXJrRU5PRU5UKCkge1xuICAgICAgICAvLyBtYXJrIGFzIFVOS05PV04gYW5kIEVOT0VOVFxuICAgICAgICBpZiAodGhpcy4jdHlwZSAmIEVOT0VOVClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy4jdHlwZSA9ICh0aGlzLiN0eXBlIHwgRU5PRU5UKSAmIElGTVRfVU5LTk9XTjtcbiAgICAgICAgdGhpcy4jbWFya0NoaWxkcmVuRU5PRU5UKCk7XG4gICAgfVxuICAgICNtYXJrQ2hpbGRyZW5FTk9FTlQoKSB7XG4gICAgICAgIC8vIGFsbCBjaGlsZHJlbiBhcmUgcHJvdmlzaW9uYWwgYW5kIGRvIG5vdCBleGlzdFxuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4oKTtcbiAgICAgICAgY2hpbGRyZW4ucHJvdmlzaW9uYWwgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IHAgb2YgY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIHAuI21hcmtFTk9FTlQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAjbWFya0VOT1JFQUxQQVRIKCkge1xuICAgICAgICB0aGlzLiN0eXBlIHw9IEVOT1JFQUxQQVRIO1xuICAgICAgICB0aGlzLiNtYXJrRU5PVERJUigpO1xuICAgIH1cbiAgICAvLyBzYXZlIHRoZSBpbmZvcm1hdGlvbiB3aGVuIHdlIGtub3cgdGhlIGVudHJ5IGlzIG5vdCBhIGRpclxuICAgICNtYXJrRU5PVERJUigpIHtcbiAgICAgICAgLy8gZW50cnkgaXMgbm90IGEgZGlyZWN0b3J5LCBzbyBhbnkgY2hpbGRyZW4gY2FuJ3QgZXhpc3QuXG4gICAgICAgIC8vIHRoaXMgKnNob3VsZCogYmUgaW1wb3NzaWJsZSwgc2luY2UgYW55IGNoaWxkcmVuIGNyZWF0ZWRcbiAgICAgICAgLy8gYWZ0ZXIgaXQncyBiZWVuIG1hcmtlZCBFTk9URElSIHNob3VsZCBiZSBtYXJrZWQgRU5PRU5ULFxuICAgICAgICAvLyBzbyBpdCB3b24ndCBldmVuIGdldCB0byB0aGlzIHBvaW50LlxuICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgaWYgKHRoaXMuI3R5cGUgJiBFTk9URElSKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICBsZXQgdCA9IHRoaXMuI3R5cGU7XG4gICAgICAgIC8vIHRoaXMgY291bGQgaGFwcGVuIGlmIHdlIHN0YXQgYSBkaXIsIHRoZW4gZGVsZXRlIGl0LFxuICAgICAgICAvLyB0aGVuIHRyeSB0byByZWFkIGl0IG9yIG9uZSBvZiBpdHMgY2hpbGRyZW4uXG4gICAgICAgIGlmICgodCAmIElGTVQpID09PSBJRkRJUilcbiAgICAgICAgICAgIHQgJj0gSUZNVF9VTktOT1dOO1xuICAgICAgICB0aGlzLiN0eXBlID0gdCB8IEVOT1RESVI7XG4gICAgICAgIHRoaXMuI21hcmtDaGlsZHJlbkVOT0VOVCgpO1xuICAgIH1cbiAgICAjcmVhZGRpckZhaWwoY29kZSA9ICcnKSB7XG4gICAgICAgIC8vIG1hcmtFTk9URElSIGFuZCBtYXJrRU5PRU5UIGFsc28gc2V0IHByb3Zpc2lvbmFsPTBcbiAgICAgICAgaWYgKGNvZGUgPT09ICdFTk9URElSJyB8fCBjb2RlID09PSAnRVBFUk0nKSB7XG4gICAgICAgICAgICB0aGlzLiNtYXJrRU5PVERJUigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvZGUgPT09ICdFTk9FTlQnKSB7XG4gICAgICAgICAgICB0aGlzLiNtYXJrRU5PRU5UKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuKCkucHJvdmlzaW9uYWwgPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgICNsc3RhdEZhaWwoY29kZSA9ICcnKSB7XG4gICAgICAgIC8vIFdpbmRvd3MganVzdCByYWlzZXMgRU5PRU5UIGluIHRoaXMgY2FzZSwgZGlzYWJsZSBmb3Igd2luIENJXG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICBpZiAoY29kZSA9PT0gJ0VOT1RESVInKSB7XG4gICAgICAgICAgICAvLyBhbHJlYWR5IGtub3cgaXQgaGFzIGEgcGFyZW50IGJ5IHRoaXMgcG9pbnRcbiAgICAgICAgICAgIGNvbnN0IHAgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgICAgIHAuI21hcmtFTk9URElSKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29kZSA9PT0gJ0VOT0VOVCcpIHtcbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgICAgICB0aGlzLiNtYXJrRU5PRU5UKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgI3JlYWRsaW5rRmFpbChjb2RlID0gJycpIHtcbiAgICAgICAgbGV0IHRlciA9IHRoaXMuI3R5cGU7XG4gICAgICAgIHRlciB8PSBFTk9SRUFETElOSztcbiAgICAgICAgaWYgKGNvZGUgPT09ICdFTk9FTlQnKVxuICAgICAgICAgICAgdGVyIHw9IEVOT0VOVDtcbiAgICAgICAgLy8gd2luZG93cyBnZXRzIGEgd2VpcmQgZXJyb3Igd2hlbiB5b3UgdHJ5IHRvIHJlYWRsaW5rIGEgZmlsZVxuICAgICAgICBpZiAoY29kZSA9PT0gJ0VJTlZBTCcgfHwgY29kZSA9PT0gJ1VOS05PV04nKSB7XG4gICAgICAgICAgICAvLyBleGlzdHMsIGJ1dCBub3QgYSBzeW1saW5rLCB3ZSBkb24ndCBrbm93IFdIQVQgaXQgaXMsIHNvIHJlbW92ZVxuICAgICAgICAgICAgLy8gYWxsIElGTVQgYml0cy5cbiAgICAgICAgICAgIHRlciAmPSBJRk1UX1VOS05PV047XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jdHlwZSA9IHRlcjtcbiAgICAgICAgLy8gd2luZG93cyBqdXN0IGdldHMgRU5PRU5UIGluIHRoaXMgY2FzZS4gIFdlIGRvIGNvdmVyIHRoZSBjYXNlLFxuICAgICAgICAvLyBqdXN0IGRpc2FibGVkIGJlY2F1c2UgaXQncyBpbXBvc3NpYmxlIG9uIFdpbmRvd3MgQ0lcbiAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIGlmIChjb2RlID09PSAnRU5PVERJUicgJiYgdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50LiNtYXJrRU5PVERJUigpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgfVxuICAgICNyZWFkZGlyQWRkQ2hpbGQoZSwgYykge1xuICAgICAgICByZXR1cm4gKHRoaXMuI3JlYWRkaXJNYXliZVByb21vdGVDaGlsZChlLCBjKSB8fFxuICAgICAgICAgICAgdGhpcy4jcmVhZGRpckFkZE5ld0NoaWxkKGUsIGMpKTtcbiAgICB9XG4gICAgI3JlYWRkaXJBZGROZXdDaGlsZChlLCBjKSB7XG4gICAgICAgIC8vIGFsbG9jIG5ldyBlbnRyeSBhdCBoZWFkLCBzbyBpdCdzIG5ldmVyIHByb3Zpc2lvbmFsXG4gICAgICAgIGNvbnN0IHR5cGUgPSBlbnRUb1R5cGUoZSk7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5uZXdDaGlsZChlLm5hbWUsIHR5cGUsIHsgcGFyZW50OiB0aGlzIH0pO1xuICAgICAgICBjb25zdCBpZm10ID0gY2hpbGQuI3R5cGUgJiBJRk1UO1xuICAgICAgICBpZiAoaWZtdCAhPT0gSUZESVIgJiYgaWZtdCAhPT0gSUZMTksgJiYgaWZtdCAhPT0gVU5LTk9XTikge1xuICAgICAgICAgICAgY2hpbGQuI3R5cGUgfD0gRU5PVERJUjtcbiAgICAgICAgfVxuICAgICAgICBjLnVuc2hpZnQoY2hpbGQpO1xuICAgICAgICBjLnByb3Zpc2lvbmFsKys7XG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9XG4gICAgI3JlYWRkaXJNYXliZVByb21vdGVDaGlsZChlLCBjKSB7XG4gICAgICAgIGZvciAobGV0IHAgPSBjLnByb3Zpc2lvbmFsOyBwIDwgYy5sZW5ndGg7IHArKykge1xuICAgICAgICAgICAgY29uc3QgcGNoaWxkID0gY1twXTtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLm5vY2FzZSA/IG5vcm1hbGl6ZU5vY2FzZShlLm5hbWUpIDogbm9ybWFsaXplKGUubmFtZSk7XG4gICAgICAgICAgICBpZiAobmFtZSAhPT0gcGNoaWxkLiNtYXRjaE5hbWUpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNyZWFkZGlyUHJvbW90ZUNoaWxkKGUsIHBjaGlsZCwgcCwgYyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgI3JlYWRkaXJQcm9tb3RlQ2hpbGQoZSwgcCwgaW5kZXgsIGMpIHtcbiAgICAgICAgY29uc3QgdiA9IHAubmFtZTtcbiAgICAgICAgLy8gcmV0YWluIGFueSBvdGhlciBmbGFncywgYnV0IHNldCBpZm10IGZyb20gZGlyZW50XG4gICAgICAgIHAuI3R5cGUgPSAocC4jdHlwZSAmIElGTVRfVU5LTk9XTikgfCBlbnRUb1R5cGUoZSk7XG4gICAgICAgIC8vIGNhc2Ugc2Vuc2l0aXZpdHkgZml4aW5nIHdoZW4gd2UgbGVhcm4gdGhlIHRydWUgbmFtZS5cbiAgICAgICAgaWYgKHYgIT09IGUubmFtZSlcbiAgICAgICAgICAgIHAubmFtZSA9IGUubmFtZTtcbiAgICAgICAgLy8ganVzdCBhZHZhbmNlIHByb3Zpc2lvbmFsIGluZGV4IChwb3RlbnRpYWxseSBvZmYgdGhlIGxpc3QpLFxuICAgICAgICAvLyBvdGhlcndpc2Ugd2UgaGF2ZSB0byBzcGxpY2UvcG9wIGl0IG91dCBhbmQgcmUtaW5zZXJ0IGF0IGhlYWRcbiAgICAgICAgaWYgKGluZGV4ICE9PSBjLnByb3Zpc2lvbmFsKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IGMubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgICAgICBjLnBvcCgpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIGMudW5zaGlmdChwKTtcbiAgICAgICAgfVxuICAgICAgICBjLnByb3Zpc2lvbmFsKys7XG4gICAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsIGxzdGF0KCkgb24gdGhpcyBQYXRoLCBhbmQgdXBkYXRlIGFsbCBrbm93biBpbmZvcm1hdGlvbiB0aGF0IGNhbiBiZVxuICAgICAqIGRldGVybWluZWQuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgdW5saWtlIGBmcy5sc3RhdCgpYCwgdGhlIHJldHVybmVkIHZhbHVlIGRvZXMgbm90IGNvbnRhaW4gc29tZVxuICAgICAqIGluZm9ybWF0aW9uLCBzdWNoIGFzIGBtb2RlYCwgYGRldmAsIGBubGlua2AsIGFuZCBgaW5vYC4gIElmIHRoYXRcbiAgICAgKiBpbmZvcm1hdGlvbiBpcyByZXF1aXJlZCwgeW91IHdpbGwgbmVlZCB0byBjYWxsIGBmcy5sc3RhdGAgeW91cnNlbGYuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgUGF0aCByZWZlcnMgdG8gYSBub25leGlzdGVudCBmaWxlLCBvciBpZiB0aGUgbHN0YXQgY2FsbCBmYWlscyBmb3JcbiAgICAgKiBhbnkgcmVhc29uLCBgdW5kZWZpbmVkYCBpcyByZXR1cm5lZC4gIE90aGVyd2lzZSB0aGUgdXBkYXRlZCBQYXRoIG9iamVjdCBpc1xuICAgICAqIHJldHVybmVkLlxuICAgICAqXG4gICAgICogUmVzdWx0cyBhcmUgY2FjaGVkLCBhbmQgdGh1cyBtYXkgYmUgb3V0IG9mIGRhdGUgaWYgdGhlIGZpbGVzeXN0ZW0gaXNcbiAgICAgKiBtdXRhdGVkLlxuICAgICAqL1xuICAgIGFzeW5jIGxzdGF0KCkge1xuICAgICAgICBpZiAoKHRoaXMuI3R5cGUgJiBFTk9FTlQpID09PSAwKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuI2FwcGx5U3RhdChhd2FpdCB0aGlzLiNmcy5wcm9taXNlcy5sc3RhdCh0aGlzLmZ1bGxwYXRoKCkpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuI2xzdGF0RmFpbChlci5jb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBzeW5jaHJvbm91cyB7QGxpbmsgUGF0aEJhc2UubHN0YXR9XG4gICAgICovXG4gICAgbHN0YXRTeW5jKCkge1xuICAgICAgICBpZiAoKHRoaXMuI3R5cGUgJiBFTk9FTlQpID09PSAwKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuI2FwcGx5U3RhdCh0aGlzLiNmcy5sc3RhdFN5bmModGhpcy5mdWxscGF0aCgpKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNsc3RhdEZhaWwoZXIuY29kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgI2FwcGx5U3RhdChzdCkge1xuICAgICAgICBjb25zdCB7IGF0aW1lLCBhdGltZU1zLCBiaXJ0aHRpbWUsIGJpcnRodGltZU1zLCBibGtzaXplLCBibG9ja3MsIGN0aW1lLCBjdGltZU1zLCBkZXYsIGdpZCwgaW5vLCBtb2RlLCBtdGltZSwgbXRpbWVNcywgbmxpbmssIHJkZXYsIHNpemUsIHVpZCwgfSA9IHN0O1xuICAgICAgICB0aGlzLiNhdGltZSA9IGF0aW1lO1xuICAgICAgICB0aGlzLiNhdGltZU1zID0gYXRpbWVNcztcbiAgICAgICAgdGhpcy4jYmlydGh0aW1lID0gYmlydGh0aW1lO1xuICAgICAgICB0aGlzLiNiaXJ0aHRpbWVNcyA9IGJpcnRodGltZU1zO1xuICAgICAgICB0aGlzLiNibGtzaXplID0gYmxrc2l6ZTtcbiAgICAgICAgdGhpcy4jYmxvY2tzID0gYmxvY2tzO1xuICAgICAgICB0aGlzLiNjdGltZSA9IGN0aW1lO1xuICAgICAgICB0aGlzLiNjdGltZU1zID0gY3RpbWVNcztcbiAgICAgICAgdGhpcy4jZGV2ID0gZGV2O1xuICAgICAgICB0aGlzLiNnaWQgPSBnaWQ7XG4gICAgICAgIHRoaXMuI2lubyA9IGlubztcbiAgICAgICAgdGhpcy4jbW9kZSA9IG1vZGU7XG4gICAgICAgIHRoaXMuI210aW1lID0gbXRpbWU7XG4gICAgICAgIHRoaXMuI210aW1lTXMgPSBtdGltZU1zO1xuICAgICAgICB0aGlzLiNubGluayA9IG5saW5rO1xuICAgICAgICB0aGlzLiNyZGV2ID0gcmRldjtcbiAgICAgICAgdGhpcy4jc2l6ZSA9IHNpemU7XG4gICAgICAgIHRoaXMuI3VpZCA9IHVpZDtcbiAgICAgICAgY29uc3QgaWZtdCA9IGVudFRvVHlwZShzdCk7XG4gICAgICAgIC8vIHJldGFpbiBhbnkgb3RoZXIgZmxhZ3MsIGJ1dCBzZXQgdGhlIGlmbXRcbiAgICAgICAgdGhpcy4jdHlwZSA9ICh0aGlzLiN0eXBlICYgSUZNVF9VTktOT1dOKSB8IGlmbXQgfCBMU1RBVF9DQUxMRUQ7XG4gICAgICAgIGlmIChpZm10ICE9PSBVTktOT1dOICYmIGlmbXQgIT09IElGRElSICYmIGlmbXQgIT09IElGTE5LKSB7XG4gICAgICAgICAgICB0aGlzLiN0eXBlIHw9IEVOT1RESVI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgI29uUmVhZGRpckNCID0gW107XG4gICAgI3JlYWRkaXJDQkluRmxpZ2h0ID0gZmFsc2U7XG4gICAgI2NhbGxPblJlYWRkaXJDQihjaGlsZHJlbikge1xuICAgICAgICB0aGlzLiNyZWFkZGlyQ0JJbkZsaWdodCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBjYnMgPSB0aGlzLiNvblJlYWRkaXJDQi5zbGljZSgpO1xuICAgICAgICB0aGlzLiNvblJlYWRkaXJDQi5sZW5ndGggPSAwO1xuICAgICAgICBjYnMuZm9yRWFjaChjYiA9PiBjYihudWxsLCBjaGlsZHJlbikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFuZGFyZCBub2RlLXN0eWxlIGNhbGxiYWNrIGludGVyZmFjZSB0byBnZXQgbGlzdCBvZiBkaXJlY3RvcnkgZW50cmllcy5cbiAgICAgKlxuICAgICAqIElmIHRoZSBQYXRoIGNhbm5vdCBvciBkb2VzIG5vdCBjb250YWluIGFueSBjaGlsZHJlbiwgdGhlbiBhbiBlbXB0eSBhcnJheVxuICAgICAqIGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogUmVzdWx0cyBhcmUgY2FjaGVkLCBhbmQgdGh1cyBtYXkgYmUgb3V0IG9mIGRhdGUgaWYgdGhlIGZpbGVzeXN0ZW0gaXNcbiAgICAgKiBtdXRhdGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNiIFRoZSBjYWxsYmFjayBjYWxsZWQgd2l0aCAoZXIsIGVudHJpZXMpLiAgTm90ZSB0aGF0IHRoZSBgZXJgXG4gICAgICogcGFyYW0gaXMgc29tZXdoYXQgZXh0cmFuZW91cywgYXMgYWxsIHJlYWRkaXIoKSBlcnJvcnMgYXJlIGhhbmRsZWQgYW5kXG4gICAgICogc2ltcGx5IHJlc3VsdCBpbiBhbiBlbXB0eSBzZXQgb2YgZW50cmllcyBiZWluZyByZXR1cm5lZC5cbiAgICAgKiBAcGFyYW0gYWxsb3daYWxnbyBCb29sZWFuIGluZGljYXRpbmcgdGhhdCBpbW1lZGlhdGVseSBrbm93biByZXN1bHRzIHNob3VsZFxuICAgICAqICpub3QqIGJlIGRlZmVycmVkIHdpdGggYHF1ZXVlTWljcm90YXNrYC4gRGVmYXVsdHMgdG8gYGZhbHNlYC4gUmVsZWFzZVxuICAgICAqIHphbGdvIGF0IHlvdXIgcGVyaWwsIHRoZSBkYXJrIHBvbnkgbG9yZCBpcyBkZXZpb3VzIGFuZCB1bmZvcmdpdmluZy5cbiAgICAgKi9cbiAgICByZWFkZGlyQ0IoY2IsIGFsbG93WmFsZ28gPSBmYWxzZSkge1xuICAgICAgICBpZiAoIXRoaXMuY2FuUmVhZGRpcigpKSB7XG4gICAgICAgICAgICBpZiAoYWxsb3daYWxnbylcbiAgICAgICAgICAgICAgICBjYihudWxsLCBbXSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gY2IobnVsbCwgW10pKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4oKTtcbiAgICAgICAgaWYgKHRoaXMuY2FsbGVkUmVhZGRpcigpKSB7XG4gICAgICAgICAgICBjb25zdCBjID0gY2hpbGRyZW4uc2xpY2UoMCwgY2hpbGRyZW4ucHJvdmlzaW9uYWwpO1xuICAgICAgICAgICAgaWYgKGFsbG93WmFsZ28pXG4gICAgICAgICAgICAgICAgY2IobnVsbCwgYyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gY2IobnVsbCwgYykpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRvbid0IGhhdmUgdG8gd29ycnkgYWJvdXQgemFsZ28gYXQgdGhpcyBwb2ludC5cbiAgICAgICAgdGhpcy4jb25SZWFkZGlyQ0IucHVzaChjYik7XG4gICAgICAgIGlmICh0aGlzLiNyZWFkZGlyQ0JJbkZsaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3JlYWRkaXJDQkluRmxpZ2h0ID0gdHJ1ZTtcbiAgICAgICAgLy8gZWxzZSByZWFkIHRoZSBkaXJlY3RvcnksIGZpbGwgdXAgY2hpbGRyZW5cbiAgICAgICAgLy8gZGUtcHJvdmlzaW9uYWxpemUgYW55IHByb3Zpc2lvbmFsIGNoaWxkcmVuLlxuICAgICAgICBjb25zdCBmdWxscGF0aCA9IHRoaXMuZnVsbHBhdGgoKTtcbiAgICAgICAgdGhpcy4jZnMucmVhZGRpcihmdWxscGF0aCwgeyB3aXRoRmlsZVR5cGVzOiB0cnVlIH0sIChlciwgZW50cmllcykgPT4ge1xuICAgICAgICAgICAgaWYgKGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jcmVhZGRpckZhaWwoZXIuY29kZSk7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4ucHJvdmlzaW9uYWwgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgd2UgZGlkbid0IGdldCBhbiBlcnJvciwgd2UgYWx3YXlzIGdldCBlbnRyaWVzLlxuICAgICAgICAgICAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZSBvZiBlbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI3JlYWRkaXJBZGRDaGlsZChlLCBjaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuI3JlYWRkaXJTdWNjZXNzKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuI2NhbGxPblJlYWRkaXJDQihjaGlsZHJlbi5zbGljZSgwLCBjaGlsZHJlbi5wcm92aXNpb25hbCkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgI2FzeW5jUmVhZGRpckluRmxpZ2h0O1xuICAgIC8qKlxuICAgICAqIFJldHVybiBhbiBhcnJheSBvZiBrbm93biBjaGlsZCBlbnRyaWVzLlxuICAgICAqXG4gICAgICogSWYgdGhlIFBhdGggY2Fubm90IG9yIGRvZXMgbm90IGNvbnRhaW4gYW55IGNoaWxkcmVuLCB0aGVuIGFuIGVtcHR5IGFycmF5XG4gICAgICogaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBSZXN1bHRzIGFyZSBjYWNoZWQsIGFuZCB0aHVzIG1heSBiZSBvdXQgb2YgZGF0ZSBpZiB0aGUgZmlsZXN5c3RlbSBpc1xuICAgICAqIG11dGF0ZWQuXG4gICAgICovXG4gICAgYXN5bmMgcmVhZGRpcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNhblJlYWRkaXIoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbigpO1xuICAgICAgICBpZiAodGhpcy5jYWxsZWRSZWFkZGlyKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZHJlbi5zbGljZSgwLCBjaGlsZHJlbi5wcm92aXNpb25hbCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZWxzZSByZWFkIHRoZSBkaXJlY3RvcnksIGZpbGwgdXAgY2hpbGRyZW5cbiAgICAgICAgLy8gZGUtcHJvdmlzaW9uYWxpemUgYW55IHByb3Zpc2lvbmFsIGNoaWxkcmVuLlxuICAgICAgICBjb25zdCBmdWxscGF0aCA9IHRoaXMuZnVsbHBhdGgoKTtcbiAgICAgICAgaWYgKHRoaXMuI2FzeW5jUmVhZGRpckluRmxpZ2h0KSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLiNhc3luY1JlYWRkaXJJbkZsaWdodDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgbGV0IHJlc29sdmUgPSAoKSA9PiB7IH07XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgdGhpcy4jYXN5bmNSZWFkZGlySW5GbGlnaHQgPSBuZXcgUHJvbWlzZShyZXMgPT4gKHJlc29sdmUgPSByZXMpKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBlIG9mIGF3YWl0IHRoaXMuI2ZzLnByb21pc2VzLnJlYWRkaXIoZnVsbHBhdGgsIHtcbiAgICAgICAgICAgICAgICAgICAgd2l0aEZpbGVUeXBlczogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNyZWFkZGlyQWRkQ2hpbGQoZSwgY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLiNyZWFkZGlyU3VjY2VzcyhjaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNyZWFkZGlyRmFpbChlci5jb2RlKTtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5wcm92aXNpb25hbCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiNhc3luY1JlYWRkaXJJbkZsaWdodCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hpbGRyZW4uc2xpY2UoMCwgY2hpbGRyZW4ucHJvdmlzaW9uYWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBzeW5jaHJvbm91cyB7QGxpbmsgUGF0aEJhc2UucmVhZGRpcn1cbiAgICAgKi9cbiAgICByZWFkZGlyU3luYygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNhblJlYWRkaXIoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbigpO1xuICAgICAgICBpZiAodGhpcy5jYWxsZWRSZWFkZGlyKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZHJlbi5zbGljZSgwLCBjaGlsZHJlbi5wcm92aXNpb25hbCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZWxzZSByZWFkIHRoZSBkaXJlY3RvcnksIGZpbGwgdXAgY2hpbGRyZW5cbiAgICAgICAgLy8gZGUtcHJvdmlzaW9uYWxpemUgYW55IHByb3Zpc2lvbmFsIGNoaWxkcmVuLlxuICAgICAgICBjb25zdCBmdWxscGF0aCA9IHRoaXMuZnVsbHBhdGgoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZSBvZiB0aGlzLiNmcy5yZWFkZGlyU3luYyhmdWxscGF0aCwge1xuICAgICAgICAgICAgICAgIHdpdGhGaWxlVHlwZXM6IHRydWUsXG4gICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuI3JlYWRkaXJBZGRDaGlsZChlLCBjaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiNyZWFkZGlyU3VjY2VzcyhjaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVyKSB7XG4gICAgICAgICAgICB0aGlzLiNyZWFkZGlyRmFpbChlci5jb2RlKTtcbiAgICAgICAgICAgIGNoaWxkcmVuLnByb3Zpc2lvbmFsID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hpbGRyZW4uc2xpY2UoMCwgY2hpbGRyZW4ucHJvdmlzaW9uYWwpO1xuICAgIH1cbiAgICBjYW5SZWFkZGlyKCkge1xuICAgICAgICBpZiAodGhpcy4jdHlwZSAmIEVOT0NISUxEKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBpZm10ID0gSUZNVCAmIHRoaXMuI3R5cGU7XG4gICAgICAgIC8vIHdlIGFsd2F5cyBzZXQgRU5PVERJUiB3aGVuIHNldHRpbmcgSUZNVCwgc28gc2hvdWxkIGJlIGltcG9zc2libGVcbiAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIGlmICghKGlmbXQgPT09IFVOS05PV04gfHwgaWZtdCA9PT0gSUZESVIgfHwgaWZtdCA9PT0gSUZMTkspKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHNob3VsZFdhbGsoZGlycywgd2Fsa0ZpbHRlcikge1xuICAgICAgICByZXR1cm4gKCh0aGlzLiN0eXBlICYgSUZESVIpID09PSBJRkRJUiAmJlxuICAgICAgICAgICAgISh0aGlzLiN0eXBlICYgRU5PQ0hJTEQpICYmXG4gICAgICAgICAgICAhZGlycy5oYXModGhpcykgJiZcbiAgICAgICAgICAgICghd2Fsa0ZpbHRlciB8fCB3YWxrRmlsdGVyKHRoaXMpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgUGF0aCBvYmplY3QgY29ycmVzcG9uZGluZyB0byBwYXRoIGFzIHJlc29sdmVkXG4gICAgICogYnkgcmVhbHBhdGgoMykuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgcmVhbHBhdGggY2FsbCBmYWlscyBmb3IgYW55IHJlYXNvbiwgYHVuZGVmaW5lZGAgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBSZXN1bHQgaXMgY2FjaGVkLCBhbmQgdGh1cyBtYXkgYmUgb3V0ZGF0ZWQgaWYgdGhlIGZpbGVzeXN0ZW0gaXMgbXV0YXRlZC5cbiAgICAgKiBPbiBzdWNjZXNzLCByZXR1cm5zIGEgUGF0aCBvYmplY3QuXG4gICAgICovXG4gICAgYXN5bmMgcmVhbHBhdGgoKSB7XG4gICAgICAgIGlmICh0aGlzLiNyZWFscGF0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNyZWFscGF0aDtcbiAgICAgICAgaWYgKChFTk9SRUFMUEFUSCB8IEVOT1JFQURMSU5LIHwgRU5PRU5UKSAmIHRoaXMuI3R5cGUpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcnAgPSBhd2FpdCB0aGlzLiNmcy5wcm9taXNlcy5yZWFscGF0aCh0aGlzLmZ1bGxwYXRoKCkpO1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLiNyZWFscGF0aCA9IHRoaXMucmVzb2x2ZShycCkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICB0aGlzLiNtYXJrRU5PUkVBTFBBVEgoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTeW5jaHJvbm91cyB7QGxpbmsgcmVhbHBhdGh9XG4gICAgICovXG4gICAgcmVhbHBhdGhTeW5jKCkge1xuICAgICAgICBpZiAodGhpcy4jcmVhbHBhdGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jcmVhbHBhdGg7XG4gICAgICAgIGlmICgoRU5PUkVBTFBBVEggfCBFTk9SRUFETElOSyB8IEVOT0VOVCkgJiB0aGlzLiN0eXBlKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJwID0gdGhpcy4jZnMucmVhbHBhdGhTeW5jKHRoaXMuZnVsbHBhdGgoKSk7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuI3JlYWxwYXRoID0gdGhpcy5yZXNvbHZlKHJwKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgIHRoaXMuI21hcmtFTk9SRUFMUEFUSCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludGVybmFsIG1ldGhvZCB0byBtYXJrIHRoaXMgUGF0aCBvYmplY3QgYXMgdGhlIHNjdXJyeSBjd2QsXG4gICAgICogY2FsbGVkIGJ5IHtAbGluayBQYXRoU2N1cnJ5I2NoZGlyfVxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgW3NldEFzQ3dkXShvbGRDd2QpIHtcbiAgICAgICAgaWYgKG9sZEN3ZCA9PT0gdGhpcylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgb2xkQ3dkLmlzQ1dEID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNDV0QgPSB0cnVlO1xuICAgICAgICBjb25zdCBjaGFuZ2VkID0gbmV3IFNldChbXSk7XG4gICAgICAgIGxldCBycCA9IFtdO1xuICAgICAgICBsZXQgcCA9IHRoaXM7XG4gICAgICAgIHdoaWxlIChwICYmIHAucGFyZW50KSB7XG4gICAgICAgICAgICBjaGFuZ2VkLmFkZChwKTtcbiAgICAgICAgICAgIHAuI3JlbGF0aXZlID0gcnAuam9pbih0aGlzLnNlcCk7XG4gICAgICAgICAgICBwLiNyZWxhdGl2ZVBvc2l4ID0gcnAuam9pbignLycpO1xuICAgICAgICAgICAgcCA9IHAucGFyZW50O1xuICAgICAgICAgICAgcnAucHVzaCgnLi4nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBub3cgdW4tbWVtb2l6ZSBwYXJlbnRzIG9mIG9sZCBjd2RcbiAgICAgICAgcCA9IG9sZEN3ZDtcbiAgICAgICAgd2hpbGUgKHAgJiYgcC5wYXJlbnQgJiYgIWNoYW5nZWQuaGFzKHApKSB7XG4gICAgICAgICAgICBwLiNyZWxhdGl2ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHAuI3JlbGF0aXZlUG9zaXggPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBwID0gcC5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIFBhdGggY2xhc3MgdXNlZCBvbiB3aW4zMiBzeXN0ZW1zXG4gKlxuICogVXNlcyBgJ1xcXFwnYCBhcyB0aGUgcGF0aCBzZXBhcmF0b3IgZm9yIHJldHVybmVkIHBhdGhzLCBlaXRoZXIgYCdcXFxcJ2Agb3IgYCcvJ2BcbiAqIGFzIHRoZSBwYXRoIHNlcGFyYXRvciBmb3IgcGFyc2luZyBwYXRocy5cbiAqL1xuZXhwb3J0IGNsYXNzIFBhdGhXaW4zMiBleHRlbmRzIFBhdGhCYXNlIHtcbiAgICAvKipcbiAgICAgKiBTZXBhcmF0b3IgZm9yIGdlbmVyYXRpbmcgcGF0aCBzdHJpbmdzLlxuICAgICAqL1xuICAgIHNlcCA9ICdcXFxcJztcbiAgICAvKipcbiAgICAgKiBTZXBhcmF0b3IgZm9yIHBhcnNpbmcgcGF0aCBzdHJpbmdzLlxuICAgICAqL1xuICAgIHNwbGl0U2VwID0gZWl0aGVyU2VwO1xuICAgIC8qKlxuICAgICAqIERvIG5vdCBjcmVhdGUgbmV3IFBhdGggb2JqZWN0cyBkaXJlY3RseS4gIFRoZXkgc2hvdWxkIGFsd2F5cyBiZSBhY2Nlc3NlZFxuICAgICAqIHZpYSB0aGUgUGF0aFNjdXJyeSBjbGFzcyBvciBvdGhlciBtZXRob2RzIG9uIHRoZSBQYXRoIGNsYXNzLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobmFtZSwgdHlwZSA9IFVOS05PV04sIHJvb3QsIHJvb3RzLCBub2Nhc2UsIGNoaWxkcmVuLCBvcHRzKSB7XG4gICAgICAgIHN1cGVyKG5hbWUsIHR5cGUsIHJvb3QsIHJvb3RzLCBub2Nhc2UsIGNoaWxkcmVuLCBvcHRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgbmV3Q2hpbGQobmFtZSwgdHlwZSA9IFVOS05PV04sIG9wdHMgPSB7fSkge1xuICAgICAgICByZXR1cm4gbmV3IFBhdGhXaW4zMihuYW1lLCB0eXBlLCB0aGlzLnJvb3QsIHRoaXMucm9vdHMsIHRoaXMubm9jYXNlLCB0aGlzLmNoaWxkcmVuQ2FjaGUoKSwgb3B0cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGdldFJvb3RTdHJpbmcocGF0aCkge1xuICAgICAgICByZXR1cm4gd2luMzIucGFyc2UocGF0aCkucm9vdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgZ2V0Um9vdChyb290UGF0aCkge1xuICAgICAgICByb290UGF0aCA9IHVuY1RvRHJpdmUocm9vdFBhdGgudG9VcHBlckNhc2UoKSk7XG4gICAgICAgIGlmIChyb290UGF0aCA9PT0gdGhpcy5yb290Lm5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJvb3Q7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb2ssIG5vdCB0aGF0IG9uZSwgY2hlY2sgaWYgaXQgbWF0Y2hlcyBhbm90aGVyIHdlIGtub3cgYWJvdXRcbiAgICAgICAgZm9yIChjb25zdCBbY29tcGFyZSwgcm9vdF0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5yb290cykpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNhbWVSb290KHJvb3RQYXRoLCBjb21wYXJlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5yb290c1tyb290UGF0aF0gPSByb290KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBvdGhlcndpc2UsIGhhdmUgdG8gY3JlYXRlIGEgbmV3IG9uZS5cbiAgICAgICAgcmV0dXJuICh0aGlzLnJvb3RzW3Jvb3RQYXRoXSA9IG5ldyBQYXRoU2N1cnJ5V2luMzIocm9vdFBhdGgsIHRoaXMpLnJvb3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBzYW1lUm9vdChyb290UGF0aCwgY29tcGFyZSA9IHRoaXMucm9vdC5uYW1lKSB7XG4gICAgICAgIC8vIHdpbmRvd3MgY2FuIChyYXJlbHkpIGhhdmUgY2FzZS1zZW5zaXRpdmUgZmlsZXN5c3RlbSwgYnV0XG4gICAgICAgIC8vIFVOQyBhbmQgZHJpdmUgbGV0dGVycyBhcmUgYWx3YXlzIGNhc2UtaW5zZW5zaXRpdmUsIGFuZCBjYW5vbmljYWxseVxuICAgICAgICAvLyByZXByZXNlbnRlZCB1cHBlcmNhc2UuXG4gICAgICAgIHJvb3RQYXRoID0gcm9vdFBhdGhcbiAgICAgICAgICAgIC50b1VwcGVyQ2FzZSgpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFwvL2csICdcXFxcJylcbiAgICAgICAgICAgIC5yZXBsYWNlKHVuY0RyaXZlUmVnZXhwLCAnJDFcXFxcJyk7XG4gICAgICAgIHJldHVybiByb290UGF0aCA9PT0gY29tcGFyZTtcbiAgICB9XG59XG4vKipcbiAqIFBhdGggY2xhc3MgdXNlZCBvbiBhbGwgcG9zaXggc3lzdGVtcy5cbiAqXG4gKiBVc2VzIGAnLydgIGFzIHRoZSBwYXRoIHNlcGFyYXRvci5cbiAqL1xuZXhwb3J0IGNsYXNzIFBhdGhQb3NpeCBleHRlbmRzIFBhdGhCYXNlIHtcbiAgICAvKipcbiAgICAgKiBzZXBhcmF0b3IgZm9yIHBhcnNpbmcgcGF0aCBzdHJpbmdzXG4gICAgICovXG4gICAgc3BsaXRTZXAgPSAnLyc7XG4gICAgLyoqXG4gICAgICogc2VwYXJhdG9yIGZvciBnZW5lcmF0aW5nIHBhdGggc3RyaW5nc1xuICAgICAqL1xuICAgIHNlcCA9ICcvJztcbiAgICAvKipcbiAgICAgKiBEbyBub3QgY3JlYXRlIG5ldyBQYXRoIG9iamVjdHMgZGlyZWN0bHkuICBUaGV5IHNob3VsZCBhbHdheXMgYmUgYWNjZXNzZWRcbiAgICAgKiB2aWEgdGhlIFBhdGhTY3VycnkgY2xhc3Mgb3Igb3RoZXIgbWV0aG9kcyBvbiB0aGUgUGF0aCBjbGFzcy5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHR5cGUgPSBVTktOT1dOLCByb290LCByb290cywgbm9jYXNlLCBjaGlsZHJlbiwgb3B0cykge1xuICAgICAgICBzdXBlcihuYW1lLCB0eXBlLCByb290LCByb290cywgbm9jYXNlLCBjaGlsZHJlbiwgb3B0cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGdldFJvb3RTdHJpbmcocGF0aCkge1xuICAgICAgICByZXR1cm4gcGF0aC5zdGFydHNXaXRoKCcvJykgPyAnLycgOiAnJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgZ2V0Um9vdChfcm9vdFBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgbmV3Q2hpbGQobmFtZSwgdHlwZSA9IFVOS05PV04sIG9wdHMgPSB7fSkge1xuICAgICAgICByZXR1cm4gbmV3IFBhdGhQb3NpeChuYW1lLCB0eXBlLCB0aGlzLnJvb3QsIHRoaXMucm9vdHMsIHRoaXMubm9jYXNlLCB0aGlzLmNoaWxkcmVuQ2FjaGUoKSwgb3B0cyk7XG4gICAgfVxufVxuLyoqXG4gKiBUaGUgYmFzZSBjbGFzcyBmb3IgYWxsIFBhdGhTY3VycnkgY2xhc3NlcywgcHJvdmlkaW5nIHRoZSBpbnRlcmZhY2UgZm9yIHBhdGhcbiAqIHJlc29sdXRpb24gYW5kIGZpbGVzeXN0ZW0gb3BlcmF0aW9ucy5cbiAqXG4gKiBUeXBpY2FsbHksIHlvdSBzaG91bGQgKm5vdCogaW5zdGFudGlhdGUgdGhpcyBjbGFzcyBkaXJlY3RseSwgYnV0IHJhdGhlciBvbmVcbiAqIG9mIHRoZSBwbGF0Zm9ybS1zcGVjaWZpYyBjbGFzc2VzLCBvciB0aGUgZXhwb3J0ZWQge0BsaW5rIFBhdGhTY3Vycnl9IHdoaWNoXG4gKiBkZWZhdWx0cyB0byB0aGUgY3VycmVudCBwbGF0Zm9ybS5cbiAqL1xuZXhwb3J0IGNsYXNzIFBhdGhTY3VycnlCYXNlIHtcbiAgICAvKipcbiAgICAgKiBUaGUgcm9vdCBQYXRoIGVudHJ5IGZvciB0aGUgY3VycmVudCB3b3JraW5nIGRpcmVjdG9yeSBvZiB0aGlzIFNjdXJyeVxuICAgICAqL1xuICAgIHJvb3Q7XG4gICAgLyoqXG4gICAgICogVGhlIHN0cmluZyBwYXRoIGZvciB0aGUgcm9vdCBvZiB0aGlzIFNjdXJyeSdzIGN1cnJlbnQgd29ya2luZyBkaXJlY3RvcnlcbiAgICAgKi9cbiAgICByb290UGF0aDtcbiAgICAvKipcbiAgICAgKiBBIGNvbGxlY3Rpb24gb2YgYWxsIHJvb3RzIGVuY291bnRlcmVkLCByZWZlcmVuY2VkIGJ5IHJvb3RQYXRoXG4gICAgICovXG4gICAgcm9vdHM7XG4gICAgLyoqXG4gICAgICogVGhlIFBhdGggZW50cnkgY29ycmVzcG9uZGluZyB0byB0aGlzIFBhdGhTY3VycnkncyBjdXJyZW50IHdvcmtpbmcgZGlyZWN0b3J5LlxuICAgICAqL1xuICAgIGN3ZDtcbiAgICAjcmVzb2x2ZUNhY2hlO1xuICAgICNyZXNvbHZlUG9zaXhDYWNoZTtcbiAgICAjY2hpbGRyZW47XG4gICAgLyoqXG4gICAgICogUGVyZm9ybSBwYXRoIGNvbXBhcmlzb25zIGNhc2UtaW5zZW5zaXRpdmVseS5cbiAgICAgKlxuICAgICAqIERlZmF1bHRzIHRydWUgb24gRGFyd2luIGFuZCBXaW5kb3dzIHN5c3RlbXMsIGZhbHNlIGVsc2V3aGVyZS5cbiAgICAgKi9cbiAgICBub2Nhc2U7XG4gICAgI2ZzO1xuICAgIC8qKlxuICAgICAqIFRoaXMgY2xhc3Mgc2hvdWxkIG5vdCBiZSBpbnN0YW50aWF0ZWQgZGlyZWN0bHkuXG4gICAgICpcbiAgICAgKiBVc2UgUGF0aFNjdXJyeVdpbjMyLCBQYXRoU2N1cnJ5RGFyd2luLCBQYXRoU2N1cnJ5UG9zaXgsIG9yIFBhdGhTY3VycnlcbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGN3ZCA9IHByb2Nlc3MuY3dkKCksIHBhdGhJbXBsLCBzZXAsIHsgbm9jYXNlLCBjaGlsZHJlbkNhY2hlU2l6ZSA9IDE2ICogMTAyNCwgZnMgPSBkZWZhdWx0RlMsIH0gPSB7fSkge1xuICAgICAgICB0aGlzLiNmcyA9IGZzRnJvbU9wdGlvbihmcyk7XG4gICAgICAgIGlmIChjd2QgaW5zdGFuY2VvZiBVUkwgfHwgY3dkLnN0YXJ0c1dpdGgoJ2ZpbGU6Ly8nKSkge1xuICAgICAgICAgICAgY3dkID0gZmlsZVVSTFRvUGF0aChjd2QpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlc29sdmUgYW5kIHNwbGl0IHJvb3QsIGFuZCB0aGVuIGFkZCB0byB0aGUgc3RvcmUuXG4gICAgICAgIC8vIHRoaXMgaXMgdGhlIG9ubHkgdGltZSB3ZSBjYWxsIHBhdGgucmVzb2x2ZSgpXG4gICAgICAgIGNvbnN0IGN3ZFBhdGggPSBwYXRoSW1wbC5yZXNvbHZlKGN3ZCk7XG4gICAgICAgIHRoaXMucm9vdHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLnJvb3RQYXRoID0gdGhpcy5wYXJzZVJvb3RQYXRoKGN3ZFBhdGgpO1xuICAgICAgICB0aGlzLiNyZXNvbHZlQ2FjaGUgPSBuZXcgUmVzb2x2ZUNhY2hlKCk7XG4gICAgICAgIHRoaXMuI3Jlc29sdmVQb3NpeENhY2hlID0gbmV3IFJlc29sdmVDYWNoZSgpO1xuICAgICAgICB0aGlzLiNjaGlsZHJlbiA9IG5ldyBDaGlsZHJlbkNhY2hlKGNoaWxkcmVuQ2FjaGVTaXplKTtcbiAgICAgICAgY29uc3Qgc3BsaXQgPSBjd2RQYXRoLnN1YnN0cmluZyh0aGlzLnJvb3RQYXRoLmxlbmd0aCkuc3BsaXQoc2VwKTtcbiAgICAgICAgLy8gcmVzb2x2ZSgnLycpIGxlYXZlcyAnJywgc3BsaXRzIHRvIFsnJ10sIHdlIGRvbid0IHdhbnQgdGhhdC5cbiAgICAgICAgaWYgKHNwbGl0Lmxlbmd0aCA9PT0gMSAmJiAhc3BsaXRbMF0pIHtcbiAgICAgICAgICAgIHNwbGl0LnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICBpZiAobm9jYXNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ211c3QgcHJvdmlkZSBub2Nhc2Ugc2V0dGluZyB0byBQYXRoU2N1cnJ5QmFzZSBjdG9yJyk7XG4gICAgICAgIH1cbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgdGhpcy5ub2Nhc2UgPSBub2Nhc2U7XG4gICAgICAgIHRoaXMucm9vdCA9IHRoaXMubmV3Um9vdCh0aGlzLiNmcyk7XG4gICAgICAgIHRoaXMucm9vdHNbdGhpcy5yb290UGF0aF0gPSB0aGlzLnJvb3Q7XG4gICAgICAgIGxldCBwcmV2ID0gdGhpcy5yb290O1xuICAgICAgICBsZXQgbGVuID0gc3BsaXQubGVuZ3RoIC0gMTtcbiAgICAgICAgY29uc3Qgam9pblNlcCA9IHBhdGhJbXBsLnNlcDtcbiAgICAgICAgbGV0IGFicyA9IHRoaXMucm9vdFBhdGg7XG4gICAgICAgIGxldCBzYXdGaXJzdCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2Ygc3BsaXQpIHtcbiAgICAgICAgICAgIGNvbnN0IGwgPSBsZW4tLTtcbiAgICAgICAgICAgIHByZXYgPSBwcmV2LmNoaWxkKHBhcnQsIHtcbiAgICAgICAgICAgICAgICByZWxhdGl2ZTogbmV3IEFycmF5KGwpLmZpbGwoJy4uJykuam9pbihqb2luU2VwKSxcbiAgICAgICAgICAgICAgICByZWxhdGl2ZVBvc2l4OiBuZXcgQXJyYXkobCkuZmlsbCgnLi4nKS5qb2luKCcvJyksXG4gICAgICAgICAgICAgICAgZnVsbHBhdGg6IChhYnMgKz0gKHNhd0ZpcnN0ID8gJycgOiBqb2luU2VwKSArIHBhcnQpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzYXdGaXJzdCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jd2QgPSBwcmV2O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGRlcHRoIG9mIGEgcHJvdmlkZWQgcGF0aCwgc3RyaW5nLCBvciB0aGUgY3dkXG4gICAgICovXG4gICAgZGVwdGgocGF0aCA9IHRoaXMuY3dkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHBhdGggPSB0aGlzLmN3ZC5yZXNvbHZlKHBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXRoLmRlcHRoKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgY2FjaGUgb2YgY2hpbGQgZW50cmllcy4gIEV4cG9zZWQgc28gc3ViY2xhc3NlcyBjYW4gY3JlYXRlXG4gICAgICogY2hpbGQgUGF0aCBvYmplY3RzIGluIGEgcGxhdGZvcm0tc3BlY2lmaWMgd2F5LlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgY2hpbGRyZW5DYWNoZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2NoaWxkcmVuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlIG9uZSBvciBtb3JlIHBhdGggc3RyaW5ncyB0byBhIHJlc29sdmVkIHN0cmluZ1xuICAgICAqXG4gICAgICogU2FtZSBpbnRlcmZhY2UgYXMgcmVxdWlyZSgncGF0aCcpLnJlc29sdmUuXG4gICAgICpcbiAgICAgKiBNdWNoIGZhc3RlciB0aGFuIHBhdGgucmVzb2x2ZSgpIHdoZW4gY2FsbGVkIG11bHRpcGxlIHRpbWVzIGZvciB0aGUgc2FtZVxuICAgICAqIHBhdGgsIGJlY2F1c2UgdGhlIHJlc29sdmVkIFBhdGggb2JqZWN0cyBhcmUgY2FjaGVkLiAgTXVjaCBzbG93ZXJcbiAgICAgKiBvdGhlcndpc2UuXG4gICAgICovXG4gICAgcmVzb2x2ZSguLi5wYXRocykge1xuICAgICAgICAvLyBmaXJzdCBmaWd1cmUgb3V0IHRoZSBtaW5pbXVtIG51bWJlciBvZiBwYXRocyB3ZSBoYXZlIHRvIHRlc3RcbiAgICAgICAgLy8gd2UgYWx3YXlzIHN0YXJ0IGF0IGN3ZCwgYnV0IGFueSBhYnNvbHV0ZXMgd2lsbCBidW1wIHRoZSBzdGFydFxuICAgICAgICBsZXQgciA9ICcnO1xuICAgICAgICBmb3IgKGxldCBpID0gcGF0aHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IHAgPSBwYXRoc1tpXTtcbiAgICAgICAgICAgIGlmICghcCB8fCBwID09PSAnLicpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICByID0gciA/IGAke3B9LyR7cn1gIDogcDtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQWJzb2x1dGUocCkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYWNoZWQgPSB0aGlzLiNyZXNvbHZlQ2FjaGUuZ2V0KHIpO1xuICAgICAgICBpZiAoY2FjaGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5jd2QucmVzb2x2ZShyKS5mdWxscGF0aCgpO1xuICAgICAgICB0aGlzLiNyZXNvbHZlQ2FjaGUuc2V0KHIsIHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc29sdmUgb25lIG9yIG1vcmUgcGF0aCBzdHJpbmdzIHRvIGEgcmVzb2x2ZWQgc3RyaW5nLCByZXR1cm5pbmdcbiAgICAgKiB0aGUgcG9zaXggcGF0aC4gIElkZW50aWNhbCB0byAucmVzb2x2ZSgpIG9uIHBvc2l4IHN5c3RlbXMsIGJ1dCBvblxuICAgICAqIHdpbmRvd3Mgd2lsbCByZXR1cm4gYSBmb3J3YXJkLXNsYXNoIHNlcGFyYXRlZCBVTkMgcGF0aC5cbiAgICAgKlxuICAgICAqIFNhbWUgaW50ZXJmYWNlIGFzIHJlcXVpcmUoJ3BhdGgnKS5yZXNvbHZlLlxuICAgICAqXG4gICAgICogTXVjaCBmYXN0ZXIgdGhhbiBwYXRoLnJlc29sdmUoKSB3aGVuIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyBmb3IgdGhlIHNhbWVcbiAgICAgKiBwYXRoLCBiZWNhdXNlIHRoZSByZXNvbHZlZCBQYXRoIG9iamVjdHMgYXJlIGNhY2hlZC4gIE11Y2ggc2xvd2VyXG4gICAgICogb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHJlc29sdmVQb3NpeCguLi5wYXRocykge1xuICAgICAgICAvLyBmaXJzdCBmaWd1cmUgb3V0IHRoZSBtaW5pbXVtIG51bWJlciBvZiBwYXRocyB3ZSBoYXZlIHRvIHRlc3RcbiAgICAgICAgLy8gd2UgYWx3YXlzIHN0YXJ0IGF0IGN3ZCwgYnV0IGFueSBhYnNvbHV0ZXMgd2lsbCBidW1wIHRoZSBzdGFydFxuICAgICAgICBsZXQgciA9ICcnO1xuICAgICAgICBmb3IgKGxldCBpID0gcGF0aHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IHAgPSBwYXRoc1tpXTtcbiAgICAgICAgICAgIGlmICghcCB8fCBwID09PSAnLicpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICByID0gciA/IGAke3B9LyR7cn1gIDogcDtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQWJzb2x1dGUocCkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYWNoZWQgPSB0aGlzLiNyZXNvbHZlUG9zaXhDYWNoZS5nZXQocik7XG4gICAgICAgIGlmIChjYWNoZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmN3ZC5yZXNvbHZlKHIpLmZ1bGxwYXRoUG9zaXgoKTtcbiAgICAgICAgdGhpcy4jcmVzb2x2ZVBvc2l4Q2FjaGUuc2V0KHIsIHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGZpbmQgdGhlIHJlbGF0aXZlIHBhdGggZnJvbSB0aGUgY3dkIHRvIHRoZSBzdXBwbGllZCBwYXRoIHN0cmluZyBvciBlbnRyeVxuICAgICAqL1xuICAgIHJlbGF0aXZlKGVudHJ5ID0gdGhpcy5jd2QpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGVudHJ5ID0gdGhpcy5jd2QucmVzb2x2ZShlbnRyeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVudHJ5LnJlbGF0aXZlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGZpbmQgdGhlIHJlbGF0aXZlIHBhdGggZnJvbSB0aGUgY3dkIHRvIHRoZSBzdXBwbGllZCBwYXRoIHN0cmluZyBvclxuICAgICAqIGVudHJ5LCB1c2luZyAvIGFzIHRoZSBwYXRoIGRlbGltaXRlciwgZXZlbiBvbiBXaW5kb3dzLlxuICAgICAqL1xuICAgIHJlbGF0aXZlUG9zaXgoZW50cnkgPSB0aGlzLmN3ZCkge1xuICAgICAgICBpZiAodHlwZW9mIGVudHJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZW50cnkgPSB0aGlzLmN3ZC5yZXNvbHZlKGVudHJ5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW50cnkucmVsYXRpdmVQb3NpeCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGJhc2VuYW1lIGZvciB0aGUgcHJvdmlkZWQgc3RyaW5nIG9yIFBhdGggb2JqZWN0XG4gICAgICovXG4gICAgYmFzZW5hbWUoZW50cnkgPSB0aGlzLmN3ZCkge1xuICAgICAgICBpZiAodHlwZW9mIGVudHJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZW50cnkgPSB0aGlzLmN3ZC5yZXNvbHZlKGVudHJ5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW50cnkubmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBkaXJuYW1lIGZvciB0aGUgcHJvdmlkZWQgc3RyaW5nIG9yIFBhdGggb2JqZWN0XG4gICAgICovXG4gICAgZGlybmFtZShlbnRyeSA9IHRoaXMuY3dkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZW50cnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBlbnRyeSA9IHRoaXMuY3dkLnJlc29sdmUoZW50cnkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoZW50cnkucGFyZW50IHx8IGVudHJ5KS5mdWxscGF0aCgpO1xuICAgIH1cbiAgICBhc3luYyByZWFkZGlyKGVudHJ5ID0gdGhpcy5jd2QsIG9wdHMgPSB7XG4gICAgICAgIHdpdGhGaWxlVHlwZXM6IHRydWUsXG4gICAgfSkge1xuICAgICAgICBpZiAodHlwZW9mIGVudHJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZW50cnkgPSB0aGlzLmN3ZC5yZXNvbHZlKGVudHJ5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghKGVudHJ5IGluc3RhbmNlb2YgUGF0aEJhc2UpKSB7XG4gICAgICAgICAgICBvcHRzID0gZW50cnk7XG4gICAgICAgICAgICBlbnRyeSA9IHRoaXMuY3dkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgd2l0aEZpbGVUeXBlcyB9ID0gb3B0cztcbiAgICAgICAgaWYgKCFlbnRyeS5jYW5SZWFkZGlyKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHAgPSBhd2FpdCBlbnRyeS5yZWFkZGlyKCk7XG4gICAgICAgICAgICByZXR1cm4gd2l0aEZpbGVUeXBlcyA/IHAgOiBwLm1hcChlID0+IGUubmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVhZGRpclN5bmMoZW50cnkgPSB0aGlzLmN3ZCwgb3B0cyA9IHtcbiAgICAgICAgd2l0aEZpbGVUeXBlczogdHJ1ZSxcbiAgICB9KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZW50cnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBlbnRyeSA9IHRoaXMuY3dkLnJlc29sdmUoZW50cnkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCEoZW50cnkgaW5zdGFuY2VvZiBQYXRoQmFzZSkpIHtcbiAgICAgICAgICAgIG9wdHMgPSBlbnRyeTtcbiAgICAgICAgICAgIGVudHJ5ID0gdGhpcy5jd2Q7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyB3aXRoRmlsZVR5cGVzID0gdHJ1ZSB9ID0gb3B0cztcbiAgICAgICAgaWYgKCFlbnRyeS5jYW5SZWFkZGlyKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh3aXRoRmlsZVR5cGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gZW50cnkucmVhZGRpclN5bmMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBlbnRyeS5yZWFkZGlyU3luYygpLm1hcChlID0+IGUubmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbCBsc3RhdCgpIG9uIHRoZSBzdHJpbmcgb3IgUGF0aCBvYmplY3QsIGFuZCB1cGRhdGUgYWxsIGtub3duXG4gICAgICogaW5mb3JtYXRpb24gdGhhdCBjYW4gYmUgZGV0ZXJtaW5lZC5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCB1bmxpa2UgYGZzLmxzdGF0KClgLCB0aGUgcmV0dXJuZWQgdmFsdWUgZG9lcyBub3QgY29udGFpbiBzb21lXG4gICAgICogaW5mb3JtYXRpb24sIHN1Y2ggYXMgYG1vZGVgLCBgZGV2YCwgYG5saW5rYCwgYW5kIGBpbm9gLiAgSWYgdGhhdFxuICAgICAqIGluZm9ybWF0aW9uIGlzIHJlcXVpcmVkLCB5b3Ugd2lsbCBuZWVkIHRvIGNhbGwgYGZzLmxzdGF0YCB5b3Vyc2VsZi5cbiAgICAgKlxuICAgICAqIElmIHRoZSBQYXRoIHJlZmVycyB0byBhIG5vbmV4aXN0ZW50IGZpbGUsIG9yIGlmIHRoZSBsc3RhdCBjYWxsIGZhaWxzIGZvclxuICAgICAqIGFueSByZWFzb24sIGB1bmRlZmluZWRgIGlzIHJldHVybmVkLiAgT3RoZXJ3aXNlIHRoZSB1cGRhdGVkIFBhdGggb2JqZWN0IGlzXG4gICAgICogcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBSZXN1bHRzIGFyZSBjYWNoZWQsIGFuZCB0aHVzIG1heSBiZSBvdXQgb2YgZGF0ZSBpZiB0aGUgZmlsZXN5c3RlbSBpc1xuICAgICAqIG11dGF0ZWQuXG4gICAgICovXG4gICAgYXN5bmMgbHN0YXQoZW50cnkgPSB0aGlzLmN3ZCkge1xuICAgICAgICBpZiAodHlwZW9mIGVudHJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZW50cnkgPSB0aGlzLmN3ZC5yZXNvbHZlKGVudHJ5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW50cnkubHN0YXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogc3luY2hyb25vdXMge0BsaW5rIFBhdGhTY3VycnlCYXNlLmxzdGF0fVxuICAgICAqL1xuICAgIGxzdGF0U3luYyhlbnRyeSA9IHRoaXMuY3dkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZW50cnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBlbnRyeSA9IHRoaXMuY3dkLnJlc29sdmUoZW50cnkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnRyeS5sc3RhdFN5bmMoKTtcbiAgICB9XG4gICAgYXN5bmMgcmVhZGxpbmsoZW50cnkgPSB0aGlzLmN3ZCwgeyB3aXRoRmlsZVR5cGVzIH0gPSB7XG4gICAgICAgIHdpdGhGaWxlVHlwZXM6IGZhbHNlLFxuICAgIH0pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGVudHJ5ID0gdGhpcy5jd2QucmVzb2x2ZShlbnRyeSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIShlbnRyeSBpbnN0YW5jZW9mIFBhdGhCYXNlKSkge1xuICAgICAgICAgICAgd2l0aEZpbGVUeXBlcyA9IGVudHJ5LndpdGhGaWxlVHlwZXM7XG4gICAgICAgICAgICBlbnRyeSA9IHRoaXMuY3dkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGUgPSBhd2FpdCBlbnRyeS5yZWFkbGluaygpO1xuICAgICAgICByZXR1cm4gd2l0aEZpbGVUeXBlcyA/IGUgOiBlPy5mdWxscGF0aCgpO1xuICAgIH1cbiAgICByZWFkbGlua1N5bmMoZW50cnkgPSB0aGlzLmN3ZCwgeyB3aXRoRmlsZVR5cGVzIH0gPSB7XG4gICAgICAgIHdpdGhGaWxlVHlwZXM6IGZhbHNlLFxuICAgIH0pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGVudHJ5ID0gdGhpcy5jd2QucmVzb2x2ZShlbnRyeSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIShlbnRyeSBpbnN0YW5jZW9mIFBhdGhCYXNlKSkge1xuICAgICAgICAgICAgd2l0aEZpbGVUeXBlcyA9IGVudHJ5LndpdGhGaWxlVHlwZXM7XG4gICAgICAgICAgICBlbnRyeSA9IHRoaXMuY3dkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGUgPSBlbnRyeS5yZWFkbGlua1N5bmMoKTtcbiAgICAgICAgcmV0dXJuIHdpdGhGaWxlVHlwZXMgPyBlIDogZT8uZnVsbHBhdGgoKTtcbiAgICB9XG4gICAgYXN5bmMgcmVhbHBhdGgoZW50cnkgPSB0aGlzLmN3ZCwgeyB3aXRoRmlsZVR5cGVzIH0gPSB7XG4gICAgICAgIHdpdGhGaWxlVHlwZXM6IGZhbHNlLFxuICAgIH0pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGVudHJ5ID0gdGhpcy5jd2QucmVzb2x2ZShlbnRyeSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIShlbnRyeSBpbnN0YW5jZW9mIFBhdGhCYXNlKSkge1xuICAgICAgICAgICAgd2l0aEZpbGVUeXBlcyA9IGVudHJ5LndpdGhGaWxlVHlwZXM7XG4gICAgICAgICAgICBlbnRyeSA9IHRoaXMuY3dkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGUgPSBhd2FpdCBlbnRyeS5yZWFscGF0aCgpO1xuICAgICAgICByZXR1cm4gd2l0aEZpbGVUeXBlcyA/IGUgOiBlPy5mdWxscGF0aCgpO1xuICAgIH1cbiAgICByZWFscGF0aFN5bmMoZW50cnkgPSB0aGlzLmN3ZCwgeyB3aXRoRmlsZVR5cGVzIH0gPSB7XG4gICAgICAgIHdpdGhGaWxlVHlwZXM6IGZhbHNlLFxuICAgIH0pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGVudHJ5ID0gdGhpcy5jd2QucmVzb2x2ZShlbnRyeSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIShlbnRyeSBpbnN0YW5jZW9mIFBhdGhCYXNlKSkge1xuICAgICAgICAgICAgd2l0aEZpbGVUeXBlcyA9IGVudHJ5LndpdGhGaWxlVHlwZXM7XG4gICAgICAgICAgICBlbnRyeSA9IHRoaXMuY3dkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGUgPSBlbnRyeS5yZWFscGF0aFN5bmMoKTtcbiAgICAgICAgcmV0dXJuIHdpdGhGaWxlVHlwZXMgPyBlIDogZT8uZnVsbHBhdGgoKTtcbiAgICB9XG4gICAgYXN5bmMgd2FsayhlbnRyeSA9IHRoaXMuY3dkLCBvcHRzID0ge30pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGVudHJ5ID0gdGhpcy5jd2QucmVzb2x2ZShlbnRyeSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIShlbnRyeSBpbnN0YW5jZW9mIFBhdGhCYXNlKSkge1xuICAgICAgICAgICAgb3B0cyA9IGVudHJ5O1xuICAgICAgICAgICAgZW50cnkgPSB0aGlzLmN3ZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHdpdGhGaWxlVHlwZXMgPSB0cnVlLCBmb2xsb3cgPSBmYWxzZSwgZmlsdGVyLCB3YWxrRmlsdGVyLCB9ID0gb3B0cztcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgICAgICBpZiAoIWZpbHRlciB8fCBmaWx0ZXIoZW50cnkpKSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2god2l0aEZpbGVUeXBlcyA/IGVudHJ5IDogZW50cnkuZnVsbHBhdGgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGlycyA9IG5ldyBTZXQoKTtcbiAgICAgICAgY29uc3Qgd2FsayA9IChkaXIsIGNiKSA9PiB7XG4gICAgICAgICAgICBkaXJzLmFkZChkaXIpO1xuICAgICAgICAgICAgZGlyLnJlYWRkaXJDQigoZXIsIGVudHJpZXMpID0+IHtcbiAgICAgICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgICAgICAgICBpZiAoZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNiKGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgICAgICAgICBsZXQgbGVuID0gZW50cmllcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKCFsZW4pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgtLWxlbiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBlIG9mIGVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWx0ZXIgfHwgZmlsdGVyKGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2god2l0aEZpbGVUeXBlcyA/IGUgOiBlLmZ1bGxwYXRoKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb2xsb3cgJiYgZS5pc1N5bWJvbGljTGluaygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnJlYWxwYXRoKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihyID0+IChyPy5pc1Vua25vd24oKSA/IHIubHN0YXQoKSA6IHIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKHIgPT4gcj8uc2hvdWxkV2FsayhkaXJzLCB3YWxrRmlsdGVyKSA/IHdhbGsociwgbmV4dCkgOiBuZXh0KCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUuc2hvdWxkV2FsayhkaXJzLCB3YWxrRmlsdGVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhbGsoZSwgbmV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0cnVlKTsgLy8gemFsZ29vb29vb29cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBlbnRyeTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgICAgICAgICAgd2FsayhzdGFydCwgZXIgPT4ge1xuICAgICAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgICAgIGlmIChlcilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlaihlcik7XG4gICAgICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgICAgICAgICByZXMocmVzdWx0cyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHdhbGtTeW5jKGVudHJ5ID0gdGhpcy5jd2QsIG9wdHMgPSB7fSkge1xuICAgICAgICBpZiAodHlwZW9mIGVudHJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZW50cnkgPSB0aGlzLmN3ZC5yZXNvbHZlKGVudHJ5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghKGVudHJ5IGluc3RhbmNlb2YgUGF0aEJhc2UpKSB7XG4gICAgICAgICAgICBvcHRzID0gZW50cnk7XG4gICAgICAgICAgICBlbnRyeSA9IHRoaXMuY3dkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgd2l0aEZpbGVUeXBlcyA9IHRydWUsIGZvbGxvdyA9IGZhbHNlLCBmaWx0ZXIsIHdhbGtGaWx0ZXIsIH0gPSBvcHRzO1xuICAgICAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgICAgIGlmICghZmlsdGVyIHx8IGZpbHRlcihlbnRyeSkpIHtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCh3aXRoRmlsZVR5cGVzID8gZW50cnkgOiBlbnRyeS5mdWxscGF0aCgpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkaXJzID0gbmV3IFNldChbZW50cnldKTtcbiAgICAgICAgZm9yIChjb25zdCBkaXIgb2YgZGlycykge1xuICAgICAgICAgICAgY29uc3QgZW50cmllcyA9IGRpci5yZWFkZGlyU3luYygpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBlIG9mIGVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWZpbHRlciB8fCBmaWx0ZXIoZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHdpdGhGaWxlVHlwZXMgPyBlIDogZS5mdWxscGF0aCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHIgPSBlO1xuICAgICAgICAgICAgICAgIGlmIChlLmlzU3ltYm9saWNMaW5rKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoZm9sbG93ICYmIChyID0gZS5yZWFscGF0aFN5bmMoKSkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyLmlzVW5rbm93bigpKVxuICAgICAgICAgICAgICAgICAgICAgICAgci5sc3RhdFN5bmMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHIuc2hvdWxkV2FsayhkaXJzLCB3YWxrRmlsdGVyKSkge1xuICAgICAgICAgICAgICAgICAgICBkaXJzLmFkZChyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN1cHBvcnQgZm9yIGBmb3IgYXdhaXRgXG4gICAgICpcbiAgICAgKiBBbGlhcyBmb3Ige0BsaW5rIFBhdGhTY3VycnlCYXNlLml0ZXJhdGV9XG4gICAgICpcbiAgICAgKiBOb3RlOiBBcyBvZiBOb2RlIDE5LCB0aGlzIGlzIHZlcnkgc2xvdywgY29tcGFyZWQgdG8gb3RoZXIgbWV0aG9kcyBvZlxuICAgICAqIHdhbGtpbmcuICBDb25zaWRlciB1c2luZyB7QGxpbmsgUGF0aFNjdXJyeUJhc2Uuc3RyZWFtfSBpZiBtZW1vcnkgb3ZlcmhlYWRcbiAgICAgKiBhbmQgYmFja3ByZXNzdXJlIGFyZSBjb25jZXJucywgb3Ige0BsaW5rIFBhdGhTY3VycnlCYXNlLndhbGt9IGlmIG5vdC5cbiAgICAgKi9cbiAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRlKCk7XG4gICAgfVxuICAgIGl0ZXJhdGUoZW50cnkgPSB0aGlzLmN3ZCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIC8vIGl0ZXJhdGluZyBhc3luYyBvdmVyIHRoZSBzdHJlYW0gaXMgc2lnbmlmaWNhbnRseSBtb3JlIHBlcmZvcm1hbnQsXG4gICAgICAgIC8vIGVzcGVjaWFsbHkgaW4gdGhlIHdhcm0tY2FjaGUgc2NlbmFyaW8sIGJlY2F1c2UgaXQgYnVmZmVycyB1cCBkaXJlY3RvcnlcbiAgICAgICAgLy8gZW50cmllcyBpbiB0aGUgYmFja2dyb3VuZCBpbnN0ZWFkIG9mIHdhaXRpbmcgZm9yIGEgeWllbGQgZm9yIGVhY2ggb25lLlxuICAgICAgICBpZiAodHlwZW9mIGVudHJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZW50cnkgPSB0aGlzLmN3ZC5yZXNvbHZlKGVudHJ5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghKGVudHJ5IGluc3RhbmNlb2YgUGF0aEJhc2UpKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gZW50cnk7XG4gICAgICAgICAgICBlbnRyeSA9IHRoaXMuY3dkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmVhbShlbnRyeSwgb3B0aW9ucylbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGluZyBvdmVyIGEgUGF0aFNjdXJyeSBwZXJmb3JtcyBhIHN5bmNocm9ub3VzIHdhbGsuXG4gICAgICpcbiAgICAgKiBBbGlhcyBmb3Ige0BsaW5rIFBhdGhTY3VycnlCYXNlLml0ZXJhdGVTeW5jfVxuICAgICAqL1xuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRlU3luYygpO1xuICAgIH1cbiAgICAqaXRlcmF0ZVN5bmMoZW50cnkgPSB0aGlzLmN3ZCwgb3B0cyA9IHt9KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZW50cnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBlbnRyeSA9IHRoaXMuY3dkLnJlc29sdmUoZW50cnkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCEoZW50cnkgaW5zdGFuY2VvZiBQYXRoQmFzZSkpIHtcbiAgICAgICAgICAgIG9wdHMgPSBlbnRyeTtcbiAgICAgICAgICAgIGVudHJ5ID0gdGhpcy5jd2Q7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyB3aXRoRmlsZVR5cGVzID0gdHJ1ZSwgZm9sbG93ID0gZmFsc2UsIGZpbHRlciwgd2Fsa0ZpbHRlciwgfSA9IG9wdHM7XG4gICAgICAgIGlmICghZmlsdGVyIHx8IGZpbHRlcihlbnRyeSkpIHtcbiAgICAgICAgICAgIHlpZWxkIHdpdGhGaWxlVHlwZXMgPyBlbnRyeSA6IGVudHJ5LmZ1bGxwYXRoKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGlycyA9IG5ldyBTZXQoW2VudHJ5XSk7XG4gICAgICAgIGZvciAoY29uc3QgZGlyIG9mIGRpcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGVudHJpZXMgPSBkaXIucmVhZGRpclN5bmMoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZSBvZiBlbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmaWx0ZXIgfHwgZmlsdGVyKGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHdpdGhGaWxlVHlwZXMgPyBlIDogZS5mdWxscGF0aCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgciA9IGU7XG4gICAgICAgICAgICAgICAgaWYgKGUuaXNTeW1ib2xpY0xpbmsoKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShmb2xsb3cgJiYgKHIgPSBlLnJlYWxwYXRoU3luYygpKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHIuaXNVbmtub3duKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByLmxzdGF0U3luYygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoci5zaG91bGRXYWxrKGRpcnMsIHdhbGtGaWx0ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpcnMuYWRkKHIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzdHJlYW0oZW50cnkgPSB0aGlzLmN3ZCwgb3B0cyA9IHt9KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZW50cnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBlbnRyeSA9IHRoaXMuY3dkLnJlc29sdmUoZW50cnkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCEoZW50cnkgaW5zdGFuY2VvZiBQYXRoQmFzZSkpIHtcbiAgICAgICAgICAgIG9wdHMgPSBlbnRyeTtcbiAgICAgICAgICAgIGVudHJ5ID0gdGhpcy5jd2Q7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyB3aXRoRmlsZVR5cGVzID0gdHJ1ZSwgZm9sbG93ID0gZmFsc2UsIGZpbHRlciwgd2Fsa0ZpbHRlciwgfSA9IG9wdHM7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBuZXcgTWluaXBhc3MoeyBvYmplY3RNb2RlOiB0cnVlIH0pO1xuICAgICAgICBpZiAoIWZpbHRlciB8fCBmaWx0ZXIoZW50cnkpKSB7XG4gICAgICAgICAgICByZXN1bHRzLndyaXRlKHdpdGhGaWxlVHlwZXMgPyBlbnRyeSA6IGVudHJ5LmZ1bGxwYXRoKCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRpcnMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGNvbnN0IHF1ZXVlID0gW2VudHJ5XTtcbiAgICAgICAgbGV0IHByb2Nlc3NpbmcgPSAwO1xuICAgICAgICBjb25zdCBwcm9jZXNzID0gKCkgPT4ge1xuICAgICAgICAgICAgbGV0IHBhdXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgd2hpbGUgKCFwYXVzZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkaXIgPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIGlmICghZGlyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzaW5nID09PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5lbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcm9jZXNzaW5nKys7XG4gICAgICAgICAgICAgICAgZGlycy5hZGQoZGlyKTtcbiAgICAgICAgICAgICAgICBjb25zdCBvblJlYWRkaXIgPSAoZXIsIGVudHJpZXMsIGRpZFJlYWxwYXRocyA9IGZhbHNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cy5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICAgICAgICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvbGxvdyAmJiAhZGlkUmVhbHBhdGhzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBlIG9mIGVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5pc1N5bWJvbGljTGluaygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlYWxwYXRoKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKChyKSA9PiByPy5pc1Vua25vd24oKSA/IHIubHN0YXQoKSA6IHIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvbWlzZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oKCkgPT4gb25SZWFkZGlyKG51bGwsIGVudHJpZXMsIHRydWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBlIG9mIGVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlICYmICghZmlsdGVyIHx8IGZpbHRlcihlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdHMud3JpdGUod2l0aEZpbGVUeXBlcyA/IGUgOiBlLmZ1bGxwYXRoKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NpbmctLTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBlIG9mIGVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHIgPSBlLnJlYWxwYXRoQ2FjaGVkKCkgfHwgZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyLnNob3VsZFdhbGsoZGlycywgd2Fsa0ZpbHRlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXVzZWQgJiYgIXJlc3VsdHMuZmxvd2luZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5vbmNlKCdkcmFpbicsIHByb2Nlc3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFzeW5jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIHphbGdvIGNvbnRhaW5tZW50XG4gICAgICAgICAgICAgICAgbGV0IHN5bmMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGRpci5yZWFkZGlyQ0Iob25SZWFkZGlyLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBzeW5jID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHByb2Nlc3MoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuICAgIHN0cmVhbVN5bmMoZW50cnkgPSB0aGlzLmN3ZCwgb3B0cyA9IHt9KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZW50cnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBlbnRyeSA9IHRoaXMuY3dkLnJlc29sdmUoZW50cnkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCEoZW50cnkgaW5zdGFuY2VvZiBQYXRoQmFzZSkpIHtcbiAgICAgICAgICAgIG9wdHMgPSBlbnRyeTtcbiAgICAgICAgICAgIGVudHJ5ID0gdGhpcy5jd2Q7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyB3aXRoRmlsZVR5cGVzID0gdHJ1ZSwgZm9sbG93ID0gZmFsc2UsIGZpbHRlciwgd2Fsa0ZpbHRlciwgfSA9IG9wdHM7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBuZXcgTWluaXBhc3MoeyBvYmplY3RNb2RlOiB0cnVlIH0pO1xuICAgICAgICBjb25zdCBkaXJzID0gbmV3IFNldCgpO1xuICAgICAgICBpZiAoIWZpbHRlciB8fCBmaWx0ZXIoZW50cnkpKSB7XG4gICAgICAgICAgICByZXN1bHRzLndyaXRlKHdpdGhGaWxlVHlwZXMgPyBlbnRyeSA6IGVudHJ5LmZ1bGxwYXRoKCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHF1ZXVlID0gW2VudHJ5XTtcbiAgICAgICAgbGV0IHByb2Nlc3NpbmcgPSAwO1xuICAgICAgICBjb25zdCBwcm9jZXNzID0gKCkgPT4ge1xuICAgICAgICAgICAgbGV0IHBhdXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgd2hpbGUgKCFwYXVzZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkaXIgPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIGlmICghZGlyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzaW5nID09PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5lbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcm9jZXNzaW5nKys7XG4gICAgICAgICAgICAgICAgZGlycy5hZGQoZGlyKTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbnRyaWVzID0gZGlyLnJlYWRkaXJTeW5jKCk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBlIG9mIGVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWx0ZXIgfHwgZmlsdGVyKGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdHMud3JpdGUod2l0aEZpbGVUeXBlcyA/IGUgOiBlLmZ1bGxwYXRoKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcm9jZXNzaW5nLS07XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBlIG9mIGVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHIgPSBlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5pc1N5bWJvbGljTGluaygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShmb2xsb3cgJiYgKHIgPSBlLnJlYWxwYXRoU3luYygpKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoci5pc1Vua25vd24oKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByLmxzdGF0U3luYygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChyLnNob3VsZFdhbGsoZGlycywgd2Fsa0ZpbHRlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2gocik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGF1c2VkICYmICFyZXN1bHRzLmZsb3dpbmcpXG4gICAgICAgICAgICAgICAgcmVzdWx0cy5vbmNlKCdkcmFpbicsIHByb2Nlc3MpO1xuICAgICAgICB9O1xuICAgICAgICBwcm9jZXNzKCk7XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbiAgICBjaGRpcihwYXRoID0gdGhpcy5jd2QpIHtcbiAgICAgICAgY29uc3Qgb2xkQ3dkID0gdGhpcy5jd2Q7XG4gICAgICAgIHRoaXMuY3dkID0gdHlwZW9mIHBhdGggPT09ICdzdHJpbmcnID8gdGhpcy5jd2QucmVzb2x2ZShwYXRoKSA6IHBhdGg7XG4gICAgICAgIHRoaXMuY3dkW3NldEFzQ3dkXShvbGRDd2QpO1xuICAgIH1cbn1cbi8qKlxuICogV2luZG93cyBpbXBsZW1lbnRhdGlvbiBvZiB7QGxpbmsgUGF0aFNjdXJyeUJhc2V9XG4gKlxuICogRGVmYXVsdHMgdG8gY2FzZSBpbnNlbnNpdHZlLCB1c2VzIGAnXFxcXCdgIHRvIGdlbmVyYXRlIHBhdGggc3RyaW5ncy4gIFVzZXNcbiAqIHtAbGluayBQYXRoV2luMzJ9IGZvciBQYXRoIG9iamVjdHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBQYXRoU2N1cnJ5V2luMzIgZXh0ZW5kcyBQYXRoU2N1cnJ5QmFzZSB7XG4gICAgLyoqXG4gICAgICogc2VwYXJhdG9yIGZvciBnZW5lcmF0aW5nIHBhdGggc3RyaW5nc1xuICAgICAqL1xuICAgIHNlcCA9ICdcXFxcJztcbiAgICBjb25zdHJ1Y3Rvcihjd2QgPSBwcm9jZXNzLmN3ZCgpLCBvcHRzID0ge30pIHtcbiAgICAgICAgY29uc3QgeyBub2Nhc2UgPSB0cnVlIH0gPSBvcHRzO1xuICAgICAgICBzdXBlcihjd2QsIHdpbjMyLCAnXFxcXCcsIHsgLi4ub3B0cywgbm9jYXNlIH0pO1xuICAgICAgICB0aGlzLm5vY2FzZSA9IG5vY2FzZTtcbiAgICAgICAgZm9yIChsZXQgcCA9IHRoaXMuY3dkOyBwOyBwID0gcC5wYXJlbnQpIHtcbiAgICAgICAgICAgIHAubm9jYXNlID0gdGhpcy5ub2Nhc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcGFyc2VSb290UGF0aChkaXIpIHtcbiAgICAgICAgLy8gaWYgdGhlIHBhdGggc3RhcnRzIHdpdGggYSBzaW5nbGUgc2VwYXJhdG9yLCBpdCdzIG5vdCBhIFVOQywgYW5kIHdlJ2xsXG4gICAgICAgIC8vIGp1c3QgZ2V0IHNlcGFyYXRvciBhcyB0aGUgcm9vdCwgYW5kIGRyaXZlRnJvbVVOQyB3aWxsIHJldHVybiBcXFxuICAgICAgICAvLyBJbiB0aGF0IGNhc2UsIG1vdW50IFxcIG9uIHRoZSByb290IGZyb20gdGhlIGN3ZC5cbiAgICAgICAgcmV0dXJuIHdpbjMyLnBhcnNlKGRpcikucm9vdC50b1VwcGVyQ2FzZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBuZXdSb290KGZzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGF0aFdpbjMyKHRoaXMucm9vdFBhdGgsIElGRElSLCB1bmRlZmluZWQsIHRoaXMucm9vdHMsIHRoaXMubm9jYXNlLCB0aGlzLmNoaWxkcmVuQ2FjaGUoKSwgeyBmcyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHByb3ZpZGVkIHBhdGggc3RyaW5nIGlzIGFuIGFic29sdXRlIHBhdGhcbiAgICAgKi9cbiAgICBpc0Fic29sdXRlKHApIHtcbiAgICAgICAgcmV0dXJuIChwLnN0YXJ0c1dpdGgoJy8nKSB8fCBwLnN0YXJ0c1dpdGgoJ1xcXFwnKSB8fCAvXlthLXpdOihcXC98XFxcXCkvaS50ZXN0KHApKTtcbiAgICB9XG59XG4vKipcbiAqIHtAbGluayBQYXRoU2N1cnJ5QmFzZX0gaW1wbGVtZW50YXRpb24gZm9yIGFsbCBwb3NpeCBzeXN0ZW1zIG90aGVyIHRoYW4gRGFyd2luLlxuICpcbiAqIERlZmF1bHRzIHRvIGNhc2Utc2Vuc2l0aXZlIG1hdGNoaW5nLCB1c2VzIGAnLydgIHRvIGdlbmVyYXRlIHBhdGggc3RyaW5ncy5cbiAqXG4gKiBVc2VzIHtAbGluayBQYXRoUG9zaXh9IGZvciBQYXRoIG9iamVjdHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBQYXRoU2N1cnJ5UG9zaXggZXh0ZW5kcyBQYXRoU2N1cnJ5QmFzZSB7XG4gICAgLyoqXG4gICAgICogc2VwYXJhdG9yIGZvciBnZW5lcmF0aW5nIHBhdGggc3RyaW5nc1xuICAgICAqL1xuICAgIHNlcCA9ICcvJztcbiAgICBjb25zdHJ1Y3Rvcihjd2QgPSBwcm9jZXNzLmN3ZCgpLCBvcHRzID0ge30pIHtcbiAgICAgICAgY29uc3QgeyBub2Nhc2UgPSBmYWxzZSB9ID0gb3B0cztcbiAgICAgICAgc3VwZXIoY3dkLCBwb3NpeCwgJy8nLCB7IC4uLm9wdHMsIG5vY2FzZSB9KTtcbiAgICAgICAgdGhpcy5ub2Nhc2UgPSBub2Nhc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHBhcnNlUm9vdFBhdGgoX2Rpcikge1xuICAgICAgICByZXR1cm4gJy8nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBuZXdSb290KGZzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGF0aFBvc2l4KHRoaXMucm9vdFBhdGgsIElGRElSLCB1bmRlZmluZWQsIHRoaXMucm9vdHMsIHRoaXMubm9jYXNlLCB0aGlzLmNoaWxkcmVuQ2FjaGUoKSwgeyBmcyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHByb3ZpZGVkIHBhdGggc3RyaW5nIGlzIGFuIGFic29sdXRlIHBhdGhcbiAgICAgKi9cbiAgICBpc0Fic29sdXRlKHApIHtcbiAgICAgICAgcmV0dXJuIHAuc3RhcnRzV2l0aCgnLycpO1xuICAgIH1cbn1cbi8qKlxuICoge0BsaW5rIFBhdGhTY3VycnlCYXNlfSBpbXBsZW1lbnRhdGlvbiBmb3IgRGFyd2luIChtYWNPUykgc3lzdGVtcy5cbiAqXG4gKiBEZWZhdWx0cyB0byBjYXNlLWluc2Vuc2l0aXZlIG1hdGNoaW5nLCB1c2VzIGAnLydgIGZvciBnZW5lcmF0aW5nIHBhdGhcbiAqIHN0cmluZ3MuXG4gKlxuICogVXNlcyB7QGxpbmsgUGF0aFBvc2l4fSBmb3IgUGF0aCBvYmplY3RzLlxuICovXG5leHBvcnQgY2xhc3MgUGF0aFNjdXJyeURhcndpbiBleHRlbmRzIFBhdGhTY3VycnlQb3NpeCB7XG4gICAgY29uc3RydWN0b3IoY3dkID0gcHJvY2Vzcy5jd2QoKSwgb3B0cyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHsgbm9jYXNlID0gdHJ1ZSB9ID0gb3B0cztcbiAgICAgICAgc3VwZXIoY3dkLCB7IC4uLm9wdHMsIG5vY2FzZSB9KTtcbiAgICB9XG59XG4vKipcbiAqIERlZmF1bHQge0BsaW5rIFBhdGhCYXNlfSBpbXBsZW1lbnRhdGlvbiBmb3IgdGhlIGN1cnJlbnQgcGxhdGZvcm0uXG4gKlxuICoge0BsaW5rIFBhdGhXaW4zMn0gb24gV2luZG93cyBzeXN0ZW1zLCB7QGxpbmsgUGF0aFBvc2l4fSBvbiBhbGwgb3RoZXJzLlxuICovXG5leHBvcnQgY29uc3QgUGF0aCA9IHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicgPyBQYXRoV2luMzIgOiBQYXRoUG9zaXg7XG4vKipcbiAqIERlZmF1bHQge0BsaW5rIFBhdGhTY3VycnlCYXNlfSBpbXBsZW1lbnRhdGlvbiBmb3IgdGhlIGN1cnJlbnQgcGxhdGZvcm0uXG4gKlxuICoge0BsaW5rIFBhdGhTY3VycnlXaW4zMn0gb24gV2luZG93cyBzeXN0ZW1zLCB7QGxpbmsgUGF0aFNjdXJyeURhcndpbn0gb25cbiAqIERhcndpbiAobWFjT1MpIHN5c3RlbXMsIHtAbGluayBQYXRoU2N1cnJ5UG9zaXh9IG9uIGFsbCBvdGhlcnMuXG4gKi9cbmV4cG9ydCBjb25zdCBQYXRoU2N1cnJ5ID0gcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyA/IFBhdGhTY3VycnlXaW4zMlxuICAgIDogcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ2RhcndpbicgPyBQYXRoU2N1cnJ5RGFyd2luXG4gICAgICAgIDogUGF0aFNjdXJyeVBvc2l4O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/e2b/node_modules/path-scurry/dist/esm/index.js\n");

/***/ })

};
;