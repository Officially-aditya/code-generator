"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/inngest";
exports.ids = ["vendor-chunks/inngest"];
exports.modules = {

/***/ "(rsc)/./node_modules/inngest/api/api.js":
/*!*****************************************!*\
  !*** ./node_modules/inngest/api/api.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InngestApi = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/inngest/node_modules/zod/lib/index.js\");\nconst consts_js_1 = __webpack_require__(/*! ../helpers/consts.js */ \"(rsc)/./node_modules/inngest/helpers/consts.js\");\nconst devserver_js_1 = __webpack_require__(/*! ../helpers/devserver.js */ \"(rsc)/./node_modules/inngest/helpers/devserver.js\");\nconst errors_js_1 = __webpack_require__(/*! ../helpers/errors.js */ \"(rsc)/./node_modules/inngest/helpers/errors.js\");\nconst net_js_1 = __webpack_require__(/*! ../helpers/net.js */ \"(rsc)/./node_modules/inngest/helpers/net.js\");\nconst strings_js_1 = __webpack_require__(/*! ../helpers/strings.js */ \"(rsc)/./node_modules/inngest/helpers/strings.js\");\nconst types_js_1 = __webpack_require__(/*! ../types.js */ \"(rsc)/./node_modules/inngest/types.js\");\nconst schema_js_1 = __webpack_require__(/*! ./schema.js */ \"(rsc)/./node_modules/inngest/api/schema.js\");\nconst realtimeSubscriptionTokenSchema = zod_1.z.object({\n    jwt: zod_1.z.string(),\n});\nconst sendSignalSuccessResponseSchema = zod_1.z.object({\n    data: zod_1.z.object({\n        run_id: zod_1.z.string().min(1),\n    }),\n});\nclass InngestApi {\n    constructor({ baseUrl, signingKey, signingKeyFallback, fetch, mode, }) {\n        this.apiBaseUrl = baseUrl;\n        this.signingKey = signingKey;\n        this.signingKeyFallback = signingKeyFallback;\n        this.fetch = fetch;\n        this.mode = mode;\n    }\n    get hashedKey() {\n        return (0, strings_js_1.hashSigningKey)(this.signingKey);\n    }\n    get hashedFallbackKey() {\n        if (!this.signingKeyFallback) {\n            return;\n        }\n        return (0, strings_js_1.hashSigningKey)(this.signingKeyFallback);\n    }\n    // set the signing key in case it was not instantiated previously\n    setSigningKey(key) {\n        if (typeof key === \"string\" && this.signingKey === \"\") {\n            this.signingKey = key;\n        }\n    }\n    setSigningKeyFallback(key) {\n        if (typeof key === \"string\" && !this.signingKeyFallback) {\n            this.signingKeyFallback = key;\n        }\n    }\n    async getTargetUrl(path) {\n        if (this.apiBaseUrl) {\n            return new URL(path, this.apiBaseUrl);\n        }\n        let url = new URL(path, consts_js_1.defaultInngestApiBaseUrl);\n        if (this.mode.isDev && this.mode.isInferred && !this.apiBaseUrl) {\n            const devAvailable = await (0, devserver_js_1.devServerAvailable)(consts_js_1.defaultDevServerHost, this.fetch);\n            if (devAvailable) {\n                url = new URL(path, consts_js_1.defaultDevServerHost);\n            }\n        }\n        return url;\n    }\n    async getRunSteps(runId, version) {\n        return (0, net_js_1.fetchWithAuthFallback)({\n            authToken: this.hashedKey,\n            authTokenFallback: this.hashedFallbackKey,\n            fetch: this.fetch,\n            url: await this.getTargetUrl(`/v0/runs/${runId}/actions`),\n        })\n            .then(async (resp) => {\n            const data = await resp.json();\n            if (resp.ok) {\n                return (0, types_js_1.ok)(schema_js_1.stepsSchemas[version].parse(data));\n            }\n            else {\n                return (0, types_js_1.err)(schema_js_1.errorSchema.parse(data));\n            }\n        })\n            .catch((error) => {\n            return (0, types_js_1.err)({\n                error: (0, errors_js_1.getErrorMessage)(error, \"Unknown error retrieving step data\"),\n                status: 500,\n            });\n        });\n    }\n    async getRunBatch(runId) {\n        return (0, net_js_1.fetchWithAuthFallback)({\n            authToken: this.hashedKey,\n            authTokenFallback: this.hashedFallbackKey,\n            fetch: this.fetch,\n            url: await this.getTargetUrl(`/v0/runs/${runId}/batch`),\n        })\n            .then(async (resp) => {\n            const data = await resp.json();\n            if (resp.ok) {\n                return (0, types_js_1.ok)(schema_js_1.batchSchema.parse(data));\n            }\n            else {\n                return (0, types_js_1.err)(schema_js_1.errorSchema.parse(data));\n            }\n        })\n            .catch((error) => {\n            return (0, types_js_1.err)({\n                error: (0, errors_js_1.getErrorMessage)(error, \"Unknown error retrieving event batch\"),\n                status: 500,\n            });\n        });\n    }\n    async publish(publishOptions, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    data) {\n        // todo it may not be a \"text/stream\"\n        const isStream = data instanceof ReadableStream;\n        const url = await this.getTargetUrl(\"/v1/realtime/publish\");\n        url.searchParams.set(\"channel\", publishOptions.channel || \"\");\n        if (publishOptions.runId) {\n            url.searchParams.set(\"run_id\", publishOptions.runId);\n        }\n        publishOptions.topics.forEach((topic) => {\n            url.searchParams.append(\"topic\", topic);\n        });\n        return (0, net_js_1.fetchWithAuthFallback)({\n            authToken: this.hashedKey,\n            authTokenFallback: this.hashedFallbackKey,\n            fetch: this.fetch,\n            url,\n            options: Object.assign({ method: \"POST\", body: isStream\n                    ? data\n                    : typeof data === \"string\"\n                        ? data\n                        : JSON.stringify(data), headers: {\n                    \"Content-Type\": isStream ? \"text/stream\" : \"application/json\",\n                } }, (isStream ? { duplex: \"half\" } : {})),\n        })\n            .then((res) => {\n            if (!res.ok) {\n                throw new Error(`Failed to publish event: ${res.status} ${res.statusText}`);\n            }\n            return (0, types_js_1.ok)(undefined);\n        })\n            .catch((error) => {\n            return (0, types_js_1.err)({\n                error: (0, errors_js_1.getErrorMessage)(error, \"Unknown error publishing event\"),\n                status: 500,\n            });\n        });\n    }\n    async sendSignal(signalOptions, options) {\n        const url = await this.getTargetUrl(\"/v1/signals\");\n        const body = {\n            signal: signalOptions.signal,\n            data: signalOptions.data,\n        };\n        return (0, net_js_1.fetchWithAuthFallback)({\n            authToken: this.hashedKey,\n            authTokenFallback: this.hashedFallbackKey,\n            fetch: this.fetch,\n            url,\n            options: {\n                method: \"POST\",\n                body: JSON.stringify(body),\n                headers: Object.assign({ \"Content-Type\": \"application/json\" }, options === null || options === void 0 ? void 0 : options.headers),\n            },\n        })\n            .then(async (res) => {\n            // A 404 is valid if the signal was not found.\n            if (res.status === 404) {\n                return (0, types_js_1.ok)({\n                    runId: undefined,\n                });\n            }\n            // Save a clone of the response we can use to get the text of if we fail\n            // to parse the JSON.\n            const resClone = res.clone();\n            // JSON!\n            let json;\n            try {\n                json = await res.json();\n            }\n            catch (error) {\n                // res.json() failed so not a valid JSON response\n                return (0, types_js_1.err)({\n                    error: `Failed to send signal: ${res.status} ${res.statusText} - ${await resClone.text()}`,\n                    status: res.status,\n                });\n            }\n            // If we're not 2xx, something went wrong.\n            if (!res.ok) {\n                try {\n                    return (0, types_js_1.err)(schema_js_1.errorSchema.parse(json));\n                }\n                catch (_a) {\n                    // schema parse failed\n                    return (0, types_js_1.err)({\n                        error: `Failed to send signal: ${res.status} ${res.statusText} - ${await res.text()}`,\n                        status: res.status,\n                    });\n                }\n            }\n            // If we are 2xx, we should have a run_id.\n            const parseRes = sendSignalSuccessResponseSchema.safeParse(json);\n            if (!parseRes.success) {\n                return (0, types_js_1.err)({\n                    error: `Successfully sent signal, but response parsing failed: ${res.status} ${res.statusText} - ${await resClone.text()}`,\n                    status: res.status,\n                });\n            }\n            return (0, types_js_1.ok)({\n                runId: parseRes.data.data.run_id,\n            });\n        })\n            .catch((error) => {\n            // Catch-all if various things go wrong\n            return (0, types_js_1.err)({\n                error: (0, errors_js_1.getErrorMessage)(error, \"Unknown error sending signal\"),\n                status: 500,\n            });\n        });\n    }\n    async getSubscriptionToken(channel, topics) {\n        const url = await this.getTargetUrl(\"/v1/realtime/token\");\n        const body = topics.map((topic) => ({\n            channel,\n            name: topic,\n            kind: \"run\",\n        }));\n        return (0, net_js_1.fetchWithAuthFallback)({\n            authToken: this.hashedKey,\n            authTokenFallback: this.hashedFallbackKey,\n            fetch: this.fetch,\n            url,\n            options: {\n                method: \"POST\",\n                body: JSON.stringify(body),\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                },\n            },\n        })\n            .then(async (res) => {\n            if (!res.ok) {\n                throw new Error(`Failed to get subscription token: ${res.status} ${res.statusText} - ${await res.text()}`);\n            }\n            const data = realtimeSubscriptionTokenSchema.parse(await res.json());\n            return data.jwt;\n        })\n            .catch((error) => {\n            throw new Error((0, errors_js_1.getErrorMessage)(error, \"Unknown error getting subscription token\"));\n        });\n    }\n}\nexports.InngestApi = InngestApi;\n//# sourceMappingURL=api.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9hcGkvYXBpLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQjtBQUNsQixjQUFjLG1CQUFPLENBQUMsdUVBQUs7QUFDM0Isb0JBQW9CLG1CQUFPLENBQUMsNEVBQXNCO0FBQ2xELHVCQUF1QixtQkFBTyxDQUFDLGtGQUF5QjtBQUN4RCxvQkFBb0IsbUJBQU8sQ0FBQyw0RUFBc0I7QUFDbEQsaUJBQWlCLG1CQUFPLENBQUMsc0VBQW1CO0FBQzVDLHFCQUFxQixtQkFBTyxDQUFDLDhFQUF1QjtBQUNwRCxtQkFBbUIsbUJBQU8sQ0FBQywwREFBYTtBQUN4QyxvQkFBb0IsbUJBQU8sQ0FBQywrREFBYTtBQUN6QztBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0Q7QUFDQSxrQkFBa0IsdURBQXVEO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsTUFBTTtBQUMzRCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELE1BQU07QUFDM0QsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnQkFBZ0IsaUJBQWlCLElBQUk7QUFDeEQsU0FBUztBQUNUO0FBQ0E7QUFDQSw0REFBNEQsWUFBWSxFQUFFLGVBQWU7QUFDekY7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLG9DQUFvQztBQUM3RSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFlBQVksRUFBRSxnQkFBZ0IsSUFBSSxzQkFBc0I7QUFDN0c7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELFlBQVksRUFBRSxnQkFBZ0IsSUFBSSxpQkFBaUI7QUFDNUc7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGLFlBQVksRUFBRSxnQkFBZ0IsSUFBSSxzQkFBc0I7QUFDN0k7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxxRUFBcUUsWUFBWSxFQUFFLGdCQUFnQixJQUFJLGlCQUFpQjtBQUN4SDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdml2ZS12aWJlLWFpLW5leHQvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9hcGkvYXBpLmpzPzFjZGEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLklubmdlc3RBcGkgPSB2b2lkIDA7XG5jb25zdCB6b2RfMSA9IHJlcXVpcmUoXCJ6b2RcIik7XG5jb25zdCBjb25zdHNfanNfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL2NvbnN0cy5qc1wiKTtcbmNvbnN0IGRldnNlcnZlcl9qc18xID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvZGV2c2VydmVyLmpzXCIpO1xuY29uc3QgZXJyb3JzX2pzXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9lcnJvcnMuanNcIik7XG5jb25zdCBuZXRfanNfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL25ldC5qc1wiKTtcbmNvbnN0IHN0cmluZ3NfanNfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL3N0cmluZ3MuanNcIik7XG5jb25zdCB0eXBlc19qc18xID0gcmVxdWlyZShcIi4uL3R5cGVzLmpzXCIpO1xuY29uc3Qgc2NoZW1hX2pzXzEgPSByZXF1aXJlKFwiLi9zY2hlbWEuanNcIik7XG5jb25zdCByZWFsdGltZVN1YnNjcmlwdGlvblRva2VuU2NoZW1hID0gem9kXzEuei5vYmplY3Qoe1xuICAgIGp3dDogem9kXzEuei5zdHJpbmcoKSxcbn0pO1xuY29uc3Qgc2VuZFNpZ25hbFN1Y2Nlc3NSZXNwb25zZVNjaGVtYSA9IHpvZF8xLnoub2JqZWN0KHtcbiAgICBkYXRhOiB6b2RfMS56Lm9iamVjdCh7XG4gICAgICAgIHJ1bl9pZDogem9kXzEuei5zdHJpbmcoKS5taW4oMSksXG4gICAgfSksXG59KTtcbmNsYXNzIElubmdlc3RBcGkge1xuICAgIGNvbnN0cnVjdG9yKHsgYmFzZVVybCwgc2lnbmluZ0tleSwgc2lnbmluZ0tleUZhbGxiYWNrLCBmZXRjaCwgbW9kZSwgfSkge1xuICAgICAgICB0aGlzLmFwaUJhc2VVcmwgPSBiYXNlVXJsO1xuICAgICAgICB0aGlzLnNpZ25pbmdLZXkgPSBzaWduaW5nS2V5O1xuICAgICAgICB0aGlzLnNpZ25pbmdLZXlGYWxsYmFjayA9IHNpZ25pbmdLZXlGYWxsYmFjaztcbiAgICAgICAgdGhpcy5mZXRjaCA9IGZldGNoO1xuICAgICAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgIH1cbiAgICBnZXQgaGFzaGVkS2V5KCkge1xuICAgICAgICByZXR1cm4gKDAsIHN0cmluZ3NfanNfMS5oYXNoU2lnbmluZ0tleSkodGhpcy5zaWduaW5nS2V5KTtcbiAgICB9XG4gICAgZ2V0IGhhc2hlZEZhbGxiYWNrS2V5KCkge1xuICAgICAgICBpZiAoIXRoaXMuc2lnbmluZ0tleUZhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCBzdHJpbmdzX2pzXzEuaGFzaFNpZ25pbmdLZXkpKHRoaXMuc2lnbmluZ0tleUZhbGxiYWNrKTtcbiAgICB9XG4gICAgLy8gc2V0IHRoZSBzaWduaW5nIGtleSBpbiBjYXNlIGl0IHdhcyBub3QgaW5zdGFudGlhdGVkIHByZXZpb3VzbHlcbiAgICBzZXRTaWduaW5nS2V5KGtleSkge1xuICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiAmJiB0aGlzLnNpZ25pbmdLZXkgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHRoaXMuc2lnbmluZ0tleSA9IGtleTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRTaWduaW5nS2V5RmFsbGJhY2soa2V5KSB7XG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiICYmICF0aGlzLnNpZ25pbmdLZXlGYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5zaWduaW5nS2V5RmFsbGJhY2sgPSBrZXk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0VGFyZ2V0VXJsKHBhdGgpIHtcbiAgICAgICAgaWYgKHRoaXMuYXBpQmFzZVVybCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVUkwocGF0aCwgdGhpcy5hcGlCYXNlVXJsKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdXJsID0gbmV3IFVSTChwYXRoLCBjb25zdHNfanNfMS5kZWZhdWx0SW5uZ2VzdEFwaUJhc2VVcmwpO1xuICAgICAgICBpZiAodGhpcy5tb2RlLmlzRGV2ICYmIHRoaXMubW9kZS5pc0luZmVycmVkICYmICF0aGlzLmFwaUJhc2VVcmwpIHtcbiAgICAgICAgICAgIGNvbnN0IGRldkF2YWlsYWJsZSA9IGF3YWl0ICgwLCBkZXZzZXJ2ZXJfanNfMS5kZXZTZXJ2ZXJBdmFpbGFibGUpKGNvbnN0c19qc18xLmRlZmF1bHREZXZTZXJ2ZXJIb3N0LCB0aGlzLmZldGNoKTtcbiAgICAgICAgICAgIGlmIChkZXZBdmFpbGFibGUpIHtcbiAgICAgICAgICAgICAgICB1cmwgPSBuZXcgVVJMKHBhdGgsIGNvbnN0c19qc18xLmRlZmF1bHREZXZTZXJ2ZXJIb3N0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH1cbiAgICBhc3luYyBnZXRSdW5TdGVwcyhydW5JZCwgdmVyc2lvbikge1xuICAgICAgICByZXR1cm4gKDAsIG5ldF9qc18xLmZldGNoV2l0aEF1dGhGYWxsYmFjaykoe1xuICAgICAgICAgICAgYXV0aFRva2VuOiB0aGlzLmhhc2hlZEtleSxcbiAgICAgICAgICAgIGF1dGhUb2tlbkZhbGxiYWNrOiB0aGlzLmhhc2hlZEZhbGxiYWNrS2V5LFxuICAgICAgICAgICAgZmV0Y2g6IHRoaXMuZmV0Y2gsXG4gICAgICAgICAgICB1cmw6IGF3YWl0IHRoaXMuZ2V0VGFyZ2V0VXJsKGAvdjAvcnVucy8ke3J1bklkfS9hY3Rpb25zYCksXG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbihhc3luYyAocmVzcCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3AuanNvbigpO1xuICAgICAgICAgICAgaWYgKHJlc3Aub2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIHR5cGVzX2pzXzEub2spKHNjaGVtYV9qc18xLnN0ZXBzU2NoZW1hc1t2ZXJzaW9uXS5wYXJzZShkYXRhKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIHR5cGVzX2pzXzEuZXJyKShzY2hlbWFfanNfMS5lcnJvclNjaGVtYS5wYXJzZShkYXRhKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIHR5cGVzX2pzXzEuZXJyKSh7XG4gICAgICAgICAgICAgICAgZXJyb3I6ICgwLCBlcnJvcnNfanNfMS5nZXRFcnJvck1lc3NhZ2UpKGVycm9yLCBcIlVua25vd24gZXJyb3IgcmV0cmlldmluZyBzdGVwIGRhdGFcIiksXG4gICAgICAgICAgICAgICAgc3RhdHVzOiA1MDAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGdldFJ1bkJhdGNoKHJ1bklkKSB7XG4gICAgICAgIHJldHVybiAoMCwgbmV0X2pzXzEuZmV0Y2hXaXRoQXV0aEZhbGxiYWNrKSh7XG4gICAgICAgICAgICBhdXRoVG9rZW46IHRoaXMuaGFzaGVkS2V5LFxuICAgICAgICAgICAgYXV0aFRva2VuRmFsbGJhY2s6IHRoaXMuaGFzaGVkRmFsbGJhY2tLZXksXG4gICAgICAgICAgICBmZXRjaDogdGhpcy5mZXRjaCxcbiAgICAgICAgICAgIHVybDogYXdhaXQgdGhpcy5nZXRUYXJnZXRVcmwoYC92MC9ydW5zLyR7cnVuSWR9L2JhdGNoYCksXG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbihhc3luYyAocmVzcCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3AuanNvbigpO1xuICAgICAgICAgICAgaWYgKHJlc3Aub2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIHR5cGVzX2pzXzEub2spKHNjaGVtYV9qc18xLmJhdGNoU2NoZW1hLnBhcnNlKGRhdGEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgdHlwZXNfanNfMS5lcnIpKHNjaGVtYV9qc18xLmVycm9yU2NoZW1hLnBhcnNlKGRhdGEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgdHlwZXNfanNfMS5lcnIpKHtcbiAgICAgICAgICAgICAgICBlcnJvcjogKDAsIGVycm9yc19qc18xLmdldEVycm9yTWVzc2FnZSkoZXJyb3IsIFwiVW5rbm93biBlcnJvciByZXRyaWV2aW5nIGV2ZW50IGJhdGNoXCIpLFxuICAgICAgICAgICAgICAgIHN0YXR1czogNTAwLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBwdWJsaXNoKHB1Ymxpc2hPcHRpb25zLCBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGRhdGEpIHtcbiAgICAgICAgLy8gdG9kbyBpdCBtYXkgbm90IGJlIGEgXCJ0ZXh0L3N0cmVhbVwiXG4gICAgICAgIGNvbnN0IGlzU3RyZWFtID0gZGF0YSBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtO1xuICAgICAgICBjb25zdCB1cmwgPSBhd2FpdCB0aGlzLmdldFRhcmdldFVybChcIi92MS9yZWFsdGltZS9wdWJsaXNoXCIpO1xuICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldChcImNoYW5uZWxcIiwgcHVibGlzaE9wdGlvbnMuY2hhbm5lbCB8fCBcIlwiKTtcbiAgICAgICAgaWYgKHB1Ymxpc2hPcHRpb25zLnJ1bklkKSB7XG4gICAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldChcInJ1bl9pZFwiLCBwdWJsaXNoT3B0aW9ucy5ydW5JZCk7XG4gICAgICAgIH1cbiAgICAgICAgcHVibGlzaE9wdGlvbnMudG9waWNzLmZvckVhY2goKHRvcGljKSA9PiB7XG4gICAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChcInRvcGljXCIsIHRvcGljKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoMCwgbmV0X2pzXzEuZmV0Y2hXaXRoQXV0aEZhbGxiYWNrKSh7XG4gICAgICAgICAgICBhdXRoVG9rZW46IHRoaXMuaGFzaGVkS2V5LFxuICAgICAgICAgICAgYXV0aFRva2VuRmFsbGJhY2s6IHRoaXMuaGFzaGVkRmFsbGJhY2tLZXksXG4gICAgICAgICAgICBmZXRjaDogdGhpcy5mZXRjaCxcbiAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgIG9wdGlvbnM6IE9iamVjdC5hc3NpZ24oeyBtZXRob2Q6IFwiUE9TVFwiLCBib2R5OiBpc1N0cmVhbVxuICAgICAgICAgICAgICAgICAgICA/IGRhdGFcbiAgICAgICAgICAgICAgICAgICAgOiB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgICAgICAgICAgICAgICAgPyBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICA6IEpTT04uc3RyaW5naWZ5KGRhdGEpLCBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IGlzU3RyZWFtID8gXCJ0ZXh0L3N0cmVhbVwiIDogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgfSB9LCAoaXNTdHJlYW0gPyB7IGR1cGxleDogXCJoYWxmXCIgfSA6IHt9KSksXG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigocmVzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXJlcy5vaykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHB1Ymxpc2ggZXZlbnQ6ICR7cmVzLnN0YXR1c30gJHtyZXMuc3RhdHVzVGV4dH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoMCwgdHlwZXNfanNfMS5vaykodW5kZWZpbmVkKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgdHlwZXNfanNfMS5lcnIpKHtcbiAgICAgICAgICAgICAgICBlcnJvcjogKDAsIGVycm9yc19qc18xLmdldEVycm9yTWVzc2FnZSkoZXJyb3IsIFwiVW5rbm93biBlcnJvciBwdWJsaXNoaW5nIGV2ZW50XCIpLFxuICAgICAgICAgICAgICAgIHN0YXR1czogNTAwLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBzZW5kU2lnbmFsKHNpZ25hbE9wdGlvbnMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgdXJsID0gYXdhaXQgdGhpcy5nZXRUYXJnZXRVcmwoXCIvdjEvc2lnbmFsc1wiKTtcbiAgICAgICAgY29uc3QgYm9keSA9IHtcbiAgICAgICAgICAgIHNpZ25hbDogc2lnbmFsT3B0aW9ucy5zaWduYWwsXG4gICAgICAgICAgICBkYXRhOiBzaWduYWxPcHRpb25zLmRhdGEsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiAoMCwgbmV0X2pzXzEuZmV0Y2hXaXRoQXV0aEZhbGxiYWNrKSh7XG4gICAgICAgICAgICBhdXRoVG9rZW46IHRoaXMuaGFzaGVkS2V5LFxuICAgICAgICAgICAgYXV0aFRva2VuRmFsbGJhY2s6IHRoaXMuaGFzaGVkRmFsbGJhY2tLZXksXG4gICAgICAgICAgICBmZXRjaDogdGhpcy5mZXRjaCxcbiAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaGVhZGVycyksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oYXN5bmMgKHJlcykgPT4ge1xuICAgICAgICAgICAgLy8gQSA0MDQgaXMgdmFsaWQgaWYgdGhlIHNpZ25hbCB3YXMgbm90IGZvdW5kLlxuICAgICAgICAgICAgaWYgKHJlcy5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgdHlwZXNfanNfMS5vaykoe1xuICAgICAgICAgICAgICAgICAgICBydW5JZDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2F2ZSBhIGNsb25lIG9mIHRoZSByZXNwb25zZSB3ZSBjYW4gdXNlIHRvIGdldCB0aGUgdGV4dCBvZiBpZiB3ZSBmYWlsXG4gICAgICAgICAgICAvLyB0byBwYXJzZSB0aGUgSlNPTi5cbiAgICAgICAgICAgIGNvbnN0IHJlc0Nsb25lID0gcmVzLmNsb25lKCk7XG4gICAgICAgICAgICAvLyBKU09OIVxuICAgICAgICAgICAgbGV0IGpzb247XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGpzb24gPSBhd2FpdCByZXMuanNvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVzLmpzb24oKSBmYWlsZWQgc28gbm90IGEgdmFsaWQgSlNPTiByZXNwb25zZVxuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgdHlwZXNfanNfMS5lcnIpKHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGBGYWlsZWQgdG8gc2VuZCBzaWduYWw6ICR7cmVzLnN0YXR1c30gJHtyZXMuc3RhdHVzVGV4dH0gLSAke2F3YWl0IHJlc0Nsb25lLnRleHQoKX1gLFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHJlcy5zdGF0dXMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB3ZSdyZSBub3QgMnh4LCBzb21ldGhpbmcgd2VudCB3cm9uZy5cbiAgICAgICAgICAgIGlmICghcmVzLm9rKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCB0eXBlc19qc18xLmVycikoc2NoZW1hX2pzXzEuZXJyb3JTY2hlbWEucGFyc2UoanNvbikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2NoZW1hIHBhcnNlIGZhaWxlZFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIHR5cGVzX2pzXzEuZXJyKSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogYEZhaWxlZCB0byBzZW5kIHNpZ25hbDogJHtyZXMuc3RhdHVzfSAke3Jlcy5zdGF0dXNUZXh0fSAtICR7YXdhaXQgcmVzLnRleHQoKX1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiByZXMuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB3ZSBhcmUgMnh4LCB3ZSBzaG91bGQgaGF2ZSBhIHJ1bl9pZC5cbiAgICAgICAgICAgIGNvbnN0IHBhcnNlUmVzID0gc2VuZFNpZ25hbFN1Y2Nlc3NSZXNwb25zZVNjaGVtYS5zYWZlUGFyc2UoanNvbik7XG4gICAgICAgICAgICBpZiAoIXBhcnNlUmVzLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIHR5cGVzX2pzXzEuZXJyKSh7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBgU3VjY2Vzc2Z1bGx5IHNlbnQgc2lnbmFsLCBidXQgcmVzcG9uc2UgcGFyc2luZyBmYWlsZWQ6ICR7cmVzLnN0YXR1c30gJHtyZXMuc3RhdHVzVGV4dH0gLSAke2F3YWl0IHJlc0Nsb25lLnRleHQoKX1gLFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHJlcy5zdGF0dXMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKDAsIHR5cGVzX2pzXzEub2spKHtcbiAgICAgICAgICAgICAgICBydW5JZDogcGFyc2VSZXMuZGF0YS5kYXRhLnJ1bl9pZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgLy8gQ2F0Y2gtYWxsIGlmIHZhcmlvdXMgdGhpbmdzIGdvIHdyb25nXG4gICAgICAgICAgICByZXR1cm4gKDAsIHR5cGVzX2pzXzEuZXJyKSh7XG4gICAgICAgICAgICAgICAgZXJyb3I6ICgwLCBlcnJvcnNfanNfMS5nZXRFcnJvck1lc3NhZ2UpKGVycm9yLCBcIlVua25vd24gZXJyb3Igc2VuZGluZyBzaWduYWxcIiksXG4gICAgICAgICAgICAgICAgc3RhdHVzOiA1MDAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGdldFN1YnNjcmlwdGlvblRva2VuKGNoYW5uZWwsIHRvcGljcykge1xuICAgICAgICBjb25zdCB1cmwgPSBhd2FpdCB0aGlzLmdldFRhcmdldFVybChcIi92MS9yZWFsdGltZS90b2tlblwiKTtcbiAgICAgICAgY29uc3QgYm9keSA9IHRvcGljcy5tYXAoKHRvcGljKSA9PiAoe1xuICAgICAgICAgICAgY2hhbm5lbCxcbiAgICAgICAgICAgIG5hbWU6IHRvcGljLFxuICAgICAgICAgICAga2luZDogXCJydW5cIixcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gKDAsIG5ldF9qc18xLmZldGNoV2l0aEF1dGhGYWxsYmFjaykoe1xuICAgICAgICAgICAgYXV0aFRva2VuOiB0aGlzLmhhc2hlZEtleSxcbiAgICAgICAgICAgIGF1dGhUb2tlbkZhbGxiYWNrOiB0aGlzLmhhc2hlZEZhbGxiYWNrS2V5LFxuICAgICAgICAgICAgZmV0Y2g6IHRoaXMuZmV0Y2gsXG4gICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oYXN5bmMgKHJlcykgPT4ge1xuICAgICAgICAgICAgaWYgKCFyZXMub2spIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBnZXQgc3Vic2NyaXB0aW9uIHRva2VuOiAke3Jlcy5zdGF0dXN9ICR7cmVzLnN0YXR1c1RleHR9IC0gJHthd2FpdCByZXMudGV4dCgpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHJlYWx0aW1lU3Vic2NyaXB0aW9uVG9rZW5TY2hlbWEucGFyc2UoYXdhaXQgcmVzLmpzb24oKSk7XG4gICAgICAgICAgICByZXR1cm4gZGF0YS5qd3Q7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKDAsIGVycm9yc19qc18xLmdldEVycm9yTWVzc2FnZSkoZXJyb3IsIFwiVW5rbm93biBlcnJvciBnZXR0aW5nIHN1YnNjcmlwdGlvbiB0b2tlblwiKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuSW5uZ2VzdEFwaSA9IElubmdlc3RBcGk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcGkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/api/api.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/api/schema.js":
/*!********************************************!*\
  !*** ./node_modules/inngest/api/schema.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.batchSchema = exports.stepsSchemas = exports.errorSchema = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/inngest/node_modules/zod/lib/index.js\");\nconst InngestExecution_js_1 = __webpack_require__(/*! ../components/execution/InngestExecution.js */ \"(rsc)/./node_modules/inngest/components/execution/InngestExecution.js\");\nconst types_js_1 = __webpack_require__(/*! ../types.js */ \"(rsc)/./node_modules/inngest/types.js\");\nexports.errorSchema = zod_1.z.object({\n    error: zod_1.z.string(),\n    status: zod_1.z.number(),\n});\nconst v0StepSchema = zod_1.z\n    .record(zod_1.z.any().refine((v) => typeof v !== \"undefined\", {\n    message: \"Values in steps must be defined\",\n}))\n    .optional()\n    .nullable();\nconst v1StepSchema = zod_1.z\n    .record(zod_1.z\n    .object({\n    type: zod_1.z.literal(\"data\").optional().default(\"data\"),\n    data: zod_1.z.any().refine((v) => typeof v !== \"undefined\", {\n        message: \"Data in steps must be defined\",\n    }),\n})\n    .strict()\n    .or(zod_1.z\n    .object({\n    type: zod_1.z.literal(\"error\").optional().default(\"error\"),\n    error: types_js_1.jsonErrorSchema,\n})\n    .strict())\n    .or(zod_1.z\n    .object({\n    type: zod_1.z.literal(\"input\").optional().default(\"input\"),\n    input: zod_1.z.any().refine((v) => typeof v !== \"undefined\", {\n        message: \"If input is present it must not be `undefined`\",\n    }),\n})\n    .strict())\n    /**\n     * If the result isn't a distcint `data` or `error` object, then it's\n     * likely that the executor has set this directly to a value, for example\n     * in the case of `sleep` or `waitForEvent`.\n     *\n     * In this case, pull the entire value through as data.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    .or(zod_1.z.any().transform((v) => ({ type: \"data\", data: v }))))\n    .default({});\nconst v2StepSchema = v1StepSchema;\nexports.stepsSchemas = {\n    [InngestExecution_js_1.ExecutionVersion.V0]: v0StepSchema,\n    [InngestExecution_js_1.ExecutionVersion.V1]: v1StepSchema,\n    [InngestExecution_js_1.ExecutionVersion.V2]: v2StepSchema,\n};\nexports.batchSchema = zod_1.z.array(zod_1.z.record(zod_1.z.any()).transform((v) => v));\n//# sourceMappingURL=schema.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9hcGkvc2NoZW1hLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQixHQUFHLG9CQUFvQixHQUFHLG1CQUFtQjtBQUNoRSxjQUFjLG1CQUFPLENBQUMsdUVBQUs7QUFDM0IsOEJBQThCLG1CQUFPLENBQUMsMEhBQTZDO0FBQ25GLG1CQUFtQixtQkFBTyxDQUFDLDBEQUFhO0FBQ3hDLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHVCQUF1QjtBQUNqRSxlQUFlO0FBQ2Y7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aXZlLXZpYmUtYWktbmV4dC8uL25vZGVfbW9kdWxlcy9pbm5nZXN0L2FwaS9zY2hlbWEuanM/YTMwZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYmF0Y2hTY2hlbWEgPSBleHBvcnRzLnN0ZXBzU2NoZW1hcyA9IGV4cG9ydHMuZXJyb3JTY2hlbWEgPSB2b2lkIDA7XG5jb25zdCB6b2RfMSA9IHJlcXVpcmUoXCJ6b2RcIik7XG5jb25zdCBJbm5nZXN0RXhlY3V0aW9uX2pzXzEgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50cy9leGVjdXRpb24vSW5uZ2VzdEV4ZWN1dGlvbi5qc1wiKTtcbmNvbnN0IHR5cGVzX2pzXzEgPSByZXF1aXJlKFwiLi4vdHlwZXMuanNcIik7XG5leHBvcnRzLmVycm9yU2NoZW1hID0gem9kXzEuei5vYmplY3Qoe1xuICAgIGVycm9yOiB6b2RfMS56LnN0cmluZygpLFxuICAgIHN0YXR1czogem9kXzEuei5udW1iZXIoKSxcbn0pO1xuY29uc3QgdjBTdGVwU2NoZW1hID0gem9kXzEuelxuICAgIC5yZWNvcmQoem9kXzEuei5hbnkoKS5yZWZpbmUoKHYpID0+IHR5cGVvZiB2ICE9PSBcInVuZGVmaW5lZFwiLCB7XG4gICAgbWVzc2FnZTogXCJWYWx1ZXMgaW4gc3RlcHMgbXVzdCBiZSBkZWZpbmVkXCIsXG59KSlcbiAgICAub3B0aW9uYWwoKVxuICAgIC5udWxsYWJsZSgpO1xuY29uc3QgdjFTdGVwU2NoZW1hID0gem9kXzEuelxuICAgIC5yZWNvcmQoem9kXzEuelxuICAgIC5vYmplY3Qoe1xuICAgIHR5cGU6IHpvZF8xLnoubGl0ZXJhbChcImRhdGFcIikub3B0aW9uYWwoKS5kZWZhdWx0KFwiZGF0YVwiKSxcbiAgICBkYXRhOiB6b2RfMS56LmFueSgpLnJlZmluZSgodikgPT4gdHlwZW9mIHYgIT09IFwidW5kZWZpbmVkXCIsIHtcbiAgICAgICAgbWVzc2FnZTogXCJEYXRhIGluIHN0ZXBzIG11c3QgYmUgZGVmaW5lZFwiLFxuICAgIH0pLFxufSlcbiAgICAuc3RyaWN0KClcbiAgICAub3Ioem9kXzEuelxuICAgIC5vYmplY3Qoe1xuICAgIHR5cGU6IHpvZF8xLnoubGl0ZXJhbChcImVycm9yXCIpLm9wdGlvbmFsKCkuZGVmYXVsdChcImVycm9yXCIpLFxuICAgIGVycm9yOiB0eXBlc19qc18xLmpzb25FcnJvclNjaGVtYSxcbn0pXG4gICAgLnN0cmljdCgpKVxuICAgIC5vcih6b2RfMS56XG4gICAgLm9iamVjdCh7XG4gICAgdHlwZTogem9kXzEuei5saXRlcmFsKFwiaW5wdXRcIikub3B0aW9uYWwoKS5kZWZhdWx0KFwiaW5wdXRcIiksXG4gICAgaW5wdXQ6IHpvZF8xLnouYW55KCkucmVmaW5lKCh2KSA9PiB0eXBlb2YgdiAhPT0gXCJ1bmRlZmluZWRcIiwge1xuICAgICAgICBtZXNzYWdlOiBcIklmIGlucHV0IGlzIHByZXNlbnQgaXQgbXVzdCBub3QgYmUgYHVuZGVmaW5lZGBcIixcbiAgICB9KSxcbn0pXG4gICAgLnN0cmljdCgpKVxuICAgIC8qKlxuICAgICAqIElmIHRoZSByZXN1bHQgaXNuJ3QgYSBkaXN0Y2ludCBgZGF0YWAgb3IgYGVycm9yYCBvYmplY3QsIHRoZW4gaXQnc1xuICAgICAqIGxpa2VseSB0aGF0IHRoZSBleGVjdXRvciBoYXMgc2V0IHRoaXMgZGlyZWN0bHkgdG8gYSB2YWx1ZSwgZm9yIGV4YW1wbGVcbiAgICAgKiBpbiB0aGUgY2FzZSBvZiBgc2xlZXBgIG9yIGB3YWl0Rm9yRXZlbnRgLlxuICAgICAqXG4gICAgICogSW4gdGhpcyBjYXNlLCBwdWxsIHRoZSBlbnRpcmUgdmFsdWUgdGhyb3VnaCBhcyBkYXRhLlxuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbiAgICAub3Ioem9kXzEuei5hbnkoKS50cmFuc2Zvcm0oKHYpID0+ICh7IHR5cGU6IFwiZGF0YVwiLCBkYXRhOiB2IH0pKSkpXG4gICAgLmRlZmF1bHQoe30pO1xuY29uc3QgdjJTdGVwU2NoZW1hID0gdjFTdGVwU2NoZW1hO1xuZXhwb3J0cy5zdGVwc1NjaGVtYXMgPSB7XG4gICAgW0lubmdlc3RFeGVjdXRpb25fanNfMS5FeGVjdXRpb25WZXJzaW9uLlYwXTogdjBTdGVwU2NoZW1hLFxuICAgIFtJbm5nZXN0RXhlY3V0aW9uX2pzXzEuRXhlY3V0aW9uVmVyc2lvbi5WMV06IHYxU3RlcFNjaGVtYSxcbiAgICBbSW5uZ2VzdEV4ZWN1dGlvbl9qc18xLkV4ZWN1dGlvblZlcnNpb24uVjJdOiB2MlN0ZXBTY2hlbWEsXG59O1xuZXhwb3J0cy5iYXRjaFNjaGVtYSA9IHpvZF8xLnouYXJyYXkoem9kXzEuei5yZWNvcmQoem9kXzEuei5hbnkoKSkudHJhbnNmb3JtKCh2KSA9PiB2KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY2hlbWEuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/api/schema.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/EventSchemas.js":
/*!*********************************************************!*\
  !*** ./node_modules/inngest/components/EventSchemas.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EventSchemas = void 0;\n/**\n * Provide an `EventSchemas` class to type events, providing type safety when\n * sending events and running functions via Inngest.\n *\n * You can provide generated Inngest types, custom types, types using Zod, or\n * a combination of the above. See {@link EventSchemas} for more information.\n *\n * @example\n *\n * ```ts\n * export const inngest = new Inngest({\n *   id: \"my-app\",\n *   schemas: new EventSchemas().fromZod({\n *     \"app/user.created\": {\n *       data: z.object({\n *         id: z.string(),\n *         name: z.string(),\n *       }),\n *     },\n *   }),\n * });\n * ```\n *\n * @public\n */\nclass EventSchemas {\n    constructor() {\n        this.runtimeSchemas = {};\n    }\n    addRuntimeSchemas(schemas) {\n        this.runtimeSchemas = Object.assign(Object.assign({}, this.runtimeSchemas), schemas);\n    }\n    /**\n     * Use generated Inngest types to type events.\n     */\n    fromGenerated() {\n        return this;\n    }\n    /**\n     * Use a `Record<>` type to type events.\n     *\n     * @example\n     *\n     * ```ts\n     * export const inngest = new Inngest({\n     *   id: \"my-app\",\n     *   schemas: new EventSchemas().fromRecord<{\n     *     \"app/user.created\": {\n     *       data: {\n     *         id: string;\n     *         name: string;\n     *       };\n     *     };\n     *   }>(),\n     * });\n     * ```\n     */\n    fromRecord(..._args) {\n        return this;\n    }\n    /**\n     * Use a union type to type events.\n     *\n     * @example\n     *\n     * ```ts\n     * type AccountCreated = {\n     *   name: \"app/account.created\";\n     *   data: { org: string };\n     *   user: { id: string };\n     * };\n     *\n     * type AccountDeleted = {\n     *   name: \"app/account.deleted\";\n     *   data: { org: string };\n     *   user: { id: string };\n     * };\n     *\n     * type Events = AccountCreated | AccountDeleted;\n     *\n     * export const inngest = new Inngest({\n     *   id: \"my-app\",\n     *   schemas: new EventSchemas().fromUnion<Events>(),\n     * });\n     * ```\n     */\n    fromUnion() {\n        return this;\n    }\n    /**\n     * Use Zod to type events.\n     *\n     * @example\n     *\n     * ```ts\n     * export const inngest = new Inngest({\n     *   id: \"my-app\",\n     *   schemas: new EventSchemas().fromZod({\n     *     \"app/user.created\": {\n     *       data: z.object({\n     *         id: z.string(),\n     *         name: z.string(),\n     *       }),\n     *     },\n     *   }),\n     * });\n     * ```\n     */\n    fromZod(schemas) {\n        let runtimeSchemas;\n        if (Array.isArray(schemas)) {\n            runtimeSchemas = schemas.reduce((acc, schema) => {\n                const _a = schema.shape, { name: { value: name } } = _a, rest = __rest(_a, [\"name\"]);\n                return Object.assign(Object.assign({}, acc), { [name]: rest });\n            }, {});\n        }\n        else {\n            runtimeSchemas = schemas;\n        }\n        this.addRuntimeSchemas(runtimeSchemas);\n        return this;\n    }\n}\nexports.EventSchemas = EventSchemas;\n//# sourceMappingURL=EventSchemas.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL0V2ZW50U2NoZW1hcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsY0FBYztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG9CQUFvQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFFBQVE7QUFDUixNQUFNO0FBQ04sSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsWUFBWTtBQUNaLFVBQVU7QUFDVixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFFBQVEsZ0JBQWdCO0FBQ25FLHFEQUFxRCxVQUFVLGNBQWM7QUFDN0UsYUFBYSxJQUFJO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aXZlLXZpYmUtYWktbmV4dC8uL25vZGVfbW9kdWxlcy9pbm5nZXN0L2NvbXBvbmVudHMvRXZlbnRTY2hlbWFzLmpzPzI0MDQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19yZXN0ID0gKHRoaXMgJiYgdGhpcy5fX3Jlc3QpIHx8IGZ1bmN0aW9uIChzLCBlKSB7XG4gICAgdmFyIHQgPSB7fTtcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcbiAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XG4gICAgICAgIH1cbiAgICByZXR1cm4gdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkV2ZW50U2NoZW1hcyA9IHZvaWQgMDtcbi8qKlxuICogUHJvdmlkZSBhbiBgRXZlbnRTY2hlbWFzYCBjbGFzcyB0byB0eXBlIGV2ZW50cywgcHJvdmlkaW5nIHR5cGUgc2FmZXR5IHdoZW5cbiAqIHNlbmRpbmcgZXZlbnRzIGFuZCBydW5uaW5nIGZ1bmN0aW9ucyB2aWEgSW5uZ2VzdC5cbiAqXG4gKiBZb3UgY2FuIHByb3ZpZGUgZ2VuZXJhdGVkIElubmdlc3QgdHlwZXMsIGN1c3RvbSB0eXBlcywgdHlwZXMgdXNpbmcgWm9kLCBvclxuICogYSBjb21iaW5hdGlvbiBvZiB0aGUgYWJvdmUuIFNlZSB7QGxpbmsgRXZlbnRTY2hlbWFzfSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiBleHBvcnQgY29uc3QgaW5uZ2VzdCA9IG5ldyBJbm5nZXN0KHtcbiAqICAgaWQ6IFwibXktYXBwXCIsXG4gKiAgIHNjaGVtYXM6IG5ldyBFdmVudFNjaGVtYXMoKS5mcm9tWm9kKHtcbiAqICAgICBcImFwcC91c2VyLmNyZWF0ZWRcIjoge1xuICogICAgICAgZGF0YTogei5vYmplY3Qoe1xuICogICAgICAgICBpZDogei5zdHJpbmcoKSxcbiAqICAgICAgICAgbmFtZTogei5zdHJpbmcoKSxcbiAqICAgICAgIH0pLFxuICogICAgIH0sXG4gKiAgIH0pLFxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIEV2ZW50U2NoZW1hcyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucnVudGltZVNjaGVtYXMgPSB7fTtcbiAgICB9XG4gICAgYWRkUnVudGltZVNjaGVtYXMoc2NoZW1hcykge1xuICAgICAgICB0aGlzLnJ1bnRpbWVTY2hlbWFzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLnJ1bnRpbWVTY2hlbWFzKSwgc2NoZW1hcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzZSBnZW5lcmF0ZWQgSW5uZ2VzdCB0eXBlcyB0byB0eXBlIGV2ZW50cy5cbiAgICAgKi9cbiAgICBmcm9tR2VuZXJhdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNlIGEgYFJlY29yZDw+YCB0eXBlIHRvIHR5cGUgZXZlbnRzLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogZXhwb3J0IGNvbnN0IGlubmdlc3QgPSBuZXcgSW5uZ2VzdCh7XG4gICAgICogICBpZDogXCJteS1hcHBcIixcbiAgICAgKiAgIHNjaGVtYXM6IG5ldyBFdmVudFNjaGVtYXMoKS5mcm9tUmVjb3JkPHtcbiAgICAgKiAgICAgXCJhcHAvdXNlci5jcmVhdGVkXCI6IHtcbiAgICAgKiAgICAgICBkYXRhOiB7XG4gICAgICogICAgICAgICBpZDogc3RyaW5nO1xuICAgICAqICAgICAgICAgbmFtZTogc3RyaW5nO1xuICAgICAqICAgICAgIH07XG4gICAgICogICAgIH07XG4gICAgICogICB9PigpLFxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGZyb21SZWNvcmQoLi4uX2FyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzZSBhIHVuaW9uIHR5cGUgdG8gdHlwZSBldmVudHMuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiB0eXBlIEFjY291bnRDcmVhdGVkID0ge1xuICAgICAqICAgbmFtZTogXCJhcHAvYWNjb3VudC5jcmVhdGVkXCI7XG4gICAgICogICBkYXRhOiB7IG9yZzogc3RyaW5nIH07XG4gICAgICogICB1c2VyOiB7IGlkOiBzdHJpbmcgfTtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdHlwZSBBY2NvdW50RGVsZXRlZCA9IHtcbiAgICAgKiAgIG5hbWU6IFwiYXBwL2FjY291bnQuZGVsZXRlZFwiO1xuICAgICAqICAgZGF0YTogeyBvcmc6IHN0cmluZyB9O1xuICAgICAqICAgdXNlcjogeyBpZDogc3RyaW5nIH07XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHR5cGUgRXZlbnRzID0gQWNjb3VudENyZWF0ZWQgfCBBY2NvdW50RGVsZXRlZDtcbiAgICAgKlxuICAgICAqIGV4cG9ydCBjb25zdCBpbm5nZXN0ID0gbmV3IElubmdlc3Qoe1xuICAgICAqICAgaWQ6IFwibXktYXBwXCIsXG4gICAgICogICBzY2hlbWFzOiBuZXcgRXZlbnRTY2hlbWFzKCkuZnJvbVVuaW9uPEV2ZW50cz4oKSxcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBmcm9tVW5pb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2UgWm9kIHRvIHR5cGUgZXZlbnRzLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogZXhwb3J0IGNvbnN0IGlubmdlc3QgPSBuZXcgSW5uZ2VzdCh7XG4gICAgICogICBpZDogXCJteS1hcHBcIixcbiAgICAgKiAgIHNjaGVtYXM6IG5ldyBFdmVudFNjaGVtYXMoKS5mcm9tWm9kKHtcbiAgICAgKiAgICAgXCJhcHAvdXNlci5jcmVhdGVkXCI6IHtcbiAgICAgKiAgICAgICBkYXRhOiB6Lm9iamVjdCh7XG4gICAgICogICAgICAgICBpZDogei5zdHJpbmcoKSxcbiAgICAgKiAgICAgICAgIG5hbWU6IHouc3RyaW5nKCksXG4gICAgICogICAgICAgfSksXG4gICAgICogICAgIH0sXG4gICAgICogICB9KSxcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBmcm9tWm9kKHNjaGVtYXMpIHtcbiAgICAgICAgbGV0IHJ1bnRpbWVTY2hlbWFzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWFzKSkge1xuICAgICAgICAgICAgcnVudGltZVNjaGVtYXMgPSBzY2hlbWFzLnJlZHVjZSgoYWNjLCBzY2hlbWEpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBfYSA9IHNjaGVtYS5zaGFwZSwgeyBuYW1lOiB7IHZhbHVlOiBuYW1lIH0gfSA9IF9hLCByZXN0ID0gX19yZXN0KF9hLCBbXCJuYW1lXCJdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhY2MpLCB7IFtuYW1lXTogcmVzdCB9KTtcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJ1bnRpbWVTY2hlbWFzID0gc2NoZW1hcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZFJ1bnRpbWVTY2hlbWFzKHJ1bnRpbWVTY2hlbWFzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuZXhwb3J0cy5FdmVudFNjaGVtYXMgPSBFdmVudFNjaGVtYXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FdmVudFNjaGVtYXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/EventSchemas.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/Fetch.js":
/*!**************************************************!*\
  !*** ./node_modules/inngest/components/Fetch.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.fetch = void 0;\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\"));\nconst als_js_1 = __webpack_require__(/*! ./execution/als.js */ \"(rsc)/./node_modules/inngest/components/execution/als.js\");\nconst InngestStepTools_js_1 = __webpack_require__(/*! ./InngestStepTools.js */ \"(rsc)/./node_modules/inngest/components/InngestStepTools.js\");\nconst globalFetch = globalThis.fetch;\nconst debug = (0, debug_1.default)(\"inngest:fetch\");\nconst createFetchShim = () => {\n    // eslint-disable-next-line prefer-const\n    let stepFetch;\n    const fetch = async (input, init) => {\n        const ctx = await (0, als_js_1.getAsyncCtx)();\n        if (!ctx) {\n            // Not in a function run\n            if (!stepFetch.fallback) {\n                // TODO Tell the user how to solve\n                throw new Error(\"step.fetch() called outside of a function and had no fallback set\");\n            }\n            debug(\"step.fetch() called outside of a function; falling back to global fetch\");\n            return stepFetch.fallback(input, init);\n        }\n        // In a function run\n        if (ctx.executingStep) {\n            // Inside a step\n            if (!stepFetch.fallback) {\n                // TODO Tell the user how to solve\n                throw new Error(`step.fetch() called inside step \"${ctx.executingStep.id}\" and had no fallback set`);\n            }\n            debug(`step.fetch() called inside step \"${ctx.executingStep.id}\"; falling back to global fetch`);\n            return stepFetch.fallback(input, init);\n        }\n        const targetUrl = new URL(input instanceof Request ? input.url : input.toString());\n        debug(\"step.fetch() shimming request to\", targetUrl.hostname);\n        // Purposefully do not try/cacth this; if it throws then we treat that as a\n        // regular `fetch()` throw, which also would not return a `Response`.\n        const jsonRes = await ctx.ctx.step[InngestStepTools_js_1.gatewaySymbol](`step.fetch: ${targetUrl.hostname}`, input, init);\n        return new Response(jsonRes.body, {\n            headers: jsonRes.headers,\n            status: jsonRes.status,\n        });\n    };\n    const optionsRef = {\n        fallback: globalFetch,\n    };\n    const extras = Object.assign({ config: (options) => {\n            Object.assign(optionsRef, options);\n            Object.assign(stepFetch, optionsRef);\n            return stepFetch;\n        } }, optionsRef);\n    stepFetch = Object.assign(fetch, extras);\n    return stepFetch;\n};\n/**\n * `fetch` is a Fetch API-compatible function that can be used to make any HTTP\n * code durable if it's called within an Inngest function.\n *\n * It will gracefully fall back to the global `fetch` if called outside of this\n * context, and a custom fallback can be set using the `config` method.\n *\n * @example Basic usage\n * ```ts\n * import { fetch } from \"inngest\";\n *\n * const api = new MyProductApi({ fetch });\n * ```\n *\n * @example Setting a custom fallback\n * ```ts\n * import { fetch } from \"inngest\";\n *\n * const api = new MyProductApi({\n *            fetch: fetch.config({ fallback: myCustomFetch }),\n * });\n * ```\n *\n * @example Do not allow fallback\n * ```ts\n * import { fetch } from \"inngest\";\n *\n * const api = new MyProductApi({\n *            fetch: fetch.config({ fallback: undefined }),\n * });\n * ```\n */\nexports.fetch = createFetchShim();\n//# sourceMappingURL=Fetch.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL0ZldGNoLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYTtBQUNiLGdDQUFnQyxtQkFBTyxDQUFDLHNEQUFPO0FBQy9DLGlCQUFpQixtQkFBTyxDQUFDLG9GQUFvQjtBQUM3Qyw4QkFBOEIsbUJBQU8sQ0FBQywwRkFBdUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UscUJBQXFCO0FBQ3pGO0FBQ0Esc0RBQXNELHFCQUFxQixHQUFHO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0EsK0ZBQStGLG1CQUFtQjtBQUNsSDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQSxvQ0FBb0MseUJBQXlCO0FBQzdELElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0Esb0NBQW9DLHFCQUFxQjtBQUN6RCxJQUFJO0FBQ0o7QUFDQTtBQUNBLGFBQWE7QUFDYiIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpdmUtdmliZS1haS1uZXh0Ly4vbm9kZV9tb2R1bGVzL2lubmdlc3QvY29tcG9uZW50cy9GZXRjaC5qcz9lMTU1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5mZXRjaCA9IHZvaWQgMDtcbmNvbnN0IGRlYnVnXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRlYnVnXCIpKTtcbmNvbnN0IGFsc19qc18xID0gcmVxdWlyZShcIi4vZXhlY3V0aW9uL2Fscy5qc1wiKTtcbmNvbnN0IElubmdlc3RTdGVwVG9vbHNfanNfMSA9IHJlcXVpcmUoXCIuL0lubmdlc3RTdGVwVG9vbHMuanNcIik7XG5jb25zdCBnbG9iYWxGZXRjaCA9IGdsb2JhbFRoaXMuZmV0Y2g7XG5jb25zdCBkZWJ1ZyA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKFwiaW5uZ2VzdDpmZXRjaFwiKTtcbmNvbnN0IGNyZWF0ZUZldGNoU2hpbSA9ICgpID0+IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWNvbnN0XG4gICAgbGV0IHN0ZXBGZXRjaDtcbiAgICBjb25zdCBmZXRjaCA9IGFzeW5jIChpbnB1dCwgaW5pdCkgPT4ge1xuICAgICAgICBjb25zdCBjdHggPSBhd2FpdCAoMCwgYWxzX2pzXzEuZ2V0QXN5bmNDdHgpKCk7XG4gICAgICAgIGlmICghY3R4KSB7XG4gICAgICAgICAgICAvLyBOb3QgaW4gYSBmdW5jdGlvbiBydW5cbiAgICAgICAgICAgIGlmICghc3RlcEZldGNoLmZhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyBUZWxsIHRoZSB1c2VyIGhvdyB0byBzb2x2ZVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInN0ZXAuZmV0Y2goKSBjYWxsZWQgb3V0c2lkZSBvZiBhIGZ1bmN0aW9uIGFuZCBoYWQgbm8gZmFsbGJhY2sgc2V0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVidWcoXCJzdGVwLmZldGNoKCkgY2FsbGVkIG91dHNpZGUgb2YgYSBmdW5jdGlvbjsgZmFsbGluZyBiYWNrIHRvIGdsb2JhbCBmZXRjaFwiKTtcbiAgICAgICAgICAgIHJldHVybiBzdGVwRmV0Y2guZmFsbGJhY2soaW5wdXQsIGluaXQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEluIGEgZnVuY3Rpb24gcnVuXG4gICAgICAgIGlmIChjdHguZXhlY3V0aW5nU3RlcCkge1xuICAgICAgICAgICAgLy8gSW5zaWRlIGEgc3RlcFxuICAgICAgICAgICAgaWYgKCFzdGVwRmV0Y2guZmFsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPIFRlbGwgdGhlIHVzZXIgaG93IHRvIHNvbHZlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzdGVwLmZldGNoKCkgY2FsbGVkIGluc2lkZSBzdGVwIFwiJHtjdHguZXhlY3V0aW5nU3RlcC5pZH1cIiBhbmQgaGFkIG5vIGZhbGxiYWNrIHNldGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVidWcoYHN0ZXAuZmV0Y2goKSBjYWxsZWQgaW5zaWRlIHN0ZXAgXCIke2N0eC5leGVjdXRpbmdTdGVwLmlkfVwiOyBmYWxsaW5nIGJhY2sgdG8gZ2xvYmFsIGZldGNoYCk7XG4gICAgICAgICAgICByZXR1cm4gc3RlcEZldGNoLmZhbGxiYWNrKGlucHV0LCBpbml0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXJnZXRVcmwgPSBuZXcgVVJMKGlucHV0IGluc3RhbmNlb2YgUmVxdWVzdCA/IGlucHV0LnVybCA6IGlucHV0LnRvU3RyaW5nKCkpO1xuICAgICAgICBkZWJ1ZyhcInN0ZXAuZmV0Y2goKSBzaGltbWluZyByZXF1ZXN0IHRvXCIsIHRhcmdldFVybC5ob3N0bmFtZSk7XG4gICAgICAgIC8vIFB1cnBvc2VmdWxseSBkbyBub3QgdHJ5L2NhY3RoIHRoaXM7IGlmIGl0IHRocm93cyB0aGVuIHdlIHRyZWF0IHRoYXQgYXMgYVxuICAgICAgICAvLyByZWd1bGFyIGBmZXRjaCgpYCB0aHJvdywgd2hpY2ggYWxzbyB3b3VsZCBub3QgcmV0dXJuIGEgYFJlc3BvbnNlYC5cbiAgICAgICAgY29uc3QganNvblJlcyA9IGF3YWl0IGN0eC5jdHguc3RlcFtJbm5nZXN0U3RlcFRvb2xzX2pzXzEuZ2F0ZXdheVN5bWJvbF0oYHN0ZXAuZmV0Y2g6ICR7dGFyZ2V0VXJsLmhvc3RuYW1lfWAsIGlucHV0LCBpbml0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShqc29uUmVzLmJvZHksIHtcbiAgICAgICAgICAgIGhlYWRlcnM6IGpzb25SZXMuaGVhZGVycyxcbiAgICAgICAgICAgIHN0YXR1czoganNvblJlcy5zdGF0dXMsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3Qgb3B0aW9uc1JlZiA9IHtcbiAgICAgICAgZmFsbGJhY2s6IGdsb2JhbEZldGNoLFxuICAgIH07XG4gICAgY29uc3QgZXh0cmFzID0gT2JqZWN0LmFzc2lnbih7IGNvbmZpZzogKG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ob3B0aW9uc1JlZiwgb3B0aW9ucyk7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHN0ZXBGZXRjaCwgb3B0aW9uc1JlZik7XG4gICAgICAgICAgICByZXR1cm4gc3RlcEZldGNoO1xuICAgICAgICB9IH0sIG9wdGlvbnNSZWYpO1xuICAgIHN0ZXBGZXRjaCA9IE9iamVjdC5hc3NpZ24oZmV0Y2gsIGV4dHJhcyk7XG4gICAgcmV0dXJuIHN0ZXBGZXRjaDtcbn07XG4vKipcbiAqIGBmZXRjaGAgaXMgYSBGZXRjaCBBUEktY29tcGF0aWJsZSBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIG1ha2UgYW55IEhUVFBcbiAqIGNvZGUgZHVyYWJsZSBpZiBpdCdzIGNhbGxlZCB3aXRoaW4gYW4gSW5uZ2VzdCBmdW5jdGlvbi5cbiAqXG4gKiBJdCB3aWxsIGdyYWNlZnVsbHkgZmFsbCBiYWNrIHRvIHRoZSBnbG9iYWwgYGZldGNoYCBpZiBjYWxsZWQgb3V0c2lkZSBvZiB0aGlzXG4gKiBjb250ZXh0LCBhbmQgYSBjdXN0b20gZmFsbGJhY2sgY2FuIGJlIHNldCB1c2luZyB0aGUgYGNvbmZpZ2AgbWV0aG9kLlxuICpcbiAqIEBleGFtcGxlIEJhc2ljIHVzYWdlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgZmV0Y2ggfSBmcm9tIFwiaW5uZ2VzdFwiO1xuICpcbiAqIGNvbnN0IGFwaSA9IG5ldyBNeVByb2R1Y3RBcGkoeyBmZXRjaCB9KTtcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlIFNldHRpbmcgYSBjdXN0b20gZmFsbGJhY2tcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBmZXRjaCB9IGZyb20gXCJpbm5nZXN0XCI7XG4gKlxuICogY29uc3QgYXBpID0gbmV3IE15UHJvZHVjdEFwaSh7XG4gKiAgICAgICAgICAgIGZldGNoOiBmZXRjaC5jb25maWcoeyBmYWxsYmFjazogbXlDdXN0b21GZXRjaCB9KSxcbiAqIH0pO1xuICogYGBgXG4gKlxuICogQGV4YW1wbGUgRG8gbm90IGFsbG93IGZhbGxiYWNrXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgZmV0Y2ggfSBmcm9tIFwiaW5uZ2VzdFwiO1xuICpcbiAqIGNvbnN0IGFwaSA9IG5ldyBNeVByb2R1Y3RBcGkoe1xuICogICAgICAgICAgICBmZXRjaDogZmV0Y2guY29uZmlnKHsgZmFsbGJhY2s6IHVuZGVmaW5lZCB9KSxcbiAqIH0pO1xuICogYGBgXG4gKi9cbmV4cG9ydHMuZmV0Y2ggPSBjcmVhdGVGZXRjaFNoaW0oKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZldGNoLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/Fetch.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/Inngest.js":
/*!****************************************************!*\
  !*** ./node_modules/inngest/components/Inngest.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.builtInMiddleware = exports.Inngest = void 0;\nconst api_js_1 = __webpack_require__(/*! ../api/api.js */ \"(rsc)/./node_modules/inngest/api/api.js\");\nconst consts_js_1 = __webpack_require__(/*! ../helpers/consts.js */ \"(rsc)/./node_modules/inngest/helpers/consts.js\");\nconst crypto_js_1 = __webpack_require__(/*! ../helpers/crypto.js */ \"(rsc)/./node_modules/inngest/helpers/crypto.js\");\nconst devserver_js_1 = __webpack_require__(/*! ../helpers/devserver.js */ \"(rsc)/./node_modules/inngest/helpers/devserver.js\");\nconst env_js_1 = __webpack_require__(/*! ../helpers/env.js */ \"(rsc)/./node_modules/inngest/helpers/env.js\");\nconst errors_js_1 = __webpack_require__(/*! ../helpers/errors.js */ \"(rsc)/./node_modules/inngest/helpers/errors.js\");\nconst promises_js_1 = __webpack_require__(/*! ../helpers/promises.js */ \"(rsc)/./node_modules/inngest/helpers/promises.js\");\nconst strings_js_1 = __webpack_require__(/*! ../helpers/strings.js */ \"(rsc)/./node_modules/inngest/helpers/strings.js\");\nconst logger_js_1 = __webpack_require__(/*! ../middleware/logger.js */ \"(rsc)/./node_modules/inngest/middleware/logger.js\");\nconst types_js_1 = __webpack_require__(/*! ../types.js */ \"(rsc)/./node_modules/inngest/types.js\");\nconst InngestFunction_js_1 = __webpack_require__(/*! ./InngestFunction.js */ \"(rsc)/./node_modules/inngest/components/InngestFunction.js\");\nconst InngestMiddleware_js_1 = __webpack_require__(/*! ./InngestMiddleware.js */ \"(rsc)/./node_modules/inngest/components/InngestMiddleware.js\");\n/**\n * A client used to interact with the Inngest API by sending or reacting to\n * events.\n *\n * To provide event typing, see {@link EventSchemas}.\n *\n * ```ts\n * const inngest = new Inngest({ id: \"my-app\" });\n *\n * // or to provide event typing too\n * const inngest = new Inngest({\n *   id: \"my-app\",\n *   schemas: new EventSchemas().fromRecord<{\n *     \"app/user.created\": {\n *       data: { userId: string };\n *     };\n *   }>(),\n * });\n * ```\n *\n * @public\n */\nclass Inngest {\n    get apiBaseUrl() {\n        return this._apiBaseUrl;\n    }\n    get eventBaseUrl() {\n        return this._eventBaseUrl;\n    }\n    get env() {\n        var _a;\n        return (_a = this.headers[consts_js_1.headerKeys.Environment]) !== null && _a !== void 0 ? _a : null;\n    }\n    get appVersion() {\n        return this._appVersion;\n    }\n    /**\n     * A client used to interact with the Inngest API by sending or reacting to\n     * events.\n     *\n     * To provide event typing, see {@link EventSchemas}.\n     *\n     * ```ts\n     * const inngest = new Inngest({ name: \"My App\" });\n     *\n     * // or to provide event typing too\n     * const inngest = new Inngest({\n     *   name: \"My App\",\n     *   schemas: new EventSchemas().fromRecord<{\n     *     \"app/user.created\": {\n     *       data: { userId: string };\n     *     };\n     *   }>(),\n     * });\n     * ```\n     */\n    constructor(options) {\n        /**\n         * Inngest event key, used to send events to Inngest Cloud.\n         */\n        this.eventKey = \"\";\n        /**\n         * The absolute URL of the Inngest Cloud API.\n         */\n        this.sendEventUrl = new URL(`e/${this.eventKey}`, consts_js_1.defaultInngestEventBaseUrl);\n        this.localFns = [];\n        this.createFunction = (rawOptions, rawTrigger, handler) => {\n            const fn = this._createFunction(rawOptions, rawTrigger, handler);\n            this.localFns.push(fn);\n            return fn;\n        };\n        this._createFunction = (rawOptions, rawTrigger, handler) => {\n            const options = this.sanitizeOptions(rawOptions);\n            const triggers = this.sanitizeTriggers(rawTrigger);\n            return new InngestFunction_js_1.InngestFunction(this, Object.assign(Object.assign({}, options), { triggers }), handler);\n        };\n        this.options = options;\n        const { id, fetch, logger = new logger_js_1.DefaultLogger(), middleware, isDev, schemas, appVersion, } = this.options;\n        if (!id) {\n            // TODO PrettyError\n            throw new Error(\"An `id` must be passed to create an Inngest instance.\");\n        }\n        this.id = id;\n        this._mode = (0, env_js_1.getMode)({\n            explicitMode: typeof isDev === \"boolean\" ? (isDev ? \"dev\" : \"cloud\") : undefined,\n        });\n        this.fetch = (0, env_js_1.getFetch)(fetch);\n        this.inngestApi = new api_js_1.InngestApi({\n            baseUrl: this.apiBaseUrl,\n            signingKey: (0, env_js_1.processEnv)(consts_js_1.envKeys.InngestSigningKey) || \"\",\n            signingKeyFallback: (0, env_js_1.processEnv)(consts_js_1.envKeys.InngestSigningKeyFallback),\n            fetch: this.fetch,\n            mode: this.mode,\n        });\n        this.schemas = schemas;\n        this.loadModeEnvVars();\n        this.logger = logger;\n        this.middleware = this.initializeMiddleware([\n            ...exports.builtInMiddleware,\n            ...(middleware || []),\n        ]);\n        this._appVersion = appVersion;\n    }\n    /**\n     * Returns a `Promise` that resolves when the app is ready and all middleware\n     * has been initialized.\n     */\n    get ready() {\n        return this.middleware.then(() => { });\n    }\n    /**\n     * Set the environment variables for this client. This is useful if you are\n     * passed environment variables at runtime instead of as globals and need to\n     * update the client with those values as requests come in.\n     */\n    setEnvVars(env = (0, env_js_1.allProcessEnv)()) {\n        this.mode = (0, env_js_1.getMode)({ env, client: this });\n        return this;\n    }\n    loadModeEnvVars() {\n        this._apiBaseUrl =\n            this.options.baseUrl ||\n                this.mode[\"env\"][consts_js_1.envKeys.InngestApiBaseUrl] ||\n                this.mode[\"env\"][consts_js_1.envKeys.InngestBaseUrl] ||\n                this.mode.getExplicitUrl(consts_js_1.defaultInngestApiBaseUrl);\n        this._eventBaseUrl =\n            this.options.baseUrl ||\n                this.mode[\"env\"][consts_js_1.envKeys.InngestEventApiBaseUrl] ||\n                this.mode[\"env\"][consts_js_1.envKeys.InngestBaseUrl] ||\n                this.mode.getExplicitUrl(consts_js_1.defaultInngestEventBaseUrl);\n        this.setEventKey(this.options.eventKey || this.mode[\"env\"][consts_js_1.envKeys.InngestEventKey] || \"\");\n        this.headers = (0, env_js_1.inngestHeaders)({\n            inngestEnv: this.options.env,\n            env: this.mode[\"env\"],\n        });\n        this.inngestApi[\"mode\"] = this.mode;\n        this.inngestApi[\"apiBaseUrl\"] = this._apiBaseUrl;\n    }\n    /**\n     * Initialize all passed middleware, running the `register` function on each\n     * in sequence and returning the requested hook registrations.\n     */\n    async initializeMiddleware(middleware = [], opts) {\n        var _a;\n        /**\n         * Wait for the prefix stack to run first; do not trigger ours before this\n         * is complete.\n         */\n        const prefix = await ((_a = opts === null || opts === void 0 ? void 0 : opts.prefixStack) !== null && _a !== void 0 ? _a : []);\n        const stack = middleware.reduce(async (acc, m) => {\n            // Be explicit about waiting for the previous middleware to finish\n            const prev = await acc;\n            const next = await m.init(Object.assign({ client: this }, opts === null || opts === void 0 ? void 0 : opts.registerInput));\n            return [...prev, next];\n        }, Promise.resolve([]));\n        return [...prefix, ...(await stack)];\n    }\n    get mode() {\n        return this._mode;\n    }\n    set mode(m) {\n        this._mode = m;\n        this.loadModeEnvVars();\n    }\n    /**\n     * Given a response from Inngest, relay the error to the caller.\n     */\n    async getResponseError(response, rawBody, foundErr = \"Unknown error\") {\n        let errorMessage = foundErr;\n        if (errorMessage === \"Unknown error\") {\n            switch (response.status) {\n                case 401:\n                    errorMessage = \"Event key Not Found\";\n                    break;\n                case 400:\n                    errorMessage = \"Cannot process event payload\";\n                    break;\n                case 403:\n                    errorMessage = \"Forbidden\";\n                    break;\n                case 404:\n                    errorMessage = \"Event key not found\";\n                    break;\n                case 406:\n                    errorMessage = `${JSON.stringify(await rawBody)}`;\n                    break;\n                case 409:\n                case 412:\n                    errorMessage = \"Event transformation failed\";\n                    break;\n                case 413:\n                    errorMessage = \"Event payload too large\";\n                    break;\n                case 500:\n                    errorMessage = \"Internal server error\";\n                    break;\n                default:\n                    try {\n                        errorMessage = await response.text();\n                    }\n                    catch (err) {\n                        errorMessage = `${JSON.stringify(await rawBody)}`;\n                    }\n                    break;\n            }\n        }\n        return new Error(`Inngest API Error: ${response.status} ${errorMessage}`);\n    }\n    /**\n     * Set the event key for this instance of Inngest. This is useful if for some\n     * reason the key is not available at time of instantiation or present in the\n     * `INNGEST_EVENT_KEY` environment variable.\n     */\n    setEventKey(\n    /**\n     * Inngest event key, used to send events to Inngest Cloud. Use this is your\n     * key is for some reason not available at time of instantiation or present\n     * in the `INNGEST_EVENT_KEY` environment variable.\n     */\n    eventKey) {\n        this.eventKey = eventKey || consts_js_1.dummyEventKey;\n        this.sendEventUrl = new URL(`e/${this.eventKey}`, this.eventBaseUrl || consts_js_1.defaultInngestEventBaseUrl);\n    }\n    eventKeySet() {\n        return Boolean(this.eventKey) && this.eventKey !== consts_js_1.dummyEventKey;\n    }\n    /**\n     * EXPERIMENTAL: This API is not yet stable and may change in the future\n     * without a major version bump.\n     *\n     * Send a Signal to Inngest.\n     */\n    async sendSignal({ signal, data, env, }) {\n        const headers = Object.assign({}, (env ? { [consts_js_1.headerKeys.Environment]: env } : {}));\n        return this._sendSignal({ signal, data, headers });\n    }\n    async _sendSignal({ signal, data, headers, }) {\n        var _a;\n        const res = await this.inngestApi.sendSignal({ signal, data }, Object.assign(Object.assign({}, this.headers), headers));\n        if (res.ok) {\n            return res.value;\n        }\n        throw new Error(`Failed to send signal: ${((_a = res.error) === null || _a === void 0 ? void 0 : _a.error) || \"Unknown error\"}`);\n    }\n    /**\n     * Send one or many events to Inngest. Takes an entire payload (including\n     * name) as each input.\n     *\n     * ```ts\n     * await inngest.send({ name: \"app/user.created\", data: { id: 123 } });\n     * ```\n     *\n     * Returns a promise that will resolve if the event(s) were sent successfully,\n     * else throws with an error explaining what went wrong.\n     *\n     * If you wish to send an event with custom types (i.e. one that hasn't been\n     * generated), make sure to add it when creating your Inngest instance, like\n     * so:\n     *\n     * ```ts\n     * const inngest = new Inngest({\n     *   name: \"My App\",\n     *   schemas: new EventSchemas().fromRecord<{\n     *     \"my/event\": {\n     *       name: \"my/event\";\n     *       data: { bar: string };\n     *     };\n     *   }>(),\n     * });\n     * ```\n     */\n    async send(payload, options) {\n        const headers = Object.assign({}, ((options === null || options === void 0 ? void 0 : options.env) ? { [consts_js_1.headerKeys.Environment]: options.env } : {}));\n        return this._send({ payload, headers });\n    }\n    /**\n     * Internal method for sending an event, used to allow Inngest internals to\n     * further customize the request sent to an Inngest Server.\n     */\n    async _send({ payload, headers, }) {\n        var _a;\n        const nowMillis = new Date().getTime();\n        let maxAttempts = 5;\n        // Attempt to set the event ID seed header. If it fails then disable retries\n        // (but we still want to send the event).\n        try {\n            const entropy = (0, crypto_js_1.createEntropy)(10);\n            const entropyBase64 = Buffer.from(entropy).toString(\"base64\");\n            headers = Object.assign(Object.assign({}, headers), { [consts_js_1.headerKeys.EventIdSeed]: `${nowMillis},${entropyBase64}` });\n        }\n        catch (err) {\n            let message = \"Event-sending retries disabled\";\n            if (err instanceof Error) {\n                message += `: ${err.message}`;\n            }\n            console.debug(message);\n            // Disable retries.\n            maxAttempts = 1;\n        }\n        const hooks = await (0, InngestMiddleware_js_1.getHookStack)(this.middleware, \"onSendEvent\", undefined, {\n            transformInput: (prev, output) => {\n                return Object.assign(Object.assign({}, prev), output);\n            },\n            transformOutput(prev, output) {\n                return {\n                    result: Object.assign(Object.assign({}, prev.result), output === null || output === void 0 ? void 0 : output.result),\n                };\n            },\n        });\n        let payloads = Array.isArray(payload)\n            ? payload\n            : payload\n                ? [payload]\n                : [];\n        const inputChanges = await ((_a = hooks.transformInput) === null || _a === void 0 ? void 0 : _a.call(hooks, {\n            payloads: [...payloads],\n        }));\n        if (inputChanges === null || inputChanges === void 0 ? void 0 : inputChanges.payloads) {\n            payloads = [...inputChanges.payloads];\n        }\n        // Ensure that we always add \"ts\" and \"data\" fields to events. \"ts\" is auto-\n        // filled by the event server so is safe, and adding here fixes Next.js\n        // server action cache issues.\n        payloads = payloads.map((p) => {\n            return Object.assign(Object.assign({}, p), { \n                // Always generate an idempotency ID for an event for retries\n                id: p.id, ts: p.ts || nowMillis, \n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                data: p.data || {} });\n        });\n        const applyHookToOutput = async (arg) => {\n            var _a;\n            const hookOutput = await ((_a = hooks.transformOutput) === null || _a === void 0 ? void 0 : _a.call(hooks, arg));\n            return Object.assign(Object.assign({}, arg.result), hookOutput === null || hookOutput === void 0 ? void 0 : hookOutput.result);\n        };\n        /**\n         * It can be valid for a user to send an empty list of events; if this\n         * happens, show a warning that this may not be intended, but don't throw.\n         */\n        if (!payloads.length) {\n            console.warn((0, errors_js_1.prettyError)({\n                type: \"warn\",\n                whatHappened: \"`inngest.send()` called with no events\",\n                reassurance: \"This is not an error, but you may not have intended to do this.\",\n                consequences: \"The returned promise will resolve, but no events have been sent to Inngest.\",\n                stack: true,\n            }));\n            return await applyHookToOutput({ result: { ids: [] } });\n        }\n        // When sending events, check if the dev server is available.  If so, use the\n        // dev server.\n        let url = this.sendEventUrl.href;\n        /**\n         * If in prod mode and key is not present, fail now.\n         */\n        if (this.mode.isCloud && !this.eventKeySet()) {\n            throw new Error((0, errors_js_1.prettyError)({\n                whatHappened: \"Failed to send event\",\n                consequences: \"Your event or events were not sent to Inngest.\",\n                why: \"We couldn't find an event key to use to send events to Inngest.\",\n                toFixNow: errors_js_1.fixEventKeyMissingSteps,\n            }));\n        }\n        /**\n         * If dev mode has been inferred, try to hit the dev server first to see if\n         * it exists. If it does, use it, otherwise fall back to whatever server we\n         * have configured.\n         *\n         * `INNGEST_BASE_URL` is used to set both dev server and prod URLs, so if a\n         * user has set this it means they have already chosen a URL to hit.\n         */\n        if (this.mode.isDev && this.mode.isInferred && !this.eventBaseUrl) {\n            const devAvailable = await (0, devserver_js_1.devServerAvailable)(consts_js_1.defaultDevServerHost, this.fetch);\n            if (devAvailable) {\n                url = (0, devserver_js_1.devServerUrl)(consts_js_1.defaultDevServerHost, `e/${this.eventKey}`).href;\n            }\n        }\n        const body = await (0, promises_js_1.retryWithBackoff)(async () => {\n            let rawBody;\n            let body;\n            // We don't need to do fallback auth here because this uses event keys and\n            // not signing keys\n            const response = await this.fetch(url, {\n                method: \"POST\",\n                body: (0, strings_js_1.stringify)(payloads),\n                headers: Object.assign(Object.assign({}, this.headers), headers),\n            });\n            try {\n                rawBody = await response.json();\n                body = await types_js_1.sendEventResponseSchema.parseAsync(rawBody);\n            }\n            catch (err) {\n                throw await this.getResponseError(response, rawBody);\n            }\n            if (body.status !== 200 || body.error) {\n                throw await this.getResponseError(response, rawBody, body.error);\n            }\n            return body;\n        }, {\n            maxAttempts,\n            baseDelay: 100,\n        });\n        return await applyHookToOutput({ result: { ids: body.ids } });\n    }\n    get funcs() {\n        return this.localFns;\n    }\n    /**\n     * Runtime-only validation.\n     */\n    sanitizeOptions(options) {\n        if (Object.prototype.hasOwnProperty.call(options, \"fns\")) {\n            // v2 -> v3 migration warning\n            console.warn(`${consts_js_1.logPrefix} InngestFunction: \\`fns\\` option has been deprecated in v3; use \\`middleware\\` instead. See https://www.inngest.com/docs/sdk/migration`);\n        }\n        if (typeof options === \"string\") {\n            // v2 -> v3 runtime migraton warning\n            console.warn(`${consts_js_1.logPrefix} InngestFunction: Creating a function with a string as the first argument has been deprecated in v3; pass an object instead. See https://www.inngest.com/docs/sdk/migration`);\n            return { id: options };\n        }\n        return options;\n    }\n    /**\n     * Runtime-only validation.\n     */\n    sanitizeTriggers(triggers) {\n        if (typeof triggers === \"string\") {\n            // v2 -> v3 migration warning\n            console.warn(`${consts_js_1.logPrefix} InngestFunction: Creating a function with a string as the second argument has been deprecated in v3; pass an object instead. See https://www.inngest.com/docs/sdk/migration`);\n            return [{ event: triggers }];\n        }\n        if (!Array.isArray(triggers)) {\n            return [triggers];\n        }\n        return triggers;\n    }\n}\nexports.Inngest = Inngest;\n/**\n * Default middleware that is included in every client, placed after the user's\n * middleware on the client but before function-level middleware.\n *\n * It is defined here to ensure that comments are included in the generated TS\n * definitions. Without this, we infer the stack of built-in middleware without\n * comments, losing a lot of value.\n *\n * If this is moved, please ensure that using this package in another project\n * can correctly access comments on mutated input and output.\n *\n * This return pattern mimics the output of a `satisfies` suffix; it's used as\n * we support versions of TypeScript prior to the introduction of `satisfies`.\n */\nexports.builtInMiddleware = ((m) => m)([\n    new InngestMiddleware_js_1.InngestMiddleware({\n        name: \"Inngest: Logger\",\n        init({ client }) {\n            return {\n                onFunctionRun(arg) {\n                    const { ctx } = arg;\n                    const metadata = {\n                        runID: ctx.runId,\n                        eventName: ctx.event.name,\n                        functionName: arg.fn.name,\n                    };\n                    let providedLogger = client[\"logger\"];\n                    // create a child logger if the provided logger has child logger implementation\n                    try {\n                        if (\"child\" in providedLogger) {\n                            providedLogger = providedLogger.child(metadata);\n                        }\n                    }\n                    catch (err) {\n                        console.error('failed to create \"childLogger\" with error: ', err);\n                        // no-op\n                    }\n                    const logger = new logger_js_1.ProxyLogger(providedLogger);\n                    return {\n                        transformInput() {\n                            return {\n                                ctx: {\n                                    /**\n                                     * The passed in logger from the user.\n                                     * Defaults to a console logger if not provided.\n                                     */\n                                    logger: logger,\n                                },\n                            };\n                        },\n                        beforeExecution() {\n                            logger.enable();\n                        },\n                        transformOutput({ result: { error } }) {\n                            if (error) {\n                                logger.error(error);\n                            }\n                        },\n                        async beforeResponse() {\n                            await logger.flush();\n                        },\n                    };\n                },\n            };\n        },\n    }),\n]);\n//# sourceMappingURL=Inngest.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL0lubmdlc3QuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QseUJBQXlCLEdBQUcsZUFBZTtBQUMzQyxpQkFBaUIsbUJBQU8sQ0FBQyw4REFBZTtBQUN4QyxvQkFBb0IsbUJBQU8sQ0FBQyw0RUFBc0I7QUFDbEQsb0JBQW9CLG1CQUFPLENBQUMsNEVBQXNCO0FBQ2xELHVCQUF1QixtQkFBTyxDQUFDLGtGQUF5QjtBQUN4RCxpQkFBaUIsbUJBQU8sQ0FBQyxzRUFBbUI7QUFDNUMsb0JBQW9CLG1CQUFPLENBQUMsNEVBQXNCO0FBQ2xELHNCQUFzQixtQkFBTyxDQUFDLGdGQUF3QjtBQUN0RCxxQkFBcUIsbUJBQU8sQ0FBQyw4RUFBdUI7QUFDcEQsb0JBQW9CLG1CQUFPLENBQUMsa0ZBQXlCO0FBQ3JELG1CQUFtQixtQkFBTyxDQUFDLDBEQUFhO0FBQ3hDLDZCQUE2QixtQkFBTyxDQUFDLHdGQUFzQjtBQUMzRCwrQkFBK0IsbUJBQU8sQ0FBQyw0RkFBd0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsbUJBQW1CO0FBQ3BEO0FBQ0E7QUFDQSxpQ0FBaUMsY0FBYztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxNQUFNO0FBQ04sSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLG1CQUFtQjtBQUN4RDtBQUNBO0FBQ0EscUNBQXFDLGdCQUFnQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxVQUFVO0FBQ1YsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0EsNEJBQTRCLE1BQU07QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLDBDQUEwQyxVQUFVLFNBQVM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aXZlLXZpYmUtYWktbmV4dC8uL25vZGVfbW9kdWxlcy9pbm5nZXN0L2NvbXBvbmVudHMvSW5uZ2VzdC5qcz9mMGNhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5idWlsdEluTWlkZGxld2FyZSA9IGV4cG9ydHMuSW5uZ2VzdCA9IHZvaWQgMDtcbmNvbnN0IGFwaV9qc18xID0gcmVxdWlyZShcIi4uL2FwaS9hcGkuanNcIik7XG5jb25zdCBjb25zdHNfanNfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL2NvbnN0cy5qc1wiKTtcbmNvbnN0IGNyeXB0b19qc18xID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvY3J5cHRvLmpzXCIpO1xuY29uc3QgZGV2c2VydmVyX2pzXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9kZXZzZXJ2ZXIuanNcIik7XG5jb25zdCBlbnZfanNfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL2Vudi5qc1wiKTtcbmNvbnN0IGVycm9yc19qc18xID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvZXJyb3JzLmpzXCIpO1xuY29uc3QgcHJvbWlzZXNfanNfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL3Byb21pc2VzLmpzXCIpO1xuY29uc3Qgc3RyaW5nc19qc18xID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvc3RyaW5ncy5qc1wiKTtcbmNvbnN0IGxvZ2dlcl9qc18xID0gcmVxdWlyZShcIi4uL21pZGRsZXdhcmUvbG9nZ2VyLmpzXCIpO1xuY29uc3QgdHlwZXNfanNfMSA9IHJlcXVpcmUoXCIuLi90eXBlcy5qc1wiKTtcbmNvbnN0IElubmdlc3RGdW5jdGlvbl9qc18xID0gcmVxdWlyZShcIi4vSW5uZ2VzdEZ1bmN0aW9uLmpzXCIpO1xuY29uc3QgSW5uZ2VzdE1pZGRsZXdhcmVfanNfMSA9IHJlcXVpcmUoXCIuL0lubmdlc3RNaWRkbGV3YXJlLmpzXCIpO1xuLyoqXG4gKiBBIGNsaWVudCB1c2VkIHRvIGludGVyYWN0IHdpdGggdGhlIElubmdlc3QgQVBJIGJ5IHNlbmRpbmcgb3IgcmVhY3RpbmcgdG9cbiAqIGV2ZW50cy5cbiAqXG4gKiBUbyBwcm92aWRlIGV2ZW50IHR5cGluZywgc2VlIHtAbGluayBFdmVudFNjaGVtYXN9LlxuICpcbiAqIGBgYHRzXG4gKiBjb25zdCBpbm5nZXN0ID0gbmV3IElubmdlc3QoeyBpZDogXCJteS1hcHBcIiB9KTtcbiAqXG4gKiAvLyBvciB0byBwcm92aWRlIGV2ZW50IHR5cGluZyB0b29cbiAqIGNvbnN0IGlubmdlc3QgPSBuZXcgSW5uZ2VzdCh7XG4gKiAgIGlkOiBcIm15LWFwcFwiLFxuICogICBzY2hlbWFzOiBuZXcgRXZlbnRTY2hlbWFzKCkuZnJvbVJlY29yZDx7XG4gKiAgICAgXCJhcHAvdXNlci5jcmVhdGVkXCI6IHtcbiAqICAgICAgIGRhdGE6IHsgdXNlcklkOiBzdHJpbmcgfTtcbiAqICAgICB9O1xuICogICB9PigpLFxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIElubmdlc3Qge1xuICAgIGdldCBhcGlCYXNlVXJsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXBpQmFzZVVybDtcbiAgICB9XG4gICAgZ2V0IGV2ZW50QmFzZVVybCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50QmFzZVVybDtcbiAgICB9XG4gICAgZ2V0IGVudigpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5oZWFkZXJzW2NvbnN0c19qc18xLmhlYWRlcktleXMuRW52aXJvbm1lbnRdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsO1xuICAgIH1cbiAgICBnZXQgYXBwVmVyc2lvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcFZlcnNpb247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgY2xpZW50IHVzZWQgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgSW5uZ2VzdCBBUEkgYnkgc2VuZGluZyBvciByZWFjdGluZyB0b1xuICAgICAqIGV2ZW50cy5cbiAgICAgKlxuICAgICAqIFRvIHByb3ZpZGUgZXZlbnQgdHlwaW5nLCBzZWUge0BsaW5rIEV2ZW50U2NoZW1hc30uXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IGlubmdlc3QgPSBuZXcgSW5uZ2VzdCh7IG5hbWU6IFwiTXkgQXBwXCIgfSk7XG4gICAgICpcbiAgICAgKiAvLyBvciB0byBwcm92aWRlIGV2ZW50IHR5cGluZyB0b29cbiAgICAgKiBjb25zdCBpbm5nZXN0ID0gbmV3IElubmdlc3Qoe1xuICAgICAqICAgbmFtZTogXCJNeSBBcHBcIixcbiAgICAgKiAgIHNjaGVtYXM6IG5ldyBFdmVudFNjaGVtYXMoKS5mcm9tUmVjb3JkPHtcbiAgICAgKiAgICAgXCJhcHAvdXNlci5jcmVhdGVkXCI6IHtcbiAgICAgKiAgICAgICBkYXRhOiB7IHVzZXJJZDogc3RyaW5nIH07XG4gICAgICogICAgIH07XG4gICAgICogICB9PigpLFxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElubmdlc3QgZXZlbnQga2V5LCB1c2VkIHRvIHNlbmQgZXZlbnRzIHRvIElubmdlc3QgQ2xvdWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmV2ZW50S2V5ID0gXCJcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhYnNvbHV0ZSBVUkwgb2YgdGhlIElubmdlc3QgQ2xvdWQgQVBJLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZW5kRXZlbnRVcmwgPSBuZXcgVVJMKGBlLyR7dGhpcy5ldmVudEtleX1gLCBjb25zdHNfanNfMS5kZWZhdWx0SW5uZ2VzdEV2ZW50QmFzZVVybCk7XG4gICAgICAgIHRoaXMubG9jYWxGbnMgPSBbXTtcbiAgICAgICAgdGhpcy5jcmVhdGVGdW5jdGlvbiA9IChyYXdPcHRpb25zLCByYXdUcmlnZ2VyLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmbiA9IHRoaXMuX2NyZWF0ZUZ1bmN0aW9uKHJhd09wdGlvbnMsIHJhd1RyaWdnZXIsIGhhbmRsZXIpO1xuICAgICAgICAgICAgdGhpcy5sb2NhbEZucy5wdXNoKGZuKTtcbiAgICAgICAgICAgIHJldHVybiBmbjtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fY3JlYXRlRnVuY3Rpb24gPSAocmF3T3B0aW9ucywgcmF3VHJpZ2dlciwgaGFuZGxlcikgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuc2FuaXRpemVPcHRpb25zKHJhd09wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgdHJpZ2dlcnMgPSB0aGlzLnNhbml0aXplVHJpZ2dlcnMocmF3VHJpZ2dlcik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IElubmdlc3RGdW5jdGlvbl9qc18xLklubmdlc3RGdW5jdGlvbih0aGlzLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCB7IHRyaWdnZXJzIH0pLCBoYW5kbGVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgeyBpZCwgZmV0Y2gsIGxvZ2dlciA9IG5ldyBsb2dnZXJfanNfMS5EZWZhdWx0TG9nZ2VyKCksIG1pZGRsZXdhcmUsIGlzRGV2LCBzY2hlbWFzLCBhcHBWZXJzaW9uLCB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBpZiAoIWlkKSB7XG4gICAgICAgICAgICAvLyBUT0RPIFByZXR0eUVycm9yXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBbiBgaWRgIG11c3QgYmUgcGFzc2VkIHRvIGNyZWF0ZSBhbiBJbm5nZXN0IGluc3RhbmNlLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMuX21vZGUgPSAoMCwgZW52X2pzXzEuZ2V0TW9kZSkoe1xuICAgICAgICAgICAgZXhwbGljaXRNb2RlOiB0eXBlb2YgaXNEZXYgPT09IFwiYm9vbGVhblwiID8gKGlzRGV2ID8gXCJkZXZcIiA6IFwiY2xvdWRcIikgOiB1bmRlZmluZWQsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmZldGNoID0gKDAsIGVudl9qc18xLmdldEZldGNoKShmZXRjaCk7XG4gICAgICAgIHRoaXMuaW5uZ2VzdEFwaSA9IG5ldyBhcGlfanNfMS5Jbm5nZXN0QXBpKHtcbiAgICAgICAgICAgIGJhc2VVcmw6IHRoaXMuYXBpQmFzZVVybCxcbiAgICAgICAgICAgIHNpZ25pbmdLZXk6ICgwLCBlbnZfanNfMS5wcm9jZXNzRW52KShjb25zdHNfanNfMS5lbnZLZXlzLklubmdlc3RTaWduaW5nS2V5KSB8fCBcIlwiLFxuICAgICAgICAgICAgc2lnbmluZ0tleUZhbGxiYWNrOiAoMCwgZW52X2pzXzEucHJvY2Vzc0VudikoY29uc3RzX2pzXzEuZW52S2V5cy5Jbm5nZXN0U2lnbmluZ0tleUZhbGxiYWNrKSxcbiAgICAgICAgICAgIGZldGNoOiB0aGlzLmZldGNoLFxuICAgICAgICAgICAgbW9kZTogdGhpcy5tb2RlLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zY2hlbWFzID0gc2NoZW1hcztcbiAgICAgICAgdGhpcy5sb2FkTW9kZUVudlZhcnMoKTtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gICAgICAgIHRoaXMubWlkZGxld2FyZSA9IHRoaXMuaW5pdGlhbGl6ZU1pZGRsZXdhcmUoW1xuICAgICAgICAgICAgLi4uZXhwb3J0cy5idWlsdEluTWlkZGxld2FyZSxcbiAgICAgICAgICAgIC4uLihtaWRkbGV3YXJlIHx8IFtdKSxcbiAgICAgICAgXSk7XG4gICAgICAgIHRoaXMuX2FwcFZlcnNpb24gPSBhcHBWZXJzaW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgYFByb21pc2VgIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgYXBwIGlzIHJlYWR5IGFuZCBhbGwgbWlkZGxld2FyZVxuICAgICAqIGhhcyBiZWVuIGluaXRpYWxpemVkLlxuICAgICAqL1xuICAgIGdldCByZWFkeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlkZGxld2FyZS50aGVuKCgpID0+IHsgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGVzIGZvciB0aGlzIGNsaWVudC4gVGhpcyBpcyB1c2VmdWwgaWYgeW91IGFyZVxuICAgICAqIHBhc3NlZCBlbnZpcm9ubWVudCB2YXJpYWJsZXMgYXQgcnVudGltZSBpbnN0ZWFkIG9mIGFzIGdsb2JhbHMgYW5kIG5lZWQgdG9cbiAgICAgKiB1cGRhdGUgdGhlIGNsaWVudCB3aXRoIHRob3NlIHZhbHVlcyBhcyByZXF1ZXN0cyBjb21lIGluLlxuICAgICAqL1xuICAgIHNldEVudlZhcnMoZW52ID0gKDAsIGVudl9qc18xLmFsbFByb2Nlc3NFbnYpKCkpIHtcbiAgICAgICAgdGhpcy5tb2RlID0gKDAsIGVudl9qc18xLmdldE1vZGUpKHsgZW52LCBjbGllbnQ6IHRoaXMgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBsb2FkTW9kZUVudlZhcnMoKSB7XG4gICAgICAgIHRoaXMuX2FwaUJhc2VVcmwgPVxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmJhc2VVcmwgfHxcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVbXCJlbnZcIl1bY29uc3RzX2pzXzEuZW52S2V5cy5Jbm5nZXN0QXBpQmFzZVVybF0gfHxcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVbXCJlbnZcIl1bY29uc3RzX2pzXzEuZW52S2V5cy5Jbm5nZXN0QmFzZVVybF0gfHxcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGUuZ2V0RXhwbGljaXRVcmwoY29uc3RzX2pzXzEuZGVmYXVsdElubmdlc3RBcGlCYXNlVXJsKTtcbiAgICAgICAgdGhpcy5fZXZlbnRCYXNlVXJsID1cbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5iYXNlVXJsIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlW1wiZW52XCJdW2NvbnN0c19qc18xLmVudktleXMuSW5uZ2VzdEV2ZW50QXBpQmFzZVVybF0gfHxcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVbXCJlbnZcIl1bY29uc3RzX2pzXzEuZW52S2V5cy5Jbm5nZXN0QmFzZVVybF0gfHxcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGUuZ2V0RXhwbGljaXRVcmwoY29uc3RzX2pzXzEuZGVmYXVsdElubmdlc3RFdmVudEJhc2VVcmwpO1xuICAgICAgICB0aGlzLnNldEV2ZW50S2V5KHRoaXMub3B0aW9ucy5ldmVudEtleSB8fCB0aGlzLm1vZGVbXCJlbnZcIl1bY29uc3RzX2pzXzEuZW52S2V5cy5Jbm5nZXN0RXZlbnRLZXldIHx8IFwiXCIpO1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSAoMCwgZW52X2pzXzEuaW5uZ2VzdEhlYWRlcnMpKHtcbiAgICAgICAgICAgIGlubmdlc3RFbnY6IHRoaXMub3B0aW9ucy5lbnYsXG4gICAgICAgICAgICBlbnY6IHRoaXMubW9kZVtcImVudlwiXSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaW5uZ2VzdEFwaVtcIm1vZGVcIl0gPSB0aGlzLm1vZGU7XG4gICAgICAgIHRoaXMuaW5uZ2VzdEFwaVtcImFwaUJhc2VVcmxcIl0gPSB0aGlzLl9hcGlCYXNlVXJsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIGFsbCBwYXNzZWQgbWlkZGxld2FyZSwgcnVubmluZyB0aGUgYHJlZ2lzdGVyYCBmdW5jdGlvbiBvbiBlYWNoXG4gICAgICogaW4gc2VxdWVuY2UgYW5kIHJldHVybmluZyB0aGUgcmVxdWVzdGVkIGhvb2sgcmVnaXN0cmF0aW9ucy5cbiAgICAgKi9cbiAgICBhc3luYyBpbml0aWFsaXplTWlkZGxld2FyZShtaWRkbGV3YXJlID0gW10sIG9wdHMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2FpdCBmb3IgdGhlIHByZWZpeCBzdGFjayB0byBydW4gZmlyc3Q7IGRvIG5vdCB0cmlnZ2VyIG91cnMgYmVmb3JlIHRoaXNcbiAgICAgICAgICogaXMgY29tcGxldGUuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBwcmVmaXggPSBhd2FpdCAoKF9hID0gb3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLnByZWZpeFN0YWNrKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSk7XG4gICAgICAgIGNvbnN0IHN0YWNrID0gbWlkZGxld2FyZS5yZWR1Y2UoYXN5bmMgKGFjYywgbSkgPT4ge1xuICAgICAgICAgICAgLy8gQmUgZXhwbGljaXQgYWJvdXQgd2FpdGluZyBmb3IgdGhlIHByZXZpb3VzIG1pZGRsZXdhcmUgdG8gZmluaXNoXG4gICAgICAgICAgICBjb25zdCBwcmV2ID0gYXdhaXQgYWNjO1xuICAgICAgICAgICAgY29uc3QgbmV4dCA9IGF3YWl0IG0uaW5pdChPYmplY3QuYXNzaWduKHsgY2xpZW50OiB0aGlzIH0sIG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5yZWdpc3RlcklucHV0KSk7XG4gICAgICAgICAgICByZXR1cm4gWy4uLnByZXYsIG5leHRdO1xuICAgICAgICB9LCBQcm9taXNlLnJlc29sdmUoW10pKTtcbiAgICAgICAgcmV0dXJuIFsuLi5wcmVmaXgsIC4uLihhd2FpdCBzdGFjayldO1xuICAgIH1cbiAgICBnZXQgbW9kZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21vZGU7XG4gICAgfVxuICAgIHNldCBtb2RlKG0pIHtcbiAgICAgICAgdGhpcy5fbW9kZSA9IG07XG4gICAgICAgIHRoaXMubG9hZE1vZGVFbnZWYXJzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgcmVzcG9uc2UgZnJvbSBJbm5nZXN0LCByZWxheSB0aGUgZXJyb3IgdG8gdGhlIGNhbGxlci5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRSZXNwb25zZUVycm9yKHJlc3BvbnNlLCByYXdCb2R5LCBmb3VuZEVyciA9IFwiVW5rbm93biBlcnJvclwiKSB7XG4gICAgICAgIGxldCBlcnJvck1lc3NhZ2UgPSBmb3VuZEVycjtcbiAgICAgICAgaWYgKGVycm9yTWVzc2FnZSA9PT0gXCJVbmtub3duIGVycm9yXCIpIHtcbiAgICAgICAgICAgIHN3aXRjaCAocmVzcG9uc2Uuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSA0MDE6XG4gICAgICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IFwiRXZlbnQga2V5IE5vdCBGb3VuZFwiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQwMDpcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gXCJDYW5ub3QgcHJvY2VzcyBldmVudCBwYXlsb2FkXCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDAzOlxuICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBcIkZvcmJpZGRlblwiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQwNDpcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gXCJFdmVudCBrZXkgbm90IGZvdW5kXCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDA2OlxuICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBgJHtKU09OLnN0cmluZ2lmeShhd2FpdCByYXdCb2R5KX1gO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQwOTpcbiAgICAgICAgICAgICAgICBjYXNlIDQxMjpcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gXCJFdmVudCB0cmFuc2Zvcm1hdGlvbiBmYWlsZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0MTM6XG4gICAgICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IFwiRXZlbnQgcGF5bG9hZCB0b28gbGFyZ2VcIjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA1MDA6XG4gICAgICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IFwiSW50ZXJuYWwgc2VydmVyIGVycm9yXCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gYCR7SlNPTi5zdHJpbmdpZnkoYXdhaXQgcmF3Qm9keSl9YDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEVycm9yKGBJbm5nZXN0IEFQSSBFcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9ICR7ZXJyb3JNZXNzYWdlfWApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGV2ZW50IGtleSBmb3IgdGhpcyBpbnN0YW5jZSBvZiBJbm5nZXN0LiBUaGlzIGlzIHVzZWZ1bCBpZiBmb3Igc29tZVxuICAgICAqIHJlYXNvbiB0aGUga2V5IGlzIG5vdCBhdmFpbGFibGUgYXQgdGltZSBvZiBpbnN0YW50aWF0aW9uIG9yIHByZXNlbnQgaW4gdGhlXG4gICAgICogYElOTkdFU1RfRVZFTlRfS0VZYCBlbnZpcm9ubWVudCB2YXJpYWJsZS5cbiAgICAgKi9cbiAgICBzZXRFdmVudEtleShcbiAgICAvKipcbiAgICAgKiBJbm5nZXN0IGV2ZW50IGtleSwgdXNlZCB0byBzZW5kIGV2ZW50cyB0byBJbm5nZXN0IENsb3VkLiBVc2UgdGhpcyBpcyB5b3VyXG4gICAgICoga2V5IGlzIGZvciBzb21lIHJlYXNvbiBub3QgYXZhaWxhYmxlIGF0IHRpbWUgb2YgaW5zdGFudGlhdGlvbiBvciBwcmVzZW50XG4gICAgICogaW4gdGhlIGBJTk5HRVNUX0VWRU5UX0tFWWAgZW52aXJvbm1lbnQgdmFyaWFibGUuXG4gICAgICovXG4gICAgZXZlbnRLZXkpIHtcbiAgICAgICAgdGhpcy5ldmVudEtleSA9IGV2ZW50S2V5IHx8IGNvbnN0c19qc18xLmR1bW15RXZlbnRLZXk7XG4gICAgICAgIHRoaXMuc2VuZEV2ZW50VXJsID0gbmV3IFVSTChgZS8ke3RoaXMuZXZlbnRLZXl9YCwgdGhpcy5ldmVudEJhc2VVcmwgfHwgY29uc3RzX2pzXzEuZGVmYXVsdElubmdlc3RFdmVudEJhc2VVcmwpO1xuICAgIH1cbiAgICBldmVudEtleVNldCgpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy5ldmVudEtleSkgJiYgdGhpcy5ldmVudEtleSAhPT0gY29uc3RzX2pzXzEuZHVtbXlFdmVudEtleTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRVhQRVJJTUVOVEFMOiBUaGlzIEFQSSBpcyBub3QgeWV0IHN0YWJsZSBhbmQgbWF5IGNoYW5nZSBpbiB0aGUgZnV0dXJlXG4gICAgICogd2l0aG91dCBhIG1ham9yIHZlcnNpb24gYnVtcC5cbiAgICAgKlxuICAgICAqIFNlbmQgYSBTaWduYWwgdG8gSW5uZ2VzdC5cbiAgICAgKi9cbiAgICBhc3luYyBzZW5kU2lnbmFsKHsgc2lnbmFsLCBkYXRhLCBlbnYsIH0pIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe30sIChlbnYgPyB7IFtjb25zdHNfanNfMS5oZWFkZXJLZXlzLkVudmlyb25tZW50XTogZW52IH0gOiB7fSkpO1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VuZFNpZ25hbCh7IHNpZ25hbCwgZGF0YSwgaGVhZGVycyB9KTtcbiAgICB9XG4gICAgYXN5bmMgX3NlbmRTaWduYWwoeyBzaWduYWwsIGRhdGEsIGhlYWRlcnMsIH0pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmlubmdlc3RBcGkuc2VuZFNpZ25hbCh7IHNpZ25hbCwgZGF0YSB9LCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuaGVhZGVycyksIGhlYWRlcnMpKTtcbiAgICAgICAgaWYgKHJlcy5vaykge1xuICAgICAgICAgICAgcmV0dXJuIHJlcy52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBzZW5kIHNpZ25hbDogJHsoKF9hID0gcmVzLmVycm9yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZXJyb3IpIHx8IFwiVW5rbm93biBlcnJvclwifWApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIG9uZSBvciBtYW55IGV2ZW50cyB0byBJbm5nZXN0LiBUYWtlcyBhbiBlbnRpcmUgcGF5bG9hZCAoaW5jbHVkaW5nXG4gICAgICogbmFtZSkgYXMgZWFjaCBpbnB1dC5cbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogYXdhaXQgaW5uZ2VzdC5zZW5kKHsgbmFtZTogXCJhcHAvdXNlci5jcmVhdGVkXCIsIGRhdGE6IHsgaWQ6IDEyMyB9IH0pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCB3aWxsIHJlc29sdmUgaWYgdGhlIGV2ZW50KHMpIHdlcmUgc2VudCBzdWNjZXNzZnVsbHksXG4gICAgICogZWxzZSB0aHJvd3Mgd2l0aCBhbiBlcnJvciBleHBsYWluaW5nIHdoYXQgd2VudCB3cm9uZy5cbiAgICAgKlxuICAgICAqIElmIHlvdSB3aXNoIHRvIHNlbmQgYW4gZXZlbnQgd2l0aCBjdXN0b20gdHlwZXMgKGkuZS4gb25lIHRoYXQgaGFzbid0IGJlZW5cbiAgICAgKiBnZW5lcmF0ZWQpLCBtYWtlIHN1cmUgdG8gYWRkIGl0IHdoZW4gY3JlYXRpbmcgeW91ciBJbm5nZXN0IGluc3RhbmNlLCBsaWtlXG4gICAgICogc286XG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IGlubmdlc3QgPSBuZXcgSW5uZ2VzdCh7XG4gICAgICogICBuYW1lOiBcIk15IEFwcFwiLFxuICAgICAqICAgc2NoZW1hczogbmV3IEV2ZW50U2NoZW1hcygpLmZyb21SZWNvcmQ8e1xuICAgICAqICAgICBcIm15L2V2ZW50XCI6IHtcbiAgICAgKiAgICAgICBuYW1lOiBcIm15L2V2ZW50XCI7XG4gICAgICogICAgICAgZGF0YTogeyBiYXI6IHN0cmluZyB9O1xuICAgICAqICAgICB9O1xuICAgICAqICAgfT4oKSxcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBzZW5kKHBheWxvYWQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe30sICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmVudikgPyB7IFtjb25zdHNfanNfMS5oZWFkZXJLZXlzLkVudmlyb25tZW50XTogb3B0aW9ucy5lbnYgfSA6IHt9KSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZW5kKHsgcGF5bG9hZCwgaGVhZGVycyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgbWV0aG9kIGZvciBzZW5kaW5nIGFuIGV2ZW50LCB1c2VkIHRvIGFsbG93IElubmdlc3QgaW50ZXJuYWxzIHRvXG4gICAgICogZnVydGhlciBjdXN0b21pemUgdGhlIHJlcXVlc3Qgc2VudCB0byBhbiBJbm5nZXN0IFNlcnZlci5cbiAgICAgKi9cbiAgICBhc3luYyBfc2VuZCh7IHBheWxvYWQsIGhlYWRlcnMsIH0pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBub3dNaWxsaXMgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgbGV0IG1heEF0dGVtcHRzID0gNTtcbiAgICAgICAgLy8gQXR0ZW1wdCB0byBzZXQgdGhlIGV2ZW50IElEIHNlZWQgaGVhZGVyLiBJZiBpdCBmYWlscyB0aGVuIGRpc2FibGUgcmV0cmllc1xuICAgICAgICAvLyAoYnV0IHdlIHN0aWxsIHdhbnQgdG8gc2VuZCB0aGUgZXZlbnQpLlxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZW50cm9weSA9ICgwLCBjcnlwdG9fanNfMS5jcmVhdGVFbnRyb3B5KSgxMCk7XG4gICAgICAgICAgICBjb25zdCBlbnRyb3B5QmFzZTY0ID0gQnVmZmVyLmZyb20oZW50cm9weSkudG9TdHJpbmcoXCJiYXNlNjRcIik7XG4gICAgICAgICAgICBoZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBoZWFkZXJzKSwgeyBbY29uc3RzX2pzXzEuaGVhZGVyS2V5cy5FdmVudElkU2VlZF06IGAke25vd01pbGxpc30sJHtlbnRyb3B5QmFzZTY0fWAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgbGV0IG1lc3NhZ2UgPSBcIkV2ZW50LXNlbmRpbmcgcmV0cmllcyBkaXNhYmxlZFwiO1xuICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSArPSBgOiAke2Vyci5tZXNzYWdlfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zb2xlLmRlYnVnKG1lc3NhZ2UpO1xuICAgICAgICAgICAgLy8gRGlzYWJsZSByZXRyaWVzLlxuICAgICAgICAgICAgbWF4QXR0ZW1wdHMgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhvb2tzID0gYXdhaXQgKDAsIElubmdlc3RNaWRkbGV3YXJlX2pzXzEuZ2V0SG9va1N0YWNrKSh0aGlzLm1pZGRsZXdhcmUsIFwib25TZW5kRXZlbnRcIiwgdW5kZWZpbmVkLCB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1JbnB1dDogKHByZXYsIG91dHB1dCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHByZXYpLCBvdXRwdXQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRyYW5zZm9ybU91dHB1dChwcmV2LCBvdXRwdXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJldi5yZXN1bHQpLCBvdXRwdXQgPT09IG51bGwgfHwgb3V0cHV0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvdXRwdXQucmVzdWx0KSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBwYXlsb2FkcyA9IEFycmF5LmlzQXJyYXkocGF5bG9hZClcbiAgICAgICAgICAgID8gcGF5bG9hZFxuICAgICAgICAgICAgOiBwYXlsb2FkXG4gICAgICAgICAgICAgICAgPyBbcGF5bG9hZF1cbiAgICAgICAgICAgICAgICA6IFtdO1xuICAgICAgICBjb25zdCBpbnB1dENoYW5nZXMgPSBhd2FpdCAoKF9hID0gaG9va3MudHJhbnNmb3JtSW5wdXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGhvb2tzLCB7XG4gICAgICAgICAgICBwYXlsb2FkczogWy4uLnBheWxvYWRzXSxcbiAgICAgICAgfSkpO1xuICAgICAgICBpZiAoaW5wdXRDaGFuZ2VzID09PSBudWxsIHx8IGlucHV0Q2hhbmdlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5wdXRDaGFuZ2VzLnBheWxvYWRzKSB7XG4gICAgICAgICAgICBwYXlsb2FkcyA9IFsuLi5pbnB1dENoYW5nZXMucGF5bG9hZHNdO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVuc3VyZSB0aGF0IHdlIGFsd2F5cyBhZGQgXCJ0c1wiIGFuZCBcImRhdGFcIiBmaWVsZHMgdG8gZXZlbnRzLiBcInRzXCIgaXMgYXV0by1cbiAgICAgICAgLy8gZmlsbGVkIGJ5IHRoZSBldmVudCBzZXJ2ZXIgc28gaXMgc2FmZSwgYW5kIGFkZGluZyBoZXJlIGZpeGVzIE5leHQuanNcbiAgICAgICAgLy8gc2VydmVyIGFjdGlvbiBjYWNoZSBpc3N1ZXMuXG4gICAgICAgIHBheWxvYWRzID0gcGF5bG9hZHMubWFwKChwKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwKSwgeyBcbiAgICAgICAgICAgICAgICAvLyBBbHdheXMgZ2VuZXJhdGUgYW4gaWRlbXBvdGVuY3kgSUQgZm9yIGFuIGV2ZW50IGZvciByZXRyaWVzXG4gICAgICAgICAgICAgICAgaWQ6IHAuaWQsIHRzOiBwLnRzIHx8IG5vd01pbGxpcywgXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgICAgICAgICAgICAgIGRhdGE6IHAuZGF0YSB8fCB7fSB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGFwcGx5SG9va1RvT3V0cHV0ID0gYXN5bmMgKGFyZykgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgY29uc3QgaG9va091dHB1dCA9IGF3YWl0ICgoX2EgPSBob29rcy50cmFuc2Zvcm1PdXRwdXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGhvb2tzLCBhcmcpKTtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFyZy5yZXN1bHQpLCBob29rT3V0cHV0ID09PSBudWxsIHx8IGhvb2tPdXRwdXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGhvb2tPdXRwdXQucmVzdWx0KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEl0IGNhbiBiZSB2YWxpZCBmb3IgYSB1c2VyIHRvIHNlbmQgYW4gZW1wdHkgbGlzdCBvZiBldmVudHM7IGlmIHRoaXNcbiAgICAgICAgICogaGFwcGVucywgc2hvdyBhIHdhcm5pbmcgdGhhdCB0aGlzIG1heSBub3QgYmUgaW50ZW5kZWQsIGJ1dCBkb24ndCB0aHJvdy5cbiAgICAgICAgICovXG4gICAgICAgIGlmICghcGF5bG9hZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oKDAsIGVycm9yc19qc18xLnByZXR0eUVycm9yKSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ3YXJuXCIsXG4gICAgICAgICAgICAgICAgd2hhdEhhcHBlbmVkOiBcImBpbm5nZXN0LnNlbmQoKWAgY2FsbGVkIHdpdGggbm8gZXZlbnRzXCIsXG4gICAgICAgICAgICAgICAgcmVhc3N1cmFuY2U6IFwiVGhpcyBpcyBub3QgYW4gZXJyb3IsIGJ1dCB5b3UgbWF5IG5vdCBoYXZlIGludGVuZGVkIHRvIGRvIHRoaXMuXCIsXG4gICAgICAgICAgICAgICAgY29uc2VxdWVuY2VzOiBcIlRoZSByZXR1cm5lZCBwcm9taXNlIHdpbGwgcmVzb2x2ZSwgYnV0IG5vIGV2ZW50cyBoYXZlIGJlZW4gc2VudCB0byBJbm5nZXN0LlwiLFxuICAgICAgICAgICAgICAgIHN0YWNrOiB0cnVlLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGFwcGx5SG9va1RvT3V0cHV0KHsgcmVzdWx0OiB7IGlkczogW10gfSB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXaGVuIHNlbmRpbmcgZXZlbnRzLCBjaGVjayBpZiB0aGUgZGV2IHNlcnZlciBpcyBhdmFpbGFibGUuICBJZiBzbywgdXNlIHRoZVxuICAgICAgICAvLyBkZXYgc2VydmVyLlxuICAgICAgICBsZXQgdXJsID0gdGhpcy5zZW5kRXZlbnRVcmwuaHJlZjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGluIHByb2QgbW9kZSBhbmQga2V5IGlzIG5vdCBwcmVzZW50LCBmYWlsIG5vdy5cbiAgICAgICAgICovXG4gICAgICAgIGlmICh0aGlzLm1vZGUuaXNDbG91ZCAmJiAhdGhpcy5ldmVudEtleVNldCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKDAsIGVycm9yc19qc18xLnByZXR0eUVycm9yKSh7XG4gICAgICAgICAgICAgICAgd2hhdEhhcHBlbmVkOiBcIkZhaWxlZCB0byBzZW5kIGV2ZW50XCIsXG4gICAgICAgICAgICAgICAgY29uc2VxdWVuY2VzOiBcIllvdXIgZXZlbnQgb3IgZXZlbnRzIHdlcmUgbm90IHNlbnQgdG8gSW5uZ2VzdC5cIixcbiAgICAgICAgICAgICAgICB3aHk6IFwiV2UgY291bGRuJ3QgZmluZCBhbiBldmVudCBrZXkgdG8gdXNlIHRvIHNlbmQgZXZlbnRzIHRvIElubmdlc3QuXCIsXG4gICAgICAgICAgICAgICAgdG9GaXhOb3c6IGVycm9yc19qc18xLmZpeEV2ZW50S2V5TWlzc2luZ1N0ZXBzLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBkZXYgbW9kZSBoYXMgYmVlbiBpbmZlcnJlZCwgdHJ5IHRvIGhpdCB0aGUgZGV2IHNlcnZlciBmaXJzdCB0byBzZWUgaWZcbiAgICAgICAgICogaXQgZXhpc3RzLiBJZiBpdCBkb2VzLCB1c2UgaXQsIG90aGVyd2lzZSBmYWxsIGJhY2sgdG8gd2hhdGV2ZXIgc2VydmVyIHdlXG4gICAgICAgICAqIGhhdmUgY29uZmlndXJlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogYElOTkdFU1RfQkFTRV9VUkxgIGlzIHVzZWQgdG8gc2V0IGJvdGggZGV2IHNlcnZlciBhbmQgcHJvZCBVUkxzLCBzbyBpZiBhXG4gICAgICAgICAqIHVzZXIgaGFzIHNldCB0aGlzIGl0IG1lYW5zIHRoZXkgaGF2ZSBhbHJlYWR5IGNob3NlbiBhIFVSTCB0byBoaXQuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAodGhpcy5tb2RlLmlzRGV2ICYmIHRoaXMubW9kZS5pc0luZmVycmVkICYmICF0aGlzLmV2ZW50QmFzZVVybCkge1xuICAgICAgICAgICAgY29uc3QgZGV2QXZhaWxhYmxlID0gYXdhaXQgKDAsIGRldnNlcnZlcl9qc18xLmRldlNlcnZlckF2YWlsYWJsZSkoY29uc3RzX2pzXzEuZGVmYXVsdERldlNlcnZlckhvc3QsIHRoaXMuZmV0Y2gpO1xuICAgICAgICAgICAgaWYgKGRldkF2YWlsYWJsZSkge1xuICAgICAgICAgICAgICAgIHVybCA9ICgwLCBkZXZzZXJ2ZXJfanNfMS5kZXZTZXJ2ZXJVcmwpKGNvbnN0c19qc18xLmRlZmF1bHREZXZTZXJ2ZXJIb3N0LCBgZS8ke3RoaXMuZXZlbnRLZXl9YCkuaHJlZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBib2R5ID0gYXdhaXQgKDAsIHByb21pc2VzX2pzXzEucmV0cnlXaXRoQmFja29mZikoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgbGV0IHJhd0JvZHk7XG4gICAgICAgICAgICBsZXQgYm9keTtcbiAgICAgICAgICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gZG8gZmFsbGJhY2sgYXV0aCBoZXJlIGJlY2F1c2UgdGhpcyB1c2VzIGV2ZW50IGtleXMgYW5kXG4gICAgICAgICAgICAvLyBub3Qgc2lnbmluZyBrZXlzXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2godXJsLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgICAgICBib2R5OiAoMCwgc3RyaW5nc19qc18xLnN0cmluZ2lmeSkocGF5bG9hZHMpLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5oZWFkZXJzKSwgaGVhZGVycyksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmF3Qm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgICAgICBib2R5ID0gYXdhaXQgdHlwZXNfanNfMS5zZW5kRXZlbnRSZXNwb25zZVNjaGVtYS5wYXJzZUFzeW5jKHJhd0JvZHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHRocm93IGF3YWl0IHRoaXMuZ2V0UmVzcG9uc2VFcnJvcihyZXNwb25zZSwgcmF3Qm9keSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYm9keS5zdGF0dXMgIT09IDIwMCB8fCBib2R5LmVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgYXdhaXQgdGhpcy5nZXRSZXNwb25zZUVycm9yKHJlc3BvbnNlLCByYXdCb2R5LCBib2R5LmVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBib2R5O1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBtYXhBdHRlbXB0cyxcbiAgICAgICAgICAgIGJhc2VEZWxheTogMTAwLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGFwcGx5SG9va1RvT3V0cHV0KHsgcmVzdWx0OiB7IGlkczogYm9keS5pZHMgfSB9KTtcbiAgICB9XG4gICAgZ2V0IGZ1bmNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbEZucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUnVudGltZS1vbmx5IHZhbGlkYXRpb24uXG4gICAgICovXG4gICAgc2FuaXRpemVPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCBcImZuc1wiKSkge1xuICAgICAgICAgICAgLy8gdjIgLT4gdjMgbWlncmF0aW9uIHdhcm5pbmdcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgJHtjb25zdHNfanNfMS5sb2dQcmVmaXh9IElubmdlc3RGdW5jdGlvbjogXFxgZm5zXFxgIG9wdGlvbiBoYXMgYmVlbiBkZXByZWNhdGVkIGluIHYzOyB1c2UgXFxgbWlkZGxld2FyZVxcYCBpbnN0ZWFkLiBTZWUgaHR0cHM6Ly93d3cuaW5uZ2VzdC5jb20vZG9jcy9zZGsvbWlncmF0aW9uYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAvLyB2MiAtPiB2MyBydW50aW1lIG1pZ3JhdG9uIHdhcm5pbmdcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgJHtjb25zdHNfanNfMS5sb2dQcmVmaXh9IElubmdlc3RGdW5jdGlvbjogQ3JlYXRpbmcgYSBmdW5jdGlvbiB3aXRoIGEgc3RyaW5nIGFzIHRoZSBmaXJzdCBhcmd1bWVudCBoYXMgYmVlbiBkZXByZWNhdGVkIGluIHYzOyBwYXNzIGFuIG9iamVjdCBpbnN0ZWFkLiBTZWUgaHR0cHM6Ly93d3cuaW5uZ2VzdC5jb20vZG9jcy9zZGsvbWlncmF0aW9uYCk7XG4gICAgICAgICAgICByZXR1cm4geyBpZDogb3B0aW9ucyB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSdW50aW1lLW9ubHkgdmFsaWRhdGlvbi5cbiAgICAgKi9cbiAgICBzYW5pdGl6ZVRyaWdnZXJzKHRyaWdnZXJzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdHJpZ2dlcnMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIC8vIHYyIC0+IHYzIG1pZ3JhdGlvbiB3YXJuaW5nXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYCR7Y29uc3RzX2pzXzEubG9nUHJlZml4fSBJbm5nZXN0RnVuY3Rpb246IENyZWF0aW5nIGEgZnVuY3Rpb24gd2l0aCBhIHN0cmluZyBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IGhhcyBiZWVuIGRlcHJlY2F0ZWQgaW4gdjM7IHBhc3MgYW4gb2JqZWN0IGluc3RlYWQuIFNlZSBodHRwczovL3d3dy5pbm5nZXN0LmNvbS9kb2NzL3Nkay9taWdyYXRpb25gKTtcbiAgICAgICAgICAgIHJldHVybiBbeyBldmVudDogdHJpZ2dlcnMgfV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRyaWdnZXJzKSkge1xuICAgICAgICAgICAgcmV0dXJuIFt0cmlnZ2Vyc107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRyaWdnZXJzO1xuICAgIH1cbn1cbmV4cG9ydHMuSW5uZ2VzdCA9IElubmdlc3Q7XG4vKipcbiAqIERlZmF1bHQgbWlkZGxld2FyZSB0aGF0IGlzIGluY2x1ZGVkIGluIGV2ZXJ5IGNsaWVudCwgcGxhY2VkIGFmdGVyIHRoZSB1c2VyJ3NcbiAqIG1pZGRsZXdhcmUgb24gdGhlIGNsaWVudCBidXQgYmVmb3JlIGZ1bmN0aW9uLWxldmVsIG1pZGRsZXdhcmUuXG4gKlxuICogSXQgaXMgZGVmaW5lZCBoZXJlIHRvIGVuc3VyZSB0aGF0IGNvbW1lbnRzIGFyZSBpbmNsdWRlZCBpbiB0aGUgZ2VuZXJhdGVkIFRTXG4gKiBkZWZpbml0aW9ucy4gV2l0aG91dCB0aGlzLCB3ZSBpbmZlciB0aGUgc3RhY2sgb2YgYnVpbHQtaW4gbWlkZGxld2FyZSB3aXRob3V0XG4gKiBjb21tZW50cywgbG9zaW5nIGEgbG90IG9mIHZhbHVlLlxuICpcbiAqIElmIHRoaXMgaXMgbW92ZWQsIHBsZWFzZSBlbnN1cmUgdGhhdCB1c2luZyB0aGlzIHBhY2thZ2UgaW4gYW5vdGhlciBwcm9qZWN0XG4gKiBjYW4gY29ycmVjdGx5IGFjY2VzcyBjb21tZW50cyBvbiBtdXRhdGVkIGlucHV0IGFuZCBvdXRwdXQuXG4gKlxuICogVGhpcyByZXR1cm4gcGF0dGVybiBtaW1pY3MgdGhlIG91dHB1dCBvZiBhIGBzYXRpc2ZpZXNgIHN1ZmZpeDsgaXQncyB1c2VkIGFzXG4gKiB3ZSBzdXBwb3J0IHZlcnNpb25zIG9mIFR5cGVTY3JpcHQgcHJpb3IgdG8gdGhlIGludHJvZHVjdGlvbiBvZiBgc2F0aXNmaWVzYC5cbiAqL1xuZXhwb3J0cy5idWlsdEluTWlkZGxld2FyZSA9ICgobSkgPT4gbSkoW1xuICAgIG5ldyBJbm5nZXN0TWlkZGxld2FyZV9qc18xLklubmdlc3RNaWRkbGV3YXJlKHtcbiAgICAgICAgbmFtZTogXCJJbm5nZXN0OiBMb2dnZXJcIixcbiAgICAgICAgaW5pdCh7IGNsaWVudCB9KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG9uRnVuY3Rpb25SdW4oYXJnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgY3R4IH0gPSBhcmc7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcnVuSUQ6IGN0eC5ydW5JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50TmFtZTogY3R4LmV2ZW50Lm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6IGFyZy5mbi5uYW1lLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBsZXQgcHJvdmlkZWRMb2dnZXIgPSBjbGllbnRbXCJsb2dnZXJcIl07XG4gICAgICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBhIGNoaWxkIGxvZ2dlciBpZiB0aGUgcHJvdmlkZWQgbG9nZ2VyIGhhcyBjaGlsZCBsb2dnZXIgaW1wbGVtZW50YXRpb25cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcImNoaWxkXCIgaW4gcHJvdmlkZWRMb2dnZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlZExvZ2dlciA9IHByb3ZpZGVkTG9nZ2VyLmNoaWxkKG1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdmYWlsZWQgdG8gY3JlYXRlIFwiY2hpbGRMb2dnZXJcIiB3aXRoIGVycm9yOiAnLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm8tb3BcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2dnZXIgPSBuZXcgbG9nZ2VyX2pzXzEuUHJveHlMb2dnZXIocHJvdmlkZWRMb2dnZXIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtSW5wdXQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFRoZSBwYXNzZWQgaW4gbG9nZ2VyIGZyb20gdGhlIHVzZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBEZWZhdWx0cyB0byBhIGNvbnNvbGUgbG9nZ2VyIGlmIG5vdCBwcm92aWRlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyOiBsb2dnZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBiZWZvcmVFeGVjdXRpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVuYWJsZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybU91dHB1dCh7IHJlc3VsdDogeyBlcnJvciB9IH0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgYXN5bmMgYmVmb3JlUmVzcG9uc2UoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgbG9nZ2VyLmZsdXNoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgIH0pLFxuXSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Jbm5nZXN0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/Inngest.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/InngestCommHandler.js":
/*!***************************************************************!*\
  !*** ./node_modules/inngest/components/InngestCommHandler.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nvar _RequestSignature_instances, _RequestSignature_verifySignature;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InngestCommHandler = void 0;\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\"));\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/inngest/node_modules/zod/lib/index.js\");\nconst ServerTiming_js_1 = __webpack_require__(/*! ../helpers/ServerTiming.js */ \"(rsc)/./node_modules/inngest/helpers/ServerTiming.js\");\nconst consts_js_1 = __webpack_require__(/*! ../helpers/consts.js */ \"(rsc)/./node_modules/inngest/helpers/consts.js\");\nconst devserver_js_1 = __webpack_require__(/*! ../helpers/devserver.js */ \"(rsc)/./node_modules/inngest/helpers/devserver.js\");\nconst enum_js_1 = __webpack_require__(/*! ../helpers/enum.js */ \"(rsc)/./node_modules/inngest/helpers/enum.js\");\nconst env_js_1 = __webpack_require__(/*! ../helpers/env.js */ \"(rsc)/./node_modules/inngest/helpers/env.js\");\nconst errors_js_1 = __webpack_require__(/*! ../helpers/errors.js */ \"(rsc)/./node_modules/inngest/helpers/errors.js\");\nconst functions_js_1 = __webpack_require__(/*! ../helpers/functions.js */ \"(rsc)/./node_modules/inngest/helpers/functions.js\");\nconst net_js_1 = __webpack_require__(/*! ../helpers/net.js */ \"(rsc)/./node_modules/inngest/helpers/net.js\");\nconst promises_js_1 = __webpack_require__(/*! ../helpers/promises.js */ \"(rsc)/./node_modules/inngest/helpers/promises.js\");\nconst stream_js_1 = __webpack_require__(/*! ../helpers/stream.js */ \"(rsc)/./node_modules/inngest/helpers/stream.js\");\nconst strings_js_1 = __webpack_require__(/*! ../helpers/strings.js */ \"(rsc)/./node_modules/inngest/helpers/strings.js\");\nconst types_js_1 = __webpack_require__(/*! ../types.js */ \"(rsc)/./node_modules/inngest/types.js\");\nconst version_js_1 = __webpack_require__(/*! ../version.js */ \"(rsc)/./node_modules/inngest/version.js\");\nconst InngestExecution_js_1 = __webpack_require__(/*! ./execution/InngestExecution.js */ \"(rsc)/./node_modules/inngest/components/execution/InngestExecution.js\");\n/**\n * A schema for the response from Inngest when registering.\n */\nconst registerResSchema = zod_1.z.object({\n    status: zod_1.z.number().default(200),\n    skipped: zod_1.z.boolean().optional().default(false),\n    modified: zod_1.z.boolean().optional().default(false),\n    error: zod_1.z.string().default(\"Successfully registered\"),\n});\n/**\n * `InngestCommHandler` is a class for handling incoming requests from Inngest (or\n * Inngest's tooling such as the dev server or CLI) and taking appropriate\n * action for any served functions.\n *\n * All handlers (Next.js, RedwoodJS, Remix, Deno Fresh, etc.) are created using\n * this class; the exposed `serve` function will - most commonly - create an\n * instance of `InngestCommHandler` and then return `instance.createHandler()`.\n *\n * See individual parameter details for more information, or see the\n * source code for an existing handler, e.g.\n * {@link https://github.com/inngest/inngest-js/blob/main/src/next.ts}\n *\n * @example\n * ```\n * // my-custom-handler.ts\n * import {\n *   InngestCommHandler,\n *   type ServeHandlerOptions,\n * } from \"./components/InngestCommHandler\";\n *\n * export const serve = (options: ServeHandlerOptions) => {\n *   const handler = new InngestCommHandler({\n *     frameworkName: \"my-custom-handler\",\n *     ...options,\n *     handler: (req: Request) => {\n *       return {\n *         body: () => req.json(),\n *         headers: (key) => req.headers.get(key),\n *         method: () => req.method,\n *         url: () => new URL(req.url, `https://${req.headers.get(\"host\") || \"\"}`),\n *         transformResponse: ({ body, status, headers }) => {\n *           return new Response(body, { status, headers });\n *         },\n *       };\n *     },\n *   });\n *\n *   return handler.createHandler();\n * };\n * ```\n *\n * @public\n */\nclass InngestCommHandler {\n    constructor(options) {\n        var _a;\n        /**\n         * A private collection of functions that are being served. This map is used\n         * to find and register functions when interacting with Inngest Cloud.\n         */\n        this.fns = {};\n        this.env = (0, env_js_1.allProcessEnv)();\n        // Set input options directly so we can reference them later\n        this._options = options;\n        /**\n         * v2 -> v3 migration error.\n         *\n         * If a serve handler is passed a client as the first argument, it'll be\n         * spread in to these options. We should be able to detect this by picking\n         * up a unique property on the object.\n         */\n        if (Object.prototype.hasOwnProperty.call(options, \"eventKey\")) {\n            throw new Error(`${consts_js_1.logPrefix} You've passed an Inngest client as the first argument to your serve handler. This is no longer supported in v3; please pass the Inngest client as the \\`client\\` property of an options object instead. See https://www.inngest.com/docs/sdk/migration`);\n        }\n        this.frameworkName = options.frameworkName;\n        this.client = options.client;\n        if (options.id) {\n            console.warn(`${consts_js_1.logPrefix} The \\`id\\` serve option is deprecated and will be removed in v4`);\n        }\n        this.id = options.id || this.client.id;\n        this.handler = options.handler;\n        /**\n         * Provide a hidden option to allow expired signatures to be accepted during\n         * testing.\n         */\n        this.allowExpiredSignatures = Boolean(\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, prefer-rest-params\n        (_a = arguments[\"0\"]) === null || _a === void 0 ? void 0 : _a.__testingAllowExpiredSignatures);\n        // Ensure we filter any undefined functions in case of missing imports.\n        this.rawFns = options.functions.filter(Boolean);\n        if (this.rawFns.length !== options.functions.length) {\n            // TODO PrettyError\n            console.warn(`Some functions passed to serve() are undefined and misconfigured.  Please check your imports.`);\n        }\n        this.fns = this.rawFns.reduce((acc, fn) => {\n            const configs = fn[\"getConfig\"]({\n                baseUrl: new URL(\"https://example.com\"),\n                appPrefix: this.id,\n            });\n            const fns = configs.reduce((acc, { id }, index) => {\n                return Object.assign(Object.assign({}, acc), { [id]: { fn, onFailure: Boolean(index) } });\n            }, {});\n            configs.forEach(({ id }) => {\n                if (acc[id]) {\n                    // TODO PrettyError\n                    throw new Error(`Duplicate function ID \"${id}\"; please change a function's name or provide an explicit ID to avoid conflicts.`);\n                }\n            });\n            return Object.assign(Object.assign({}, acc), fns);\n        }, {});\n        this.inngestRegisterUrl = new URL(\"/fn/register\", this.apiBaseUrl);\n        this.signingKey = options.signingKey;\n        this.signingKeyFallback = options.signingKeyFallback;\n        this._serveHost = options.serveHost || this.env[consts_js_1.envKeys.InngestServeHost];\n        this._servePath = options.servePath || this.env[consts_js_1.envKeys.InngestServePath];\n        this.skipSignatureValidation = options.skipSignatureValidation || false;\n        const defaultLogLevel = \"info\";\n        this.logLevel = zod_1.z\n            .enum(types_js_1.logLevels)\n            .default(defaultLogLevel)\n            .catch((ctx) => {\n            this.log(\"warn\", `Unknown log level passed: ${String(ctx.input)}; defaulting to ${defaultLogLevel}`);\n            return defaultLogLevel;\n        })\n            .parse(options.logLevel || this.env[consts_js_1.envKeys.InngestLogLevel]);\n        if (this.logLevel === \"debug\") {\n            /**\n             * `debug` is an old library; sometimes its runtime detection doesn't work\n             * for newer pairings of framework/runtime.\n             *\n             * One silly symptom of this is that `Debug()` returns an anonymous\n             * function with no extra properties instead of a `Debugger` instance if\n             * the wrong code is consumed following a bad detection. This results in\n             * the following `.enable()` call failing, so we just try carefully to\n             * enable it here.\n             */\n            if (debug_1.default.enable && typeof debug_1.default.enable === \"function\") {\n                debug_1.default.enable(`${consts_js_1.debugPrefix}:*`);\n            }\n        }\n        const defaultStreamingOption = false;\n        this.streaming = zod_1.z\n            .union([zod_1.z.enum([\"allow\", \"force\"]), zod_1.z.literal(false)])\n            .default(defaultStreamingOption)\n            .catch((ctx) => {\n            this.log(\"warn\", `Unknown streaming option passed: ${String(ctx.input)}; defaulting to ${String(defaultStreamingOption)}`);\n            return defaultStreamingOption;\n        })\n            .parse(options.streaming || this.env[consts_js_1.envKeys.InngestStreaming]);\n        this.fetch = options.fetch ? (0, env_js_1.getFetch)(options.fetch) : this.client[\"fetch\"];\n    }\n    /**\n     * Get the API base URL for the Inngest API.\n     *\n     * This is a getter to encourage checking the environment for the API base URL\n     * each time it's accessed, as it may change during execution.\n     */\n    get apiBaseUrl() {\n        return (this._options.baseUrl ||\n            this.env[consts_js_1.envKeys.InngestApiBaseUrl] ||\n            this.env[consts_js_1.envKeys.InngestBaseUrl] ||\n            this.client.apiBaseUrl ||\n            consts_js_1.defaultInngestApiBaseUrl);\n    }\n    /**\n     * Get the event API base URL for the Inngest API.\n     *\n     * This is a getter to encourage checking the environment for the event API\n     * base URL each time it's accessed, as it may change during execution.\n     */\n    get eventApiBaseUrl() {\n        return (this._options.baseUrl ||\n            this.env[consts_js_1.envKeys.InngestEventApiBaseUrl] ||\n            this.env[consts_js_1.envKeys.InngestBaseUrl] ||\n            this.client.eventBaseUrl ||\n            consts_js_1.defaultInngestEventBaseUrl);\n    }\n    /**\n     * The host used to access the Inngest serve endpoint, e.g.:\n     *\n     *     \"https://myapp.com\"\n     *\n     * By default, the library will try to infer this using request details such\n     * as the \"Host\" header and request path, but sometimes this isn't possible\n     * (e.g. when running in a more controlled environments such as AWS Lambda or\n     * when dealing with proxies/redirects).\n     *\n     * Provide the custom hostname here to ensure that the path is reported\n     * correctly when registering functions with Inngest.\n     *\n     * To also provide a custom path, use `servePath`.\n     */\n    get serveHost() {\n        return this._serveHost || this.env[consts_js_1.envKeys.InngestServeHost];\n    }\n    /**\n     * The path to the Inngest serve endpoint. e.g.:\n     *\n     *     \"/some/long/path/to/inngest/endpoint\"\n     *\n     * By default, the library will try to infer this using request details such\n     * as the \"Host\" header and request path, but sometimes this isn't possible\n     * (e.g. when running in a more controlled environments such as AWS Lambda or\n     * when dealing with proxies/redirects).\n     *\n     * Provide the custom path (excluding the hostname) here to ensure that the\n     * path is reported correctly when registering functions with Inngest.\n     *\n     * To also provide a custom hostname, use `serveHost`.\n     *\n     * This is a getter to encourage checking the environment for the serve path\n     * each time it's accessed, as it may change during execution.\n     */\n    get servePath() {\n        return this._servePath || this.env[consts_js_1.envKeys.InngestServePath];\n    }\n    get hashedEventKey() {\n        if (!this.client[\"eventKey\"] || this.client[\"eventKey\"] === consts_js_1.dummyEventKey) {\n            return undefined;\n        }\n        return (0, strings_js_1.hashEventKey)(this.client[\"eventKey\"]);\n    }\n    // hashedSigningKey creates a sha256 checksum of the signing key with the\n    // same signing key prefix.\n    get hashedSigningKey() {\n        if (!this.signingKey) {\n            return undefined;\n        }\n        return (0, strings_js_1.hashSigningKey)(this.signingKey);\n    }\n    get hashedSigningKeyFallback() {\n        if (!this.signingKeyFallback) {\n            return undefined;\n        }\n        return (0, strings_js_1.hashSigningKey)(this.signingKeyFallback);\n    }\n    /**\n     * Returns a `boolean` representing whether this handler will stream responses\n     * or not. Takes into account the user's preference and the platform's\n     * capabilities.\n     */\n    async shouldStream(actions) {\n        const rawProbe = await actions.queryStringWithDefaults(\"testing for probe\", consts_js_1.queryKeys.Probe);\n        if (rawProbe !== undefined) {\n            return false;\n        }\n        // We must be able to stream responses to continue.\n        if (!actions.transformStreamingResponse) {\n            return false;\n        }\n        // If the user has forced streaming, we should always stream.\n        if (this.streaming === \"force\") {\n            return true;\n        }\n        // If the user has allowed streaming, we should stream if the platform\n        // supports it.\n        return (this.streaming === \"allow\" &&\n            (0, env_js_1.platformSupportsStreaming)(this.frameworkName, this.env));\n    }\n    /**\n     * `createHandler` should be used to return a type-equivalent version of the\n     * `handler` specified during instantiation.\n     *\n     * @example\n     * ```\n     * // my-custom-handler.ts\n     * import {\n     *   InngestCommHandler,\n     *   type ServeHandlerOptions,\n     * } from \"./components/InngestCommHandler\";\n     *\n     * export const serve = (options: ServeHandlerOptions) => {\n     *   const handler = new InngestCommHandler({\n     *     frameworkName: \"my-custom-handler\",\n     *     ...options,\n     *     handler: (req: Request) => {\n     *       return {\n     *         body: () => req.json(),\n     *         headers: (key) => req.headers.get(key),\n     *         method: () => req.method,\n     *         url: () => new URL(req.url, `https://${req.headers.get(\"host\") || \"\"}`),\n     *         transformResponse: ({ body, status, headers }) => {\n     *           return new Response(body, { status, headers });\n     *         },\n     *       };\n     *     },\n     *   });\n     *\n     *   return handler.createHandler();\n     * };\n     * ```\n     */\n    createHandler() {\n        const handler = async (...args) => {\n            var _a, _b;\n            const timer = new ServerTiming_js_1.ServerTiming();\n            /**\n             * Used for testing, allow setting action overrides externally when\n             * calling the handler. Always search the final argument.\n             */\n            const lastArg = args[args.length - 1];\n            const actionOverrides = typeof lastArg === \"object\" &&\n                lastArg !== null &&\n                \"actionOverrides\" in lastArg &&\n                typeof lastArg[\"actionOverrides\"] === \"object\" &&\n                lastArg[\"actionOverrides\"] !== null\n                ? lastArg[\"actionOverrides\"]\n                : {};\n            /**\n             * We purposefully `await` the handler, as it could be either sync or\n             * async.\n             */\n            const rawActions = Object.assign(Object.assign({}, (await timer\n                .wrap(\"handler\", () => this.handler(...args))\n                .catch((0, errors_js_1.rethrowError)(\"Serve handler failed to run\")))), actionOverrides);\n            /**\n             * Map over every `action` in `rawActions` and create a new `actions`\n             * object where each function is safely promisified with each access\n             * requiring a reason.\n             *\n             * This helps us provide high quality errors about what's going wrong for\n             * each access without having to wrap every access in a try/catch.\n             */\n            const promisifiedActions = Object.entries(rawActions).reduce((acc, [key, value]) => {\n                if (typeof value !== \"function\") {\n                    return acc;\n                }\n                return Object.assign(Object.assign({}, acc), { [key]: (reason, ...args) => {\n                        const errMessage = [\n                            `Failed calling \\`${key}\\` from serve handler`,\n                            reason,\n                        ]\n                            .filter(Boolean)\n                            .join(\" when \");\n                        const fn = () => value(...args);\n                        return (0, promises_js_1.runAsPromise)(fn)\n                            .catch((0, errors_js_1.rethrowError)(errMessage))\n                            .catch((err) => {\n                            this.log(\"error\", err);\n                            throw err;\n                        });\n                    } });\n            }, {});\n            /**\n             * Mapped promisified handlers from userland `serve()` function mixed in\n             * with some helpers.\n             */\n            const actions = Object.assign(Object.assign(Object.assign({}, promisifiedActions), { queryStringWithDefaults: async (reason, key) => {\n                    var _a;\n                    const url = await actions.url(reason);\n                    const ret = (await ((_a = actions.queryString) === null || _a === void 0 ? void 0 : _a.call(actions, reason, key, url))) ||\n                        url.searchParams.get(key) ||\n                        undefined;\n                    return ret;\n                } }), actionOverrides);\n            const [env, expectedServerKind] = await Promise.all([\n                (_a = actions.env) === null || _a === void 0 ? void 0 : _a.call(actions, \"starting to handle request\"),\n                actions.headers(\"checking expected server kind\", consts_js_1.headerKeys.InngestServerKind),\n            ]);\n            // Always make sure to merge whatever env we've been given with\n            // `process.env`; some platforms may not provide all the necessary\n            // environment variables or may use two sources.\n            this.env = Object.assign(Object.assign({}, (0, env_js_1.allProcessEnv)()), env);\n            const getInngestHeaders = () => (0, env_js_1.inngestHeaders)({\n                env: this.env,\n                framework: this.frameworkName,\n                client: this.client,\n                expectedServerKind: expectedServerKind || undefined,\n                extras: {\n                    \"Server-Timing\": timer.getHeader(),\n                },\n            });\n            const assumedMode = (0, env_js_1.getMode)({ env: this.env, client: this.client });\n            if (assumedMode.isExplicit) {\n                this._mode = assumedMode;\n            }\n            else {\n                const serveIsProd = await ((_b = actions.isProduction) === null || _b === void 0 ? void 0 : _b.call(actions, \"starting to handle request\"));\n                if (typeof serveIsProd === \"boolean\") {\n                    this._mode = new env_js_1.Mode({\n                        type: serveIsProd ? \"cloud\" : \"dev\",\n                        isExplicit: false,\n                    });\n                }\n                else {\n                    this._mode = assumedMode;\n                }\n            }\n            this.upsertKeysFromEnv();\n            const methodP = actions.method(\"starting to handle request\");\n            const headerPromises = [\n                consts_js_1.headerKeys.TraceParent,\n                consts_js_1.headerKeys.TraceState,\n            ].map(async (header) => {\n                const value = await actions.headers(`fetching ${header} for forwarding`, header);\n                return { header, value };\n            });\n            const contentLength = await actions\n                .headers(\"checking signature for request\", consts_js_1.headerKeys.ContentLength)\n                .then((value) => {\n                if (!value) {\n                    return undefined;\n                }\n                return parseInt(value, 10);\n            });\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            const [signature, method, body] = await Promise.all([\n                actions\n                    .headers(\"checking signature for request\", consts_js_1.headerKeys.Signature)\n                    .then((headerSignature) => {\n                    return headerSignature !== null && headerSignature !== void 0 ? headerSignature : undefined;\n                }),\n                methodP,\n                methodP.then((method) => {\n                    if (method === \"POST\" || method === \"PUT\") {\n                        if (!contentLength) {\n                            // Return empty string because req.json() will throw an error.\n                            return \"\";\n                        }\n                        return actions.body(`checking body for request signing as method is ${method}`);\n                    }\n                    return \"\";\n                }),\n            ]);\n            const signatureValidation = this.validateSignature(signature, body);\n            const headersToForwardP = Promise.all(headerPromises).then((fetchedHeaders) => {\n                return fetchedHeaders.reduce((acc, { header, value }) => {\n                    if (value) {\n                        acc[header] = value;\n                    }\n                    return acc;\n                }, {});\n            });\n            const actionRes = timer.wrap(\"action\", () => this.handleAction({\n                actions,\n                timer,\n                getInngestHeaders,\n                reqArgs: args,\n                signatureValidation,\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                body,\n                method,\n                headers: headersToForwardP,\n            }));\n            /**\n             * Prepares an action response by merging returned data to provide\n             * trailing information such as `Server-Timing` headers.\n             *\n             * It should always prioritize the headers returned by the action, as they\n             * may contain important information such as `Content-Type`.\n             */\n            const prepareActionRes = async (res) => {\n                var _a;\n                const headers = Object.assign(Object.assign(Object.assign(Object.assign({}, getInngestHeaders()), (await headersToForwardP)), res.headers), (res.version === null\n                    ? {}\n                    : {\n                        [consts_js_1.headerKeys.RequestVersion]: ((_a = res.version) !== null && _a !== void 0 ? _a : InngestExecution_js_1.PREFERRED_EXECUTION_VERSION).toString(),\n                    }));\n                let signature;\n                try {\n                    signature = await signatureValidation.then((result) => {\n                        if (!result.success || !result.keyUsed) {\n                            return undefined;\n                        }\n                        return this.getResponseSignature(result.keyUsed, res.body);\n                    });\n                }\n                catch (err) {\n                    // If we fail to sign, retun a 500 with the error.\n                    return Object.assign(Object.assign({}, res), { headers, body: (0, strings_js_1.stringify)((0, errors_js_1.serializeError)(err)), status: 500 });\n                }\n                if (signature) {\n                    headers[consts_js_1.headerKeys.Signature] = signature;\n                }\n                return Object.assign(Object.assign({}, res), { headers });\n            };\n            if (await this.shouldStream(actions)) {\n                const method = await actions.method(\"starting streaming response\");\n                if (method === \"POST\") {\n                    const { stream, finalize } = await (0, stream_js_1.createStream)();\n                    /**\n                     * Errors are handled by `handleAction` here to ensure that an\n                     * appropriate response is always given.\n                     */\n                    void actionRes.then((res) => {\n                        return finalize(prepareActionRes(res));\n                    });\n                    return timer.wrap(\"res\", () => {\n                        var _a;\n                        return (_a = actions.transformStreamingResponse) === null || _a === void 0 ? void 0 : _a.call(actions, \"starting streaming response\", {\n                            status: 201,\n                            headers: getInngestHeaders(),\n                            body: stream,\n                            version: null,\n                        });\n                    });\n                }\n            }\n            return timer.wrap(\"res\", async () => {\n                return actionRes.then(prepareActionRes).then((actionRes) => {\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                    return actions.transformResponse(\"sending back response\", actionRes);\n                });\n            });\n        };\n        /**\n         * Some platforms check (at runtime) the length of the function being used\n         * to handle an endpoint. If this is a variadic function, it will fail that\n         * check.\n         *\n         * Therefore, we expect the arguments accepted to be the same length as the\n         * `handler` function passed internally.\n         *\n         * We also set a name to avoid a common useless name in tracing such as\n         * `\"anonymous\"` or `\"bound function\"`.\n         *\n         * https://github.com/getsentry/sentry-javascript/issues/3284\n         */\n        Object.defineProperties(handler, {\n            name: {\n                value: \"InngestHandler\",\n            },\n            length: {\n                value: this.handler.length,\n            },\n        });\n        return handler;\n    }\n    get mode() {\n        return this._mode;\n    }\n    set mode(m) {\n        this._mode = m;\n        if (m) {\n            this.client[\"mode\"] = m;\n        }\n    }\n    /**\n     * Given a set of functions to check if an action is available from the\n     * instance's handler, enact any action that is found.\n     *\n     * This method can fetch varying payloads of data, but ultimately is the place\n     * where _decisions_ are made regarding functionality.\n     *\n     * For example, if we find that we should be viewing the UI, this function\n     * will decide whether the UI should be visible based on the payload it has\n     * found (e.g. env vars, options, etc).\n     */\n    async handleAction({ actions, timer, getInngestHeaders, reqArgs, signatureValidation, body, method, headers, }) {\n        var _a;\n        // This is when the request body is completely missing; it does not\n        // include an empty body. This commonly happens when the HTTP framework\n        // doesn't have body parsing middleware.\n        const isMissingBody = body === undefined;\n        try {\n            let url = await actions.url(\"starting to handle request\");\n            if (method === \"POST\") {\n                if (isMissingBody) {\n                    this.log(\"error\", \"Missing body when executing, possibly due to missing request body middleware\");\n                    return {\n                        status: 500,\n                        headers: {\n                            \"Content-Type\": \"application/json\",\n                        },\n                        body: (0, strings_js_1.stringify)((0, errors_js_1.serializeError)(new Error(\"Missing request body when executing, possibly due to missing request body middleware\"))),\n                        version: undefined,\n                    };\n                }\n                const validationResult = await signatureValidation;\n                if (!validationResult.success) {\n                    return {\n                        status: 401,\n                        headers: {\n                            \"Content-Type\": \"application/json\",\n                        },\n                        body: (0, strings_js_1.stringify)((0, errors_js_1.serializeError)(validationResult.err)),\n                        version: undefined,\n                    };\n                }\n                const rawProbe = await actions.queryStringWithDefaults(\"testing for probe\", consts_js_1.queryKeys.Probe);\n                if (rawProbe) {\n                    const probe = (0, enum_js_1.enumFromValue)(consts_js_1.probe, rawProbe);\n                    if (!probe) {\n                        // If we're here, we've received a probe that we don't recognize.\n                        // Fail.\n                        return {\n                            status: 400,\n                            headers: {\n                                \"Content-Type\": \"application/json\",\n                            },\n                            body: (0, strings_js_1.stringify)((0, errors_js_1.serializeError)(new Error(`Unknown probe \"${rawProbe}\"`))),\n                            version: undefined,\n                        };\n                    }\n                    // Provide actions for every probe available.\n                    const probeActions = {\n                        [consts_js_1.probe.Trust]: () => ({\n                            status: 200,\n                            headers: {\n                                \"Content-Type\": \"application/json\",\n                            },\n                            body: \"\",\n                            version: undefined,\n                        }),\n                    };\n                    return probeActions[probe]();\n                }\n                const fnId = await actions.queryStringWithDefaults(\"processing run request\", consts_js_1.queryKeys.FnId);\n                if (!fnId) {\n                    // TODO PrettyError\n                    throw new Error(\"No function ID found in request\");\n                }\n                const stepId = (await actions.queryStringWithDefaults(\"processing run request\", consts_js_1.queryKeys.StepId)) || null;\n                const { version, result } = this.runStep({\n                    functionId: fnId,\n                    data: body,\n                    stepId,\n                    timer,\n                    reqArgs,\n                    headers: await headers,\n                });\n                const stepOutput = await result;\n                /**\n                 * Functions can return `undefined`, but we'll always convert this to\n                 * `null`, as this is appropriately serializable by JSON.\n                 */\n                const opDataUndefinedToNull = (op) => {\n                    op.data = (0, functions_js_1.undefinedToNull)(op.data);\n                    return op;\n                };\n                const resultHandlers = {\n                    \"function-rejected\": (result) => {\n                        return {\n                            status: result.retriable ? 500 : 400,\n                            headers: Object.assign({ \"Content-Type\": \"application/json\", [consts_js_1.headerKeys.NoRetry]: result.retriable ? \"false\" : \"true\" }, (typeof result.retriable === \"string\"\n                                ? { [consts_js_1.headerKeys.RetryAfter]: result.retriable }\n                                : {})),\n                            body: (0, strings_js_1.stringify)((0, functions_js_1.undefinedToNull)(result.error)),\n                            version,\n                        };\n                    },\n                    \"function-resolved\": (result) => {\n                        return {\n                            status: 200,\n                            headers: {\n                                \"Content-Type\": \"application/json\",\n                            },\n                            body: (0, strings_js_1.stringify)((0, functions_js_1.undefinedToNull)(result.data)),\n                            version,\n                        };\n                    },\n                    \"step-not-found\": (result) => {\n                        return {\n                            status: 500,\n                            headers: {\n                                \"Content-Type\": \"application/json\",\n                                [consts_js_1.headerKeys.NoRetry]: \"false\",\n                            },\n                            body: (0, strings_js_1.stringify)({\n                                error: `Could not find step \"${result.step.displayName || result.step.id}\" to run; timed out`,\n                            }),\n                            version,\n                        };\n                    },\n                    \"step-ran\": (result) => {\n                        const step = opDataUndefinedToNull(result.step);\n                        return {\n                            status: 206,\n                            headers: Object.assign({ \"Content-Type\": \"application/json\" }, (typeof result.retriable !== \"undefined\"\n                                ? Object.assign({ [consts_js_1.headerKeys.NoRetry]: result.retriable ? \"false\" : \"true\" }, (typeof result.retriable === \"string\"\n                                    ? { [consts_js_1.headerKeys.RetryAfter]: result.retriable }\n                                    : {})) : {})),\n                            body: (0, strings_js_1.stringify)([step]),\n                            version,\n                        };\n                    },\n                    \"steps-found\": (result) => {\n                        const steps = result.steps.map(opDataUndefinedToNull);\n                        return {\n                            status: 206,\n                            headers: {\n                                \"Content-Type\": \"application/json\",\n                            },\n                            body: (0, strings_js_1.stringify)(steps),\n                            version,\n                        };\n                    },\n                };\n                const handler = resultHandlers[stepOutput.type];\n                try {\n                    return await handler(stepOutput);\n                }\n                catch (err) {\n                    this.log(\"error\", \"Error handling execution result\", err);\n                    throw err;\n                }\n            }\n            // TODO: This feels hacky, so we should probably make it not hacky.\n            const env = (_a = getInngestHeaders()[consts_js_1.headerKeys.Environment]) !== null && _a !== void 0 ? _a : null;\n            if (method === \"GET\") {\n                return {\n                    status: 200,\n                    body: (0, strings_js_1.stringify)(await this.introspectionBody({\n                        actions,\n                        env,\n                        signatureValidation,\n                        url,\n                    })),\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                    },\n                    version: undefined,\n                };\n            }\n            if (method === \"PUT\") {\n                const [deployId, inBandSyncRequested] = await Promise.all([\n                    actions\n                        .queryStringWithDefaults(\"processing deployment request\", consts_js_1.queryKeys.DeployId)\n                        .then((deployId) => {\n                        return deployId === \"undefined\" ? undefined : deployId;\n                    }),\n                    Promise.resolve((0, env_js_1.parseAsBoolean)(this.env[consts_js_1.envKeys.InngestAllowInBandSync]))\n                        .then((allowInBandSync) => {\n                        if (allowInBandSync !== undefined && !allowInBandSync) {\n                            return consts_js_1.syncKind.OutOfBand;\n                        }\n                        return actions.headers(\"processing deployment request\", consts_js_1.headerKeys.InngestSyncKind);\n                    })\n                        .then((kind) => {\n                        return kind === consts_js_1.syncKind.InBand;\n                    }),\n                ]);\n                if (inBandSyncRequested) {\n                    if (isMissingBody) {\n                        this.log(\"error\", \"Missing body when syncing, possibly due to missing request body middleware\");\n                        return {\n                            status: 500,\n                            headers: {\n                                \"Content-Type\": \"application/json\",\n                            },\n                            body: (0, strings_js_1.stringify)((0, errors_js_1.serializeError)(new Error(\"Missing request body when syncing, possibly due to missing request body middleware\"))),\n                            version: undefined,\n                        };\n                    }\n                    // Validation can be successful if we're in dev mode and did not\n                    // actually validate a key. In this case, also check that we did indeed\n                    // use a particular key to validate.\n                    const sigCheck = await signatureValidation;\n                    if (!sigCheck.success) {\n                        return {\n                            status: 401,\n                            body: (0, strings_js_1.stringify)({\n                                code: \"sig_verification_failed\",\n                            }),\n                            headers: {\n                                \"Content-Type\": \"application/json\",\n                            },\n                            version: undefined,\n                        };\n                    }\n                    const res = types_js_1.inBandSyncRequestBodySchema.safeParse(body);\n                    if (!res.success) {\n                        return {\n                            status: 400,\n                            body: (0, strings_js_1.stringify)({\n                                code: \"invalid_request\",\n                                message: res.error.message,\n                            }),\n                            headers: {\n                                \"Content-Type\": \"application/json\",\n                            },\n                            version: undefined,\n                        };\n                    }\n                    // We can trust the URL here because it's coming from\n                    // signature-verified request.\n                    url = this.reqUrl(new URL(res.data.url));\n                    // This should be an in-band sync\n                    const respBody = await this.inBandRegisterBody({\n                        actions,\n                        deployId,\n                        env,\n                        signatureValidation,\n                        url,\n                    });\n                    return {\n                        status: 200,\n                        body: (0, strings_js_1.stringify)(respBody),\n                        headers: {\n                            \"Content-Type\": \"application/json\",\n                            [consts_js_1.headerKeys.InngestSyncKind]: consts_js_1.syncKind.InBand,\n                        },\n                        version: undefined,\n                    };\n                }\n                // If we're here, this is a legacy out-of-band sync\n                const { status, message, modified } = await this.register(this.reqUrl(url), deployId, getInngestHeaders);\n                return {\n                    status,\n                    body: (0, strings_js_1.stringify)({ message, modified }),\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        [consts_js_1.headerKeys.InngestSyncKind]: consts_js_1.syncKind.OutOfBand,\n                    },\n                    version: undefined,\n                };\n            }\n        }\n        catch (err) {\n            return {\n                status: 500,\n                body: (0, strings_js_1.stringify)(Object.assign({ type: \"internal\" }, (0, errors_js_1.serializeError)(err))),\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                },\n                version: undefined,\n            };\n        }\n        return {\n            status: 405,\n            body: JSON.stringify({\n                message: \"No action found; request was likely not POST, PUT, or GET\",\n                mode: this._mode,\n            }),\n            headers: {},\n            version: undefined,\n        };\n    }\n    runStep({ functionId, stepId, data, timer, reqArgs, headers, }) {\n        var _a, _b;\n        const fn = this.fns[functionId];\n        if (!fn) {\n            // TODO PrettyError\n            throw new Error(`Could not find function with ID \"${functionId}\"`);\n        }\n        const immediateFnData = (0, functions_js_1.parseFnData)(data);\n        let { version } = immediateFnData;\n        // Handle opting in to optimized parallelism in v3.\n        if (version === InngestExecution_js_1.ExecutionVersion.V1 &&\n            ((_b = (_a = fn.fn)[\"shouldOptimizeParallelism\"]) === null || _b === void 0 ? void 0 : _b.call(_a))) {\n            version = InngestExecution_js_1.ExecutionVersion.V2;\n        }\n        const result = (0, promises_js_1.runAsPromise)(async () => {\n            const anyFnData = await (0, functions_js_1.fetchAllFnData)({\n                data: immediateFnData,\n                api: this.client[\"inngestApi\"],\n                version,\n            });\n            if (!anyFnData.ok) {\n                throw new Error(anyFnData.error);\n            }\n            const executionStarters = ((s) => s)({\n                [InngestExecution_js_1.ExecutionVersion.V0]: ({ event, events, steps, ctx, version }) => {\n                    var _a, _b, _c;\n                    const stepState = Object.entries(steps !== null && steps !== void 0 ? steps : {}).reduce((acc, [id, data]) => {\n                        return Object.assign(Object.assign({}, acc), { \n                            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                            [id]: { id, data } });\n                    }, {});\n                    return {\n                        version,\n                        partialOptions: {\n                            client: this.client,\n                            runId: (ctx === null || ctx === void 0 ? void 0 : ctx.run_id) || \"\",\n                            data: {\n                                event: event,\n                                events: events,\n                                runId: (ctx === null || ctx === void 0 ? void 0 : ctx.run_id) || \"\",\n                                attempt: (_a = ctx === null || ctx === void 0 ? void 0 : ctx.attempt) !== null && _a !== void 0 ? _a : 0,\n                            },\n                            stepState,\n                            requestedRunStep: stepId === \"step\" ? undefined : stepId || undefined,\n                            timer,\n                            isFailureHandler: fn.onFailure,\n                            stepCompletionOrder: (_c = (_b = ctx === null || ctx === void 0 ? void 0 : ctx.stack) === null || _b === void 0 ? void 0 : _b.stack) !== null && _c !== void 0 ? _c : [],\n                            reqArgs,\n                            headers,\n                        },\n                    };\n                },\n                [InngestExecution_js_1.ExecutionVersion.V1]: ({ event, events, steps, ctx, version }) => {\n                    var _a, _b, _c;\n                    const stepState = Object.entries(steps !== null && steps !== void 0 ? steps : {}).reduce((acc, [id, result]) => {\n                        return Object.assign(Object.assign({}, acc), { [id]: result.type === \"data\"\n                                ? // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                                    { id, data: result.data }\n                                : result.type === \"input\"\n                                    ? // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                                        { id, input: result.input }\n                                    : { id, error: result.error } });\n                    }, {});\n                    return {\n                        version,\n                        partialOptions: {\n                            client: this.client,\n                            runId: (ctx === null || ctx === void 0 ? void 0 : ctx.run_id) || \"\",\n                            data: {\n                                event: event,\n                                events: events,\n                                runId: (ctx === null || ctx === void 0 ? void 0 : ctx.run_id) || \"\",\n                                attempt: (_a = ctx === null || ctx === void 0 ? void 0 : ctx.attempt) !== null && _a !== void 0 ? _a : 0,\n                            },\n                            stepState,\n                            requestedRunStep: stepId === \"step\" ? undefined : stepId || undefined,\n                            timer,\n                            isFailureHandler: fn.onFailure,\n                            disableImmediateExecution: ctx === null || ctx === void 0 ? void 0 : ctx.disable_immediate_execution,\n                            stepCompletionOrder: (_c = (_b = ctx === null || ctx === void 0 ? void 0 : ctx.stack) === null || _b === void 0 ? void 0 : _b.stack) !== null && _c !== void 0 ? _c : [],\n                            reqArgs,\n                            headers,\n                        },\n                    };\n                },\n                [InngestExecution_js_1.ExecutionVersion.V2]: ({ event, events, steps, ctx, version }) => {\n                    var _a, _b, _c;\n                    const stepState = Object.entries(steps !== null && steps !== void 0 ? steps : {}).reduce((acc, [id, result]) => {\n                        return Object.assign(Object.assign({}, acc), { [id]: result.type === \"data\"\n                                ? // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                                    { id, data: result.data }\n                                : result.type === \"input\"\n                                    ? // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                                        { id, input: result.input }\n                                    : { id, error: result.error } });\n                    }, {});\n                    return {\n                        version,\n                        partialOptions: {\n                            client: this.client,\n                            runId: (ctx === null || ctx === void 0 ? void 0 : ctx.run_id) || \"\",\n                            data: {\n                                event: event,\n                                events: events,\n                                runId: (ctx === null || ctx === void 0 ? void 0 : ctx.run_id) || \"\",\n                                attempt: (_a = ctx === null || ctx === void 0 ? void 0 : ctx.attempt) !== null && _a !== void 0 ? _a : 0,\n                            },\n                            stepState,\n                            requestedRunStep: stepId === \"step\" ? undefined : stepId || undefined,\n                            timer,\n                            isFailureHandler: fn.onFailure,\n                            disableImmediateExecution: ctx === null || ctx === void 0 ? void 0 : ctx.disable_immediate_execution,\n                            stepCompletionOrder: (_c = (_b = ctx === null || ctx === void 0 ? void 0 : ctx.stack) === null || _b === void 0 ? void 0 : _b.stack) !== null && _c !== void 0 ? _c : [],\n                            reqArgs,\n                            headers,\n                        },\n                    };\n                },\n            });\n            const executionOptions = await executionStarters[version](anyFnData.value);\n            return fn.fn[\"createExecution\"](executionOptions).start();\n        });\n        return { version, result };\n    }\n    configs(url) {\n        const configs = Object.values(this.rawFns).reduce((acc, fn) => [\n            ...acc,\n            ...fn[\"getConfig\"]({ baseUrl: url, appPrefix: this.id }),\n        ], []);\n        for (const config of configs) {\n            const check = types_js_1.functionConfigSchema.safeParse(config);\n            if (!check.success) {\n                const errors = check.error.errors.map((err) => err.message).join(\"; \");\n                this.log(\"warn\", `Config invalid for function \"${config.id}\" : ${errors}`);\n            }\n        }\n        return configs;\n    }\n    /**\n     * Return an Inngest serve endpoint URL given a potential `path` and `host`.\n     *\n     * Will automatically use the `serveHost` and `servePath` if they have been\n     * set when registering.\n     */\n    reqUrl(url) {\n        let ret = new URL(url);\n        const serveHost = this.serveHost || this.env[consts_js_1.envKeys.InngestServeHost];\n        const servePath = this.servePath || this.env[consts_js_1.envKeys.InngestServePath];\n        if (servePath) {\n            ret.pathname = servePath;\n        }\n        if (serveHost) {\n            ret = new URL(ret.pathname + ret.search, serveHost);\n        }\n        return ret;\n    }\n    registerBody({ url, deployId, }) {\n        const body = {\n            url: url.href,\n            deployType: \"ping\",\n            framework: this.frameworkName,\n            appName: this.id,\n            functions: this.configs(url),\n            sdk: `js:v${version_js_1.version}`,\n            v: \"0.1\",\n            deployId: deployId || undefined,\n            capabilities: {\n                trust_probe: \"v1\",\n                connect: \"v1\",\n            },\n            appVersion: this.client.appVersion,\n        };\n        return body;\n    }\n    async inBandRegisterBody({ actions, deployId, env, signatureValidation, url, }) {\n        const registerBody = this.registerBody({ deployId, url });\n        const introspectionBody = await this.introspectionBody({\n            actions,\n            env,\n            signatureValidation,\n            url,\n        });\n        const body = {\n            app_id: this.id,\n            appVersion: this.client.appVersion,\n            capabilities: registerBody.capabilities,\n            env,\n            framework: registerBody.framework,\n            functions: registerBody.functions,\n            inspection: introspectionBody,\n            platform: (0, env_js_1.getPlatformName)(Object.assign(Object.assign({}, (0, env_js_1.allProcessEnv)()), this.env)),\n            sdk_author: \"inngest\",\n            sdk_language: \"\",\n            sdk_version: \"\",\n            sdk: registerBody.sdk,\n            url: registerBody.url,\n        };\n        if (introspectionBody.authentication_succeeded) {\n            body.sdk_language = introspectionBody.sdk_language;\n            body.sdk_version = introspectionBody.sdk_version;\n        }\n        return body;\n    }\n    async introspectionBody({ actions, env, signatureValidation, url, }) {\n        var _a, _b, _c, _d, _e;\n        const registerBody = this.registerBody({\n            url: this.reqUrl(url),\n            deployId: null,\n        });\n        if (!this._mode) {\n            throw new Error(\"No mode set; cannot introspect without mode\");\n        }\n        let introspection = {\n            authentication_succeeded: null,\n            extra: {\n                is_mode_explicit: this._mode.isExplicit,\n            },\n            has_event_key: this.client[\"eventKeySet\"](),\n            has_signing_key: Boolean(this.signingKey),\n            function_count: registerBody.functions.length,\n            mode: this._mode.type,\n            schema_version: \"2024-05-24\",\n        };\n        // Only allow authenticated introspection in Cloud mode, since Dev mode skips\n        // signature validation\n        if (this._mode.type === \"cloud\") {\n            try {\n                const validationResult = await signatureValidation;\n                if (!validationResult.success) {\n                    throw new Error(\"Signature validation failed\");\n                }\n                introspection = Object.assign(Object.assign({}, introspection), { authentication_succeeded: true, api_origin: this.apiBaseUrl, app_id: this.id, capabilities: {\n                        trust_probe: \"v1\",\n                        connect: \"v1\",\n                    }, env, event_api_origin: this.eventApiBaseUrl, event_key_hash: (_a = this.hashedEventKey) !== null && _a !== void 0 ? _a : null, extra: Object.assign(Object.assign({}, introspection.extra), { is_streaming: await this.shouldStream(actions) }), framework: this.frameworkName, sdk_language: \"js\", sdk_version: version_js_1.version, serve_origin: (_b = this.serveHost) !== null && _b !== void 0 ? _b : null, serve_path: (_c = this.servePath) !== null && _c !== void 0 ? _c : null, signing_key_fallback_hash: (_d = this.hashedSigningKeyFallback) !== null && _d !== void 0 ? _d : null, signing_key_hash: (_e = this.hashedSigningKey) !== null && _e !== void 0 ? _e : null });\n            }\n            catch (_f) {\n                // Swallow signature validation error since we'll just return the\n                // unauthenticated introspection\n                introspection = Object.assign(Object.assign({}, introspection), { authentication_succeeded: false });\n            }\n        }\n        return introspection;\n    }\n    async register(url, deployId, getHeaders) {\n        var _a;\n        const body = this.registerBody({ url, deployId });\n        let res;\n        // Whenever we register, we check to see if the dev server is up.  This\n        // is a noop and returns false in production. Clone the URL object to avoid\n        // mutating the property between requests.\n        let registerURL = new URL(this.inngestRegisterUrl.href);\n        const inferredDevMode = this._mode && this._mode.isInferred && this._mode.isDev;\n        if (inferredDevMode) {\n            const host = (0, env_js_1.devServerHost)(this.env);\n            const hasDevServer = await (0, devserver_js_1.devServerAvailable)(host, this.fetch);\n            if (hasDevServer) {\n                registerURL = (0, devserver_js_1.devServerUrl)(host, \"/fn/register\");\n            }\n        }\n        else if ((_a = this._mode) === null || _a === void 0 ? void 0 : _a.explicitDevUrl) {\n            registerURL = (0, devserver_js_1.devServerUrl)(this._mode.explicitDevUrl.href, \"/fn/register\");\n        }\n        if (deployId) {\n            registerURL.searchParams.set(consts_js_1.queryKeys.DeployId, deployId);\n        }\n        try {\n            res = await (0, net_js_1.fetchWithAuthFallback)({\n                authToken: this.hashedSigningKey,\n                authTokenFallback: this.hashedSigningKeyFallback,\n                fetch: this.fetch,\n                url: registerURL.href,\n                options: {\n                    method: \"POST\",\n                    body: (0, strings_js_1.stringify)(body),\n                    headers: Object.assign(Object.assign({}, getHeaders()), { [consts_js_1.headerKeys.InngestSyncKind]: consts_js_1.syncKind.OutOfBand }),\n                    redirect: \"follow\",\n                },\n            });\n        }\n        catch (err) {\n            this.log(\"error\", err);\n            return {\n                status: 500,\n                message: `Failed to register${err instanceof Error ? `; ${err.message}` : \"\"}`,\n                modified: false,\n            };\n        }\n        const raw = await res.text();\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        let data = {};\n        try {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            data = JSON.parse(raw);\n        }\n        catch (err) {\n            this.log(\"warn\", \"Couldn't unpack register response:\", err);\n            let message = \"Failed to register\";\n            if (err instanceof Error) {\n                message += `; ${err.message}`;\n            }\n            message += `; status code: ${res.status}`;\n            return {\n                status: 500,\n                message,\n                modified: false,\n            };\n        }\n        let status;\n        let error;\n        let skipped;\n        let modified;\n        try {\n            ({ status, error, skipped, modified } = registerResSchema.parse(data));\n        }\n        catch (err) {\n            this.log(\"warn\", \"Invalid register response schema:\", err);\n            let message = \"Failed to register\";\n            if (err instanceof Error) {\n                message += `; ${err.message}`;\n            }\n            message += `; status code: ${res.status}`;\n            return {\n                status: 500,\n                message,\n                modified: false,\n            };\n        }\n        // The dev server polls this endpoint to register functions every few\n        // seconds, but we only want to log that we've registered functions if\n        // the function definitions change.  Therefore, we compare the body sent\n        // during registration with the body of the current functions and refuse\n        // to register if the functions are the same.\n        if (!skipped) {\n            this.log(\"debug\", \"registered inngest functions:\", res.status, res.statusText, data);\n        }\n        return { status, message: error, modified };\n    }\n    /**\n     * Given an environment, upsert any missing keys. This is useful in\n     * situations where environment variables are passed directly to handlers or\n     * are otherwise difficult to access during initialization.\n     */\n    upsertKeysFromEnv() {\n        if (this.env[consts_js_1.envKeys.InngestSigningKey]) {\n            if (!this.signingKey) {\n                this.signingKey = String(this.env[consts_js_1.envKeys.InngestSigningKey]);\n            }\n            this.client[\"inngestApi\"].setSigningKey(this.signingKey);\n        }\n        if (this.env[consts_js_1.envKeys.InngestSigningKeyFallback]) {\n            if (!this.signingKeyFallback) {\n                this.signingKeyFallback = String(this.env[consts_js_1.envKeys.InngestSigningKeyFallback]);\n            }\n            this.client[\"inngestApi\"].setSigningKeyFallback(this.signingKeyFallback);\n        }\n        if (!this.client[\"eventKeySet\"]() && this.env[consts_js_1.envKeys.InngestEventKey]) {\n            this.client.setEventKey(String(this.env[consts_js_1.envKeys.InngestEventKey]));\n        }\n        // v2 -> v3 migration warnings\n        if (this.env[consts_js_1.envKeys.InngestDevServerUrl]) {\n            this.log(\"warn\", `Use of ${consts_js_1.envKeys.InngestDevServerUrl} has been deprecated in v3; please use ${consts_js_1.envKeys.InngestBaseUrl} instead. See https://www.inngest.com/docs/sdk/migration`);\n        }\n    }\n    /**\n     * Validate the signature of a request and return the signing key used to\n     * validate it.\n     */\n    // eslint-disable-next-line @typescript-eslint/require-await\n    async validateSignature(sig, body) {\n        try {\n            // Skip signature validation if requested (used by connect)\n            if (this.skipSignatureValidation) {\n                return { success: true, keyUsed: \"\" };\n            }\n            // Never validate signatures outside of prod. Make sure to check the mode\n            // exists here instead of using nullish coalescing to confirm that the check\n            // has been completed.\n            if (this._mode && !this._mode.isCloud) {\n                return { success: true, keyUsed: \"\" };\n            }\n            // If we're here, we're in production; lack of a signing key is an error.\n            if (!this.signingKey) {\n                // TODO PrettyError\n                throw new Error(`No signing key found in client options or ${consts_js_1.envKeys.InngestSigningKey} env var. Find your keys at https://app.inngest.com/secrets`);\n            }\n            // If we're here, we're in production; lack of a req signature is an error.\n            if (!sig) {\n                // TODO PrettyError\n                throw new Error(`No ${consts_js_1.headerKeys.Signature} provided`);\n            }\n            // Validate the signature\n            return {\n                success: true,\n                keyUsed: new RequestSignature(sig).verifySignature({\n                    body,\n                    allowExpiredSignatures: this.allowExpiredSignatures,\n                    signingKey: this.signingKey,\n                    signingKeyFallback: this.signingKeyFallback,\n                }),\n            };\n        }\n        catch (err) {\n            return { success: false, err: err };\n        }\n    }\n    getResponseSignature(key, body) {\n        const now = Date.now();\n        const mac = (0, net_js_1.signDataWithKey)(body, key, now.toString());\n        return `t=${now}&s=${mac}`;\n    }\n    /**\n     * Log to stdout/stderr if the log level is set to include the given level.\n     * The default log level is `\"info\"`.\n     *\n     * This is an abstraction over `console.log` and will try to use the correct\n     * method for the given log level.  For example, `log(\"error\", \"foo\")` will\n     * call `console.error(\"foo\")`.\n     */\n    log(level, ...args) {\n        const logLevels = [\n            \"debug\",\n            \"info\",\n            \"warn\",\n            \"error\",\n            \"fatal\",\n            \"silent\",\n        ];\n        const logLevelSetting = logLevels.indexOf(this.logLevel);\n        const currentLevel = logLevels.indexOf(level);\n        if (currentLevel >= logLevelSetting) {\n            let logger = console.log;\n            if (Object.prototype.hasOwnProperty.call(console, level)) {\n                logger = console[level];\n            }\n            logger(`${consts_js_1.logPrefix} ${level} -`, ...args);\n        }\n    }\n}\nexports.InngestCommHandler = InngestCommHandler;\nclass RequestSignature {\n    constructor(sig) {\n        _RequestSignature_instances.add(this);\n        const params = new URLSearchParams(sig);\n        this.timestamp = params.get(\"t\") || \"\";\n        this.signature = params.get(\"s\") || \"\";\n        if (!this.timestamp || !this.signature) {\n            // TODO PrettyError\n            throw new Error(`Invalid ${consts_js_1.headerKeys.Signature} provided`);\n        }\n    }\n    hasExpired(allowExpiredSignatures) {\n        if (allowExpiredSignatures) {\n            return false;\n        }\n        const delta = Date.now() - new Date(parseInt(this.timestamp) * 1000).valueOf();\n        return delta > 1000 * 60 * 5;\n    }\n    verifySignature({ body, signingKey, signingKeyFallback, allowExpiredSignatures, }) {\n        try {\n            __classPrivateFieldGet(this, _RequestSignature_instances, \"m\", _RequestSignature_verifySignature).call(this, { body, signingKey, allowExpiredSignatures });\n            return signingKey;\n        }\n        catch (err) {\n            if (!signingKeyFallback) {\n                throw err;\n            }\n            __classPrivateFieldGet(this, _RequestSignature_instances, \"m\", _RequestSignature_verifySignature).call(this, {\n                body,\n                signingKey: signingKeyFallback,\n                allowExpiredSignatures,\n            });\n            return signingKeyFallback;\n        }\n    }\n}\n_RequestSignature_instances = new WeakSet(), _RequestSignature_verifySignature = function _RequestSignature_verifySignature({ body, signingKey, allowExpiredSignatures, }) {\n    if (this.hasExpired(allowExpiredSignatures)) {\n        // TODO PrettyError\n        throw new Error(\"Signature has expired\");\n    }\n    const mac = (0, net_js_1.signDataWithKey)(body, signingKey, this.timestamp);\n    if (mac !== this.signature) {\n        // TODO PrettyError\n        throw new Error(\"Invalid signature\");\n    }\n};\n//# sourceMappingURL=InngestCommHandler.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL0lubmdlc3RDb21tSGFuZGxlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDBCQUEwQjtBQUMxQixnQ0FBZ0MsbUJBQU8sQ0FBQyxzREFBTztBQUMvQyxjQUFjLG1CQUFPLENBQUMsdUVBQUs7QUFDM0IsMEJBQTBCLG1CQUFPLENBQUMsd0ZBQTRCO0FBQzlELG9CQUFvQixtQkFBTyxDQUFDLDRFQUFzQjtBQUNsRCx1QkFBdUIsbUJBQU8sQ0FBQyxrRkFBeUI7QUFDeEQsa0JBQWtCLG1CQUFPLENBQUMsd0VBQW9CO0FBQzlDLGlCQUFpQixtQkFBTyxDQUFDLHNFQUFtQjtBQUM1QyxvQkFBb0IsbUJBQU8sQ0FBQyw0RUFBc0I7QUFDbEQsdUJBQXVCLG1CQUFPLENBQUMsa0ZBQXlCO0FBQ3hELGlCQUFpQixtQkFBTyxDQUFDLHNFQUFtQjtBQUM1QyxzQkFBc0IsbUJBQU8sQ0FBQyxnRkFBd0I7QUFDdEQsb0JBQW9CLG1CQUFPLENBQUMsNEVBQXNCO0FBQ2xELHFCQUFxQixtQkFBTyxDQUFDLDhFQUF1QjtBQUNwRCxtQkFBbUIsbUJBQU8sQ0FBQywwREFBYTtBQUN4QyxxQkFBcUIsbUJBQU8sQ0FBQyw4REFBZTtBQUM1Qyw4QkFBOEIsbUJBQU8sQ0FBQyw4R0FBaUM7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix1QkFBdUIsRUFBRSxPQUFPO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGtDQUFrQztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsK0RBQStEO0FBQ3JGO0FBQ0EsMkhBQTJILDBDQUEwQztBQUNySztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhIQUE4SCwyQ0FBMkM7QUFDeks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpdmUtdmliZS1haS1uZXh0Ly4vbm9kZV9tb2R1bGVzL2lubmdlc3QvY29tcG9uZW50cy9Jbm5nZXN0Q29tbUhhbmRsZXIuanM/NmFjYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xudmFyIF9SZXF1ZXN0U2lnbmF0dXJlX2luc3RhbmNlcywgX1JlcXVlc3RTaWduYXR1cmVfdmVyaWZ5U2lnbmF0dXJlO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Jbm5nZXN0Q29tbUhhbmRsZXIgPSB2b2lkIDA7XG5jb25zdCBkZWJ1Z18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWJ1Z1wiKSk7XG5jb25zdCB6b2RfMSA9IHJlcXVpcmUoXCJ6b2RcIik7XG5jb25zdCBTZXJ2ZXJUaW1pbmdfanNfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL1NlcnZlclRpbWluZy5qc1wiKTtcbmNvbnN0IGNvbnN0c19qc18xID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvY29uc3RzLmpzXCIpO1xuY29uc3QgZGV2c2VydmVyX2pzXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9kZXZzZXJ2ZXIuanNcIik7XG5jb25zdCBlbnVtX2pzXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9lbnVtLmpzXCIpO1xuY29uc3QgZW52X2pzXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9lbnYuanNcIik7XG5jb25zdCBlcnJvcnNfanNfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL2Vycm9ycy5qc1wiKTtcbmNvbnN0IGZ1bmN0aW9uc19qc18xID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvZnVuY3Rpb25zLmpzXCIpO1xuY29uc3QgbmV0X2pzXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9uZXQuanNcIik7XG5jb25zdCBwcm9taXNlc19qc18xID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvcHJvbWlzZXMuanNcIik7XG5jb25zdCBzdHJlYW1fanNfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL3N0cmVhbS5qc1wiKTtcbmNvbnN0IHN0cmluZ3NfanNfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL3N0cmluZ3MuanNcIik7XG5jb25zdCB0eXBlc19qc18xID0gcmVxdWlyZShcIi4uL3R5cGVzLmpzXCIpO1xuY29uc3QgdmVyc2lvbl9qc18xID0gcmVxdWlyZShcIi4uL3ZlcnNpb24uanNcIik7XG5jb25zdCBJbm5nZXN0RXhlY3V0aW9uX2pzXzEgPSByZXF1aXJlKFwiLi9leGVjdXRpb24vSW5uZ2VzdEV4ZWN1dGlvbi5qc1wiKTtcbi8qKlxuICogQSBzY2hlbWEgZm9yIHRoZSByZXNwb25zZSBmcm9tIElubmdlc3Qgd2hlbiByZWdpc3RlcmluZy5cbiAqL1xuY29uc3QgcmVnaXN0ZXJSZXNTY2hlbWEgPSB6b2RfMS56Lm9iamVjdCh7XG4gICAgc3RhdHVzOiB6b2RfMS56Lm51bWJlcigpLmRlZmF1bHQoMjAwKSxcbiAgICBza2lwcGVkOiB6b2RfMS56LmJvb2xlYW4oKS5vcHRpb25hbCgpLmRlZmF1bHQoZmFsc2UpLFxuICAgIG1vZGlmaWVkOiB6b2RfMS56LmJvb2xlYW4oKS5vcHRpb25hbCgpLmRlZmF1bHQoZmFsc2UpLFxuICAgIGVycm9yOiB6b2RfMS56LnN0cmluZygpLmRlZmF1bHQoXCJTdWNjZXNzZnVsbHkgcmVnaXN0ZXJlZFwiKSxcbn0pO1xuLyoqXG4gKiBgSW5uZ2VzdENvbW1IYW5kbGVyYCBpcyBhIGNsYXNzIGZvciBoYW5kbGluZyBpbmNvbWluZyByZXF1ZXN0cyBmcm9tIElubmdlc3QgKG9yXG4gKiBJbm5nZXN0J3MgdG9vbGluZyBzdWNoIGFzIHRoZSBkZXYgc2VydmVyIG9yIENMSSkgYW5kIHRha2luZyBhcHByb3ByaWF0ZVxuICogYWN0aW9uIGZvciBhbnkgc2VydmVkIGZ1bmN0aW9ucy5cbiAqXG4gKiBBbGwgaGFuZGxlcnMgKE5leHQuanMsIFJlZHdvb2RKUywgUmVtaXgsIERlbm8gRnJlc2gsIGV0Yy4pIGFyZSBjcmVhdGVkIHVzaW5nXG4gKiB0aGlzIGNsYXNzOyB0aGUgZXhwb3NlZCBgc2VydmVgIGZ1bmN0aW9uIHdpbGwgLSBtb3N0IGNvbW1vbmx5IC0gY3JlYXRlIGFuXG4gKiBpbnN0YW5jZSBvZiBgSW5uZ2VzdENvbW1IYW5kbGVyYCBhbmQgdGhlbiByZXR1cm4gYGluc3RhbmNlLmNyZWF0ZUhhbmRsZXIoKWAuXG4gKlxuICogU2VlIGluZGl2aWR1YWwgcGFyYW1ldGVyIGRldGFpbHMgZm9yIG1vcmUgaW5mb3JtYXRpb24sIG9yIHNlZSB0aGVcbiAqIHNvdXJjZSBjb2RlIGZvciBhbiBleGlzdGluZyBoYW5kbGVyLCBlLmcuXG4gKiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2lubmdlc3QvaW5uZ2VzdC1qcy9ibG9iL21haW4vc3JjL25leHQudHN9XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYFxuICogLy8gbXktY3VzdG9tLWhhbmRsZXIudHNcbiAqIGltcG9ydCB7XG4gKiAgIElubmdlc3RDb21tSGFuZGxlcixcbiAqICAgdHlwZSBTZXJ2ZUhhbmRsZXJPcHRpb25zLFxuICogfSBmcm9tIFwiLi9jb21wb25lbnRzL0lubmdlc3RDb21tSGFuZGxlclwiO1xuICpcbiAqIGV4cG9ydCBjb25zdCBzZXJ2ZSA9IChvcHRpb25zOiBTZXJ2ZUhhbmRsZXJPcHRpb25zKSA9PiB7XG4gKiAgIGNvbnN0IGhhbmRsZXIgPSBuZXcgSW5uZ2VzdENvbW1IYW5kbGVyKHtcbiAqICAgICBmcmFtZXdvcmtOYW1lOiBcIm15LWN1c3RvbS1oYW5kbGVyXCIsXG4gKiAgICAgLi4ub3B0aW9ucyxcbiAqICAgICBoYW5kbGVyOiAocmVxOiBSZXF1ZXN0KSA9PiB7XG4gKiAgICAgICByZXR1cm4ge1xuICogICAgICAgICBib2R5OiAoKSA9PiByZXEuanNvbigpLFxuICogICAgICAgICBoZWFkZXJzOiAoa2V5KSA9PiByZXEuaGVhZGVycy5nZXQoa2V5KSxcbiAqICAgICAgICAgbWV0aG9kOiAoKSA9PiByZXEubWV0aG9kLFxuICogICAgICAgICB1cmw6ICgpID0+IG5ldyBVUkwocmVxLnVybCwgYGh0dHBzOi8vJHtyZXEuaGVhZGVycy5nZXQoXCJob3N0XCIpIHx8IFwiXCJ9YCksXG4gKiAgICAgICAgIHRyYW5zZm9ybVJlc3BvbnNlOiAoeyBib2R5LCBzdGF0dXMsIGhlYWRlcnMgfSkgPT4ge1xuICogICAgICAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UoYm9keSwgeyBzdGF0dXMsIGhlYWRlcnMgfSk7XG4gKiAgICAgICAgIH0sXG4gKiAgICAgICB9O1xuICogICAgIH0sXG4gKiAgIH0pO1xuICpcbiAqICAgcmV0dXJuIGhhbmRsZXIuY3JlYXRlSGFuZGxlcigpO1xuICogfTtcbiAqIGBgYFxuICpcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgSW5uZ2VzdENvbW1IYW5kbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgcHJpdmF0ZSBjb2xsZWN0aW9uIG9mIGZ1bmN0aW9ucyB0aGF0IGFyZSBiZWluZyBzZXJ2ZWQuIFRoaXMgbWFwIGlzIHVzZWRcbiAgICAgICAgICogdG8gZmluZCBhbmQgcmVnaXN0ZXIgZnVuY3Rpb25zIHdoZW4gaW50ZXJhY3Rpbmcgd2l0aCBJbm5nZXN0IENsb3VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mbnMgPSB7fTtcbiAgICAgICAgdGhpcy5lbnYgPSAoMCwgZW52X2pzXzEuYWxsUHJvY2Vzc0VudikoKTtcbiAgICAgICAgLy8gU2V0IGlucHV0IG9wdGlvbnMgZGlyZWN0bHkgc28gd2UgY2FuIHJlZmVyZW5jZSB0aGVtIGxhdGVyXG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICAvKipcbiAgICAgICAgICogdjIgLT4gdjMgbWlncmF0aW9uIGVycm9yLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiBhIHNlcnZlIGhhbmRsZXIgaXMgcGFzc2VkIGEgY2xpZW50IGFzIHRoZSBmaXJzdCBhcmd1bWVudCwgaXQnbGwgYmVcbiAgICAgICAgICogc3ByZWFkIGluIHRvIHRoZXNlIG9wdGlvbnMuIFdlIHNob3VsZCBiZSBhYmxlIHRvIGRldGVjdCB0aGlzIGJ5IHBpY2tpbmdcbiAgICAgICAgICogdXAgYSB1bmlxdWUgcHJvcGVydHkgb24gdGhlIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgXCJldmVudEtleVwiKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2NvbnN0c19qc18xLmxvZ1ByZWZpeH0gWW91J3ZlIHBhc3NlZCBhbiBJbm5nZXN0IGNsaWVudCBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8geW91ciBzZXJ2ZSBoYW5kbGVyLiBUaGlzIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQgaW4gdjM7IHBsZWFzZSBwYXNzIHRoZSBJbm5nZXN0IGNsaWVudCBhcyB0aGUgXFxgY2xpZW50XFxgIHByb3BlcnR5IG9mIGFuIG9wdGlvbnMgb2JqZWN0IGluc3RlYWQuIFNlZSBodHRwczovL3d3dy5pbm5nZXN0LmNvbS9kb2NzL3Nkay9taWdyYXRpb25gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZyYW1ld29ya05hbWUgPSBvcHRpb25zLmZyYW1ld29ya05hbWU7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gb3B0aW9ucy5jbGllbnQ7XG4gICAgICAgIGlmIChvcHRpb25zLmlkKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYCR7Y29uc3RzX2pzXzEubG9nUHJlZml4fSBUaGUgXFxgaWRcXGAgc2VydmUgb3B0aW9uIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB2NGApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaWQgPSBvcHRpb25zLmlkIHx8IHRoaXMuY2xpZW50LmlkO1xuICAgICAgICB0aGlzLmhhbmRsZXIgPSBvcHRpb25zLmhhbmRsZXI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm92aWRlIGEgaGlkZGVuIG9wdGlvbiB0byBhbGxvdyBleHBpcmVkIHNpZ25hdHVyZXMgdG8gYmUgYWNjZXB0ZWQgZHVyaW5nXG4gICAgICAgICAqIHRlc3RpbmcuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFsbG93RXhwaXJlZFNpZ25hdHVyZXMgPSBCb29sZWFuKFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzLCBwcmVmZXItcmVzdC1wYXJhbXNcbiAgICAgICAgKF9hID0gYXJndW1lbnRzW1wiMFwiXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLl9fdGVzdGluZ0FsbG93RXhwaXJlZFNpZ25hdHVyZXMpO1xuICAgICAgICAvLyBFbnN1cmUgd2UgZmlsdGVyIGFueSB1bmRlZmluZWQgZnVuY3Rpb25zIGluIGNhc2Ugb2YgbWlzc2luZyBpbXBvcnRzLlxuICAgICAgICB0aGlzLnJhd0ZucyA9IG9wdGlvbnMuZnVuY3Rpb25zLmZpbHRlcihCb29sZWFuKTtcbiAgICAgICAgaWYgKHRoaXMucmF3Rm5zLmxlbmd0aCAhPT0gb3B0aW9ucy5mdW5jdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBUT0RPIFByZXR0eUVycm9yXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFNvbWUgZnVuY3Rpb25zIHBhc3NlZCB0byBzZXJ2ZSgpIGFyZSB1bmRlZmluZWQgYW5kIG1pc2NvbmZpZ3VyZWQuICBQbGVhc2UgY2hlY2sgeW91ciBpbXBvcnRzLmApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZm5zID0gdGhpcy5yYXdGbnMucmVkdWNlKChhY2MsIGZuKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb25maWdzID0gZm5bXCJnZXRDb25maWdcIl0oe1xuICAgICAgICAgICAgICAgIGJhc2VVcmw6IG5ldyBVUkwoXCJodHRwczovL2V4YW1wbGUuY29tXCIpLFxuICAgICAgICAgICAgICAgIGFwcFByZWZpeDogdGhpcy5pZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgZm5zID0gY29uZmlncy5yZWR1Y2UoKGFjYywgeyBpZCB9LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFjYyksIHsgW2lkXTogeyBmbiwgb25GYWlsdXJlOiBCb29sZWFuKGluZGV4KSB9IH0pO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICAgICAgY29uZmlncy5mb3JFYWNoKCh7IGlkIH0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYWNjW2lkXSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIFByZXR0eUVycm9yXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGZ1bmN0aW9uIElEIFwiJHtpZH1cIjsgcGxlYXNlIGNoYW5nZSBhIGZ1bmN0aW9uJ3MgbmFtZSBvciBwcm92aWRlIGFuIGV4cGxpY2l0IElEIHRvIGF2b2lkIGNvbmZsaWN0cy5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFjYyksIGZucyk7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgdGhpcy5pbm5nZXN0UmVnaXN0ZXJVcmwgPSBuZXcgVVJMKFwiL2ZuL3JlZ2lzdGVyXCIsIHRoaXMuYXBpQmFzZVVybCk7XG4gICAgICAgIHRoaXMuc2lnbmluZ0tleSA9IG9wdGlvbnMuc2lnbmluZ0tleTtcbiAgICAgICAgdGhpcy5zaWduaW5nS2V5RmFsbGJhY2sgPSBvcHRpb25zLnNpZ25pbmdLZXlGYWxsYmFjaztcbiAgICAgICAgdGhpcy5fc2VydmVIb3N0ID0gb3B0aW9ucy5zZXJ2ZUhvc3QgfHwgdGhpcy5lbnZbY29uc3RzX2pzXzEuZW52S2V5cy5Jbm5nZXN0U2VydmVIb3N0XTtcbiAgICAgICAgdGhpcy5fc2VydmVQYXRoID0gb3B0aW9ucy5zZXJ2ZVBhdGggfHwgdGhpcy5lbnZbY29uc3RzX2pzXzEuZW52S2V5cy5Jbm5nZXN0U2VydmVQYXRoXTtcbiAgICAgICAgdGhpcy5za2lwU2lnbmF0dXJlVmFsaWRhdGlvbiA9IG9wdGlvbnMuc2tpcFNpZ25hdHVyZVZhbGlkYXRpb24gfHwgZmFsc2U7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRMb2dMZXZlbCA9IFwiaW5mb1wiO1xuICAgICAgICB0aGlzLmxvZ0xldmVsID0gem9kXzEuelxuICAgICAgICAgICAgLmVudW0odHlwZXNfanNfMS5sb2dMZXZlbHMpXG4gICAgICAgICAgICAuZGVmYXVsdChkZWZhdWx0TG9nTGV2ZWwpXG4gICAgICAgICAgICAuY2F0Y2goKGN0eCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5sb2coXCJ3YXJuXCIsIGBVbmtub3duIGxvZyBsZXZlbCBwYXNzZWQ6ICR7U3RyaW5nKGN0eC5pbnB1dCl9OyBkZWZhdWx0aW5nIHRvICR7ZGVmYXVsdExvZ0xldmVsfWApO1xuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRMb2dMZXZlbDtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5wYXJzZShvcHRpb25zLmxvZ0xldmVsIHx8IHRoaXMuZW52W2NvbnN0c19qc18xLmVudktleXMuSW5uZ2VzdExvZ0xldmVsXSk7XG4gICAgICAgIGlmICh0aGlzLmxvZ0xldmVsID09PSBcImRlYnVnXCIpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogYGRlYnVnYCBpcyBhbiBvbGQgbGlicmFyeTsgc29tZXRpbWVzIGl0cyBydW50aW1lIGRldGVjdGlvbiBkb2Vzbid0IHdvcmtcbiAgICAgICAgICAgICAqIGZvciBuZXdlciBwYWlyaW5ncyBvZiBmcmFtZXdvcmsvcnVudGltZS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBPbmUgc2lsbHkgc3ltcHRvbSBvZiB0aGlzIGlzIHRoYXQgYERlYnVnKClgIHJldHVybnMgYW4gYW5vbnltb3VzXG4gICAgICAgICAgICAgKiBmdW5jdGlvbiB3aXRoIG5vIGV4dHJhIHByb3BlcnRpZXMgaW5zdGVhZCBvZiBhIGBEZWJ1Z2dlcmAgaW5zdGFuY2UgaWZcbiAgICAgICAgICAgICAqIHRoZSB3cm9uZyBjb2RlIGlzIGNvbnN1bWVkIGZvbGxvd2luZyBhIGJhZCBkZXRlY3Rpb24uIFRoaXMgcmVzdWx0cyBpblxuICAgICAgICAgICAgICogdGhlIGZvbGxvd2luZyBgLmVuYWJsZSgpYCBjYWxsIGZhaWxpbmcsIHNvIHdlIGp1c3QgdHJ5IGNhcmVmdWxseSB0b1xuICAgICAgICAgICAgICogZW5hYmxlIGl0IGhlcmUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChkZWJ1Z18xLmRlZmF1bHQuZW5hYmxlICYmIHR5cGVvZiBkZWJ1Z18xLmRlZmF1bHQuZW5hYmxlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBkZWJ1Z18xLmRlZmF1bHQuZW5hYmxlKGAke2NvbnN0c19qc18xLmRlYnVnUHJlZml4fToqYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVmYXVsdFN0cmVhbWluZ09wdGlvbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN0cmVhbWluZyA9IHpvZF8xLnpcbiAgICAgICAgICAgIC51bmlvbihbem9kXzEuei5lbnVtKFtcImFsbG93XCIsIFwiZm9yY2VcIl0pLCB6b2RfMS56LmxpdGVyYWwoZmFsc2UpXSlcbiAgICAgICAgICAgIC5kZWZhdWx0KGRlZmF1bHRTdHJlYW1pbmdPcHRpb24pXG4gICAgICAgICAgICAuY2F0Y2goKGN0eCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5sb2coXCJ3YXJuXCIsIGBVbmtub3duIHN0cmVhbWluZyBvcHRpb24gcGFzc2VkOiAke1N0cmluZyhjdHguaW5wdXQpfTsgZGVmYXVsdGluZyB0byAke1N0cmluZyhkZWZhdWx0U3RyZWFtaW5nT3B0aW9uKX1gKTtcbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0U3RyZWFtaW5nT3B0aW9uO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLnBhcnNlKG9wdGlvbnMuc3RyZWFtaW5nIHx8IHRoaXMuZW52W2NvbnN0c19qc18xLmVudktleXMuSW5uZ2VzdFN0cmVhbWluZ10pO1xuICAgICAgICB0aGlzLmZldGNoID0gb3B0aW9ucy5mZXRjaCA/ICgwLCBlbnZfanNfMS5nZXRGZXRjaCkob3B0aW9ucy5mZXRjaCkgOiB0aGlzLmNsaWVudFtcImZldGNoXCJdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIEFQSSBiYXNlIFVSTCBmb3IgdGhlIElubmdlc3QgQVBJLlxuICAgICAqXG4gICAgICogVGhpcyBpcyBhIGdldHRlciB0byBlbmNvdXJhZ2UgY2hlY2tpbmcgdGhlIGVudmlyb25tZW50IGZvciB0aGUgQVBJIGJhc2UgVVJMXG4gICAgICogZWFjaCB0aW1lIGl0J3MgYWNjZXNzZWQsIGFzIGl0IG1heSBjaGFuZ2UgZHVyaW5nIGV4ZWN1dGlvbi5cbiAgICAgKi9cbiAgICBnZXQgYXBpQmFzZVVybCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9vcHRpb25zLmJhc2VVcmwgfHxcbiAgICAgICAgICAgIHRoaXMuZW52W2NvbnN0c19qc18xLmVudktleXMuSW5uZ2VzdEFwaUJhc2VVcmxdIHx8XG4gICAgICAgICAgICB0aGlzLmVudltjb25zdHNfanNfMS5lbnZLZXlzLklubmdlc3RCYXNlVXJsXSB8fFxuICAgICAgICAgICAgdGhpcy5jbGllbnQuYXBpQmFzZVVybCB8fFxuICAgICAgICAgICAgY29uc3RzX2pzXzEuZGVmYXVsdElubmdlc3RBcGlCYXNlVXJsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBldmVudCBBUEkgYmFzZSBVUkwgZm9yIHRoZSBJbm5nZXN0IEFQSS5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgYSBnZXR0ZXIgdG8gZW5jb3VyYWdlIGNoZWNraW5nIHRoZSBlbnZpcm9ubWVudCBmb3IgdGhlIGV2ZW50IEFQSVxuICAgICAqIGJhc2UgVVJMIGVhY2ggdGltZSBpdCdzIGFjY2Vzc2VkLCBhcyBpdCBtYXkgY2hhbmdlIGR1cmluZyBleGVjdXRpb24uXG4gICAgICovXG4gICAgZ2V0IGV2ZW50QXBpQmFzZVVybCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9vcHRpb25zLmJhc2VVcmwgfHxcbiAgICAgICAgICAgIHRoaXMuZW52W2NvbnN0c19qc18xLmVudktleXMuSW5uZ2VzdEV2ZW50QXBpQmFzZVVybF0gfHxcbiAgICAgICAgICAgIHRoaXMuZW52W2NvbnN0c19qc18xLmVudktleXMuSW5uZ2VzdEJhc2VVcmxdIHx8XG4gICAgICAgICAgICB0aGlzLmNsaWVudC5ldmVudEJhc2VVcmwgfHxcbiAgICAgICAgICAgIGNvbnN0c19qc18xLmRlZmF1bHRJbm5nZXN0RXZlbnRCYXNlVXJsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGhvc3QgdXNlZCB0byBhY2Nlc3MgdGhlIElubmdlc3Qgc2VydmUgZW5kcG9pbnQsIGUuZy46XG4gICAgICpcbiAgICAgKiAgICAgXCJodHRwczovL215YXBwLmNvbVwiXG4gICAgICpcbiAgICAgKiBCeSBkZWZhdWx0LCB0aGUgbGlicmFyeSB3aWxsIHRyeSB0byBpbmZlciB0aGlzIHVzaW5nIHJlcXVlc3QgZGV0YWlscyBzdWNoXG4gICAgICogYXMgdGhlIFwiSG9zdFwiIGhlYWRlciBhbmQgcmVxdWVzdCBwYXRoLCBidXQgc29tZXRpbWVzIHRoaXMgaXNuJ3QgcG9zc2libGVcbiAgICAgKiAoZS5nLiB3aGVuIHJ1bm5pbmcgaW4gYSBtb3JlIGNvbnRyb2xsZWQgZW52aXJvbm1lbnRzIHN1Y2ggYXMgQVdTIExhbWJkYSBvclxuICAgICAqIHdoZW4gZGVhbGluZyB3aXRoIHByb3hpZXMvcmVkaXJlY3RzKS5cbiAgICAgKlxuICAgICAqIFByb3ZpZGUgdGhlIGN1c3RvbSBob3N0bmFtZSBoZXJlIHRvIGVuc3VyZSB0aGF0IHRoZSBwYXRoIGlzIHJlcG9ydGVkXG4gICAgICogY29ycmVjdGx5IHdoZW4gcmVnaXN0ZXJpbmcgZnVuY3Rpb25zIHdpdGggSW5uZ2VzdC5cbiAgICAgKlxuICAgICAqIFRvIGFsc28gcHJvdmlkZSBhIGN1c3RvbSBwYXRoLCB1c2UgYHNlcnZlUGF0aGAuXG4gICAgICovXG4gICAgZ2V0IHNlcnZlSG9zdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlcnZlSG9zdCB8fCB0aGlzLmVudltjb25zdHNfanNfMS5lbnZLZXlzLklubmdlc3RTZXJ2ZUhvc3RdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgcGF0aCB0byB0aGUgSW5uZ2VzdCBzZXJ2ZSBlbmRwb2ludC4gZS5nLjpcbiAgICAgKlxuICAgICAqICAgICBcIi9zb21lL2xvbmcvcGF0aC90by9pbm5nZXN0L2VuZHBvaW50XCJcbiAgICAgKlxuICAgICAqIEJ5IGRlZmF1bHQsIHRoZSBsaWJyYXJ5IHdpbGwgdHJ5IHRvIGluZmVyIHRoaXMgdXNpbmcgcmVxdWVzdCBkZXRhaWxzIHN1Y2hcbiAgICAgKiBhcyB0aGUgXCJIb3N0XCIgaGVhZGVyIGFuZCByZXF1ZXN0IHBhdGgsIGJ1dCBzb21ldGltZXMgdGhpcyBpc24ndCBwb3NzaWJsZVxuICAgICAqIChlLmcuIHdoZW4gcnVubmluZyBpbiBhIG1vcmUgY29udHJvbGxlZCBlbnZpcm9ubWVudHMgc3VjaCBhcyBBV1MgTGFtYmRhIG9yXG4gICAgICogd2hlbiBkZWFsaW5nIHdpdGggcHJveGllcy9yZWRpcmVjdHMpLlxuICAgICAqXG4gICAgICogUHJvdmlkZSB0aGUgY3VzdG9tIHBhdGggKGV4Y2x1ZGluZyB0aGUgaG9zdG5hbWUpIGhlcmUgdG8gZW5zdXJlIHRoYXQgdGhlXG4gICAgICogcGF0aCBpcyByZXBvcnRlZCBjb3JyZWN0bHkgd2hlbiByZWdpc3RlcmluZyBmdW5jdGlvbnMgd2l0aCBJbm5nZXN0LlxuICAgICAqXG4gICAgICogVG8gYWxzbyBwcm92aWRlIGEgY3VzdG9tIGhvc3RuYW1lLCB1c2UgYHNlcnZlSG9zdGAuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIGEgZ2V0dGVyIHRvIGVuY291cmFnZSBjaGVja2luZyB0aGUgZW52aXJvbm1lbnQgZm9yIHRoZSBzZXJ2ZSBwYXRoXG4gICAgICogZWFjaCB0aW1lIGl0J3MgYWNjZXNzZWQsIGFzIGl0IG1heSBjaGFuZ2UgZHVyaW5nIGV4ZWN1dGlvbi5cbiAgICAgKi9cbiAgICBnZXQgc2VydmVQYXRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VydmVQYXRoIHx8IHRoaXMuZW52W2NvbnN0c19qc18xLmVudktleXMuSW5uZ2VzdFNlcnZlUGF0aF07XG4gICAgfVxuICAgIGdldCBoYXNoZWRFdmVudEtleSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNsaWVudFtcImV2ZW50S2V5XCJdIHx8IHRoaXMuY2xpZW50W1wiZXZlbnRLZXlcIl0gPT09IGNvbnN0c19qc18xLmR1bW15RXZlbnRLZXkpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCBzdHJpbmdzX2pzXzEuaGFzaEV2ZW50S2V5KSh0aGlzLmNsaWVudFtcImV2ZW50S2V5XCJdKTtcbiAgICB9XG4gICAgLy8gaGFzaGVkU2lnbmluZ0tleSBjcmVhdGVzIGEgc2hhMjU2IGNoZWNrc3VtIG9mIHRoZSBzaWduaW5nIGtleSB3aXRoIHRoZVxuICAgIC8vIHNhbWUgc2lnbmluZyBrZXkgcHJlZml4LlxuICAgIGdldCBoYXNoZWRTaWduaW5nS2V5KCkge1xuICAgICAgICBpZiAoIXRoaXMuc2lnbmluZ0tleSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIHN0cmluZ3NfanNfMS5oYXNoU2lnbmluZ0tleSkodGhpcy5zaWduaW5nS2V5KTtcbiAgICB9XG4gICAgZ2V0IGhhc2hlZFNpZ25pbmdLZXlGYWxsYmFjaygpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNpZ25pbmdLZXlGYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIHN0cmluZ3NfanNfMS5oYXNoU2lnbmluZ0tleSkodGhpcy5zaWduaW5nS2V5RmFsbGJhY2spO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgYGJvb2xlYW5gIHJlcHJlc2VudGluZyB3aGV0aGVyIHRoaXMgaGFuZGxlciB3aWxsIHN0cmVhbSByZXNwb25zZXNcbiAgICAgKiBvciBub3QuIFRha2VzIGludG8gYWNjb3VudCB0aGUgdXNlcidzIHByZWZlcmVuY2UgYW5kIHRoZSBwbGF0Zm9ybSdzXG4gICAgICogY2FwYWJpbGl0aWVzLlxuICAgICAqL1xuICAgIGFzeW5jIHNob3VsZFN0cmVhbShhY3Rpb25zKSB7XG4gICAgICAgIGNvbnN0IHJhd1Byb2JlID0gYXdhaXQgYWN0aW9ucy5xdWVyeVN0cmluZ1dpdGhEZWZhdWx0cyhcInRlc3RpbmcgZm9yIHByb2JlXCIsIGNvbnN0c19qc18xLnF1ZXJ5S2V5cy5Qcm9iZSk7XG4gICAgICAgIGlmIChyYXdQcm9iZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgbXVzdCBiZSBhYmxlIHRvIHN0cmVhbSByZXNwb25zZXMgdG8gY29udGludWUuXG4gICAgICAgIGlmICghYWN0aW9ucy50cmFuc2Zvcm1TdHJlYW1pbmdSZXNwb25zZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSB1c2VyIGhhcyBmb3JjZWQgc3RyZWFtaW5nLCB3ZSBzaG91bGQgYWx3YXlzIHN0cmVhbS5cbiAgICAgICAgaWYgKHRoaXMuc3RyZWFtaW5nID09PSBcImZvcmNlXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSB1c2VyIGhhcyBhbGxvd2VkIHN0cmVhbWluZywgd2Ugc2hvdWxkIHN0cmVhbSBpZiB0aGUgcGxhdGZvcm1cbiAgICAgICAgLy8gc3VwcG9ydHMgaXQuXG4gICAgICAgIHJldHVybiAodGhpcy5zdHJlYW1pbmcgPT09IFwiYWxsb3dcIiAmJlxuICAgICAgICAgICAgKDAsIGVudl9qc18xLnBsYXRmb3JtU3VwcG9ydHNTdHJlYW1pbmcpKHRoaXMuZnJhbWV3b3JrTmFtZSwgdGhpcy5lbnYpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGNyZWF0ZUhhbmRsZXJgIHNob3VsZCBiZSB1c2VkIHRvIHJldHVybiBhIHR5cGUtZXF1aXZhbGVudCB2ZXJzaW9uIG9mIHRoZVxuICAgICAqIGBoYW5kbGVyYCBzcGVjaWZpZWQgZHVyaW5nIGluc3RhbnRpYXRpb24uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYFxuICAgICAqIC8vIG15LWN1c3RvbS1oYW5kbGVyLnRzXG4gICAgICogaW1wb3J0IHtcbiAgICAgKiAgIElubmdlc3RDb21tSGFuZGxlcixcbiAgICAgKiAgIHR5cGUgU2VydmVIYW5kbGVyT3B0aW9ucyxcbiAgICAgKiB9IGZyb20gXCIuL2NvbXBvbmVudHMvSW5uZ2VzdENvbW1IYW5kbGVyXCI7XG4gICAgICpcbiAgICAgKiBleHBvcnQgY29uc3Qgc2VydmUgPSAob3B0aW9uczogU2VydmVIYW5kbGVyT3B0aW9ucykgPT4ge1xuICAgICAqICAgY29uc3QgaGFuZGxlciA9IG5ldyBJbm5nZXN0Q29tbUhhbmRsZXIoe1xuICAgICAqICAgICBmcmFtZXdvcmtOYW1lOiBcIm15LWN1c3RvbS1oYW5kbGVyXCIsXG4gICAgICogICAgIC4uLm9wdGlvbnMsXG4gICAgICogICAgIGhhbmRsZXI6IChyZXE6IFJlcXVlc3QpID0+IHtcbiAgICAgKiAgICAgICByZXR1cm4ge1xuICAgICAqICAgICAgICAgYm9keTogKCkgPT4gcmVxLmpzb24oKSxcbiAgICAgKiAgICAgICAgIGhlYWRlcnM6IChrZXkpID0+IHJlcS5oZWFkZXJzLmdldChrZXkpLFxuICAgICAqICAgICAgICAgbWV0aG9kOiAoKSA9PiByZXEubWV0aG9kLFxuICAgICAqICAgICAgICAgdXJsOiAoKSA9PiBuZXcgVVJMKHJlcS51cmwsIGBodHRwczovLyR7cmVxLmhlYWRlcnMuZ2V0KFwiaG9zdFwiKSB8fCBcIlwifWApLFxuICAgICAqICAgICAgICAgdHJhbnNmb3JtUmVzcG9uc2U6ICh7IGJvZHksIHN0YXR1cywgaGVhZGVycyB9KSA9PiB7XG4gICAgICogICAgICAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UoYm9keSwgeyBzdGF0dXMsIGhlYWRlcnMgfSk7XG4gICAgICogICAgICAgICB9LFxuICAgICAqICAgICAgIH07XG4gICAgICogICAgIH0sXG4gICAgICogICB9KTtcbiAgICAgKlxuICAgICAqICAgcmV0dXJuIGhhbmRsZXIuY3JlYXRlSGFuZGxlcigpO1xuICAgICAqIH07XG4gICAgICogYGBgXG4gICAgICovXG4gICAgY3JlYXRlSGFuZGxlcigpIHtcbiAgICAgICAgY29uc3QgaGFuZGxlciA9IGFzeW5jICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgY29uc3QgdGltZXIgPSBuZXcgU2VydmVyVGltaW5nX2pzXzEuU2VydmVyVGltaW5nKCk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFVzZWQgZm9yIHRlc3RpbmcsIGFsbG93IHNldHRpbmcgYWN0aW9uIG92ZXJyaWRlcyBleHRlcm5hbGx5IHdoZW5cbiAgICAgICAgICAgICAqIGNhbGxpbmcgdGhlIGhhbmRsZXIuIEFsd2F5cyBzZWFyY2ggdGhlIGZpbmFsIGFyZ3VtZW50LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zdCBsYXN0QXJnID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgY29uc3QgYWN0aW9uT3ZlcnJpZGVzID0gdHlwZW9mIGxhc3RBcmcgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgICAgICBsYXN0QXJnICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgXCJhY3Rpb25PdmVycmlkZXNcIiBpbiBsYXN0QXJnICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGxhc3RBcmdbXCJhY3Rpb25PdmVycmlkZXNcIl0gPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgICAgICBsYXN0QXJnW1wiYWN0aW9uT3ZlcnJpZGVzXCJdICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBsYXN0QXJnW1wiYWN0aW9uT3ZlcnJpZGVzXCJdXG4gICAgICAgICAgICAgICAgOiB7fTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2UgcHVycG9zZWZ1bGx5IGBhd2FpdGAgdGhlIGhhbmRsZXIsIGFzIGl0IGNvdWxkIGJlIGVpdGhlciBzeW5jIG9yXG4gICAgICAgICAgICAgKiBhc3luYy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3QgcmF3QWN0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKGF3YWl0IHRpbWVyXG4gICAgICAgICAgICAgICAgLndyYXAoXCJoYW5kbGVyXCIsICgpID0+IHRoaXMuaGFuZGxlciguLi5hcmdzKSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goKDAsIGVycm9yc19qc18xLnJldGhyb3dFcnJvcikoXCJTZXJ2ZSBoYW5kbGVyIGZhaWxlZCB0byBydW5cIikpKSksIGFjdGlvbk92ZXJyaWRlcyk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE1hcCBvdmVyIGV2ZXJ5IGBhY3Rpb25gIGluIGByYXdBY3Rpb25zYCBhbmQgY3JlYXRlIGEgbmV3IGBhY3Rpb25zYFxuICAgICAgICAgICAgICogb2JqZWN0IHdoZXJlIGVhY2ggZnVuY3Rpb24gaXMgc2FmZWx5IHByb21pc2lmaWVkIHdpdGggZWFjaCBhY2Nlc3NcbiAgICAgICAgICAgICAqIHJlcXVpcmluZyBhIHJlYXNvbi5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBUaGlzIGhlbHBzIHVzIHByb3ZpZGUgaGlnaCBxdWFsaXR5IGVycm9ycyBhYm91dCB3aGF0J3MgZ29pbmcgd3JvbmcgZm9yXG4gICAgICAgICAgICAgKiBlYWNoIGFjY2VzcyB3aXRob3V0IGhhdmluZyB0byB3cmFwIGV2ZXJ5IGFjY2VzcyBpbiBhIHRyeS9jYXRjaC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzaWZpZWRBY3Rpb25zID0gT2JqZWN0LmVudHJpZXMocmF3QWN0aW9ucykucmVkdWNlKChhY2MsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhY2MpLCB7IFtrZXldOiAocmVhc29uLCAuLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJNZXNzYWdlID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBGYWlsZWQgY2FsbGluZyBcXGAke2tleX1cXGAgZnJvbSBzZXJ2ZSBoYW5kbGVyYCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihCb29sZWFuKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5qb2luKFwiIHdoZW4gXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZm4gPSAoKSA9PiB2YWx1ZSguLi5hcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgcHJvbWlzZXNfanNfMS5ydW5Bc1Byb21pc2UpKGZuKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoMCwgZXJyb3JzX2pzXzEucmV0aHJvd0Vycm9yKShlcnJNZXNzYWdlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nKFwiZXJyb3JcIiwgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSB9KTtcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTWFwcGVkIHByb21pc2lmaWVkIGhhbmRsZXJzIGZyb20gdXNlcmxhbmQgYHNlcnZlKClgIGZ1bmN0aW9uIG1peGVkIGluXG4gICAgICAgICAgICAgKiB3aXRoIHNvbWUgaGVscGVycy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3QgYWN0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwcm9taXNpZmllZEFjdGlvbnMpLCB7IHF1ZXJ5U3RyaW5nV2l0aERlZmF1bHRzOiBhc3luYyAocmVhc29uLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1cmwgPSBhd2FpdCBhY3Rpb25zLnVybChyZWFzb24pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXQgPSAoYXdhaXQgKChfYSA9IGFjdGlvbnMucXVlcnlTdHJpbmcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGFjdGlvbnMsIHJlYXNvbiwga2V5LCB1cmwpKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybC5zZWFyY2hQYXJhbXMuZ2V0KGtleSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICB9IH0pLCBhY3Rpb25PdmVycmlkZXMpO1xuICAgICAgICAgICAgY29uc3QgW2VudiwgZXhwZWN0ZWRTZXJ2ZXJLaW5kXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICAoX2EgPSBhY3Rpb25zLmVudikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoYWN0aW9ucywgXCJzdGFydGluZyB0byBoYW5kbGUgcmVxdWVzdFwiKSxcbiAgICAgICAgICAgICAgICBhY3Rpb25zLmhlYWRlcnMoXCJjaGVja2luZyBleHBlY3RlZCBzZXJ2ZXIga2luZFwiLCBjb25zdHNfanNfMS5oZWFkZXJLZXlzLklubmdlc3RTZXJ2ZXJLaW5kKSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgLy8gQWx3YXlzIG1ha2Ugc3VyZSB0byBtZXJnZSB3aGF0ZXZlciBlbnYgd2UndmUgYmVlbiBnaXZlbiB3aXRoXG4gICAgICAgICAgICAvLyBgcHJvY2Vzcy5lbnZgOyBzb21lIHBsYXRmb3JtcyBtYXkgbm90IHByb3ZpZGUgYWxsIHRoZSBuZWNlc3NhcnlcbiAgICAgICAgICAgIC8vIGVudmlyb25tZW50IHZhcmlhYmxlcyBvciBtYXkgdXNlIHR3byBzb3VyY2VzLlxuICAgICAgICAgICAgdGhpcy5lbnYgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sICgwLCBlbnZfanNfMS5hbGxQcm9jZXNzRW52KSgpKSwgZW52KTtcbiAgICAgICAgICAgIGNvbnN0IGdldElubmdlc3RIZWFkZXJzID0gKCkgPT4gKDAsIGVudl9qc18xLmlubmdlc3RIZWFkZXJzKSh7XG4gICAgICAgICAgICAgICAgZW52OiB0aGlzLmVudixcbiAgICAgICAgICAgICAgICBmcmFtZXdvcms6IHRoaXMuZnJhbWV3b3JrTmFtZSxcbiAgICAgICAgICAgICAgICBjbGllbnQ6IHRoaXMuY2xpZW50LFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkU2VydmVyS2luZDogZXhwZWN0ZWRTZXJ2ZXJLaW5kIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBleHRyYXM6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJTZXJ2ZXItVGltaW5nXCI6IHRpbWVyLmdldEhlYWRlcigpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGFzc3VtZWRNb2RlID0gKDAsIGVudl9qc18xLmdldE1vZGUpKHsgZW52OiB0aGlzLmVudiwgY2xpZW50OiB0aGlzLmNsaWVudCB9KTtcbiAgICAgICAgICAgIGlmIChhc3N1bWVkTW9kZS5pc0V4cGxpY2l0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9kZSA9IGFzc3VtZWRNb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VydmVJc1Byb2QgPSBhd2FpdCAoKF9iID0gYWN0aW9ucy5pc1Byb2R1Y3Rpb24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKGFjdGlvbnMsIFwic3RhcnRpbmcgdG8gaGFuZGxlIHJlcXVlc3RcIikpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VydmVJc1Byb2QgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21vZGUgPSBuZXcgZW52X2pzXzEuTW9kZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBzZXJ2ZUlzUHJvZCA/IFwiY2xvdWRcIiA6IFwiZGV2XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0V4cGxpY2l0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tb2RlID0gYXNzdW1lZE1vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51cHNlcnRLZXlzRnJvbUVudigpO1xuICAgICAgICAgICAgY29uc3QgbWV0aG9kUCA9IGFjdGlvbnMubWV0aG9kKFwic3RhcnRpbmcgdG8gaGFuZGxlIHJlcXVlc3RcIik7XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQcm9taXNlcyA9IFtcbiAgICAgICAgICAgICAgICBjb25zdHNfanNfMS5oZWFkZXJLZXlzLlRyYWNlUGFyZW50LFxuICAgICAgICAgICAgICAgIGNvbnN0c19qc18xLmhlYWRlcktleXMuVHJhY2VTdGF0ZSxcbiAgICAgICAgICAgIF0ubWFwKGFzeW5jIChoZWFkZXIpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGFjdGlvbnMuaGVhZGVycyhgZmV0Y2hpbmcgJHtoZWFkZXJ9IGZvciBmb3J3YXJkaW5nYCwgaGVhZGVyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBoZWFkZXIsIHZhbHVlIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRMZW5ndGggPSBhd2FpdCBhY3Rpb25zXG4gICAgICAgICAgICAgICAgLmhlYWRlcnMoXCJjaGVja2luZyBzaWduYXR1cmUgZm9yIHJlcXVlc3RcIiwgY29uc3RzX2pzXzEuaGVhZGVyS2V5cy5Db250ZW50TGVuZ3RoKVxuICAgICAgICAgICAgICAgIC50aGVuKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbiAgICAgICAgICAgIGNvbnN0IFtzaWduYXR1cmUsIG1ldGhvZCwgYm9keV0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgYWN0aW9uc1xuICAgICAgICAgICAgICAgICAgICAuaGVhZGVycyhcImNoZWNraW5nIHNpZ25hdHVyZSBmb3IgcmVxdWVzdFwiLCBjb25zdHNfanNfMS5oZWFkZXJLZXlzLlNpZ25hdHVyZSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKGhlYWRlclNpZ25hdHVyZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGVhZGVyU2lnbmF0dXJlICE9PSBudWxsICYmIGhlYWRlclNpZ25hdHVyZSAhPT0gdm9pZCAwID8gaGVhZGVyU2lnbmF0dXJlIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIG1ldGhvZFAsXG4gICAgICAgICAgICAgICAgbWV0aG9kUC50aGVuKChtZXRob2QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJQT1NUXCIgfHwgbWV0aG9kID09PSBcIlBVVFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnRlbnRMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gZW1wdHkgc3RyaW5nIGJlY2F1c2UgcmVxLmpzb24oKSB3aWxsIHRocm93IGFuIGVycm9yLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjdGlvbnMuYm9keShgY2hlY2tpbmcgYm9keSBmb3IgcmVxdWVzdCBzaWduaW5nIGFzIG1ldGhvZCBpcyAke21ldGhvZH1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgY29uc3Qgc2lnbmF0dXJlVmFsaWRhdGlvbiA9IHRoaXMudmFsaWRhdGVTaWduYXR1cmUoc2lnbmF0dXJlLCBib2R5KTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlcnNUb0ZvcndhcmRQID0gUHJvbWlzZS5hbGwoaGVhZGVyUHJvbWlzZXMpLnRoZW4oKGZldGNoZWRIZWFkZXJzKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZldGNoZWRIZWFkZXJzLnJlZHVjZSgoYWNjLCB7IGhlYWRlciwgdmFsdWUgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY1toZWFkZXJdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGFjdGlvblJlcyA9IHRpbWVyLndyYXAoXCJhY3Rpb25cIiwgKCkgPT4gdGhpcy5oYW5kbGVBY3Rpb24oe1xuICAgICAgICAgICAgICAgIGFjdGlvbnMsXG4gICAgICAgICAgICAgICAgdGltZXIsXG4gICAgICAgICAgICAgICAgZ2V0SW5uZ2VzdEhlYWRlcnMsXG4gICAgICAgICAgICAgICAgcmVxQXJnczogYXJncyxcbiAgICAgICAgICAgICAgICBzaWduYXR1cmVWYWxpZGF0aW9uLFxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbiAgICAgICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzVG9Gb3J3YXJkUCxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUHJlcGFyZXMgYW4gYWN0aW9uIHJlc3BvbnNlIGJ5IG1lcmdpbmcgcmV0dXJuZWQgZGF0YSB0byBwcm92aWRlXG4gICAgICAgICAgICAgKiB0cmFpbGluZyBpbmZvcm1hdGlvbiBzdWNoIGFzIGBTZXJ2ZXItVGltaW5nYCBoZWFkZXJzLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEl0IHNob3VsZCBhbHdheXMgcHJpb3JpdGl6ZSB0aGUgaGVhZGVycyByZXR1cm5lZCBieSB0aGUgYWN0aW9uLCBhcyB0aGV5XG4gICAgICAgICAgICAgKiBtYXkgY29udGFpbiBpbXBvcnRhbnQgaW5mb3JtYXRpb24gc3VjaCBhcyBgQ29udGVudC1UeXBlYC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3QgcHJlcGFyZUFjdGlvblJlcyA9IGFzeW5jIChyZXMpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGdldElubmdlc3RIZWFkZXJzKCkpLCAoYXdhaXQgaGVhZGVyc1RvRm9yd2FyZFApKSwgcmVzLmhlYWRlcnMpLCAocmVzLnZlcnNpb24gPT09IG51bGxcbiAgICAgICAgICAgICAgICAgICAgPyB7fVxuICAgICAgICAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFtjb25zdHNfanNfMS5oZWFkZXJLZXlzLlJlcXVlc3RWZXJzaW9uXTogKChfYSA9IHJlcy52ZXJzaW9uKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBJbm5nZXN0RXhlY3V0aW9uX2pzXzEuUFJFRkVSUkVEX0VYRUNVVElPTl9WRVJTSU9OKS50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgbGV0IHNpZ25hdHVyZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmUgPSBhd2FpdCBzaWduYXR1cmVWYWxpZGF0aW9uLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQuc3VjY2VzcyB8fCAhcmVzdWx0LmtleVVzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmVzcG9uc2VTaWduYXR1cmUocmVzdWx0LmtleVVzZWQsIHJlcy5ib2R5KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgZmFpbCB0byBzaWduLCByZXR1biBhIDUwMCB3aXRoIHRoZSBlcnJvci5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVzKSwgeyBoZWFkZXJzLCBib2R5OiAoMCwgc3RyaW5nc19qc18xLnN0cmluZ2lmeSkoKDAsIGVycm9yc19qc18xLnNlcmlhbGl6ZUVycm9yKShlcnIpKSwgc3RhdHVzOiA1MDAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzaWduYXR1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1tjb25zdHNfanNfMS5oZWFkZXJLZXlzLlNpZ25hdHVyZV0gPSBzaWduYXR1cmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlcyksIHsgaGVhZGVycyB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoYXdhaXQgdGhpcy5zaG91bGRTdHJlYW0oYWN0aW9ucykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXRob2QgPSBhd2FpdCBhY3Rpb25zLm1ldGhvZChcInN0YXJ0aW5nIHN0cmVhbWluZyByZXNwb25zZVwiKTtcbiAgICAgICAgICAgICAgICBpZiAobWV0aG9kID09PSBcIlBPU1RcIikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHN0cmVhbSwgZmluYWxpemUgfSA9IGF3YWl0ICgwLCBzdHJlYW1fanNfMS5jcmVhdGVTdHJlYW0pKCk7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBFcnJvcnMgYXJlIGhhbmRsZWQgYnkgYGhhbmRsZUFjdGlvbmAgaGVyZSB0byBlbnN1cmUgdGhhdCBhblxuICAgICAgICAgICAgICAgICAgICAgKiBhcHByb3ByaWF0ZSByZXNwb25zZSBpcyBhbHdheXMgZ2l2ZW4uXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICB2b2lkIGFjdGlvblJlcy50aGVuKChyZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaW5hbGl6ZShwcmVwYXJlQWN0aW9uUmVzKHJlcykpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRpbWVyLndyYXAoXCJyZXNcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChfYSA9IGFjdGlvbnMudHJhbnNmb3JtU3RyZWFtaW5nUmVzcG9uc2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGFjdGlvbnMsIFwic3RhcnRpbmcgc3RyZWFtaW5nIHJlc3BvbnNlXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IDIwMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBnZXRJbm5nZXN0SGVhZGVycygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IHN0cmVhbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aW1lci53cmFwKFwicmVzXCIsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWN0aW9uUmVzLnRoZW4ocHJlcGFyZUFjdGlvblJlcykudGhlbigoYWN0aW9uUmVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVyblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWN0aW9ucy50cmFuc2Zvcm1SZXNwb25zZShcInNlbmRpbmcgYmFjayByZXNwb25zZVwiLCBhY3Rpb25SZXMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTb21lIHBsYXRmb3JtcyBjaGVjayAoYXQgcnVudGltZSkgdGhlIGxlbmd0aCBvZiB0aGUgZnVuY3Rpb24gYmVpbmcgdXNlZFxuICAgICAgICAgKiB0byBoYW5kbGUgYW4gZW5kcG9pbnQuIElmIHRoaXMgaXMgYSB2YXJpYWRpYyBmdW5jdGlvbiwgaXQgd2lsbCBmYWlsIHRoYXRcbiAgICAgICAgICogY2hlY2suXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZXJlZm9yZSwgd2UgZXhwZWN0IHRoZSBhcmd1bWVudHMgYWNjZXB0ZWQgdG8gYmUgdGhlIHNhbWUgbGVuZ3RoIGFzIHRoZVxuICAgICAgICAgKiBgaGFuZGxlcmAgZnVuY3Rpb24gcGFzc2VkIGludGVybmFsbHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIFdlIGFsc28gc2V0IGEgbmFtZSB0byBhdm9pZCBhIGNvbW1vbiB1c2VsZXNzIG5hbWUgaW4gdHJhY2luZyBzdWNoIGFzXG4gICAgICAgICAqIGBcImFub255bW91c1wiYCBvciBgXCJib3VuZCBmdW5jdGlvblwiYC5cbiAgICAgICAgICpcbiAgICAgICAgICogaHR0cHM6Ly9naXRodWIuY29tL2dldHNlbnRyeS9zZW50cnktamF2YXNjcmlwdC9pc3N1ZXMvMzI4NFxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoaGFuZGxlciwge1xuICAgICAgICAgICAgbmFtZToge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBcIklubmdlc3RIYW5kbGVyXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGVuZ3RoOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuaGFuZGxlci5sZW5ndGgsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGhhbmRsZXI7XG4gICAgfVxuICAgIGdldCBtb2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbW9kZTtcbiAgICB9XG4gICAgc2V0IG1vZGUobSkge1xuICAgICAgICB0aGlzLl9tb2RlID0gbTtcbiAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgIHRoaXMuY2xpZW50W1wibW9kZVwiXSA9IG07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBzZXQgb2YgZnVuY3Rpb25zIHRvIGNoZWNrIGlmIGFuIGFjdGlvbiBpcyBhdmFpbGFibGUgZnJvbSB0aGVcbiAgICAgKiBpbnN0YW5jZSdzIGhhbmRsZXIsIGVuYWN0IGFueSBhY3Rpb24gdGhhdCBpcyBmb3VuZC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGNhbiBmZXRjaCB2YXJ5aW5nIHBheWxvYWRzIG9mIGRhdGEsIGJ1dCB1bHRpbWF0ZWx5IGlzIHRoZSBwbGFjZVxuICAgICAqIHdoZXJlIF9kZWNpc2lvbnNfIGFyZSBtYWRlIHJlZ2FyZGluZyBmdW5jdGlvbmFsaXR5LlxuICAgICAqXG4gICAgICogRm9yIGV4YW1wbGUsIGlmIHdlIGZpbmQgdGhhdCB3ZSBzaG91bGQgYmUgdmlld2luZyB0aGUgVUksIHRoaXMgZnVuY3Rpb25cbiAgICAgKiB3aWxsIGRlY2lkZSB3aGV0aGVyIHRoZSBVSSBzaG91bGQgYmUgdmlzaWJsZSBiYXNlZCBvbiB0aGUgcGF5bG9hZCBpdCBoYXNcbiAgICAgKiBmb3VuZCAoZS5nLiBlbnYgdmFycywgb3B0aW9ucywgZXRjKS5cbiAgICAgKi9cbiAgICBhc3luYyBoYW5kbGVBY3Rpb24oeyBhY3Rpb25zLCB0aW1lciwgZ2V0SW5uZ2VzdEhlYWRlcnMsIHJlcUFyZ3MsIHNpZ25hdHVyZVZhbGlkYXRpb24sIGJvZHksIG1ldGhvZCwgaGVhZGVycywgfSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8vIFRoaXMgaXMgd2hlbiB0aGUgcmVxdWVzdCBib2R5IGlzIGNvbXBsZXRlbHkgbWlzc2luZzsgaXQgZG9lcyBub3RcbiAgICAgICAgLy8gaW5jbHVkZSBhbiBlbXB0eSBib2R5LiBUaGlzIGNvbW1vbmx5IGhhcHBlbnMgd2hlbiB0aGUgSFRUUCBmcmFtZXdvcmtcbiAgICAgICAgLy8gZG9lc24ndCBoYXZlIGJvZHkgcGFyc2luZyBtaWRkbGV3YXJlLlxuICAgICAgICBjb25zdCBpc01pc3NpbmdCb2R5ID0gYm9keSA9PT0gdW5kZWZpbmVkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IHVybCA9IGF3YWl0IGFjdGlvbnMudXJsKFwic3RhcnRpbmcgdG8gaGFuZGxlIHJlcXVlc3RcIik7XG4gICAgICAgICAgICBpZiAobWV0aG9kID09PSBcIlBPU1RcIikge1xuICAgICAgICAgICAgICAgIGlmIChpc01pc3NpbmdCb2R5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nKFwiZXJyb3JcIiwgXCJNaXNzaW5nIGJvZHkgd2hlbiBleGVjdXRpbmcsIHBvc3NpYmx5IGR1ZSB0byBtaXNzaW5nIHJlcXVlc3QgYm9keSBtaWRkbGV3YXJlXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiA1MDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogKDAsIHN0cmluZ3NfanNfMS5zdHJpbmdpZnkpKCgwLCBlcnJvcnNfanNfMS5zZXJpYWxpemVFcnJvcikobmV3IEVycm9yKFwiTWlzc2luZyByZXF1ZXN0IGJvZHkgd2hlbiBleGVjdXRpbmcsIHBvc3NpYmx5IGR1ZSB0byBtaXNzaW5nIHJlcXVlc3QgYm9keSBtaWRkbGV3YXJlXCIpKSksXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkYXRpb25SZXN1bHQgPSBhd2FpdCBzaWduYXR1cmVWYWxpZGF0aW9uO1xuICAgICAgICAgICAgICAgIGlmICghdmFsaWRhdGlvblJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IDQwMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5OiAoMCwgc3RyaW5nc19qc18xLnN0cmluZ2lmeSkoKDAsIGVycm9yc19qc18xLnNlcmlhbGl6ZUVycm9yKSh2YWxpZGF0aW9uUmVzdWx0LmVycikpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVyc2lvbjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByYXdQcm9iZSA9IGF3YWl0IGFjdGlvbnMucXVlcnlTdHJpbmdXaXRoRGVmYXVsdHMoXCJ0ZXN0aW5nIGZvciBwcm9iZVwiLCBjb25zdHNfanNfMS5xdWVyeUtleXMuUHJvYmUpO1xuICAgICAgICAgICAgICAgIGlmIChyYXdQcm9iZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9iZSA9ICgwLCBlbnVtX2pzXzEuZW51bUZyb21WYWx1ZSkoY29uc3RzX2pzXzEucHJvYmUsIHJhd1Byb2JlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwcm9iZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UncmUgaGVyZSwgd2UndmUgcmVjZWl2ZWQgYSBwcm9iZSB0aGF0IHdlIGRvbid0IHJlY29nbml6ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZhaWwuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogNDAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiAoMCwgc3RyaW5nc19qc18xLnN0cmluZ2lmeSkoKDAsIGVycm9yc19qc18xLnNlcmlhbGl6ZUVycm9yKShuZXcgRXJyb3IoYFVua25vd24gcHJvYmUgXCIke3Jhd1Byb2JlfVwiYCkpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFByb3ZpZGUgYWN0aW9ucyBmb3IgZXZlcnkgcHJvYmUgYXZhaWxhYmxlLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9iZUFjdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBbY29uc3RzX2pzXzEucHJvYmUuVHJ1c3RdOiAoKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogMjAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlcnNpb246IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvYmVBY3Rpb25zW3Byb2JlXSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBmbklkID0gYXdhaXQgYWN0aW9ucy5xdWVyeVN0cmluZ1dpdGhEZWZhdWx0cyhcInByb2Nlc3NpbmcgcnVuIHJlcXVlc3RcIiwgY29uc3RzX2pzXzEucXVlcnlLZXlzLkZuSWQpO1xuICAgICAgICAgICAgICAgIGlmICghZm5JZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIFByZXR0eUVycm9yXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGZ1bmN0aW9uIElEIGZvdW5kIGluIHJlcXVlc3RcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHN0ZXBJZCA9IChhd2FpdCBhY3Rpb25zLnF1ZXJ5U3RyaW5nV2l0aERlZmF1bHRzKFwicHJvY2Vzc2luZyBydW4gcmVxdWVzdFwiLCBjb25zdHNfanNfMS5xdWVyeUtleXMuU3RlcElkKSkgfHwgbnVsbDtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHZlcnNpb24sIHJlc3VsdCB9ID0gdGhpcy5ydW5TdGVwKHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25JZDogZm5JZCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogYm9keSxcbiAgICAgICAgICAgICAgICAgICAgc3RlcElkLFxuICAgICAgICAgICAgICAgICAgICB0aW1lcixcbiAgICAgICAgICAgICAgICAgICAgcmVxQXJncyxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogYXdhaXQgaGVhZGVycyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGVwT3V0cHV0ID0gYXdhaXQgcmVzdWx0O1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEZ1bmN0aW9ucyBjYW4gcmV0dXJuIGB1bmRlZmluZWRgLCBidXQgd2UnbGwgYWx3YXlzIGNvbnZlcnQgdGhpcyB0b1xuICAgICAgICAgICAgICAgICAqIGBudWxsYCwgYXMgdGhpcyBpcyBhcHByb3ByaWF0ZWx5IHNlcmlhbGl6YWJsZSBieSBKU09OLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGNvbnN0IG9wRGF0YVVuZGVmaW5lZFRvTnVsbCA9IChvcCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBvcC5kYXRhID0gKDAsIGZ1bmN0aW9uc19qc18xLnVuZGVmaW5lZFRvTnVsbCkob3AuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdEhhbmRsZXJzID0ge1xuICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uLXJlamVjdGVkXCI6IChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiByZXN1bHQucmV0cmlhYmxlID8gNTAwIDogNDAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiwgW2NvbnN0c19qc18xLmhlYWRlcktleXMuTm9SZXRyeV06IHJlc3VsdC5yZXRyaWFibGUgPyBcImZhbHNlXCIgOiBcInRydWVcIiB9LCAodHlwZW9mIHJlc3VsdC5yZXRyaWFibGUgPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB7IFtjb25zdHNfanNfMS5oZWFkZXJLZXlzLlJldHJ5QWZ0ZXJdOiByZXN1bHQucmV0cmlhYmxlIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB7fSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6ICgwLCBzdHJpbmdzX2pzXzEuc3RyaW5naWZ5KSgoMCwgZnVuY3Rpb25zX2pzXzEudW5kZWZpbmVkVG9OdWxsKShyZXN1bHQuZXJyb3IpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvbi1yZXNvbHZlZFwiOiAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogMjAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiAoMCwgc3RyaW5nc19qc18xLnN0cmluZ2lmeSkoKDAsIGZ1bmN0aW9uc19qc18xLnVuZGVmaW5lZFRvTnVsbCkocmVzdWx0LmRhdGEpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXCJzdGVwLW5vdC1mb3VuZFwiOiAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogNTAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtjb25zdHNfanNfMS5oZWFkZXJLZXlzLk5vUmV0cnldOiBcImZhbHNlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiAoMCwgc3RyaW5nc19qc18xLnN0cmluZ2lmeSkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogYENvdWxkIG5vdCBmaW5kIHN0ZXAgXCIke3Jlc3VsdC5zdGVwLmRpc3BsYXlOYW1lIHx8IHJlc3VsdC5zdGVwLmlkfVwiIHRvIHJ1bjsgdGltZWQgb3V0YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXCJzdGVwLXJhblwiOiAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGVwID0gb3BEYXRhVW5kZWZpbmVkVG9OdWxsKHJlc3VsdC5zdGVwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiAyMDYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogT2JqZWN0LmFzc2lnbih7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sICh0eXBlb2YgcmVzdWx0LnJldHJpYWJsZSAhPT0gXCJ1bmRlZmluZWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IE9iamVjdC5hc3NpZ24oeyBbY29uc3RzX2pzXzEuaGVhZGVyS2V5cy5Ob1JldHJ5XTogcmVzdWx0LnJldHJpYWJsZSA/IFwiZmFsc2VcIiA6IFwidHJ1ZVwiIH0sICh0eXBlb2YgcmVzdWx0LnJldHJpYWJsZSA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB7IFtjb25zdHNfanNfMS5oZWFkZXJLZXlzLlJldHJ5QWZ0ZXJdOiByZXN1bHQucmV0cmlhYmxlIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDoge30pKSA6IHt9KSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogKDAsIHN0cmluZ3NfanNfMS5zdHJpbmdpZnkpKFtzdGVwXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVyc2lvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIFwic3RlcHMtZm91bmRcIjogKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RlcHMgPSByZXN1bHQuc3RlcHMubWFwKG9wRGF0YVVuZGVmaW5lZFRvTnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogMjA2LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiAoMCwgc3RyaW5nc19qc18xLnN0cmluZ2lmeSkoc3RlcHMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlcnNpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlciA9IHJlc3VsdEhhbmRsZXJzW3N0ZXBPdXRwdXQudHlwZV07XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGhhbmRsZXIoc3RlcE91dHB1dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2coXCJlcnJvclwiLCBcIkVycm9yIGhhbmRsaW5nIGV4ZWN1dGlvbiByZXN1bHRcIiwgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRPRE86IFRoaXMgZmVlbHMgaGFja3ksIHNvIHdlIHNob3VsZCBwcm9iYWJseSBtYWtlIGl0IG5vdCBoYWNreS5cbiAgICAgICAgICAgIGNvbnN0IGVudiA9IChfYSA9IGdldElubmdlc3RIZWFkZXJzKClbY29uc3RzX2pzXzEuaGVhZGVyS2V5cy5FbnZpcm9ubWVudF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG51bGw7XG4gICAgICAgICAgICBpZiAobWV0aG9kID09PSBcIkdFVFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiAyMDAsXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6ICgwLCBzdHJpbmdzX2pzXzEuc3RyaW5naWZ5KShhd2FpdCB0aGlzLmludHJvc3BlY3Rpb25Cb2R5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnYsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmVWYWxpZGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgICAgICB9KSksXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXRob2QgPT09IFwiUFVUXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbZGVwbG95SWQsIGluQmFuZFN5bmNSZXF1ZXN0ZWRdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAucXVlcnlTdHJpbmdXaXRoRGVmYXVsdHMoXCJwcm9jZXNzaW5nIGRlcGxveW1lbnQgcmVxdWVzdFwiLCBjb25zdHNfanNfMS5xdWVyeUtleXMuRGVwbG95SWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbigoZGVwbG95SWQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkZXBsb3lJZCA9PT0gXCJ1bmRlZmluZWRcIiA/IHVuZGVmaW5lZCA6IGRlcGxveUlkO1xuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCgwLCBlbnZfanNfMS5wYXJzZUFzQm9vbGVhbikodGhpcy5lbnZbY29uc3RzX2pzXzEuZW52S2V5cy5Jbm5nZXN0QWxsb3dJbkJhbmRTeW5jXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbigoYWxsb3dJbkJhbmRTeW5jKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWxsb3dJbkJhbmRTeW5jICE9PSB1bmRlZmluZWQgJiYgIWFsbG93SW5CYW5kU3luYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25zdHNfanNfMS5zeW5jS2luZC5PdXRPZkJhbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWN0aW9ucy5oZWFkZXJzKFwicHJvY2Vzc2luZyBkZXBsb3ltZW50IHJlcXVlc3RcIiwgY29uc3RzX2pzXzEuaGVhZGVyS2V5cy5Jbm5nZXN0U3luY0tpbmQpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oKGtpbmQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBraW5kID09PSBjb25zdHNfanNfMS5zeW5jS2luZC5JbkJhbmQ7XG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIGlmIChpbkJhbmRTeW5jUmVxdWVzdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc01pc3NpbmdCb2R5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZyhcImVycm9yXCIsIFwiTWlzc2luZyBib2R5IHdoZW4gc3luY2luZywgcG9zc2libHkgZHVlIHRvIG1pc3NpbmcgcmVxdWVzdCBib2R5IG1pZGRsZXdhcmVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogNTAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiAoMCwgc3RyaW5nc19qc18xLnN0cmluZ2lmeSkoKDAsIGVycm9yc19qc18xLnNlcmlhbGl6ZUVycm9yKShuZXcgRXJyb3IoXCJNaXNzaW5nIHJlcXVlc3QgYm9keSB3aGVuIHN5bmNpbmcsIHBvc3NpYmx5IGR1ZSB0byBtaXNzaW5nIHJlcXVlc3QgYm9keSBtaWRkbGV3YXJlXCIpKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVyc2lvbjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBWYWxpZGF0aW9uIGNhbiBiZSBzdWNjZXNzZnVsIGlmIHdlJ3JlIGluIGRldiBtb2RlIGFuZCBkaWQgbm90XG4gICAgICAgICAgICAgICAgICAgIC8vIGFjdHVhbGx5IHZhbGlkYXRlIGEga2V5LiBJbiB0aGlzIGNhc2UsIGFsc28gY2hlY2sgdGhhdCB3ZSBkaWQgaW5kZWVkXG4gICAgICAgICAgICAgICAgICAgIC8vIHVzZSBhIHBhcnRpY3VsYXIga2V5IHRvIHZhbGlkYXRlLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzaWdDaGVjayA9IGF3YWl0IHNpZ25hdHVyZVZhbGlkYXRpb247XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2lnQ2hlY2suc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IDQwMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiAoMCwgc3RyaW5nc19qc18xLnN0cmluZ2lmeSkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcInNpZ192ZXJpZmljYXRpb25fZmFpbGVkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlcnNpb246IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzID0gdHlwZXNfanNfMS5pbkJhbmRTeW5jUmVxdWVzdEJvZHlTY2hlbWEuc2FmZVBhcnNlKGJvZHkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlcy5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogNDAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6ICgwLCBzdHJpbmdzX2pzXzEuc3RyaW5naWZ5KSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF9yZXF1ZXN0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHJlcy5lcnJvci5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGNhbiB0cnVzdCB0aGUgVVJMIGhlcmUgYmVjYXVzZSBpdCdzIGNvbWluZyBmcm9tXG4gICAgICAgICAgICAgICAgICAgIC8vIHNpZ25hdHVyZS12ZXJpZmllZCByZXF1ZXN0LlxuICAgICAgICAgICAgICAgICAgICB1cmwgPSB0aGlzLnJlcVVybChuZXcgVVJMKHJlcy5kYXRhLnVybCkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBiZSBhbiBpbi1iYW5kIHN5bmNcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcEJvZHkgPSBhd2FpdCB0aGlzLmluQmFuZFJlZ2lzdGVyQm9keSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVwbG95SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnYsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmVWYWxpZGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogMjAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogKDAsIHN0cmluZ3NfanNfMS5zdHJpbmdpZnkpKHJlc3BCb2R5KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbY29uc3RzX2pzXzEuaGVhZGVyS2V5cy5Jbm5nZXN0U3luY0tpbmRdOiBjb25zdHNfanNfMS5zeW5jS2luZC5JbkJhbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVyc2lvbjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSdyZSBoZXJlLCB0aGlzIGlzIGEgbGVnYWN5IG91dC1vZi1iYW5kIHN5bmNcbiAgICAgICAgICAgICAgICBjb25zdCB7IHN0YXR1cywgbWVzc2FnZSwgbW9kaWZpZWQgfSA9IGF3YWl0IHRoaXMucmVnaXN0ZXIodGhpcy5yZXFVcmwodXJsKSwgZGVwbG95SWQsIGdldElubmdlc3RIZWFkZXJzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6ICgwLCBzdHJpbmdzX2pzXzEuc3RyaW5naWZ5KSh7IG1lc3NhZ2UsIG1vZGlmaWVkIH0pLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFtjb25zdHNfanNfMS5oZWFkZXJLZXlzLklubmdlc3RTeW5jS2luZF06IGNvbnN0c19qc18xLnN5bmNLaW5kLk91dE9mQmFuZCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgdmVyc2lvbjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdGF0dXM6IDUwMCxcbiAgICAgICAgICAgICAgICBib2R5OiAoMCwgc3RyaW5nc19qc18xLnN0cmluZ2lmeSkoT2JqZWN0LmFzc2lnbih7IHR5cGU6IFwiaW50ZXJuYWxcIiB9LCAoMCwgZXJyb3JzX2pzXzEuc2VyaWFsaXplRXJyb3IpKGVycikpKSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdmVyc2lvbjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhdHVzOiA0MDUsXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogXCJObyBhY3Rpb24gZm91bmQ7IHJlcXVlc3Qgd2FzIGxpa2VseSBub3QgUE9TVCwgUFVULCBvciBHRVRcIixcbiAgICAgICAgICAgICAgICBtb2RlOiB0aGlzLl9tb2RlLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBoZWFkZXJzOiB7fSxcbiAgICAgICAgICAgIHZlcnNpb246IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcnVuU3RlcCh7IGZ1bmN0aW9uSWQsIHN0ZXBJZCwgZGF0YSwgdGltZXIsIHJlcUFyZ3MsIGhlYWRlcnMsIH0pIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgZm4gPSB0aGlzLmZuc1tmdW5jdGlvbklkXTtcbiAgICAgICAgaWYgKCFmbikge1xuICAgICAgICAgICAgLy8gVE9ETyBQcmV0dHlFcnJvclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCBmdW5jdGlvbiB3aXRoIElEIFwiJHtmdW5jdGlvbklkfVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW1tZWRpYXRlRm5EYXRhID0gKDAsIGZ1bmN0aW9uc19qc18xLnBhcnNlRm5EYXRhKShkYXRhKTtcbiAgICAgICAgbGV0IHsgdmVyc2lvbiB9ID0gaW1tZWRpYXRlRm5EYXRhO1xuICAgICAgICAvLyBIYW5kbGUgb3B0aW5nIGluIHRvIG9wdGltaXplZCBwYXJhbGxlbGlzbSBpbiB2My5cbiAgICAgICAgaWYgKHZlcnNpb24gPT09IElubmdlc3RFeGVjdXRpb25fanNfMS5FeGVjdXRpb25WZXJzaW9uLlYxICYmXG4gICAgICAgICAgICAoKF9iID0gKF9hID0gZm4uZm4pW1wic2hvdWxkT3B0aW1pemVQYXJhbGxlbGlzbVwiXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpKSkge1xuICAgICAgICAgICAgdmVyc2lvbiA9IElubmdlc3RFeGVjdXRpb25fanNfMS5FeGVjdXRpb25WZXJzaW9uLlYyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9ICgwLCBwcm9taXNlc19qc18xLnJ1bkFzUHJvbWlzZSkoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYW55Rm5EYXRhID0gYXdhaXQgKDAsIGZ1bmN0aW9uc19qc18xLmZldGNoQWxsRm5EYXRhKSh7XG4gICAgICAgICAgICAgICAgZGF0YTogaW1tZWRpYXRlRm5EYXRhLFxuICAgICAgICAgICAgICAgIGFwaTogdGhpcy5jbGllbnRbXCJpbm5nZXN0QXBpXCJdLFxuICAgICAgICAgICAgICAgIHZlcnNpb24sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghYW55Rm5EYXRhLm9rKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGFueUZuRGF0YS5lcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBleGVjdXRpb25TdGFydGVycyA9ICgocykgPT4gcykoe1xuICAgICAgICAgICAgICAgIFtJbm5nZXN0RXhlY3V0aW9uX2pzXzEuRXhlY3V0aW9uVmVyc2lvbi5WMF06ICh7IGV2ZW50LCBldmVudHMsIHN0ZXBzLCBjdHgsIHZlcnNpb24gfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RlcFN0YXRlID0gT2JqZWN0LmVudHJpZXMoc3RlcHMgIT09IG51bGwgJiYgc3RlcHMgIT09IHZvaWQgMCA/IHN0ZXBzIDoge30pLnJlZHVjZSgoYWNjLCBbaWQsIGRhdGFdKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhY2MpLCB7IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbaWRdOiB7IGlkLCBkYXRhIH0gfSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcnNpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsT3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudDogdGhpcy5jbGllbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVuSWQ6IChjdHggPT09IG51bGwgfHwgY3R4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdHgucnVuX2lkKSB8fCBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudHM6IGV2ZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVuSWQ6IChjdHggPT09IG51bGwgfHwgY3R4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdHgucnVuX2lkKSB8fCBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRlbXB0OiAoX2EgPSBjdHggPT09IG51bGwgfHwgY3R4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdHguYXR0ZW1wdCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXBTdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0ZWRSdW5TdGVwOiBzdGVwSWQgPT09IFwic3RlcFwiID8gdW5kZWZpbmVkIDogc3RlcElkIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0ZhaWx1cmVIYW5kbGVyOiBmbi5vbkZhaWx1cmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RlcENvbXBsZXRpb25PcmRlcjogKF9jID0gKF9iID0gY3R4ID09PSBudWxsIHx8IGN0eCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3R4LnN0YWNrKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc3RhY2spICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcUFyZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBbSW5uZ2VzdEV4ZWN1dGlvbl9qc18xLkV4ZWN1dGlvblZlcnNpb24uVjFdOiAoeyBldmVudCwgZXZlbnRzLCBzdGVwcywgY3R4LCB2ZXJzaW9uIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0ZXBTdGF0ZSA9IE9iamVjdC5lbnRyaWVzKHN0ZXBzICE9PSBudWxsICYmIHN0ZXBzICE9PSB2b2lkIDAgPyBzdGVwcyA6IHt9KS5yZWR1Y2UoKGFjYywgW2lkLCByZXN1bHRdKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhY2MpLCB7IFtpZF06IHJlc3VsdC50eXBlID09PSBcImRhdGFcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgaWQsIGRhdGE6IHJlc3VsdC5kYXRhIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiByZXN1bHQudHlwZSA9PT0gXCJpbnB1dFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGlkLCBpbnB1dDogcmVzdWx0LmlucHV0IH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogeyBpZCwgZXJyb3I6IHJlc3VsdC5lcnJvciB9IH0pO1xuICAgICAgICAgICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbE9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGllbnQ6IHRoaXMuY2xpZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bklkOiAoY3R4ID09PSBudWxsIHx8IGN0eCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3R4LnJ1bl9pZCkgfHwgXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRzOiBldmVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bklkOiAoY3R4ID09PSBudWxsIHx8IGN0eCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3R4LnJ1bl9pZCkgfHwgXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0ZW1wdDogKF9hID0gY3R4ID09PSBudWxsIHx8IGN0eCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3R4LmF0dGVtcHQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGVwU3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdGVkUnVuU3RlcDogc3RlcElkID09PSBcInN0ZXBcIiA/IHVuZGVmaW5lZCA6IHN0ZXBJZCB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNGYWlsdXJlSGFuZGxlcjogZm4ub25GYWlsdXJlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVJbW1lZGlhdGVFeGVjdXRpb246IGN0eCA9PT0gbnVsbCB8fCBjdHggPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN0eC5kaXNhYmxlX2ltbWVkaWF0ZV9leGVjdXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RlcENvbXBsZXRpb25PcmRlcjogKF9jID0gKF9iID0gY3R4ID09PSBudWxsIHx8IGN0eCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3R4LnN0YWNrKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc3RhY2spICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcUFyZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBbSW5uZ2VzdEV4ZWN1dGlvbl9qc18xLkV4ZWN1dGlvblZlcnNpb24uVjJdOiAoeyBldmVudCwgZXZlbnRzLCBzdGVwcywgY3R4LCB2ZXJzaW9uIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0ZXBTdGF0ZSA9IE9iamVjdC5lbnRyaWVzKHN0ZXBzICE9PSBudWxsICYmIHN0ZXBzICE9PSB2b2lkIDAgPyBzdGVwcyA6IHt9KS5yZWR1Y2UoKGFjYywgW2lkLCByZXN1bHRdKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhY2MpLCB7IFtpZF06IHJlc3VsdC50eXBlID09PSBcImRhdGFcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgaWQsIGRhdGE6IHJlc3VsdC5kYXRhIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiByZXN1bHQudHlwZSA9PT0gXCJpbnB1dFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGlkLCBpbnB1dDogcmVzdWx0LmlucHV0IH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogeyBpZCwgZXJyb3I6IHJlc3VsdC5lcnJvciB9IH0pO1xuICAgICAgICAgICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbE9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGllbnQ6IHRoaXMuY2xpZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bklkOiAoY3R4ID09PSBudWxsIHx8IGN0eCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3R4LnJ1bl9pZCkgfHwgXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRzOiBldmVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bklkOiAoY3R4ID09PSBudWxsIHx8IGN0eCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3R4LnJ1bl9pZCkgfHwgXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0ZW1wdDogKF9hID0gY3R4ID09PSBudWxsIHx8IGN0eCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3R4LmF0dGVtcHQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGVwU3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdGVkUnVuU3RlcDogc3RlcElkID09PSBcInN0ZXBcIiA/IHVuZGVmaW5lZCA6IHN0ZXBJZCB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNGYWlsdXJlSGFuZGxlcjogZm4ub25GYWlsdXJlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVJbW1lZGlhdGVFeGVjdXRpb246IGN0eCA9PT0gbnVsbCB8fCBjdHggPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN0eC5kaXNhYmxlX2ltbWVkaWF0ZV9leGVjdXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RlcENvbXBsZXRpb25PcmRlcjogKF9jID0gKF9iID0gY3R4ID09PSBudWxsIHx8IGN0eCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3R4LnN0YWNrKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc3RhY2spICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcUFyZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgZXhlY3V0aW9uT3B0aW9ucyA9IGF3YWl0IGV4ZWN1dGlvblN0YXJ0ZXJzW3ZlcnNpb25dKGFueUZuRGF0YS52YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gZm4uZm5bXCJjcmVhdGVFeGVjdXRpb25cIl0oZXhlY3V0aW9uT3B0aW9ucykuc3RhcnQoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7IHZlcnNpb24sIHJlc3VsdCB9O1xuICAgIH1cbiAgICBjb25maWdzKHVybCkge1xuICAgICAgICBjb25zdCBjb25maWdzID0gT2JqZWN0LnZhbHVlcyh0aGlzLnJhd0ZucykucmVkdWNlKChhY2MsIGZuKSA9PiBbXG4gICAgICAgICAgICAuLi5hY2MsXG4gICAgICAgICAgICAuLi5mbltcImdldENvbmZpZ1wiXSh7IGJhc2VVcmw6IHVybCwgYXBwUHJlZml4OiB0aGlzLmlkIH0pLFxuICAgICAgICBdLCBbXSk7XG4gICAgICAgIGZvciAoY29uc3QgY29uZmlnIG9mIGNvbmZpZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrID0gdHlwZXNfanNfMS5mdW5jdGlvbkNvbmZpZ1NjaGVtYS5zYWZlUGFyc2UoY29uZmlnKTtcbiAgICAgICAgICAgIGlmICghY2hlY2suc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9ycyA9IGNoZWNrLmVycm9yLmVycm9ycy5tYXAoKGVycikgPT4gZXJyLm1lc3NhZ2UpLmpvaW4oXCI7IFwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZyhcIndhcm5cIiwgYENvbmZpZyBpbnZhbGlkIGZvciBmdW5jdGlvbiBcIiR7Y29uZmlnLmlkfVwiIDogJHtlcnJvcnN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbmZpZ3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhbiBJbm5nZXN0IHNlcnZlIGVuZHBvaW50IFVSTCBnaXZlbiBhIHBvdGVudGlhbCBgcGF0aGAgYW5kIGBob3N0YC5cbiAgICAgKlxuICAgICAqIFdpbGwgYXV0b21hdGljYWxseSB1c2UgdGhlIGBzZXJ2ZUhvc3RgIGFuZCBgc2VydmVQYXRoYCBpZiB0aGV5IGhhdmUgYmVlblxuICAgICAqIHNldCB3aGVuIHJlZ2lzdGVyaW5nLlxuICAgICAqL1xuICAgIHJlcVVybCh1cmwpIHtcbiAgICAgICAgbGV0IHJldCA9IG5ldyBVUkwodXJsKTtcbiAgICAgICAgY29uc3Qgc2VydmVIb3N0ID0gdGhpcy5zZXJ2ZUhvc3QgfHwgdGhpcy5lbnZbY29uc3RzX2pzXzEuZW52S2V5cy5Jbm5nZXN0U2VydmVIb3N0XTtcbiAgICAgICAgY29uc3Qgc2VydmVQYXRoID0gdGhpcy5zZXJ2ZVBhdGggfHwgdGhpcy5lbnZbY29uc3RzX2pzXzEuZW52S2V5cy5Jbm5nZXN0U2VydmVQYXRoXTtcbiAgICAgICAgaWYgKHNlcnZlUGF0aCkge1xuICAgICAgICAgICAgcmV0LnBhdGhuYW1lID0gc2VydmVQYXRoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXJ2ZUhvc3QpIHtcbiAgICAgICAgICAgIHJldCA9IG5ldyBVUkwocmV0LnBhdGhuYW1lICsgcmV0LnNlYXJjaCwgc2VydmVIb3N0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICByZWdpc3RlckJvZHkoeyB1cmwsIGRlcGxveUlkLCB9KSB7XG4gICAgICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAgICAgICB1cmw6IHVybC5ocmVmLFxuICAgICAgICAgICAgZGVwbG95VHlwZTogXCJwaW5nXCIsXG4gICAgICAgICAgICBmcmFtZXdvcms6IHRoaXMuZnJhbWV3b3JrTmFtZSxcbiAgICAgICAgICAgIGFwcE5hbWU6IHRoaXMuaWQsXG4gICAgICAgICAgICBmdW5jdGlvbnM6IHRoaXMuY29uZmlncyh1cmwpLFxuICAgICAgICAgICAgc2RrOiBganM6diR7dmVyc2lvbl9qc18xLnZlcnNpb259YCxcbiAgICAgICAgICAgIHY6IFwiMC4xXCIsXG4gICAgICAgICAgICBkZXBsb3lJZDogZGVwbG95SWQgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgY2FwYWJpbGl0aWVzOiB7XG4gICAgICAgICAgICAgICAgdHJ1c3RfcHJvYmU6IFwidjFcIixcbiAgICAgICAgICAgICAgICBjb25uZWN0OiBcInYxXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXBwVmVyc2lvbjogdGhpcy5jbGllbnQuYXBwVmVyc2lvbixcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGJvZHk7XG4gICAgfVxuICAgIGFzeW5jIGluQmFuZFJlZ2lzdGVyQm9keSh7IGFjdGlvbnMsIGRlcGxveUlkLCBlbnYsIHNpZ25hdHVyZVZhbGlkYXRpb24sIHVybCwgfSkge1xuICAgICAgICBjb25zdCByZWdpc3RlckJvZHkgPSB0aGlzLnJlZ2lzdGVyQm9keSh7IGRlcGxveUlkLCB1cmwgfSk7XG4gICAgICAgIGNvbnN0IGludHJvc3BlY3Rpb25Cb2R5ID0gYXdhaXQgdGhpcy5pbnRyb3NwZWN0aW9uQm9keSh7XG4gICAgICAgICAgICBhY3Rpb25zLFxuICAgICAgICAgICAgZW52LFxuICAgICAgICAgICAgc2lnbmF0dXJlVmFsaWRhdGlvbixcbiAgICAgICAgICAgIHVybCxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAgICAgICBhcHBfaWQ6IHRoaXMuaWQsXG4gICAgICAgICAgICBhcHBWZXJzaW9uOiB0aGlzLmNsaWVudC5hcHBWZXJzaW9uLFxuICAgICAgICAgICAgY2FwYWJpbGl0aWVzOiByZWdpc3RlckJvZHkuY2FwYWJpbGl0aWVzLFxuICAgICAgICAgICAgZW52LFxuICAgICAgICAgICAgZnJhbWV3b3JrOiByZWdpc3RlckJvZHkuZnJhbWV3b3JrLFxuICAgICAgICAgICAgZnVuY3Rpb25zOiByZWdpc3RlckJvZHkuZnVuY3Rpb25zLFxuICAgICAgICAgICAgaW5zcGVjdGlvbjogaW50cm9zcGVjdGlvbkJvZHksXG4gICAgICAgICAgICBwbGF0Zm9ybTogKDAsIGVudl9qc18xLmdldFBsYXRmb3JtTmFtZSkoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAoMCwgZW52X2pzXzEuYWxsUHJvY2Vzc0VudikoKSksIHRoaXMuZW52KSksXG4gICAgICAgICAgICBzZGtfYXV0aG9yOiBcImlubmdlc3RcIixcbiAgICAgICAgICAgIHNka19sYW5ndWFnZTogXCJcIixcbiAgICAgICAgICAgIHNka192ZXJzaW9uOiBcIlwiLFxuICAgICAgICAgICAgc2RrOiByZWdpc3RlckJvZHkuc2RrLFxuICAgICAgICAgICAgdXJsOiByZWdpc3RlckJvZHkudXJsLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoaW50cm9zcGVjdGlvbkJvZHkuYXV0aGVudGljYXRpb25fc3VjY2VlZGVkKSB7XG4gICAgICAgICAgICBib2R5LnNka19sYW5ndWFnZSA9IGludHJvc3BlY3Rpb25Cb2R5LnNka19sYW5ndWFnZTtcbiAgICAgICAgICAgIGJvZHkuc2RrX3ZlcnNpb24gPSBpbnRyb3NwZWN0aW9uQm9keS5zZGtfdmVyc2lvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYm9keTtcbiAgICB9XG4gICAgYXN5bmMgaW50cm9zcGVjdGlvbkJvZHkoeyBhY3Rpb25zLCBlbnYsIHNpZ25hdHVyZVZhbGlkYXRpb24sIHVybCwgfSkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgICAgICBjb25zdCByZWdpc3RlckJvZHkgPSB0aGlzLnJlZ2lzdGVyQm9keSh7XG4gICAgICAgICAgICB1cmw6IHRoaXMucmVxVXJsKHVybCksXG4gICAgICAgICAgICBkZXBsb3lJZDogbnVsbCxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghdGhpcy5fbW9kZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gbW9kZSBzZXQ7IGNhbm5vdCBpbnRyb3NwZWN0IHdpdGhvdXQgbW9kZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaW50cm9zcGVjdGlvbiA9IHtcbiAgICAgICAgICAgIGF1dGhlbnRpY2F0aW9uX3N1Y2NlZWRlZDogbnVsbCxcbiAgICAgICAgICAgIGV4dHJhOiB7XG4gICAgICAgICAgICAgICAgaXNfbW9kZV9leHBsaWNpdDogdGhpcy5fbW9kZS5pc0V4cGxpY2l0LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhhc19ldmVudF9rZXk6IHRoaXMuY2xpZW50W1wiZXZlbnRLZXlTZXRcIl0oKSxcbiAgICAgICAgICAgIGhhc19zaWduaW5nX2tleTogQm9vbGVhbih0aGlzLnNpZ25pbmdLZXkpLFxuICAgICAgICAgICAgZnVuY3Rpb25fY291bnQ6IHJlZ2lzdGVyQm9keS5mdW5jdGlvbnMubGVuZ3RoLFxuICAgICAgICAgICAgbW9kZTogdGhpcy5fbW9kZS50eXBlLFxuICAgICAgICAgICAgc2NoZW1hX3ZlcnNpb246IFwiMjAyNC0wNS0yNFwiLFxuICAgICAgICB9O1xuICAgICAgICAvLyBPbmx5IGFsbG93IGF1dGhlbnRpY2F0ZWQgaW50cm9zcGVjdGlvbiBpbiBDbG91ZCBtb2RlLCBzaW5jZSBEZXYgbW9kZSBza2lwc1xuICAgICAgICAvLyBzaWduYXR1cmUgdmFsaWRhdGlvblxuICAgICAgICBpZiAodGhpcy5fbW9kZS50eXBlID09PSBcImNsb3VkXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsaWRhdGlvblJlc3VsdCA9IGF3YWl0IHNpZ25hdHVyZVZhbGlkYXRpb247XG4gICAgICAgICAgICAgICAgaWYgKCF2YWxpZGF0aW9uUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2lnbmF0dXJlIHZhbGlkYXRpb24gZmFpbGVkXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbnRyb3NwZWN0aW9uID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBpbnRyb3NwZWN0aW9uKSwgeyBhdXRoZW50aWNhdGlvbl9zdWNjZWVkZWQ6IHRydWUsIGFwaV9vcmlnaW46IHRoaXMuYXBpQmFzZVVybCwgYXBwX2lkOiB0aGlzLmlkLCBjYXBhYmlsaXRpZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRydXN0X3Byb2JlOiBcInYxXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0OiBcInYxXCIsXG4gICAgICAgICAgICAgICAgICAgIH0sIGVudiwgZXZlbnRfYXBpX29yaWdpbjogdGhpcy5ldmVudEFwaUJhc2VVcmwsIGV2ZW50X2tleV9oYXNoOiAoX2EgPSB0aGlzLmhhc2hlZEV2ZW50S2V5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsLCBleHRyYTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBpbnRyb3NwZWN0aW9uLmV4dHJhKSwgeyBpc19zdHJlYW1pbmc6IGF3YWl0IHRoaXMuc2hvdWxkU3RyZWFtKGFjdGlvbnMpIH0pLCBmcmFtZXdvcms6IHRoaXMuZnJhbWV3b3JrTmFtZSwgc2RrX2xhbmd1YWdlOiBcImpzXCIsIHNka192ZXJzaW9uOiB2ZXJzaW9uX2pzXzEudmVyc2lvbiwgc2VydmVfb3JpZ2luOiAoX2IgPSB0aGlzLnNlcnZlSG9zdCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbnVsbCwgc2VydmVfcGF0aDogKF9jID0gdGhpcy5zZXJ2ZVBhdGgpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IG51bGwsIHNpZ25pbmdfa2V5X2ZhbGxiYWNrX2hhc2g6IChfZCA9IHRoaXMuaGFzaGVkU2lnbmluZ0tleUZhbGxiYWNrKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBudWxsLCBzaWduaW5nX2tleV9oYXNoOiAoX2UgPSB0aGlzLmhhc2hlZFNpZ25pbmdLZXkpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IG51bGwgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoX2YpIHtcbiAgICAgICAgICAgICAgICAvLyBTd2FsbG93IHNpZ25hdHVyZSB2YWxpZGF0aW9uIGVycm9yIHNpbmNlIHdlJ2xsIGp1c3QgcmV0dXJuIHRoZVxuICAgICAgICAgICAgICAgIC8vIHVuYXV0aGVudGljYXRlZCBpbnRyb3NwZWN0aW9uXG4gICAgICAgICAgICAgICAgaW50cm9zcGVjdGlvbiA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaW50cm9zcGVjdGlvbiksIHsgYXV0aGVudGljYXRpb25fc3VjY2VlZGVkOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW50cm9zcGVjdGlvbjtcbiAgICB9XG4gICAgYXN5bmMgcmVnaXN0ZXIodXJsLCBkZXBsb3lJZCwgZ2V0SGVhZGVycykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGJvZHkgPSB0aGlzLnJlZ2lzdGVyQm9keSh7IHVybCwgZGVwbG95SWQgfSk7XG4gICAgICAgIGxldCByZXM7XG4gICAgICAgIC8vIFdoZW5ldmVyIHdlIHJlZ2lzdGVyLCB3ZSBjaGVjayB0byBzZWUgaWYgdGhlIGRldiBzZXJ2ZXIgaXMgdXAuICBUaGlzXG4gICAgICAgIC8vIGlzIGEgbm9vcCBhbmQgcmV0dXJucyBmYWxzZSBpbiBwcm9kdWN0aW9uLiBDbG9uZSB0aGUgVVJMIG9iamVjdCB0byBhdm9pZFxuICAgICAgICAvLyBtdXRhdGluZyB0aGUgcHJvcGVydHkgYmV0d2VlbiByZXF1ZXN0cy5cbiAgICAgICAgbGV0IHJlZ2lzdGVyVVJMID0gbmV3IFVSTCh0aGlzLmlubmdlc3RSZWdpc3RlclVybC5ocmVmKTtcbiAgICAgICAgY29uc3QgaW5mZXJyZWREZXZNb2RlID0gdGhpcy5fbW9kZSAmJiB0aGlzLl9tb2RlLmlzSW5mZXJyZWQgJiYgdGhpcy5fbW9kZS5pc0RldjtcbiAgICAgICAgaWYgKGluZmVycmVkRGV2TW9kZSkge1xuICAgICAgICAgICAgY29uc3QgaG9zdCA9ICgwLCBlbnZfanNfMS5kZXZTZXJ2ZXJIb3N0KSh0aGlzLmVudik7XG4gICAgICAgICAgICBjb25zdCBoYXNEZXZTZXJ2ZXIgPSBhd2FpdCAoMCwgZGV2c2VydmVyX2pzXzEuZGV2U2VydmVyQXZhaWxhYmxlKShob3N0LCB0aGlzLmZldGNoKTtcbiAgICAgICAgICAgIGlmIChoYXNEZXZTZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICByZWdpc3RlclVSTCA9ICgwLCBkZXZzZXJ2ZXJfanNfMS5kZXZTZXJ2ZXJVcmwpKGhvc3QsIFwiL2ZuL3JlZ2lzdGVyXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChfYSA9IHRoaXMuX21vZGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5leHBsaWNpdERldlVybCkge1xuICAgICAgICAgICAgcmVnaXN0ZXJVUkwgPSAoMCwgZGV2c2VydmVyX2pzXzEuZGV2U2VydmVyVXJsKSh0aGlzLl9tb2RlLmV4cGxpY2l0RGV2VXJsLmhyZWYsIFwiL2ZuL3JlZ2lzdGVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZXBsb3lJZCkge1xuICAgICAgICAgICAgcmVnaXN0ZXJVUkwuc2VhcmNoUGFyYW1zLnNldChjb25zdHNfanNfMS5xdWVyeUtleXMuRGVwbG95SWQsIGRlcGxveUlkKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzID0gYXdhaXQgKDAsIG5ldF9qc18xLmZldGNoV2l0aEF1dGhGYWxsYmFjaykoe1xuICAgICAgICAgICAgICAgIGF1dGhUb2tlbjogdGhpcy5oYXNoZWRTaWduaW5nS2V5LFxuICAgICAgICAgICAgICAgIGF1dGhUb2tlbkZhbGxiYWNrOiB0aGlzLmhhc2hlZFNpZ25pbmdLZXlGYWxsYmFjayxcbiAgICAgICAgICAgICAgICBmZXRjaDogdGhpcy5mZXRjaCxcbiAgICAgICAgICAgICAgICB1cmw6IHJlZ2lzdGVyVVJMLmhyZWYsXG4gICAgICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgICAgICAgICBib2R5OiAoMCwgc3RyaW5nc19qc18xLnN0cmluZ2lmeSkoYm9keSksXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZ2V0SGVhZGVycygpKSwgeyBbY29uc3RzX2pzXzEuaGVhZGVyS2V5cy5Jbm5nZXN0U3luY0tpbmRdOiBjb25zdHNfanNfMS5zeW5jS2luZC5PdXRPZkJhbmQgfSksXG4gICAgICAgICAgICAgICAgICAgIHJlZGlyZWN0OiBcImZvbGxvd1wiLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmxvZyhcImVycm9yXCIsIGVycik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXR1czogNTAwLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBGYWlsZWQgdG8gcmVnaXN0ZXIke2VyciBpbnN0YW5jZW9mIEVycm9yID8gYDsgJHtlcnIubWVzc2FnZX1gIDogXCJcIn1gLFxuICAgICAgICAgICAgICAgIG1vZGlmaWVkOiBmYWxzZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmF3ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgICAgICBsZXQgZGF0YSA9IHt9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UocmF3KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmxvZyhcIndhcm5cIiwgXCJDb3VsZG4ndCB1bnBhY2sgcmVnaXN0ZXIgcmVzcG9uc2U6XCIsIGVycik7XG4gICAgICAgICAgICBsZXQgbWVzc2FnZSA9IFwiRmFpbGVkIHRvIHJlZ2lzdGVyXCI7XG4gICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlICs9IGA7ICR7ZXJyLm1lc3NhZ2V9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gYDsgc3RhdHVzIGNvZGU6ICR7cmVzLnN0YXR1c31gO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdGF0dXM6IDUwMCxcbiAgICAgICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgICAgIG1vZGlmaWVkOiBmYWxzZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXR1cztcbiAgICAgICAgbGV0IGVycm9yO1xuICAgICAgICBsZXQgc2tpcHBlZDtcbiAgICAgICAgbGV0IG1vZGlmaWVkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgKHsgc3RhdHVzLCBlcnJvciwgc2tpcHBlZCwgbW9kaWZpZWQgfSA9IHJlZ2lzdGVyUmVzU2NoZW1hLnBhcnNlKGRhdGEpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmxvZyhcIndhcm5cIiwgXCJJbnZhbGlkIHJlZ2lzdGVyIHJlc3BvbnNlIHNjaGVtYTpcIiwgZXJyKTtcbiAgICAgICAgICAgIGxldCBtZXNzYWdlID0gXCJGYWlsZWQgdG8gcmVnaXN0ZXJcIjtcbiAgICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gYDsgJHtlcnIubWVzc2FnZX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWVzc2FnZSArPSBgOyBzdGF0dXMgY29kZTogJHtyZXMuc3RhdHVzfWA7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXR1czogNTAwLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgbW9kaWZpZWQ6IGZhbHNlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgZGV2IHNlcnZlciBwb2xscyB0aGlzIGVuZHBvaW50IHRvIHJlZ2lzdGVyIGZ1bmN0aW9ucyBldmVyeSBmZXdcbiAgICAgICAgLy8gc2Vjb25kcywgYnV0IHdlIG9ubHkgd2FudCB0byBsb2cgdGhhdCB3ZSd2ZSByZWdpc3RlcmVkIGZ1bmN0aW9ucyBpZlxuICAgICAgICAvLyB0aGUgZnVuY3Rpb24gZGVmaW5pdGlvbnMgY2hhbmdlLiAgVGhlcmVmb3JlLCB3ZSBjb21wYXJlIHRoZSBib2R5IHNlbnRcbiAgICAgICAgLy8gZHVyaW5nIHJlZ2lzdHJhdGlvbiB3aXRoIHRoZSBib2R5IG9mIHRoZSBjdXJyZW50IGZ1bmN0aW9ucyBhbmQgcmVmdXNlXG4gICAgICAgIC8vIHRvIHJlZ2lzdGVyIGlmIHRoZSBmdW5jdGlvbnMgYXJlIHRoZSBzYW1lLlxuICAgICAgICBpZiAoIXNraXBwZWQpIHtcbiAgICAgICAgICAgIHRoaXMubG9nKFwiZGVidWdcIiwgXCJyZWdpc3RlcmVkIGlubmdlc3QgZnVuY3Rpb25zOlwiLCByZXMuc3RhdHVzLCByZXMuc3RhdHVzVGV4dCwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzLCBtZXNzYWdlOiBlcnJvciwgbW9kaWZpZWQgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYW4gZW52aXJvbm1lbnQsIHVwc2VydCBhbnkgbWlzc2luZyBrZXlzLiBUaGlzIGlzIHVzZWZ1bCBpblxuICAgICAqIHNpdHVhdGlvbnMgd2hlcmUgZW52aXJvbm1lbnQgdmFyaWFibGVzIGFyZSBwYXNzZWQgZGlyZWN0bHkgdG8gaGFuZGxlcnMgb3JcbiAgICAgKiBhcmUgb3RoZXJ3aXNlIGRpZmZpY3VsdCB0byBhY2Nlc3MgZHVyaW5nIGluaXRpYWxpemF0aW9uLlxuICAgICAqL1xuICAgIHVwc2VydEtleXNGcm9tRW52KCkge1xuICAgICAgICBpZiAodGhpcy5lbnZbY29uc3RzX2pzXzEuZW52S2V5cy5Jbm5nZXN0U2lnbmluZ0tleV0pIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zaWduaW5nS2V5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaWduaW5nS2V5ID0gU3RyaW5nKHRoaXMuZW52W2NvbnN0c19qc18xLmVudktleXMuSW5uZ2VzdFNpZ25pbmdLZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2xpZW50W1wiaW5uZ2VzdEFwaVwiXS5zZXRTaWduaW5nS2V5KHRoaXMuc2lnbmluZ0tleSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZW52W2NvbnN0c19qc18xLmVudktleXMuSW5uZ2VzdFNpZ25pbmdLZXlGYWxsYmFja10pIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zaWduaW5nS2V5RmFsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNpZ25pbmdLZXlGYWxsYmFjayA9IFN0cmluZyh0aGlzLmVudltjb25zdHNfanNfMS5lbnZLZXlzLklubmdlc3RTaWduaW5nS2V5RmFsbGJhY2tdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2xpZW50W1wiaW5uZ2VzdEFwaVwiXS5zZXRTaWduaW5nS2V5RmFsbGJhY2sodGhpcy5zaWduaW5nS2V5RmFsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5jbGllbnRbXCJldmVudEtleVNldFwiXSgpICYmIHRoaXMuZW52W2NvbnN0c19qc18xLmVudktleXMuSW5uZ2VzdEV2ZW50S2V5XSkge1xuICAgICAgICAgICAgdGhpcy5jbGllbnQuc2V0RXZlbnRLZXkoU3RyaW5nKHRoaXMuZW52W2NvbnN0c19qc18xLmVudktleXMuSW5uZ2VzdEV2ZW50S2V5XSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHYyIC0+IHYzIG1pZ3JhdGlvbiB3YXJuaW5nc1xuICAgICAgICBpZiAodGhpcy5lbnZbY29uc3RzX2pzXzEuZW52S2V5cy5Jbm5nZXN0RGV2U2VydmVyVXJsXSkge1xuICAgICAgICAgICAgdGhpcy5sb2coXCJ3YXJuXCIsIGBVc2Ugb2YgJHtjb25zdHNfanNfMS5lbnZLZXlzLklubmdlc3REZXZTZXJ2ZXJVcmx9IGhhcyBiZWVuIGRlcHJlY2F0ZWQgaW4gdjM7IHBsZWFzZSB1c2UgJHtjb25zdHNfanNfMS5lbnZLZXlzLklubmdlc3RCYXNlVXJsfSBpbnN0ZWFkLiBTZWUgaHR0cHM6Ly93d3cuaW5uZ2VzdC5jb20vZG9jcy9zZGsvbWlncmF0aW9uYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGUgdGhlIHNpZ25hdHVyZSBvZiBhIHJlcXVlc3QgYW5kIHJldHVybiB0aGUgc2lnbmluZyBrZXkgdXNlZCB0b1xuICAgICAqIHZhbGlkYXRlIGl0LlxuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVxdWlyZS1hd2FpdFxuICAgIGFzeW5jIHZhbGlkYXRlU2lnbmF0dXJlKHNpZywgYm9keSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gU2tpcCBzaWduYXR1cmUgdmFsaWRhdGlvbiBpZiByZXF1ZXN0ZWQgKHVzZWQgYnkgY29ubmVjdClcbiAgICAgICAgICAgIGlmICh0aGlzLnNraXBTaWduYXR1cmVWYWxpZGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwga2V5VXNlZDogXCJcIiB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTmV2ZXIgdmFsaWRhdGUgc2lnbmF0dXJlcyBvdXRzaWRlIG9mIHByb2QuIE1ha2Ugc3VyZSB0byBjaGVjayB0aGUgbW9kZVxuICAgICAgICAgICAgLy8gZXhpc3RzIGhlcmUgaW5zdGVhZCBvZiB1c2luZyBudWxsaXNoIGNvYWxlc2NpbmcgdG8gY29uZmlybSB0aGF0IHRoZSBjaGVja1xuICAgICAgICAgICAgLy8gaGFzIGJlZW4gY29tcGxldGVkLlxuICAgICAgICAgICAgaWYgKHRoaXMuX21vZGUgJiYgIXRoaXMuX21vZGUuaXNDbG91ZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIGtleVVzZWQ6IFwiXCIgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHdlJ3JlIGhlcmUsIHdlJ3JlIGluIHByb2R1Y3Rpb247IGxhY2sgb2YgYSBzaWduaW5nIGtleSBpcyBhbiBlcnJvci5cbiAgICAgICAgICAgIGlmICghdGhpcy5zaWduaW5nS2V5KSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyBQcmV0dHlFcnJvclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gc2lnbmluZyBrZXkgZm91bmQgaW4gY2xpZW50IG9wdGlvbnMgb3IgJHtjb25zdHNfanNfMS5lbnZLZXlzLklubmdlc3RTaWduaW5nS2V5fSBlbnYgdmFyLiBGaW5kIHlvdXIga2V5cyBhdCBodHRwczovL2FwcC5pbm5nZXN0LmNvbS9zZWNyZXRzYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB3ZSdyZSBoZXJlLCB3ZSdyZSBpbiBwcm9kdWN0aW9uOyBsYWNrIG9mIGEgcmVxIHNpZ25hdHVyZSBpcyBhbiBlcnJvci5cbiAgICAgICAgICAgIGlmICghc2lnKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyBQcmV0dHlFcnJvclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gJHtjb25zdHNfanNfMS5oZWFkZXJLZXlzLlNpZ25hdHVyZX0gcHJvdmlkZWRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFZhbGlkYXRlIHRoZSBzaWduYXR1cmVcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBrZXlVc2VkOiBuZXcgUmVxdWVzdFNpZ25hdHVyZShzaWcpLnZlcmlmeVNpZ25hdHVyZSh7XG4gICAgICAgICAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICAgICAgICAgIGFsbG93RXhwaXJlZFNpZ25hdHVyZXM6IHRoaXMuYWxsb3dFeHBpcmVkU2lnbmF0dXJlcyxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmluZ0tleTogdGhpcy5zaWduaW5nS2V5LFxuICAgICAgICAgICAgICAgICAgICBzaWduaW5nS2V5RmFsbGJhY2s6IHRoaXMuc2lnbmluZ0tleUZhbGxiYWNrLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyOiBlcnIgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRSZXNwb25zZVNpZ25hdHVyZShrZXksIGJvZHkpIHtcbiAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgY29uc3QgbWFjID0gKDAsIG5ldF9qc18xLnNpZ25EYXRhV2l0aEtleSkoYm9keSwga2V5LCBub3cudG9TdHJpbmcoKSk7XG4gICAgICAgIHJldHVybiBgdD0ke25vd30mcz0ke21hY31gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2cgdG8gc3Rkb3V0L3N0ZGVyciBpZiB0aGUgbG9nIGxldmVsIGlzIHNldCB0byBpbmNsdWRlIHRoZSBnaXZlbiBsZXZlbC5cbiAgICAgKiBUaGUgZGVmYXVsdCBsb2cgbGV2ZWwgaXMgYFwiaW5mb1wiYC5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgYW4gYWJzdHJhY3Rpb24gb3ZlciBgY29uc29sZS5sb2dgIGFuZCB3aWxsIHRyeSB0byB1c2UgdGhlIGNvcnJlY3RcbiAgICAgKiBtZXRob2QgZm9yIHRoZSBnaXZlbiBsb2cgbGV2ZWwuICBGb3IgZXhhbXBsZSwgYGxvZyhcImVycm9yXCIsIFwiZm9vXCIpYCB3aWxsXG4gICAgICogY2FsbCBgY29uc29sZS5lcnJvcihcImZvb1wiKWAuXG4gICAgICovXG4gICAgbG9nKGxldmVsLCAuLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IGxvZ0xldmVscyA9IFtcbiAgICAgICAgICAgIFwiZGVidWdcIixcbiAgICAgICAgICAgIFwiaW5mb1wiLFxuICAgICAgICAgICAgXCJ3YXJuXCIsXG4gICAgICAgICAgICBcImVycm9yXCIsXG4gICAgICAgICAgICBcImZhdGFsXCIsXG4gICAgICAgICAgICBcInNpbGVudFwiLFxuICAgICAgICBdO1xuICAgICAgICBjb25zdCBsb2dMZXZlbFNldHRpbmcgPSBsb2dMZXZlbHMuaW5kZXhPZih0aGlzLmxvZ0xldmVsKTtcbiAgICAgICAgY29uc3QgY3VycmVudExldmVsID0gbG9nTGV2ZWxzLmluZGV4T2YobGV2ZWwpO1xuICAgICAgICBpZiAoY3VycmVudExldmVsID49IGxvZ0xldmVsU2V0dGluZykge1xuICAgICAgICAgICAgbGV0IGxvZ2dlciA9IGNvbnNvbGUubG9nO1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjb25zb2xlLCBsZXZlbCkpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIgPSBjb25zb2xlW2xldmVsXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlcihgJHtjb25zdHNfanNfMS5sb2dQcmVmaXh9ICR7bGV2ZWx9IC1gLCAuLi5hcmdzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuSW5uZ2VzdENvbW1IYW5kbGVyID0gSW5uZ2VzdENvbW1IYW5kbGVyO1xuY2xhc3MgUmVxdWVzdFNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3Ioc2lnKSB7XG4gICAgICAgIF9SZXF1ZXN0U2lnbmF0dXJlX2luc3RhbmNlcy5hZGQodGhpcyk7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoc2lnKTtcbiAgICAgICAgdGhpcy50aW1lc3RhbXAgPSBwYXJhbXMuZ2V0KFwidFwiKSB8fCBcIlwiO1xuICAgICAgICB0aGlzLnNpZ25hdHVyZSA9IHBhcmFtcy5nZXQoXCJzXCIpIHx8IFwiXCI7XG4gICAgICAgIGlmICghdGhpcy50aW1lc3RhbXAgfHwgIXRoaXMuc2lnbmF0dXJlKSB7XG4gICAgICAgICAgICAvLyBUT0RPIFByZXR0eUVycm9yXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgJHtjb25zdHNfanNfMS5oZWFkZXJLZXlzLlNpZ25hdHVyZX0gcHJvdmlkZWRgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYXNFeHBpcmVkKGFsbG93RXhwaXJlZFNpZ25hdHVyZXMpIHtcbiAgICAgICAgaWYgKGFsbG93RXhwaXJlZFNpZ25hdHVyZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWx0YSA9IERhdGUubm93KCkgLSBuZXcgRGF0ZShwYXJzZUludCh0aGlzLnRpbWVzdGFtcCkgKiAxMDAwKS52YWx1ZU9mKCk7XG4gICAgICAgIHJldHVybiBkZWx0YSA+IDEwMDAgKiA2MCAqIDU7XG4gICAgfVxuICAgIHZlcmlmeVNpZ25hdHVyZSh7IGJvZHksIHNpZ25pbmdLZXksIHNpZ25pbmdLZXlGYWxsYmFjaywgYWxsb3dFeHBpcmVkU2lnbmF0dXJlcywgfSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfUmVxdWVzdFNpZ25hdHVyZV9pbnN0YW5jZXMsIFwibVwiLCBfUmVxdWVzdFNpZ25hdHVyZV92ZXJpZnlTaWduYXR1cmUpLmNhbGwodGhpcywgeyBib2R5LCBzaWduaW5nS2V5LCBhbGxvd0V4cGlyZWRTaWduYXR1cmVzIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHNpZ25pbmdLZXk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKCFzaWduaW5nS2V5RmFsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9SZXF1ZXN0U2lnbmF0dXJlX2luc3RhbmNlcywgXCJtXCIsIF9SZXF1ZXN0U2lnbmF0dXJlX3ZlcmlmeVNpZ25hdHVyZSkuY2FsbCh0aGlzLCB7XG4gICAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgICAgICBzaWduaW5nS2V5OiBzaWduaW5nS2V5RmFsbGJhY2ssXG4gICAgICAgICAgICAgICAgYWxsb3dFeHBpcmVkU2lnbmF0dXJlcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHNpZ25pbmdLZXlGYWxsYmFjaztcbiAgICAgICAgfVxuICAgIH1cbn1cbl9SZXF1ZXN0U2lnbmF0dXJlX2luc3RhbmNlcyA9IG5ldyBXZWFrU2V0KCksIF9SZXF1ZXN0U2lnbmF0dXJlX3ZlcmlmeVNpZ25hdHVyZSA9IGZ1bmN0aW9uIF9SZXF1ZXN0U2lnbmF0dXJlX3ZlcmlmeVNpZ25hdHVyZSh7IGJvZHksIHNpZ25pbmdLZXksIGFsbG93RXhwaXJlZFNpZ25hdHVyZXMsIH0pIHtcbiAgICBpZiAodGhpcy5oYXNFeHBpcmVkKGFsbG93RXhwaXJlZFNpZ25hdHVyZXMpKSB7XG4gICAgICAgIC8vIFRPRE8gUHJldHR5RXJyb3JcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2lnbmF0dXJlIGhhcyBleHBpcmVkXCIpO1xuICAgIH1cbiAgICBjb25zdCBtYWMgPSAoMCwgbmV0X2pzXzEuc2lnbkRhdGFXaXRoS2V5KShib2R5LCBzaWduaW5nS2V5LCB0aGlzLnRpbWVzdGFtcCk7XG4gICAgaWYgKG1hYyAhPT0gdGhpcy5zaWduYXR1cmUpIHtcbiAgICAgICAgLy8gVE9ETyBQcmV0dHlFcnJvclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNpZ25hdHVyZVwiKTtcbiAgICB9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SW5uZ2VzdENvbW1IYW5kbGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/InngestCommHandler.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/InngestFunction.js":
/*!************************************************************!*\
  !*** ./node_modules/inngest/components/InngestFunction.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InngestFunction = void 0;\nconst consts_js_1 = __webpack_require__(/*! ../helpers/consts.js */ \"(rsc)/./node_modules/inngest/helpers/consts.js\");\nconst strings_js_1 = __webpack_require__(/*! ../helpers/strings.js */ \"(rsc)/./node_modules/inngest/helpers/strings.js\");\nconst InngestExecution_js_1 = __webpack_require__(/*! ./execution/InngestExecution.js */ \"(rsc)/./node_modules/inngest/components/execution/InngestExecution.js\");\nconst v0_js_1 = __webpack_require__(/*! ./execution/v0.js */ \"(rsc)/./node_modules/inngest/components/execution/v0.js\");\nconst v1_js_1 = __webpack_require__(/*! ./execution/v1.js */ \"(rsc)/./node_modules/inngest/components/execution/v1.js\");\nconst v2_js_1 = __webpack_require__(/*! ./execution/v2.js */ \"(rsc)/./node_modules/inngest/components/execution/v2.js\");\n/**\n * A stateless Inngest function, wrapping up function configuration and any\n * in-memory steps to run when triggered.\n *\n * This function can be \"registered\" to create a handler that Inngest can\n * trigger remotely.\n *\n * @public\n */\nclass InngestFunction {\n    /**\n     * A stateless Inngest function, wrapping up function configuration and any\n     * in-memory steps to run when triggered.\n     *\n     * This function can be \"registered\" to create a handler that Inngest can\n     * trigger remotely.\n     */\n    constructor(client, \n    /**\n     * Options\n     */\n    opts, fn) {\n        this.client = client;\n        this.opts = opts;\n        this.fn = fn;\n        this.onFailureFn = this.opts.onFailure;\n        this.middleware = this.client[\"initializeMiddleware\"](this.opts.middleware, { registerInput: { fn: this }, prefixStack: this.client[\"middleware\"] });\n    }\n    /**\n     * The generated or given ID for this function.\n     */\n    id(prefix) {\n        return [prefix, this.opts.id].filter(Boolean).join(\"-\");\n    }\n    /**\n     * The generated or given ID for this function, prefixed with the app ID. This\n     * is used for routing invokes and identifying the function across apps.\n     */\n    get absoluteId() {\n        return this.id(this.client.id);\n    }\n    /**\n     * The name of this function as it will appear in the Inngest Cloud UI.\n     */\n    get name() {\n        return this.opts.name || this.id();\n    }\n    /**\n     * The description of this function.\n     */\n    get description() {\n        return this.opts.description;\n    }\n    /**\n     * Retrieve the Inngest config for this function.\n     */\n    getConfig({ baseUrl, appPrefix, isConnect, }) {\n        var _a, _b;\n        const fnId = this.id(appPrefix);\n        const stepUrl = new URL(baseUrl.href);\n        stepUrl.searchParams.set(consts_js_1.queryKeys.FnId, fnId);\n        stepUrl.searchParams.set(consts_js_1.queryKeys.StepId, InngestFunction.stepId);\n        const { retries: attempts, cancelOn, idempotency, batchEvents, rateLimit, throttle, concurrency, debounce, timeouts, priority, singleton, } = this.opts;\n        /**\n         * Convert retries into the format required when defining function\n         * configuration.\n         */\n        const retries = typeof attempts === \"undefined\" ? undefined : { attempts };\n        const fn = {\n            id: fnId,\n            name: this.name,\n            triggers: ((_a = this.opts.triggers) !== null && _a !== void 0 ? _a : []).map((trigger) => {\n                if (\"event\" in trigger) {\n                    return {\n                        event: trigger.event,\n                        expression: trigger.if,\n                    };\n                }\n                return {\n                    cron: trigger.cron,\n                };\n            }),\n            steps: {\n                [InngestFunction.stepId]: {\n                    id: InngestFunction.stepId,\n                    name: InngestFunction.stepId,\n                    runtime: {\n                        type: isConnect ? \"ws\" : \"http\",\n                        url: stepUrl.href,\n                    },\n                    retries,\n                },\n            },\n            idempotency,\n            batchEvents,\n            rateLimit,\n            throttle,\n            concurrency,\n            debounce,\n            priority,\n            timeouts,\n            singleton,\n        };\n        if (cancelOn) {\n            fn.cancel = cancelOn.map(({ event, timeout, if: ifStr, match }) => {\n                const ret = {\n                    event,\n                };\n                if (timeout) {\n                    ret.timeout = (0, strings_js_1.timeStr)(timeout);\n                }\n                if (match) {\n                    ret.if = `event.${match} == async.${match}`;\n                }\n                else if (ifStr) {\n                    ret.if = ifStr;\n                }\n                return ret;\n            }, []);\n        }\n        const config = [fn];\n        if (this.onFailureFn) {\n            const id = `${fn.id}${InngestFunction.failureSuffix}`;\n            const name = `${(_b = fn.name) !== null && _b !== void 0 ? _b : fn.id} (failure)`;\n            const failureStepUrl = new URL(stepUrl.href);\n            failureStepUrl.searchParams.set(consts_js_1.queryKeys.FnId, id);\n            config.push({\n                id,\n                name,\n                triggers: [\n                    {\n                        event: consts_js_1.internalEvents.FunctionFailed,\n                        expression: `event.data.function_id == '${fnId}'`,\n                    },\n                ],\n                steps: {\n                    [InngestFunction.stepId]: {\n                        id: InngestFunction.stepId,\n                        name: InngestFunction.stepId,\n                        runtime: {\n                            type: \"http\",\n                            url: failureStepUrl.href,\n                        },\n                        retries: { attempts: 1 },\n                    },\n                },\n            });\n        }\n        return config;\n    }\n    createExecution(opts) {\n        const options = Object.assign({ fn: this }, opts.partialOptions);\n        const versionHandlers = {\n            [InngestExecution_js_1.ExecutionVersion.V2]: () => (0, v2_js_1.createV2InngestExecution)(options),\n            [InngestExecution_js_1.ExecutionVersion.V1]: () => (0, v1_js_1.createV1InngestExecution)(options),\n            [InngestExecution_js_1.ExecutionVersion.V0]: () => (0, v0_js_1.createV0InngestExecution)(options),\n        };\n        return versionHandlers[opts.version]();\n    }\n    shouldOptimizeParallelism() {\n        var _a, _b;\n        // TODO We should check the commhandler's client instead of this one?\n        return ((_b = (_a = this.opts.optimizeParallelism) !== null && _a !== void 0 ? _a : this.client[\"options\"].optimizeParallelism) !== null && _b !== void 0 ? _b : false);\n    }\n}\nexports.InngestFunction = InngestFunction;\nInngestFunction.stepId = \"step\";\nInngestFunction.failureSuffix = \"-failure\";\n//# sourceMappingURL=InngestFunction.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL0lubmdlc3RGdW5jdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx1QkFBdUI7QUFDdkIsb0JBQW9CLG1CQUFPLENBQUMsNEVBQXNCO0FBQ2xELHFCQUFxQixtQkFBTyxDQUFDLDhFQUF1QjtBQUNwRCw4QkFBOEIsbUJBQU8sQ0FBQyw4R0FBaUM7QUFDdkUsZ0JBQWdCLG1CQUFPLENBQUMsa0ZBQW1CO0FBQzNDLGdCQUFnQixtQkFBTyxDQUFDLGtGQUFtQjtBQUMzQyxnQkFBZ0IsbUJBQU8sQ0FBQyxrRkFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRixpQkFBaUIsVUFBVSwwQ0FBMEM7QUFDM0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnQ0FBZ0M7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvSUFBb0k7QUFDcEo7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msa0NBQWtDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLE9BQU8sV0FBVyxNQUFNO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLE1BQU0sRUFBRSw4QkFBOEI7QUFDaEUsNEJBQTRCLHVEQUF1RDtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLEtBQUs7QUFDdkUscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsbUNBQW1DLGFBQWE7QUFDaEQscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsVUFBVTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aXZlLXZpYmUtYWktbmV4dC8uL25vZGVfbW9kdWxlcy9pbm5nZXN0L2NvbXBvbmVudHMvSW5uZ2VzdEZ1bmN0aW9uLmpzP2RiNDQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLklubmdlc3RGdW5jdGlvbiA9IHZvaWQgMDtcbmNvbnN0IGNvbnN0c19qc18xID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvY29uc3RzLmpzXCIpO1xuY29uc3Qgc3RyaW5nc19qc18xID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvc3RyaW5ncy5qc1wiKTtcbmNvbnN0IElubmdlc3RFeGVjdXRpb25fanNfMSA9IHJlcXVpcmUoXCIuL2V4ZWN1dGlvbi9Jbm5nZXN0RXhlY3V0aW9uLmpzXCIpO1xuY29uc3QgdjBfanNfMSA9IHJlcXVpcmUoXCIuL2V4ZWN1dGlvbi92MC5qc1wiKTtcbmNvbnN0IHYxX2pzXzEgPSByZXF1aXJlKFwiLi9leGVjdXRpb24vdjEuanNcIik7XG5jb25zdCB2Ml9qc18xID0gcmVxdWlyZShcIi4vZXhlY3V0aW9uL3YyLmpzXCIpO1xuLyoqXG4gKiBBIHN0YXRlbGVzcyBJbm5nZXN0IGZ1bmN0aW9uLCB3cmFwcGluZyB1cCBmdW5jdGlvbiBjb25maWd1cmF0aW9uIGFuZCBhbnlcbiAqIGluLW1lbW9yeSBzdGVwcyB0byBydW4gd2hlbiB0cmlnZ2VyZWQuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBjYW4gYmUgXCJyZWdpc3RlcmVkXCIgdG8gY3JlYXRlIGEgaGFuZGxlciB0aGF0IElubmdlc3QgY2FuXG4gKiB0cmlnZ2VyIHJlbW90ZWx5LlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgSW5uZ2VzdEZ1bmN0aW9uIHtcbiAgICAvKipcbiAgICAgKiBBIHN0YXRlbGVzcyBJbm5nZXN0IGZ1bmN0aW9uLCB3cmFwcGluZyB1cCBmdW5jdGlvbiBjb25maWd1cmF0aW9uIGFuZCBhbnlcbiAgICAgKiBpbi1tZW1vcnkgc3RlcHMgdG8gcnVuIHdoZW4gdHJpZ2dlcmVkLlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBjYW4gYmUgXCJyZWdpc3RlcmVkXCIgdG8gY3JlYXRlIGEgaGFuZGxlciB0aGF0IElubmdlc3QgY2FuXG4gICAgICogdHJpZ2dlciByZW1vdGVseS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihjbGllbnQsIFxuICAgIC8qKlxuICAgICAqIE9wdGlvbnNcbiAgICAgKi9cbiAgICBvcHRzLCBmbikge1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICAgICAgdGhpcy5vcHRzID0gb3B0cztcbiAgICAgICAgdGhpcy5mbiA9IGZuO1xuICAgICAgICB0aGlzLm9uRmFpbHVyZUZuID0gdGhpcy5vcHRzLm9uRmFpbHVyZTtcbiAgICAgICAgdGhpcy5taWRkbGV3YXJlID0gdGhpcy5jbGllbnRbXCJpbml0aWFsaXplTWlkZGxld2FyZVwiXSh0aGlzLm9wdHMubWlkZGxld2FyZSwgeyByZWdpc3RlcklucHV0OiB7IGZuOiB0aGlzIH0sIHByZWZpeFN0YWNrOiB0aGlzLmNsaWVudFtcIm1pZGRsZXdhcmVcIl0gfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBnZW5lcmF0ZWQgb3IgZ2l2ZW4gSUQgZm9yIHRoaXMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgaWQocHJlZml4KSB7XG4gICAgICAgIHJldHVybiBbcHJlZml4LCB0aGlzLm9wdHMuaWRdLmZpbHRlcihCb29sZWFuKS5qb2luKFwiLVwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGdlbmVyYXRlZCBvciBnaXZlbiBJRCBmb3IgdGhpcyBmdW5jdGlvbiwgcHJlZml4ZWQgd2l0aCB0aGUgYXBwIElELiBUaGlzXG4gICAgICogaXMgdXNlZCBmb3Igcm91dGluZyBpbnZva2VzIGFuZCBpZGVudGlmeWluZyB0aGUgZnVuY3Rpb24gYWNyb3NzIGFwcHMuXG4gICAgICovXG4gICAgZ2V0IGFic29sdXRlSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlkKHRoaXMuY2xpZW50LmlkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhpcyBmdW5jdGlvbiBhcyBpdCB3aWxsIGFwcGVhciBpbiB0aGUgSW5uZ2VzdCBDbG91ZCBVSS5cbiAgICAgKi9cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0cy5uYW1lIHx8IHRoaXMuaWQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGRlc2NyaXB0aW9uIG9mIHRoaXMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZ2V0IGRlc2NyaXB0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRzLmRlc2NyaXB0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSB0aGUgSW5uZ2VzdCBjb25maWcgZm9yIHRoaXMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZ2V0Q29uZmlnKHsgYmFzZVVybCwgYXBwUHJlZml4LCBpc0Nvbm5lY3QsIH0pIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgZm5JZCA9IHRoaXMuaWQoYXBwUHJlZml4KTtcbiAgICAgICAgY29uc3Qgc3RlcFVybCA9IG5ldyBVUkwoYmFzZVVybC5ocmVmKTtcbiAgICAgICAgc3RlcFVybC5zZWFyY2hQYXJhbXMuc2V0KGNvbnN0c19qc18xLnF1ZXJ5S2V5cy5GbklkLCBmbklkKTtcbiAgICAgICAgc3RlcFVybC5zZWFyY2hQYXJhbXMuc2V0KGNvbnN0c19qc18xLnF1ZXJ5S2V5cy5TdGVwSWQsIElubmdlc3RGdW5jdGlvbi5zdGVwSWQpO1xuICAgICAgICBjb25zdCB7IHJldHJpZXM6IGF0dGVtcHRzLCBjYW5jZWxPbiwgaWRlbXBvdGVuY3ksIGJhdGNoRXZlbnRzLCByYXRlTGltaXQsIHRocm90dGxlLCBjb25jdXJyZW5jeSwgZGVib3VuY2UsIHRpbWVvdXRzLCBwcmlvcml0eSwgc2luZ2xldG9uLCB9ID0gdGhpcy5vcHRzO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydCByZXRyaWVzIGludG8gdGhlIGZvcm1hdCByZXF1aXJlZCB3aGVuIGRlZmluaW5nIGZ1bmN0aW9uXG4gICAgICAgICAqIGNvbmZpZ3VyYXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCByZXRyaWVzID0gdHlwZW9mIGF0dGVtcHRzID09PSBcInVuZGVmaW5lZFwiID8gdW5kZWZpbmVkIDogeyBhdHRlbXB0cyB9O1xuICAgICAgICBjb25zdCBmbiA9IHtcbiAgICAgICAgICAgIGlkOiBmbklkLFxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgdHJpZ2dlcnM6ICgoX2EgPSB0aGlzLm9wdHMudHJpZ2dlcnMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdKS5tYXAoKHRyaWdnZXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoXCJldmVudFwiIGluIHRyaWdnZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiB0cmlnZ2VyLmV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogdHJpZ2dlci5pZixcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgY3JvbjogdHJpZ2dlci5jcm9uLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHN0ZXBzOiB7XG4gICAgICAgICAgICAgICAgW0lubmdlc3RGdW5jdGlvbi5zdGVwSWRdOiB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBJbm5nZXN0RnVuY3Rpb24uc3RlcElkLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBJbm5nZXN0RnVuY3Rpb24uc3RlcElkLFxuICAgICAgICAgICAgICAgICAgICBydW50aW1lOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBpc0Nvbm5lY3QgPyBcIndzXCIgOiBcImh0dHBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogc3RlcFVybC5ocmVmLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICByZXRyaWVzLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaWRlbXBvdGVuY3ksXG4gICAgICAgICAgICBiYXRjaEV2ZW50cyxcbiAgICAgICAgICAgIHJhdGVMaW1pdCxcbiAgICAgICAgICAgIHRocm90dGxlLFxuICAgICAgICAgICAgY29uY3VycmVuY3ksXG4gICAgICAgICAgICBkZWJvdW5jZSxcbiAgICAgICAgICAgIHByaW9yaXR5LFxuICAgICAgICAgICAgdGltZW91dHMsXG4gICAgICAgICAgICBzaW5nbGV0b24sXG4gICAgICAgIH07XG4gICAgICAgIGlmIChjYW5jZWxPbikge1xuICAgICAgICAgICAgZm4uY2FuY2VsID0gY2FuY2VsT24ubWFwKCh7IGV2ZW50LCB0aW1lb3V0LCBpZjogaWZTdHIsIG1hdGNoIH0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0LnRpbWVvdXQgPSAoMCwgc3RyaW5nc19qc18xLnRpbWVTdHIpKHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0LmlmID0gYGV2ZW50LiR7bWF0Y2h9ID09IGFzeW5jLiR7bWF0Y2h9YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaWZTdHIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0LmlmID0gaWZTdHI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9LCBbXSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29uZmlnID0gW2ZuXTtcbiAgICAgICAgaWYgKHRoaXMub25GYWlsdXJlRm4pIHtcbiAgICAgICAgICAgIGNvbnN0IGlkID0gYCR7Zm4uaWR9JHtJbm5nZXN0RnVuY3Rpb24uZmFpbHVyZVN1ZmZpeH1gO1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGAkeyhfYiA9IGZuLm5hbWUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZuLmlkfSAoZmFpbHVyZSlgO1xuICAgICAgICAgICAgY29uc3QgZmFpbHVyZVN0ZXBVcmwgPSBuZXcgVVJMKHN0ZXBVcmwuaHJlZik7XG4gICAgICAgICAgICBmYWlsdXJlU3RlcFVybC5zZWFyY2hQYXJhbXMuc2V0KGNvbnN0c19qc18xLnF1ZXJ5S2V5cy5GbklkLCBpZCk7XG4gICAgICAgICAgICBjb25maWcucHVzaCh7XG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICB0cmlnZ2VyczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudDogY29uc3RzX2pzXzEuaW50ZXJuYWxFdmVudHMuRnVuY3Rpb25GYWlsZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBgZXZlbnQuZGF0YS5mdW5jdGlvbl9pZCA9PSAnJHtmbklkfSdgLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgc3RlcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgW0lubmdlc3RGdW5jdGlvbi5zdGVwSWRdOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogSW5uZ2VzdEZ1bmN0aW9uLnN0ZXBJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IElubmdlc3RGdW5jdGlvbi5zdGVwSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBydW50aW1lOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJodHRwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBmYWlsdXJlU3RlcFVybC5ocmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHJpZXM6IHsgYXR0ZW1wdHM6IDEgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9XG4gICAgY3JlYXRlRXhlY3V0aW9uKG9wdHMpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oeyBmbjogdGhpcyB9LCBvcHRzLnBhcnRpYWxPcHRpb25zKTtcbiAgICAgICAgY29uc3QgdmVyc2lvbkhhbmRsZXJzID0ge1xuICAgICAgICAgICAgW0lubmdlc3RFeGVjdXRpb25fanNfMS5FeGVjdXRpb25WZXJzaW9uLlYyXTogKCkgPT4gKDAsIHYyX2pzXzEuY3JlYXRlVjJJbm5nZXN0RXhlY3V0aW9uKShvcHRpb25zKSxcbiAgICAgICAgICAgIFtJbm5nZXN0RXhlY3V0aW9uX2pzXzEuRXhlY3V0aW9uVmVyc2lvbi5WMV06ICgpID0+ICgwLCB2MV9qc18xLmNyZWF0ZVYxSW5uZ2VzdEV4ZWN1dGlvbikob3B0aW9ucyksXG4gICAgICAgICAgICBbSW5uZ2VzdEV4ZWN1dGlvbl9qc18xLkV4ZWN1dGlvblZlcnNpb24uVjBdOiAoKSA9PiAoMCwgdjBfanNfMS5jcmVhdGVWMElubmdlc3RFeGVjdXRpb24pKG9wdGlvbnMpLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdmVyc2lvbkhhbmRsZXJzW29wdHMudmVyc2lvbl0oKTtcbiAgICB9XG4gICAgc2hvdWxkT3B0aW1pemVQYXJhbGxlbGlzbSgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgLy8gVE9ETyBXZSBzaG91bGQgY2hlY2sgdGhlIGNvbW1oYW5kbGVyJ3MgY2xpZW50IGluc3RlYWQgb2YgdGhpcyBvbmU/XG4gICAgICAgIHJldHVybiAoKF9iID0gKF9hID0gdGhpcy5vcHRzLm9wdGltaXplUGFyYWxsZWxpc20pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMuY2xpZW50W1wib3B0aW9uc1wiXS5vcHRpbWl6ZVBhcmFsbGVsaXNtKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmYWxzZSk7XG4gICAgfVxufVxuZXhwb3J0cy5Jbm5nZXN0RnVuY3Rpb24gPSBJbm5nZXN0RnVuY3Rpb247XG5Jbm5nZXN0RnVuY3Rpb24uc3RlcElkID0gXCJzdGVwXCI7XG5Jbm5nZXN0RnVuY3Rpb24uZmFpbHVyZVN1ZmZpeCA9IFwiLWZhaWx1cmVcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUlubmdlc3RGdW5jdGlvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/InngestFunction.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/InngestFunctionReference.js":
/*!*********************************************************************!*\
  !*** ./node_modules/inngest/components/InngestFunctionReference.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.referenceFunction = exports.InngestFunctionReference = void 0;\n/**\n * A reference to an `InngestFunction` that can be used to represent both local\n * and remote functions without pulling in the full function definition (i.e.\n * dependencies).\n *\n * These references can be invoked in the same manner as a regular\n * `InngestFunction`.\n *\n * To create a reference function, use the {@link referenceFunction} helper.\n *\n * @public\n */\nclass InngestFunctionReference {\n    constructor(opts) {\n        this.opts = opts;\n    }\n}\nexports.InngestFunctionReference = InngestFunctionReference;\n/**\n * Create a reference to an `InngestFunction` that can be used to represent both\n * local and remote functions without pulling in the full function definition\n * (i.e. dependencies).\n *\n * These references can be invoked in the same manner as a regular\n * `InngestFunction`.\n *\n * @public\n */\nconst referenceFunction = ({ functionId, appId, }) => {\n    return new InngestFunctionReference({\n        functionId,\n        appId,\n    });\n};\nexports.referenceFunction = referenceFunction;\n//# sourceMappingURL=InngestFunctionReference.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL0lubmdlc3RGdW5jdGlvblJlZmVyZW5jZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx5QkFBeUIsR0FBRyxnQ0FBZ0M7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyx5QkFBeUI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixvQkFBb0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EseUJBQXlCO0FBQ3pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdml2ZS12aWJlLWFpLW5leHQvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL0lubmdlc3RGdW5jdGlvblJlZmVyZW5jZS5qcz8yNjc4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZWZlcmVuY2VGdW5jdGlvbiA9IGV4cG9ydHMuSW5uZ2VzdEZ1bmN0aW9uUmVmZXJlbmNlID0gdm9pZCAwO1xuLyoqXG4gKiBBIHJlZmVyZW5jZSB0byBhbiBgSW5uZ2VzdEZ1bmN0aW9uYCB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlcHJlc2VudCBib3RoIGxvY2FsXG4gKiBhbmQgcmVtb3RlIGZ1bmN0aW9ucyB3aXRob3V0IHB1bGxpbmcgaW4gdGhlIGZ1bGwgZnVuY3Rpb24gZGVmaW5pdGlvbiAoaS5lLlxuICogZGVwZW5kZW5jaWVzKS5cbiAqXG4gKiBUaGVzZSByZWZlcmVuY2VzIGNhbiBiZSBpbnZva2VkIGluIHRoZSBzYW1lIG1hbm5lciBhcyBhIHJlZ3VsYXJcbiAqIGBJbm5nZXN0RnVuY3Rpb25gLlxuICpcbiAqIFRvIGNyZWF0ZSBhIHJlZmVyZW5jZSBmdW5jdGlvbiwgdXNlIHRoZSB7QGxpbmsgcmVmZXJlbmNlRnVuY3Rpb259IGhlbHBlci5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIElubmdlc3RGdW5jdGlvblJlZmVyZW5jZSB7XG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICB0aGlzLm9wdHMgPSBvcHRzO1xuICAgIH1cbn1cbmV4cG9ydHMuSW5uZ2VzdEZ1bmN0aW9uUmVmZXJlbmNlID0gSW5uZ2VzdEZ1bmN0aW9uUmVmZXJlbmNlO1xuLyoqXG4gKiBDcmVhdGUgYSByZWZlcmVuY2UgdG8gYW4gYElubmdlc3RGdW5jdGlvbmAgdGhhdCBjYW4gYmUgdXNlZCB0byByZXByZXNlbnQgYm90aFxuICogbG9jYWwgYW5kIHJlbW90ZSBmdW5jdGlvbnMgd2l0aG91dCBwdWxsaW5nIGluIHRoZSBmdWxsIGZ1bmN0aW9uIGRlZmluaXRpb25cbiAqIChpLmUuIGRlcGVuZGVuY2llcykuXG4gKlxuICogVGhlc2UgcmVmZXJlbmNlcyBjYW4gYmUgaW52b2tlZCBpbiB0aGUgc2FtZSBtYW5uZXIgYXMgYSByZWd1bGFyXG4gKiBgSW5uZ2VzdEZ1bmN0aW9uYC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IHJlZmVyZW5jZUZ1bmN0aW9uID0gKHsgZnVuY3Rpb25JZCwgYXBwSWQsIH0pID0+IHtcbiAgICByZXR1cm4gbmV3IElubmdlc3RGdW5jdGlvblJlZmVyZW5jZSh7XG4gICAgICAgIGZ1bmN0aW9uSWQsXG4gICAgICAgIGFwcElkLFxuICAgIH0pO1xufTtcbmV4cG9ydHMucmVmZXJlbmNlRnVuY3Rpb24gPSByZWZlcmVuY2VGdW5jdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUlubmdlc3RGdW5jdGlvblJlZmVyZW5jZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/InngestFunctionReference.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/InngestMiddleware.js":
/*!**************************************************************!*\
  !*** ./node_modules/inngest/components/InngestMiddleware.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getHookStack = exports.InngestMiddleware = void 0;\nconst functions_js_1 = __webpack_require__(/*! ../helpers/functions.js */ \"(rsc)/./node_modules/inngest/helpers/functions.js\");\n/**\n * A middleware that can be registered with Inngest to hook into various\n * lifecycles of the SDK and affect input and output of Inngest functionality.\n *\n * See {@link https://innge.st/middleware}\n *\n * @example\n *\n * ```ts\n * export const inngest = new Inngest({\n *   middleware: [\n *     new InngestMiddleware({\n *       name: \"My Middleware\",\n *       init: () => {\n *         // ...\n *       }\n *     })\n *   ]\n * });\n * ```\n *\n * @public\n */\nclass InngestMiddleware {\n    constructor({ name, init }) {\n        this.name = name;\n        this.init = init;\n    }\n}\nexports.InngestMiddleware = InngestMiddleware;\n/**\n * Given some middleware and an entrypoint, runs the initializer for the given\n * `key` and returns functions that will pass arguments through a stack of each\n * given hook in a middleware's lifecycle.\n *\n * Lets the middleware initialize before starting.\n */\nconst getHookStack = async (\n/**\n * The stack of middleware that will be used to run hooks.\n */\nmiddleware, \n/**\n * The hook type to initialize.\n */\nkey, \n/**\n * Arguments for the initial hook.\n */\narg, transforms) => {\n    // Wait for middleware to initialize\n    const mwStack = await middleware;\n    // Step through each middleware and get the hook for the given key\n    const keyFns = mwStack.reduce((acc, mw) => {\n        const fn = mw[key];\n        if (fn) {\n            return [...acc, fn];\n        }\n        return acc;\n    }, []);\n    // Run each hook found in sequence and collect the results\n    const hooksRegistered = await keyFns.reduce(async (acc, fn) => {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return [...(await acc), await fn(arg)];\n    }, Promise.resolve([]));\n    // Prepare the return object - mutating this instead of using reduce as it\n    // results in cleaner code.\n    const ret = {};\n    // Step through each hook result and create a waterfall joining each key\n    for (const hook of hooksRegistered) {\n        const hookKeys = Object.keys(hook);\n        for (const key of hookKeys) {\n            let fns = [hook[key]];\n            const existingWaterfall = ret[key];\n            if (existingWaterfall) {\n                fns = [existingWaterfall, hook[key]];\n            }\n            const transform = transforms[key];\n            ret[key] = (0, functions_js_1.waterfall)(fns, transform);\n        }\n    }\n    // Cache each function in the stack to ensure each can only be called once\n    for (const k of Object.keys(ret)) {\n        const key = k;\n        ret[key] = (0, functions_js_1.cacheFn)(ret[key]);\n    }\n    return ret;\n};\nexports.getHookStack = getHookStack;\n//# sourceMappingURL=InngestMiddleware.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL0lubmdlc3RNaWRkbGV3YXJlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQixHQUFHLHlCQUF5QjtBQUNoRCx1QkFBdUIsbUJBQU8sQ0FBQyxrRkFBeUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdml2ZS12aWJlLWFpLW5leHQvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL0lubmdlc3RNaWRkbGV3YXJlLmpzPzAzN2EiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldEhvb2tTdGFjayA9IGV4cG9ydHMuSW5uZ2VzdE1pZGRsZXdhcmUgPSB2b2lkIDA7XG5jb25zdCBmdW5jdGlvbnNfanNfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL2Z1bmN0aW9ucy5qc1wiKTtcbi8qKlxuICogQSBtaWRkbGV3YXJlIHRoYXQgY2FuIGJlIHJlZ2lzdGVyZWQgd2l0aCBJbm5nZXN0IHRvIGhvb2sgaW50byB2YXJpb3VzXG4gKiBsaWZlY3ljbGVzIG9mIHRoZSBTREsgYW5kIGFmZmVjdCBpbnB1dCBhbmQgb3V0cHV0IG9mIElubmdlc3QgZnVuY3Rpb25hbGl0eS5cbiAqXG4gKiBTZWUge0BsaW5rIGh0dHBzOi8vaW5uZ2Uuc3QvbWlkZGxld2FyZX1cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiBleHBvcnQgY29uc3QgaW5uZ2VzdCA9IG5ldyBJbm5nZXN0KHtcbiAqICAgbWlkZGxld2FyZTogW1xuICogICAgIG5ldyBJbm5nZXN0TWlkZGxld2FyZSh7XG4gKiAgICAgICBuYW1lOiBcIk15IE1pZGRsZXdhcmVcIixcbiAqICAgICAgIGluaXQ6ICgpID0+IHtcbiAqICAgICAgICAgLy8gLi4uXG4gKiAgICAgICB9XG4gKiAgICAgfSlcbiAqICAgXVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIElubmdlc3RNaWRkbGV3YXJlIHtcbiAgICBjb25zdHJ1Y3Rvcih7IG5hbWUsIGluaXQgfSkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmluaXQgPSBpbml0O1xuICAgIH1cbn1cbmV4cG9ydHMuSW5uZ2VzdE1pZGRsZXdhcmUgPSBJbm5nZXN0TWlkZGxld2FyZTtcbi8qKlxuICogR2l2ZW4gc29tZSBtaWRkbGV3YXJlIGFuZCBhbiBlbnRyeXBvaW50LCBydW5zIHRoZSBpbml0aWFsaXplciBmb3IgdGhlIGdpdmVuXG4gKiBga2V5YCBhbmQgcmV0dXJucyBmdW5jdGlvbnMgdGhhdCB3aWxsIHBhc3MgYXJndW1lbnRzIHRocm91Z2ggYSBzdGFjayBvZiBlYWNoXG4gKiBnaXZlbiBob29rIGluIGEgbWlkZGxld2FyZSdzIGxpZmVjeWNsZS5cbiAqXG4gKiBMZXRzIHRoZSBtaWRkbGV3YXJlIGluaXRpYWxpemUgYmVmb3JlIHN0YXJ0aW5nLlxuICovXG5jb25zdCBnZXRIb29rU3RhY2sgPSBhc3luYyAoXG4vKipcbiAqIFRoZSBzdGFjayBvZiBtaWRkbGV3YXJlIHRoYXQgd2lsbCBiZSB1c2VkIHRvIHJ1biBob29rcy5cbiAqL1xubWlkZGxld2FyZSwgXG4vKipcbiAqIFRoZSBob29rIHR5cGUgdG8gaW5pdGlhbGl6ZS5cbiAqL1xua2V5LCBcbi8qKlxuICogQXJndW1lbnRzIGZvciB0aGUgaW5pdGlhbCBob29rLlxuICovXG5hcmcsIHRyYW5zZm9ybXMpID0+IHtcbiAgICAvLyBXYWl0IGZvciBtaWRkbGV3YXJlIHRvIGluaXRpYWxpemVcbiAgICBjb25zdCBtd1N0YWNrID0gYXdhaXQgbWlkZGxld2FyZTtcbiAgICAvLyBTdGVwIHRocm91Z2ggZWFjaCBtaWRkbGV3YXJlIGFuZCBnZXQgdGhlIGhvb2sgZm9yIHRoZSBnaXZlbiBrZXlcbiAgICBjb25zdCBrZXlGbnMgPSBtd1N0YWNrLnJlZHVjZSgoYWNjLCBtdykgPT4ge1xuICAgICAgICBjb25zdCBmbiA9IG13W2tleV07XG4gICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgcmV0dXJuIFsuLi5hY2MsIGZuXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH0sIFtdKTtcbiAgICAvLyBSdW4gZWFjaCBob29rIGZvdW5kIGluIHNlcXVlbmNlIGFuZCBjb2xsZWN0IHRoZSByZXN1bHRzXG4gICAgY29uc3QgaG9va3NSZWdpc3RlcmVkID0gYXdhaXQga2V5Rm5zLnJlZHVjZShhc3luYyAoYWNjLCBmbikgPT4ge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm5cbiAgICAgICAgcmV0dXJuIFsuLi4oYXdhaXQgYWNjKSwgYXdhaXQgZm4oYXJnKV07XG4gICAgfSwgUHJvbWlzZS5yZXNvbHZlKFtdKSk7XG4gICAgLy8gUHJlcGFyZSB0aGUgcmV0dXJuIG9iamVjdCAtIG11dGF0aW5nIHRoaXMgaW5zdGVhZCBvZiB1c2luZyByZWR1Y2UgYXMgaXRcbiAgICAvLyByZXN1bHRzIGluIGNsZWFuZXIgY29kZS5cbiAgICBjb25zdCByZXQgPSB7fTtcbiAgICAvLyBTdGVwIHRocm91Z2ggZWFjaCBob29rIHJlc3VsdCBhbmQgY3JlYXRlIGEgd2F0ZXJmYWxsIGpvaW5pbmcgZWFjaCBrZXlcbiAgICBmb3IgKGNvbnN0IGhvb2sgb2YgaG9va3NSZWdpc3RlcmVkKSB7XG4gICAgICAgIGNvbnN0IGhvb2tLZXlzID0gT2JqZWN0LmtleXMoaG9vayk7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGhvb2tLZXlzKSB7XG4gICAgICAgICAgICBsZXQgZm5zID0gW2hvb2tba2V5XV07XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ1dhdGVyZmFsbCA9IHJldFtrZXldO1xuICAgICAgICAgICAgaWYgKGV4aXN0aW5nV2F0ZXJmYWxsKSB7XG4gICAgICAgICAgICAgICAgZm5zID0gW2V4aXN0aW5nV2F0ZXJmYWxsLCBob29rW2tleV1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gdHJhbnNmb3Jtc1trZXldO1xuICAgICAgICAgICAgcmV0W2tleV0gPSAoMCwgZnVuY3Rpb25zX2pzXzEud2F0ZXJmYWxsKShmbnMsIHRyYW5zZm9ybSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQ2FjaGUgZWFjaCBmdW5jdGlvbiBpbiB0aGUgc3RhY2sgdG8gZW5zdXJlIGVhY2ggY2FuIG9ubHkgYmUgY2FsbGVkIG9uY2VcbiAgICBmb3IgKGNvbnN0IGsgb2YgT2JqZWN0LmtleXMocmV0KSkge1xuICAgICAgICBjb25zdCBrZXkgPSBrO1xuICAgICAgICByZXRba2V5XSA9ICgwLCBmdW5jdGlvbnNfanNfMS5jYWNoZUZuKShyZXRba2V5XSk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59O1xuZXhwb3J0cy5nZXRIb29rU3RhY2sgPSBnZXRIb29rU3RhY2s7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Jbm5nZXN0TWlkZGxld2FyZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/InngestMiddleware.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/InngestStepTools.js":
/*!*************************************************************!*\
  !*** ./node_modules/inngest/components/InngestStepTools.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.invokePayloadSchema = exports.gatewaySymbol = exports.createStepTools = exports.STEP_INDEXING_SUFFIX = exports.getStepOptions = void 0;\nconst ai_1 = __webpack_require__(/*! @inngest/ai */ \"(rsc)/./node_modules/@inngest/ai/dist/index.js\");\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/inngest/node_modules/zod/lib/index.js\");\nconst consts_js_1 = __webpack_require__(/*! ../helpers/consts.js */ \"(rsc)/./node_modules/inngest/helpers/consts.js\");\nconst strings_js_1 = __webpack_require__(/*! ../helpers/strings.js */ \"(rsc)/./node_modules/inngest/helpers/strings.js\");\nconst Temporal = __importStar(__webpack_require__(/*! ../helpers/temporal.js */ \"(rsc)/./node_modules/inngest/helpers/temporal.js\"));\nconst types_js_1 = __webpack_require__(/*! ../types.js */ \"(rsc)/./node_modules/inngest/types.js\");\nconst Fetch_js_1 = __webpack_require__(/*! ./Fetch.js */ \"(rsc)/./node_modules/inngest/components/Fetch.js\");\nconst InngestFunction_js_1 = __webpack_require__(/*! ./InngestFunction.js */ \"(rsc)/./node_modules/inngest/components/InngestFunction.js\");\nconst InngestFunctionReference_js_1 = __webpack_require__(/*! ./InngestFunctionReference.js */ \"(rsc)/./node_modules/inngest/components/InngestFunctionReference.js\");\nconst getStepOptions = (options) => {\n    if (typeof options === \"string\") {\n        return { id: options };\n    }\n    return options;\n};\nexports.getStepOptions = getStepOptions;\n/**\n * Suffix used to namespace steps that are automatically indexed.\n */\nexports.STEP_INDEXING_SUFFIX = \":\";\n/**\n * Create a new set of step function tools ready to be used in a step function.\n * This function should be run and a fresh set of tools provided every time a\n * function is run.\n *\n * An op stack (function state) is passed in as well as some mutable properties\n * that the tools can use to submit a new op.\n */\nconst createStepTools = (client, execution, stepHandler) => {\n    /**\n     * A local helper used to create tools that can be used to submit an op.\n     *\n     * When using this function, a generic type should be provided which is the\n     * function signature exposed to the user.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const createTool = (\n    /**\n     * A function that returns an ID for this op. This is used to ensure that\n     * the op stack is correctly filled, submitted, and retrieved with the same\n     * ID.\n     *\n     * It is passed the arguments passed by the user.\n     *\n     * Most simple tools will likely only need to define this.\n     */\n    matchOp, opts) => {\n        return (async (...args) => {\n            const parsedArgs = args;\n            return stepHandler({ args: parsedArgs, matchOp, opts });\n        });\n    };\n    /**\n     * Create a new step run tool that can be used to run a step function using\n     * `step.run()` as a shim.\n     */\n    const createStepRun = (\n    /**\n     * The sub-type of this step tool, exposed via `opts.type` when the op is\n     * reported.\n     */\n    type) => {\n        return createTool(({ id, name }, _fn, ...input) => {\n            const opts = Object.assign(Object.assign({}, (input.length ? { input } : {})), (type ? { type } : {}));\n            return Object.assign({ id, op: types_js_1.StepOpCode.StepPlanned, name: id, displayName: name !== null && name !== void 0 ? name : id }, (Object.keys(opts).length ? { opts } : {}));\n        }, {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n            fn: (_, fn, ...input) => fn(...input),\n        });\n    };\n    /**\n     * Define the set of tools the user has access to for their step functions.\n     *\n     * Each key is the function name and is expected to run `createTool` and pass\n     * a generic type for that function as it will appear in the user's code.\n     */\n    const tools = {\n        /**\n         * Send one or many events to Inngest. Should always be used in place of\n         * `inngest.send()` to ensure that the event send is successfully retried\n         * and not sent multiple times due to memoisation.\n         *\n         * @example\n         * ```ts\n         * await step.sendEvent(\"emit-user-creation\", {\n         *   name: \"app/user.created\",\n         *   data: { id: 123 },\n         * });\n         *\n         * await step.sendEvent(\"emit-user-updates\", [\n         *   {\n         *     name: \"app/user.created\",\n         *     data: { id: 123 },\n         *   },\n         *   {\n         *     name: \"app/user.feed.created\",\n         *     data: { id: 123 },\n         *   },\n         * ]);\n         * ```\n         *\n         * Returns a promise that will resolve once the event has been sent.\n         */\n        sendEvent: createTool(({ id, name }) => {\n            return {\n                id,\n                op: types_js_1.StepOpCode.StepPlanned,\n                name: \"sendEvent\",\n                displayName: name !== null && name !== void 0 ? name : id,\n                opts: {\n                    type: \"step.sendEvent\",\n                },\n            };\n        }, {\n            fn: (idOrOptions, payload) => {\n                return client[\"_send\"]({\n                    payload,\n                    headers: execution[\"options\"][\"headers\"],\n                });\n            },\n        }),\n        /**\n         * EXPERIMENTAL: This API is not yet stable and may change in the future\n         * without a major version bump.\n         *\n         * Wait for a particular signal to be received before continuing. When the\n         * signal is received, its data will be returned.\n         */\n        waitForSignal: createTool(({ id, name }, opts) => {\n            // TODO Should support Temporal.DurationLike, Temporal.InstantLike,\n            // Temporal.ZonedDateTimeLike\n            return {\n                id,\n                op: types_js_1.StepOpCode.WaitForSignal,\n                name: opts.signal,\n                displayName: name !== null && name !== void 0 ? name : id,\n                opts: {\n                    signal: opts.signal,\n                    timeout: (0, strings_js_1.timeStr)(opts.timeout),\n                    conflict: opts.onConflict,\n                },\n            };\n        }),\n        /**\n         * Send a Signal to Inngest.\n         */\n        sendSignal: createTool(({ id, name }, opts) => {\n            return {\n                id,\n                op: types_js_1.StepOpCode.StepPlanned,\n                name: \"sendSignal\",\n                displayName: name !== null && name !== void 0 ? name : id,\n                opts: {\n                    type: \"step.sendSignal\",\n                    signal: opts.signal,\n                },\n            };\n        }, {\n            fn: (_idOrOptions, opts) => {\n                return client[\"_sendSignal\"]({\n                    signal: opts.signal,\n                    data: opts.data,\n                    headers: execution[\"options\"][\"headers\"],\n                });\n            },\n        }),\n        /**\n         * Wait for a particular event to be received before continuing. When the\n         * event is received, it will be returned.\n         *\n         * You can also provide options to control the particular event that is\n         * received, for example to ensure that a user ID matches between two\n         * events, or to only wait a maximum amount of time before giving up and\n         * returning `null` instead of any event data.\n         */\n        waitForEvent: createTool(({ id, name }, \n        /**\n         * Options to control the event we're waiting for.\n         */\n        opts) => {\n            const matchOpts = {\n                timeout: (0, strings_js_1.timeStr)(typeof opts === \"string\" ? opts : opts.timeout),\n            };\n            if (typeof opts !== \"string\") {\n                if (opts === null || opts === void 0 ? void 0 : opts.match) {\n                    matchOpts.if = `event.${opts.match} == async.${opts.match}`;\n                }\n                else if (opts === null || opts === void 0 ? void 0 : opts.if) {\n                    matchOpts.if = opts.if;\n                }\n            }\n            return {\n                id,\n                op: types_js_1.StepOpCode.WaitForEvent,\n                name: opts.event,\n                opts: matchOpts,\n                displayName: name !== null && name !== void 0 ? name : id,\n            };\n        }),\n        /**\n         * Use this tool to run business logic. Each call to `run` will be retried\n         * individually, meaning you can compose complex workflows that safely\n         * retry dependent asynchronous actions.\n         *\n         * The function you pass to `run` will be called only when this \"step\" is to\n         * be executed and can be synchronous or asynchronous.\n         *\n         * In either case, the return value of the function will be the return value\n         * of the `run` tool, meaning you can return and reason about return data\n         * for next steps.\n         */\n        run: createStepRun(),\n        /**\n         * AI tooling for running AI models and other AI-related tasks.\n         */\n        ai: {\n            /**\n             * Use this tool to have Inngest make your AI calls. Useful for agentic workflows.\n             *\n             * Input is also tracked for this tool, meaning you can pass input to the\n             * function and it will be displayed and editable in the UI.\n             */\n            infer: createTool(({ id, name }, options) => {\n                var _a, _b;\n                const modelCopy = Object.assign({}, options.model);\n                // Allow the model to mutate options and body for this call\n                (_b = (_a = options.model).onCall) === null || _b === void 0 ? void 0 : _b.call(_a, modelCopy, options.body);\n                return {\n                    id,\n                    op: types_js_1.StepOpCode.AiGateway,\n                    displayName: name !== null && name !== void 0 ? name : id,\n                    opts: {\n                        type: \"step.ai.infer\",\n                        url: modelCopy.url,\n                        headers: modelCopy.headers,\n                        auth_key: modelCopy.authKey,\n                        format: modelCopy.format,\n                        body: options.body,\n                    },\n                };\n            }),\n            /**\n             * Use this tool to wrap AI models and other AI-related tasks. Each call\n             * to `wrap` will be retried individually, meaning you can compose complex\n             * workflows that safely retry dependent asynchronous actions.\n             *\n             * Input is also tracked for this tool, meaning you can pass input to the\n             * function and it will be displayed and editable in the UI.\n             */\n            wrap: createStepRun(\"step.ai.wrap\"),\n            /**\n             * Models for AI inference and other AI-related tasks.\n             */\n            models: Object.assign({}, ai_1.models),\n        },\n        /**\n         * Wait a specified amount of time before continuing.\n         *\n         * The time to wait can be specified using a `number` of milliseconds or an\n         * `ms`-compatible time string like `\"1 hour\"`, `\"30 mins\"`, or `\"2.5d\"`.\n         *\n         * {@link https://npm.im/ms}\n         *\n         * To wait until a particular date, use `sleepUntil` instead.\n         */\n        sleep: createTool(({ id, name }, time) => {\n            /**\n             * The presence of this operation in the returned stack indicates that the\n             * sleep is over and we should continue execution.\n             */\n            const msTimeStr = (0, strings_js_1.timeStr)(Temporal.isTemporalDuration(time)\n                ? time.total({ unit: \"milliseconds\" })\n                : time);\n            return {\n                id,\n                op: types_js_1.StepOpCode.Sleep,\n                name: msTimeStr,\n                displayName: name !== null && name !== void 0 ? name : id,\n            };\n        }),\n        /**\n         * Wait until a particular date before continuing by passing a `Date`.\n         *\n         * To wait for a particular amount of time from now, always use `sleep`\n         * instead.\n         */\n        sleepUntil: createTool(({ id, name }, time) => {\n            try {\n                const iso = Temporal.getISOString(time);\n                /**\n                 * The presence of this operation in the returned stack indicates that the\n                 * sleep is over and we should continue execution.\n                 */\n                return {\n                    id,\n                    op: types_js_1.StepOpCode.Sleep,\n                    name: iso,\n                    displayName: name !== null && name !== void 0 ? name : id,\n                };\n            }\n            catch (err) {\n                /**\n                 * If we're here, it's because the date is invalid. We'll throw a custom\n                 * error here to standardise this response.\n                 */\n                // TODO PrettyError\n                console.warn(\"Invalid `Date`, date string, `Temporal.Instant`, or `Temporal.ZonedDateTime` passed to sleepUntil;\", err);\n                // TODO PrettyError\n                throw new Error(`Invalid \\`Date\\`, date string, \\`Temporal.Instant\\`, or \\`Temporal.ZonedDateTime\\` passed to sleepUntil: ${\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                time}`);\n            }\n        }),\n        /**\n         * Invoke a passed Inngest `function` with the given `data`. Returns the\n         * result of the returned value of the function or `null` if the function\n         * does not return a value.\n         *\n         * A string ID can also be passed to reference functions outside of the\n         * current app.\n         */\n        invoke: createTool(({ id, name }, invokeOpts) => {\n            // Create a discriminated union to operate on based on the input types\n            // available for this tool.\n            const optsSchema = exports.invokePayloadSchema.extend({\n                timeout: zod_1.z.union([zod_1.z.number(), zod_1.z.string(), zod_1.z.date()]).optional(),\n            });\n            const parsedFnOpts = optsSchema\n                .extend({\n                _type: zod_1.z.literal(\"fullId\").optional().default(\"fullId\"),\n                function: zod_1.z.string().min(1),\n            })\n                .or(optsSchema.extend({\n                _type: zod_1.z.literal(\"fnInstance\").optional().default(\"fnInstance\"),\n                function: zod_1.z.instanceof(InngestFunction_js_1.InngestFunction),\n            }))\n                .or(optsSchema.extend({\n                _type: zod_1.z.literal(\"refInstance\").optional().default(\"refInstance\"),\n                function: zod_1.z.instanceof(InngestFunctionReference_js_1.InngestFunctionReference),\n            }))\n                .safeParse(invokeOpts);\n            if (!parsedFnOpts.success) {\n                throw new Error(`Invalid invocation options passed to invoke; must include either a function or functionId.`);\n            }\n            const { _type, function: fn, data, user, v, timeout } = parsedFnOpts.data;\n            const payload = { data, user, v };\n            const opts = {\n                payload,\n                function_id: \"\",\n                timeout: typeof timeout === \"undefined\" ? undefined : (0, strings_js_1.timeStr)(timeout),\n            };\n            switch (_type) {\n                case \"fnInstance\":\n                    opts.function_id = fn.id(fn[\"client\"].id);\n                    break;\n                case \"fullId\":\n                    console.warn(`${consts_js_1.logPrefix} Invoking function with \\`function: string\\` is deprecated and will be removed in v4.0.0; use an imported function or \\`referenceFunction()\\` instead. See https://innge.st/ts-referencing-functions`);\n                    opts.function_id = fn;\n                    break;\n                case \"refInstance\":\n                    opts.function_id = [fn.opts.appId || client.id, fn.opts.functionId]\n                        .filter(Boolean)\n                        .join(\"-\");\n                    break;\n            }\n            return {\n                id,\n                op: types_js_1.StepOpCode.InvokeFunction,\n                displayName: name !== null && name !== void 0 ? name : id,\n                opts,\n            };\n        }),\n        /**\n         * `step.fetch` is a Fetch-API-compatible function that can be used to make\n         * any HTTP code durable if it's called within an Inngest function.\n         *\n         * It will gracefully fall back to the global `fetch` if called outside of\n         * this context, and a custom fallback can be set using the `config` method.\n         */\n        fetch: Fetch_js_1.fetch,\n    };\n    // Add an uptyped gateway\n    tools[exports.gatewaySymbol] = createTool(({ id, name }, input, init) => {\n        var _a;\n        const url = input instanceof Request ? input.url : input.toString();\n        const headers = {};\n        if (input instanceof Request) {\n            input.headers.forEach((value, key) => (headers[key] = value));\n        }\n        else if (init === null || init === void 0 ? void 0 : init.headers) {\n            const h = new Headers(init.headers);\n            h.forEach((value, key) => (headers[key] = value));\n        }\n        return {\n            id,\n            op: types_js_1.StepOpCode.Gateway,\n            displayName: name !== null && name !== void 0 ? name : id,\n            opts: {\n                url,\n                method: (_a = init === null || init === void 0 ? void 0 : init.method) !== null && _a !== void 0 ? _a : \"GET\",\n                headers,\n                body: init === null || init === void 0 ? void 0 : init.body,\n            },\n        };\n    });\n    return tools;\n};\nexports.createStepTools = createStepTools;\nexports.gatewaySymbol = Symbol.for(\"inngest.step.gateway\");\n/**\n * The event payload portion of the options for `step.invoke()`. This does not\n * include non-payload options like `timeout` or the function to invoke.\n */\nexports.invokePayloadSchema = zod_1.z.object({\n    data: zod_1.z.record(zod_1.z.any()).optional(),\n    user: zod_1.z.record(zod_1.z.any()).optional(),\n    v: zod_1.z.string().optional(),\n});\n//# sourceMappingURL=InngestStepTools.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL0lubmdlc3RTdGVwVG9vbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxjQUFjO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMkJBQTJCLEdBQUcscUJBQXFCLEdBQUcsdUJBQXVCLEdBQUcsNEJBQTRCLEdBQUcsc0JBQXNCO0FBQ3JJLGFBQWEsbUJBQU8sQ0FBQyxtRUFBYTtBQUNsQyxjQUFjLG1CQUFPLENBQUMsdUVBQUs7QUFDM0Isb0JBQW9CLG1CQUFPLENBQUMsNEVBQXNCO0FBQ2xELHFCQUFxQixtQkFBTyxDQUFDLDhFQUF1QjtBQUNwRCw4QkFBOEIsbUJBQU8sQ0FBQyxnRkFBd0I7QUFDOUQsbUJBQW1CLG1CQUFPLENBQUMsMERBQWE7QUFDeEMsbUJBQW1CLG1CQUFPLENBQUMsb0VBQVk7QUFDdkMsNkJBQTZCLG1CQUFPLENBQUMsd0ZBQXNCO0FBQzNELHNDQUFzQyxtQkFBTyxDQUFDLDBHQUErQjtBQUM3RTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixVQUFVO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBLG9CQUFvQiw4Q0FBOEM7QUFDbEUsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHVCQUF1Qix5RkFBeUY7QUFDcEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxVQUFVO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpdmUtdmliZS1haS1uZXh0Ly4vbm9kZV9tb2R1bGVzL2lubmdlc3QvY29tcG9uZW50cy9Jbm5nZXN0U3RlcFRvb2xzLmpzPzEzMjgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG93bktleXMgPSBmdW5jdGlvbihvKSB7XG4gICAgICAgIG93bktleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgdmFyIGFyID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBrIGluIG8pIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgaykpIGFyW2FyLmxlbmd0aF0gPSBrO1xuICAgICAgICAgICAgcmV0dXJuIGFyO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gb3duS2V5cyhvKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAobW9kKSB7XG4gICAgICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrID0gb3duS2V5cyhtb2QpLCBpID0gMDsgaSA8IGsubGVuZ3RoOyBpKyspIGlmIChrW2ldICE9PSBcImRlZmF1bHRcIikgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrW2ldKTtcbiAgICAgICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaW52b2tlUGF5bG9hZFNjaGVtYSA9IGV4cG9ydHMuZ2F0ZXdheVN5bWJvbCA9IGV4cG9ydHMuY3JlYXRlU3RlcFRvb2xzID0gZXhwb3J0cy5TVEVQX0lOREVYSU5HX1NVRkZJWCA9IGV4cG9ydHMuZ2V0U3RlcE9wdGlvbnMgPSB2b2lkIDA7XG5jb25zdCBhaV8xID0gcmVxdWlyZShcIkBpbm5nZXN0L2FpXCIpO1xuY29uc3Qgem9kXzEgPSByZXF1aXJlKFwiem9kXCIpO1xuY29uc3QgY29uc3RzX2pzXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9jb25zdHMuanNcIik7XG5jb25zdCBzdHJpbmdzX2pzXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9zdHJpbmdzLmpzXCIpO1xuY29uc3QgVGVtcG9yYWwgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL2hlbHBlcnMvdGVtcG9yYWwuanNcIikpO1xuY29uc3QgdHlwZXNfanNfMSA9IHJlcXVpcmUoXCIuLi90eXBlcy5qc1wiKTtcbmNvbnN0IEZldGNoX2pzXzEgPSByZXF1aXJlKFwiLi9GZXRjaC5qc1wiKTtcbmNvbnN0IElubmdlc3RGdW5jdGlvbl9qc18xID0gcmVxdWlyZShcIi4vSW5uZ2VzdEZ1bmN0aW9uLmpzXCIpO1xuY29uc3QgSW5uZ2VzdEZ1bmN0aW9uUmVmZXJlbmNlX2pzXzEgPSByZXF1aXJlKFwiLi9Jbm5nZXN0RnVuY3Rpb25SZWZlcmVuY2UuanNcIik7XG5jb25zdCBnZXRTdGVwT3B0aW9ucyA9IChvcHRpb25zKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiB7IGlkOiBvcHRpb25zIH07XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xufTtcbmV4cG9ydHMuZ2V0U3RlcE9wdGlvbnMgPSBnZXRTdGVwT3B0aW9ucztcbi8qKlxuICogU3VmZml4IHVzZWQgdG8gbmFtZXNwYWNlIHN0ZXBzIHRoYXQgYXJlIGF1dG9tYXRpY2FsbHkgaW5kZXhlZC5cbiAqL1xuZXhwb3J0cy5TVEVQX0lOREVYSU5HX1NVRkZJWCA9IFwiOlwiO1xuLyoqXG4gKiBDcmVhdGUgYSBuZXcgc2V0IG9mIHN0ZXAgZnVuY3Rpb24gdG9vbHMgcmVhZHkgdG8gYmUgdXNlZCBpbiBhIHN0ZXAgZnVuY3Rpb24uXG4gKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBiZSBydW4gYW5kIGEgZnJlc2ggc2V0IG9mIHRvb2xzIHByb3ZpZGVkIGV2ZXJ5IHRpbWUgYVxuICogZnVuY3Rpb24gaXMgcnVuLlxuICpcbiAqIEFuIG9wIHN0YWNrIChmdW5jdGlvbiBzdGF0ZSkgaXMgcGFzc2VkIGluIGFzIHdlbGwgYXMgc29tZSBtdXRhYmxlIHByb3BlcnRpZXNcbiAqIHRoYXQgdGhlIHRvb2xzIGNhbiB1c2UgdG8gc3VibWl0IGEgbmV3IG9wLlxuICovXG5jb25zdCBjcmVhdGVTdGVwVG9vbHMgPSAoY2xpZW50LCBleGVjdXRpb24sIHN0ZXBIYW5kbGVyKSA9PiB7XG4gICAgLyoqXG4gICAgICogQSBsb2NhbCBoZWxwZXIgdXNlZCB0byBjcmVhdGUgdG9vbHMgdGhhdCBjYW4gYmUgdXNlZCB0byBzdWJtaXQgYW4gb3AuXG4gICAgICpcbiAgICAgKiBXaGVuIHVzaW5nIHRoaXMgZnVuY3Rpb24sIGEgZ2VuZXJpYyB0eXBlIHNob3VsZCBiZSBwcm92aWRlZCB3aGljaCBpcyB0aGVcbiAgICAgKiBmdW5jdGlvbiBzaWduYXR1cmUgZXhwb3NlZCB0byB0aGUgdXNlci5cbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGNvbnN0IGNyZWF0ZVRvb2wgPSAoXG4gICAgLyoqXG4gICAgICogQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gSUQgZm9yIHRoaXMgb3AuIFRoaXMgaXMgdXNlZCB0byBlbnN1cmUgdGhhdFxuICAgICAqIHRoZSBvcCBzdGFjayBpcyBjb3JyZWN0bHkgZmlsbGVkLCBzdWJtaXR0ZWQsIGFuZCByZXRyaWV2ZWQgd2l0aCB0aGUgc2FtZVxuICAgICAqIElELlxuICAgICAqXG4gICAgICogSXQgaXMgcGFzc2VkIHRoZSBhcmd1bWVudHMgcGFzc2VkIGJ5IHRoZSB1c2VyLlxuICAgICAqXG4gICAgICogTW9zdCBzaW1wbGUgdG9vbHMgd2lsbCBsaWtlbHkgb25seSBuZWVkIHRvIGRlZmluZSB0aGlzLlxuICAgICAqL1xuICAgIG1hdGNoT3AsIG9wdHMpID0+IHtcbiAgICAgICAgcmV0dXJuIChhc3luYyAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkQXJncyA9IGFyZ3M7XG4gICAgICAgICAgICByZXR1cm4gc3RlcEhhbmRsZXIoeyBhcmdzOiBwYXJzZWRBcmdzLCBtYXRjaE9wLCBvcHRzIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBzdGVwIHJ1biB0b29sIHRoYXQgY2FuIGJlIHVzZWQgdG8gcnVuIGEgc3RlcCBmdW5jdGlvbiB1c2luZ1xuICAgICAqIGBzdGVwLnJ1bigpYCBhcyBhIHNoaW0uXG4gICAgICovXG4gICAgY29uc3QgY3JlYXRlU3RlcFJ1biA9IChcbiAgICAvKipcbiAgICAgKiBUaGUgc3ViLXR5cGUgb2YgdGhpcyBzdGVwIHRvb2wsIGV4cG9zZWQgdmlhIGBvcHRzLnR5cGVgIHdoZW4gdGhlIG9wIGlzXG4gICAgICogcmVwb3J0ZWQuXG4gICAgICovXG4gICAgdHlwZSkgPT4ge1xuICAgICAgICByZXR1cm4gY3JlYXRlVG9vbCgoeyBpZCwgbmFtZSB9LCBfZm4sIC4uLmlucHV0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvcHRzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAoaW5wdXQubGVuZ3RoID8geyBpbnB1dCB9IDoge30pKSwgKHR5cGUgPyB7IHR5cGUgfSA6IHt9KSk7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7IGlkLCBvcDogdHlwZXNfanNfMS5TdGVwT3BDb2RlLlN0ZXBQbGFubmVkLCBuYW1lOiBpZCwgZGlzcGxheU5hbWU6IG5hbWUgIT09IG51bGwgJiYgbmFtZSAhPT0gdm9pZCAwID8gbmFtZSA6IGlkIH0sIChPYmplY3Qua2V5cyhvcHRzKS5sZW5ndGggPyB7IG9wdHMgfSA6IHt9KSk7XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50XG4gICAgICAgICAgICBmbjogKF8sIGZuLCAuLi5pbnB1dCkgPT4gZm4oLi4uaW5wdXQpLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERlZmluZSB0aGUgc2V0IG9mIHRvb2xzIHRoZSB1c2VyIGhhcyBhY2Nlc3MgdG8gZm9yIHRoZWlyIHN0ZXAgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogRWFjaCBrZXkgaXMgdGhlIGZ1bmN0aW9uIG5hbWUgYW5kIGlzIGV4cGVjdGVkIHRvIHJ1biBgY3JlYXRlVG9vbGAgYW5kIHBhc3NcbiAgICAgKiBhIGdlbmVyaWMgdHlwZSBmb3IgdGhhdCBmdW5jdGlvbiBhcyBpdCB3aWxsIGFwcGVhciBpbiB0aGUgdXNlcidzIGNvZGUuXG4gICAgICovXG4gICAgY29uc3QgdG9vbHMgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZW5kIG9uZSBvciBtYW55IGV2ZW50cyB0byBJbm5nZXN0LiBTaG91bGQgYWx3YXlzIGJlIHVzZWQgaW4gcGxhY2Ugb2ZcbiAgICAgICAgICogYGlubmdlc3Quc2VuZCgpYCB0byBlbnN1cmUgdGhhdCB0aGUgZXZlbnQgc2VuZCBpcyBzdWNjZXNzZnVsbHkgcmV0cmllZFxuICAgICAgICAgKiBhbmQgbm90IHNlbnQgbXVsdGlwbGUgdGltZXMgZHVlIHRvIG1lbW9pc2F0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGB0c1xuICAgICAgICAgKiBhd2FpdCBzdGVwLnNlbmRFdmVudChcImVtaXQtdXNlci1jcmVhdGlvblwiLCB7XG4gICAgICAgICAqICAgbmFtZTogXCJhcHAvdXNlci5jcmVhdGVkXCIsXG4gICAgICAgICAqICAgZGF0YTogeyBpZDogMTIzIH0sXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBhd2FpdCBzdGVwLnNlbmRFdmVudChcImVtaXQtdXNlci11cGRhdGVzXCIsIFtcbiAgICAgICAgICogICB7XG4gICAgICAgICAqICAgICBuYW1lOiBcImFwcC91c2VyLmNyZWF0ZWRcIixcbiAgICAgICAgICogICAgIGRhdGE6IHsgaWQ6IDEyMyB9LFxuICAgICAgICAgKiAgIH0sXG4gICAgICAgICAqICAge1xuICAgICAgICAgKiAgICAgbmFtZTogXCJhcHAvdXNlci5mZWVkLmNyZWF0ZWRcIixcbiAgICAgICAgICogICAgIGRhdGE6IHsgaWQ6IDEyMyB9LFxuICAgICAgICAgKiAgIH0sXG4gICAgICAgICAqIF0pO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICpcbiAgICAgICAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCB3aWxsIHJlc29sdmUgb25jZSB0aGUgZXZlbnQgaGFzIGJlZW4gc2VudC5cbiAgICAgICAgICovXG4gICAgICAgIHNlbmRFdmVudDogY3JlYXRlVG9vbCgoeyBpZCwgbmFtZSB9KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIG9wOiB0eXBlc19qc18xLlN0ZXBPcENvZGUuU3RlcFBsYW5uZWQsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJzZW5kRXZlbnRcIixcbiAgICAgICAgICAgICAgICBkaXNwbGF5TmFtZTogbmFtZSAhPT0gbnVsbCAmJiBuYW1lICE9PSB2b2lkIDAgPyBuYW1lIDogaWQsXG4gICAgICAgICAgICAgICAgb3B0czoge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN0ZXAuc2VuZEV2ZW50XCIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGZuOiAoaWRPck9wdGlvbnMsIHBheWxvYWQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xpZW50W1wiX3NlbmRcIl0oe1xuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBleGVjdXRpb25bXCJvcHRpb25zXCJdW1wiaGVhZGVyc1wiXSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pLFxuICAgICAgICAvKipcbiAgICAgICAgICogRVhQRVJJTUVOVEFMOiBUaGlzIEFQSSBpcyBub3QgeWV0IHN0YWJsZSBhbmQgbWF5IGNoYW5nZSBpbiB0aGUgZnV0dXJlXG4gICAgICAgICAqIHdpdGhvdXQgYSBtYWpvciB2ZXJzaW9uIGJ1bXAuXG4gICAgICAgICAqXG4gICAgICAgICAqIFdhaXQgZm9yIGEgcGFydGljdWxhciBzaWduYWwgdG8gYmUgcmVjZWl2ZWQgYmVmb3JlIGNvbnRpbnVpbmcuIFdoZW4gdGhlXG4gICAgICAgICAqIHNpZ25hbCBpcyByZWNlaXZlZCwgaXRzIGRhdGEgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgICAgICovXG4gICAgICAgIHdhaXRGb3JTaWduYWw6IGNyZWF0ZVRvb2woKHsgaWQsIG5hbWUgfSwgb3B0cykgPT4ge1xuICAgICAgICAgICAgLy8gVE9ETyBTaG91bGQgc3VwcG9ydCBUZW1wb3JhbC5EdXJhdGlvbkxpa2UsIFRlbXBvcmFsLkluc3RhbnRMaWtlLFxuICAgICAgICAgICAgLy8gVGVtcG9yYWwuWm9uZWREYXRlVGltZUxpa2VcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgb3A6IHR5cGVzX2pzXzEuU3RlcE9wQ29kZS5XYWl0Rm9yU2lnbmFsLFxuICAgICAgICAgICAgICAgIG5hbWU6IG9wdHMuc2lnbmFsLFxuICAgICAgICAgICAgICAgIGRpc3BsYXlOYW1lOiBuYW1lICE9PSBudWxsICYmIG5hbWUgIT09IHZvaWQgMCA/IG5hbWUgOiBpZCxcbiAgICAgICAgICAgICAgICBvcHRzOiB7XG4gICAgICAgICAgICAgICAgICAgIHNpZ25hbDogb3B0cy5zaWduYWwsXG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXQ6ICgwLCBzdHJpbmdzX2pzXzEudGltZVN0cikob3B0cy50aW1lb3V0KSxcbiAgICAgICAgICAgICAgICAgICAgY29uZmxpY3Q6IG9wdHMub25Db25mbGljdCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZW5kIGEgU2lnbmFsIHRvIElubmdlc3QuXG4gICAgICAgICAqL1xuICAgICAgICBzZW5kU2lnbmFsOiBjcmVhdGVUb29sKCh7IGlkLCBuYW1lIH0sIG9wdHMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgb3A6IHR5cGVzX2pzXzEuU3RlcE9wQ29kZS5TdGVwUGxhbm5lZCxcbiAgICAgICAgICAgICAgICBuYW1lOiBcInNlbmRTaWduYWxcIixcbiAgICAgICAgICAgICAgICBkaXNwbGF5TmFtZTogbmFtZSAhPT0gbnVsbCAmJiBuYW1lICE9PSB2b2lkIDAgPyBuYW1lIDogaWQsXG4gICAgICAgICAgICAgICAgb3B0czoge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN0ZXAuc2VuZFNpZ25hbFwiLFxuICAgICAgICAgICAgICAgICAgICBzaWduYWw6IG9wdHMuc2lnbmFsLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBmbjogKF9pZE9yT3B0aW9ucywgb3B0cykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjbGllbnRbXCJfc2VuZFNpZ25hbFwiXSh7XG4gICAgICAgICAgICAgICAgICAgIHNpZ25hbDogb3B0cy5zaWduYWwsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IG9wdHMuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogZXhlY3V0aW9uW1wib3B0aW9uc1wiXVtcImhlYWRlcnNcIl0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdhaXQgZm9yIGEgcGFydGljdWxhciBldmVudCB0byBiZSByZWNlaXZlZCBiZWZvcmUgY29udGludWluZy4gV2hlbiB0aGVcbiAgICAgICAgICogZXZlbnQgaXMgcmVjZWl2ZWQsIGl0IHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFlvdSBjYW4gYWxzbyBwcm92aWRlIG9wdGlvbnMgdG8gY29udHJvbCB0aGUgcGFydGljdWxhciBldmVudCB0aGF0IGlzXG4gICAgICAgICAqIHJlY2VpdmVkLCBmb3IgZXhhbXBsZSB0byBlbnN1cmUgdGhhdCBhIHVzZXIgSUQgbWF0Y2hlcyBiZXR3ZWVuIHR3b1xuICAgICAgICAgKiBldmVudHMsIG9yIHRvIG9ubHkgd2FpdCBhIG1heGltdW0gYW1vdW50IG9mIHRpbWUgYmVmb3JlIGdpdmluZyB1cCBhbmRcbiAgICAgICAgICogcmV0dXJuaW5nIGBudWxsYCBpbnN0ZWFkIG9mIGFueSBldmVudCBkYXRhLlxuICAgICAgICAgKi9cbiAgICAgICAgd2FpdEZvckV2ZW50OiBjcmVhdGVUb29sKCh7IGlkLCBuYW1lIH0sIFxuICAgICAgICAvKipcbiAgICAgICAgICogT3B0aW9ucyB0byBjb250cm9sIHRoZSBldmVudCB3ZSdyZSB3YWl0aW5nIGZvci5cbiAgICAgICAgICovXG4gICAgICAgIG9wdHMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoT3B0cyA9IHtcbiAgICAgICAgICAgICAgICB0aW1lb3V0OiAoMCwgc3RyaW5nc19qc18xLnRpbWVTdHIpKHR5cGVvZiBvcHRzID09PSBcInN0cmluZ1wiID8gb3B0cyA6IG9wdHMudGltZW91dCksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRzICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5tYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaE9wdHMuaWYgPSBgZXZlbnQuJHtvcHRzLm1hdGNofSA9PSBhc3luYy4ke29wdHMubWF0Y2h9YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLmlmKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoT3B0cy5pZiA9IG9wdHMuaWY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBvcDogdHlwZXNfanNfMS5TdGVwT3BDb2RlLldhaXRGb3JFdmVudCxcbiAgICAgICAgICAgICAgICBuYW1lOiBvcHRzLmV2ZW50LFxuICAgICAgICAgICAgICAgIG9wdHM6IG1hdGNoT3B0cyxcbiAgICAgICAgICAgICAgICBkaXNwbGF5TmFtZTogbmFtZSAhPT0gbnVsbCAmJiBuYW1lICE9PSB2b2lkIDAgPyBuYW1lIDogaWQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVzZSB0aGlzIHRvb2wgdG8gcnVuIGJ1c2luZXNzIGxvZ2ljLiBFYWNoIGNhbGwgdG8gYHJ1bmAgd2lsbCBiZSByZXRyaWVkXG4gICAgICAgICAqIGluZGl2aWR1YWxseSwgbWVhbmluZyB5b3UgY2FuIGNvbXBvc2UgY29tcGxleCB3b3JrZmxvd3MgdGhhdCBzYWZlbHlcbiAgICAgICAgICogcmV0cnkgZGVwZW5kZW50IGFzeW5jaHJvbm91cyBhY3Rpb25zLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgZnVuY3Rpb24geW91IHBhc3MgdG8gYHJ1bmAgd2lsbCBiZSBjYWxsZWQgb25seSB3aGVuIHRoaXMgXCJzdGVwXCIgaXMgdG9cbiAgICAgICAgICogYmUgZXhlY3V0ZWQgYW5kIGNhbiBiZSBzeW5jaHJvbm91cyBvciBhc3luY2hyb25vdXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEluIGVpdGhlciBjYXNlLCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmdW5jdGlvbiB3aWxsIGJlIHRoZSByZXR1cm4gdmFsdWVcbiAgICAgICAgICogb2YgdGhlIGBydW5gIHRvb2wsIG1lYW5pbmcgeW91IGNhbiByZXR1cm4gYW5kIHJlYXNvbiBhYm91dCByZXR1cm4gZGF0YVxuICAgICAgICAgKiBmb3IgbmV4dCBzdGVwcy5cbiAgICAgICAgICovXG4gICAgICAgIHJ1bjogY3JlYXRlU3RlcFJ1bigpLFxuICAgICAgICAvKipcbiAgICAgICAgICogQUkgdG9vbGluZyBmb3IgcnVubmluZyBBSSBtb2RlbHMgYW5kIG90aGVyIEFJLXJlbGF0ZWQgdGFza3MuXG4gICAgICAgICAqL1xuICAgICAgICBhaToge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBVc2UgdGhpcyB0b29sIHRvIGhhdmUgSW5uZ2VzdCBtYWtlIHlvdXIgQUkgY2FsbHMuIFVzZWZ1bCBmb3IgYWdlbnRpYyB3b3JrZmxvd3MuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogSW5wdXQgaXMgYWxzbyB0cmFja2VkIGZvciB0aGlzIHRvb2wsIG1lYW5pbmcgeW91IGNhbiBwYXNzIGlucHV0IHRvIHRoZVxuICAgICAgICAgICAgICogZnVuY3Rpb24gYW5kIGl0IHdpbGwgYmUgZGlzcGxheWVkIGFuZCBlZGl0YWJsZSBpbiB0aGUgVUkuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGluZmVyOiBjcmVhdGVUb29sKCh7IGlkLCBuYW1lIH0sIG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vZGVsQ29weSA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMubW9kZWwpO1xuICAgICAgICAgICAgICAgIC8vIEFsbG93IHRoZSBtb2RlbCB0byBtdXRhdGUgb3B0aW9ucyBhbmQgYm9keSBmb3IgdGhpcyBjYWxsXG4gICAgICAgICAgICAgICAgKF9iID0gKF9hID0gb3B0aW9ucy5tb2RlbCkub25DYWxsKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgbW9kZWxDb3B5LCBvcHRpb25zLmJvZHkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICBvcDogdHlwZXNfanNfMS5TdGVwT3BDb2RlLkFpR2F0ZXdheSxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheU5hbWU6IG5hbWUgIT09IG51bGwgJiYgbmFtZSAhPT0gdm9pZCAwID8gbmFtZSA6IGlkLFxuICAgICAgICAgICAgICAgICAgICBvcHRzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN0ZXAuYWkuaW5mZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogbW9kZWxDb3B5LnVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IG1vZGVsQ29weS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXV0aF9rZXk6IG1vZGVsQ29weS5hdXRoS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiBtb2RlbENvcHkuZm9ybWF0LFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogb3B0aW9ucy5ib2R5LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVXNlIHRoaXMgdG9vbCB0byB3cmFwIEFJIG1vZGVscyBhbmQgb3RoZXIgQUktcmVsYXRlZCB0YXNrcy4gRWFjaCBjYWxsXG4gICAgICAgICAgICAgKiB0byBgd3JhcGAgd2lsbCBiZSByZXRyaWVkIGluZGl2aWR1YWxseSwgbWVhbmluZyB5b3UgY2FuIGNvbXBvc2UgY29tcGxleFxuICAgICAgICAgICAgICogd29ya2Zsb3dzIHRoYXQgc2FmZWx5IHJldHJ5IGRlcGVuZGVudCBhc3luY2hyb25vdXMgYWN0aW9ucy5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBJbnB1dCBpcyBhbHNvIHRyYWNrZWQgZm9yIHRoaXMgdG9vbCwgbWVhbmluZyB5b3UgY2FuIHBhc3MgaW5wdXQgdG8gdGhlXG4gICAgICAgICAgICAgKiBmdW5jdGlvbiBhbmQgaXQgd2lsbCBiZSBkaXNwbGF5ZWQgYW5kIGVkaXRhYmxlIGluIHRoZSBVSS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgd3JhcDogY3JlYXRlU3RlcFJ1bihcInN0ZXAuYWkud3JhcFwiKSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTW9kZWxzIGZvciBBSSBpbmZlcmVuY2UgYW5kIG90aGVyIEFJLXJlbGF0ZWQgdGFza3MuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIG1vZGVsczogT2JqZWN0LmFzc2lnbih7fSwgYWlfMS5tb2RlbHMpLFxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogV2FpdCBhIHNwZWNpZmllZCBhbW91bnQgb2YgdGltZSBiZWZvcmUgY29udGludWluZy5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIHRpbWUgdG8gd2FpdCBjYW4gYmUgc3BlY2lmaWVkIHVzaW5nIGEgYG51bWJlcmAgb2YgbWlsbGlzZWNvbmRzIG9yIGFuXG4gICAgICAgICAqIGBtc2AtY29tcGF0aWJsZSB0aW1lIHN0cmluZyBsaWtlIGBcIjEgaG91clwiYCwgYFwiMzAgbWluc1wiYCwgb3IgYFwiMi41ZFwiYC5cbiAgICAgICAgICpcbiAgICAgICAgICoge0BsaW5rIGh0dHBzOi8vbnBtLmltL21zfVxuICAgICAgICAgKlxuICAgICAgICAgKiBUbyB3YWl0IHVudGlsIGEgcGFydGljdWxhciBkYXRlLCB1c2UgYHNsZWVwVW50aWxgIGluc3RlYWQuXG4gICAgICAgICAqL1xuICAgICAgICBzbGVlcDogY3JlYXRlVG9vbCgoeyBpZCwgbmFtZSB9LCB0aW1lKSA9PiB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSBwcmVzZW5jZSBvZiB0aGlzIG9wZXJhdGlvbiBpbiB0aGUgcmV0dXJuZWQgc3RhY2sgaW5kaWNhdGVzIHRoYXQgdGhlXG4gICAgICAgICAgICAgKiBzbGVlcCBpcyBvdmVyIGFuZCB3ZSBzaG91bGQgY29udGludWUgZXhlY3V0aW9uLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zdCBtc1RpbWVTdHIgPSAoMCwgc3RyaW5nc19qc18xLnRpbWVTdHIpKFRlbXBvcmFsLmlzVGVtcG9yYWxEdXJhdGlvbih0aW1lKVxuICAgICAgICAgICAgICAgID8gdGltZS50b3RhbCh7IHVuaXQ6IFwibWlsbGlzZWNvbmRzXCIgfSlcbiAgICAgICAgICAgICAgICA6IHRpbWUpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBvcDogdHlwZXNfanNfMS5TdGVwT3BDb2RlLlNsZWVwLFxuICAgICAgICAgICAgICAgIG5hbWU6IG1zVGltZVN0cixcbiAgICAgICAgICAgICAgICBkaXNwbGF5TmFtZTogbmFtZSAhPT0gbnVsbCAmJiBuYW1lICE9PSB2b2lkIDAgPyBuYW1lIDogaWQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdhaXQgdW50aWwgYSBwYXJ0aWN1bGFyIGRhdGUgYmVmb3JlIGNvbnRpbnVpbmcgYnkgcGFzc2luZyBhIGBEYXRlYC5cbiAgICAgICAgICpcbiAgICAgICAgICogVG8gd2FpdCBmb3IgYSBwYXJ0aWN1bGFyIGFtb3VudCBvZiB0aW1lIGZyb20gbm93LCBhbHdheXMgdXNlIGBzbGVlcGBcbiAgICAgICAgICogaW5zdGVhZC5cbiAgICAgICAgICovXG4gICAgICAgIHNsZWVwVW50aWw6IGNyZWF0ZVRvb2woKHsgaWQsIG5hbWUgfSwgdGltZSkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpc28gPSBUZW1wb3JhbC5nZXRJU09TdHJpbmcodGltZSk7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogVGhlIHByZXNlbmNlIG9mIHRoaXMgb3BlcmF0aW9uIGluIHRoZSByZXR1cm5lZCBzdGFjayBpbmRpY2F0ZXMgdGhhdCB0aGVcbiAgICAgICAgICAgICAgICAgKiBzbGVlcCBpcyBvdmVyIGFuZCB3ZSBzaG91bGQgY29udGludWUgZXhlY3V0aW9uLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICBvcDogdHlwZXNfanNfMS5TdGVwT3BDb2RlLlNsZWVwLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBpc28sXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlOYW1lOiBuYW1lICE9PSBudWxsICYmIG5hbWUgIT09IHZvaWQgMCA/IG5hbWUgOiBpZCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIElmIHdlJ3JlIGhlcmUsIGl0J3MgYmVjYXVzZSB0aGUgZGF0ZSBpcyBpbnZhbGlkLiBXZSdsbCB0aHJvdyBhIGN1c3RvbVxuICAgICAgICAgICAgICAgICAqIGVycm9yIGhlcmUgdG8gc3RhbmRhcmRpc2UgdGhpcyByZXNwb25zZS5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAvLyBUT0RPIFByZXR0eUVycm9yXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiSW52YWxpZCBgRGF0ZWAsIGRhdGUgc3RyaW5nLCBgVGVtcG9yYWwuSW5zdGFudGAsIG9yIGBUZW1wb3JhbC5ab25lZERhdGVUaW1lYCBwYXNzZWQgdG8gc2xlZXBVbnRpbDtcIiwgZXJyKTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPIFByZXR0eUVycm9yXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIFxcYERhdGVcXGAsIGRhdGUgc3RyaW5nLCBcXGBUZW1wb3JhbC5JbnN0YW50XFxgLCBvciBcXGBUZW1wb3JhbC5ab25lZERhdGVUaW1lXFxgIHBhc3NlZCB0byBzbGVlcFVudGlsOiAke1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgdGltZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnZva2UgYSBwYXNzZWQgSW5uZ2VzdCBgZnVuY3Rpb25gIHdpdGggdGhlIGdpdmVuIGBkYXRhYC4gUmV0dXJucyB0aGVcbiAgICAgICAgICogcmVzdWx0IG9mIHRoZSByZXR1cm5lZCB2YWx1ZSBvZiB0aGUgZnVuY3Rpb24gb3IgYG51bGxgIGlmIHRoZSBmdW5jdGlvblxuICAgICAgICAgKiBkb2VzIG5vdCByZXR1cm4gYSB2YWx1ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQSBzdHJpbmcgSUQgY2FuIGFsc28gYmUgcGFzc2VkIHRvIHJlZmVyZW5jZSBmdW5jdGlvbnMgb3V0c2lkZSBvZiB0aGVcbiAgICAgICAgICogY3VycmVudCBhcHAuXG4gICAgICAgICAqL1xuICAgICAgICBpbnZva2U6IGNyZWF0ZVRvb2woKHsgaWQsIG5hbWUgfSwgaW52b2tlT3B0cykgPT4ge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgZGlzY3JpbWluYXRlZCB1bmlvbiB0byBvcGVyYXRlIG9uIGJhc2VkIG9uIHRoZSBpbnB1dCB0eXBlc1xuICAgICAgICAgICAgLy8gYXZhaWxhYmxlIGZvciB0aGlzIHRvb2wuXG4gICAgICAgICAgICBjb25zdCBvcHRzU2NoZW1hID0gZXhwb3J0cy5pbnZva2VQYXlsb2FkU2NoZW1hLmV4dGVuZCh7XG4gICAgICAgICAgICAgICAgdGltZW91dDogem9kXzEuei51bmlvbihbem9kXzEuei5udW1iZXIoKSwgem9kXzEuei5zdHJpbmcoKSwgem9kXzEuei5kYXRlKCldKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRGbk9wdHMgPSBvcHRzU2NoZW1hXG4gICAgICAgICAgICAgICAgLmV4dGVuZCh7XG4gICAgICAgICAgICAgICAgX3R5cGU6IHpvZF8xLnoubGl0ZXJhbChcImZ1bGxJZFwiKS5vcHRpb25hbCgpLmRlZmF1bHQoXCJmdWxsSWRcIiksXG4gICAgICAgICAgICAgICAgZnVuY3Rpb246IHpvZF8xLnouc3RyaW5nKCkubWluKDEpLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAub3Iob3B0c1NjaGVtYS5leHRlbmQoe1xuICAgICAgICAgICAgICAgIF90eXBlOiB6b2RfMS56LmxpdGVyYWwoXCJmbkluc3RhbmNlXCIpLm9wdGlvbmFsKCkuZGVmYXVsdChcImZuSW5zdGFuY2VcIiksXG4gICAgICAgICAgICAgICAgZnVuY3Rpb246IHpvZF8xLnouaW5zdGFuY2VvZihJbm5nZXN0RnVuY3Rpb25fanNfMS5Jbm5nZXN0RnVuY3Rpb24pLFxuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgICAgLm9yKG9wdHNTY2hlbWEuZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICBfdHlwZTogem9kXzEuei5saXRlcmFsKFwicmVmSW5zdGFuY2VcIikub3B0aW9uYWwoKS5kZWZhdWx0KFwicmVmSW5zdGFuY2VcIiksXG4gICAgICAgICAgICAgICAgZnVuY3Rpb246IHpvZF8xLnouaW5zdGFuY2VvZihJbm5nZXN0RnVuY3Rpb25SZWZlcmVuY2VfanNfMS5Jbm5nZXN0RnVuY3Rpb25SZWZlcmVuY2UpLFxuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgICAgLnNhZmVQYXJzZShpbnZva2VPcHRzKTtcbiAgICAgICAgICAgIGlmICghcGFyc2VkRm5PcHRzLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgaW52b2NhdGlvbiBvcHRpb25zIHBhc3NlZCB0byBpbnZva2U7IG11c3QgaW5jbHVkZSBlaXRoZXIgYSBmdW5jdGlvbiBvciBmdW5jdGlvbklkLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBfdHlwZSwgZnVuY3Rpb246IGZuLCBkYXRhLCB1c2VyLCB2LCB0aW1lb3V0IH0gPSBwYXJzZWRGbk9wdHMuZGF0YTtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB7IGRhdGEsIHVzZXIsIHYgfTtcbiAgICAgICAgICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbl9pZDogXCJcIixcbiAgICAgICAgICAgICAgICB0aW1lb3V0OiB0eXBlb2YgdGltZW91dCA9PT0gXCJ1bmRlZmluZWRcIiA/IHVuZGVmaW5lZCA6ICgwLCBzdHJpbmdzX2pzXzEudGltZVN0cikodGltZW91dCksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc3dpdGNoIChfdHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmbkluc3RhbmNlXCI6XG4gICAgICAgICAgICAgICAgICAgIG9wdHMuZnVuY3Rpb25faWQgPSBmbi5pZChmbltcImNsaWVudFwiXS5pZCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmdWxsSWRcIjpcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGAke2NvbnN0c19qc18xLmxvZ1ByZWZpeH0gSW52b2tpbmcgZnVuY3Rpb24gd2l0aCBcXGBmdW5jdGlvbjogc3RyaW5nXFxgIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB2NC4wLjA7IHVzZSBhbiBpbXBvcnRlZCBmdW5jdGlvbiBvciBcXGByZWZlcmVuY2VGdW5jdGlvbigpXFxgIGluc3RlYWQuIFNlZSBodHRwczovL2lubmdlLnN0L3RzLXJlZmVyZW5jaW5nLWZ1bmN0aW9uc2ApO1xuICAgICAgICAgICAgICAgICAgICBvcHRzLmZ1bmN0aW9uX2lkID0gZm47XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJyZWZJbnN0YW5jZVwiOlxuICAgICAgICAgICAgICAgICAgICBvcHRzLmZ1bmN0aW9uX2lkID0gW2ZuLm9wdHMuYXBwSWQgfHwgY2xpZW50LmlkLCBmbi5vcHRzLmZ1bmN0aW9uSWRdXG4gICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICAgICAgICAgICAgICAgICAgICAgICAuam9pbihcIi1cIik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBvcDogdHlwZXNfanNfMS5TdGVwT3BDb2RlLkludm9rZUZ1bmN0aW9uLFxuICAgICAgICAgICAgICAgIGRpc3BsYXlOYW1lOiBuYW1lICE9PSBudWxsICYmIG5hbWUgIT09IHZvaWQgMCA/IG5hbWUgOiBpZCxcbiAgICAgICAgICAgICAgICBvcHRzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBgc3RlcC5mZXRjaGAgaXMgYSBGZXRjaC1BUEktY29tcGF0aWJsZSBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIG1ha2VcbiAgICAgICAgICogYW55IEhUVFAgY29kZSBkdXJhYmxlIGlmIGl0J3MgY2FsbGVkIHdpdGhpbiBhbiBJbm5nZXN0IGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJdCB3aWxsIGdyYWNlZnVsbHkgZmFsbCBiYWNrIHRvIHRoZSBnbG9iYWwgYGZldGNoYCBpZiBjYWxsZWQgb3V0c2lkZSBvZlxuICAgICAgICAgKiB0aGlzIGNvbnRleHQsIGFuZCBhIGN1c3RvbSBmYWxsYmFjayBjYW4gYmUgc2V0IHVzaW5nIHRoZSBgY29uZmlnYCBtZXRob2QuXG4gICAgICAgICAqL1xuICAgICAgICBmZXRjaDogRmV0Y2hfanNfMS5mZXRjaCxcbiAgICB9O1xuICAgIC8vIEFkZCBhbiB1cHR5cGVkIGdhdGV3YXlcbiAgICB0b29sc1tleHBvcnRzLmdhdGV3YXlTeW1ib2xdID0gY3JlYXRlVG9vbCgoeyBpZCwgbmFtZSB9LCBpbnB1dCwgaW5pdCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHVybCA9IGlucHV0IGluc3RhbmNlb2YgUmVxdWVzdCA/IGlucHV0LnVybCA6IGlucHV0LnRvU3RyaW5nKCk7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgUmVxdWVzdCkge1xuICAgICAgICAgICAgaW5wdXQuaGVhZGVycy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiAoaGVhZGVyc1trZXldID0gdmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbml0ID09PSBudWxsIHx8IGluaXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluaXQuaGVhZGVycykge1xuICAgICAgICAgICAgY29uc3QgaCA9IG5ldyBIZWFkZXJzKGluaXQuaGVhZGVycyk7XG4gICAgICAgICAgICBoLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IChoZWFkZXJzW2tleV0gPSB2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIG9wOiB0eXBlc19qc18xLlN0ZXBPcENvZGUuR2F0ZXdheSxcbiAgICAgICAgICAgIGRpc3BsYXlOYW1lOiBuYW1lICE9PSBudWxsICYmIG5hbWUgIT09IHZvaWQgMCA/IG5hbWUgOiBpZCxcbiAgICAgICAgICAgIG9wdHM6IHtcbiAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAoX2EgPSBpbml0ID09PSBudWxsIHx8IGluaXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluaXQubWV0aG9kKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIkdFVFwiLFxuICAgICAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogaW5pdCA9PT0gbnVsbCB8fCBpbml0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbml0LmJvZHksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiB0b29scztcbn07XG5leHBvcnRzLmNyZWF0ZVN0ZXBUb29scyA9IGNyZWF0ZVN0ZXBUb29scztcbmV4cG9ydHMuZ2F0ZXdheVN5bWJvbCA9IFN5bWJvbC5mb3IoXCJpbm5nZXN0LnN0ZXAuZ2F0ZXdheVwiKTtcbi8qKlxuICogVGhlIGV2ZW50IHBheWxvYWQgcG9ydGlvbiBvZiB0aGUgb3B0aW9ucyBmb3IgYHN0ZXAuaW52b2tlKClgLiBUaGlzIGRvZXMgbm90XG4gKiBpbmNsdWRlIG5vbi1wYXlsb2FkIG9wdGlvbnMgbGlrZSBgdGltZW91dGAgb3IgdGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAqL1xuZXhwb3J0cy5pbnZva2VQYXlsb2FkU2NoZW1hID0gem9kXzEuei5vYmplY3Qoe1xuICAgIGRhdGE6IHpvZF8xLnoucmVjb3JkKHpvZF8xLnouYW55KCkpLm9wdGlvbmFsKCksXG4gICAgdXNlcjogem9kXzEuei5yZWNvcmQoem9kXzEuei5hbnkoKSkub3B0aW9uYWwoKSxcbiAgICB2OiB6b2RfMS56LnN0cmluZygpLm9wdGlvbmFsKCksXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUlubmdlc3RTdGVwVG9vbHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/InngestStepTools.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/NonRetriableError.js":
/*!**************************************************************!*\
  !*** ./node_modules/inngest/components/NonRetriableError.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.NonRetriableError = void 0;\n/**\n * An error that, when thrown, indicates to Inngest that the function should\n * cease all execution and not retry.\n *\n * A `message` must be provided, and an optional `cause` can be provided to\n * provide more context to the error.\n *\n * @public\n */\nclass NonRetriableError extends Error {\n    constructor(message, options) {\n        super(message);\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        this.cause = options === null || options === void 0 ? void 0 : options.cause;\n        this.name = \"NonRetriableError\";\n    }\n}\nexports.NonRetriableError = NonRetriableError;\n//# sourceMappingURL=NonRetriableError.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL05vblJldHJpYWJsZUVycm9yLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdml2ZS12aWJlLWFpLW5leHQvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL05vblJldHJpYWJsZUVycm9yLmpzPzk4ZGQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk5vblJldHJpYWJsZUVycm9yID0gdm9pZCAwO1xuLyoqXG4gKiBBbiBlcnJvciB0aGF0LCB3aGVuIHRocm93biwgaW5kaWNhdGVzIHRvIElubmdlc3QgdGhhdCB0aGUgZnVuY3Rpb24gc2hvdWxkXG4gKiBjZWFzZSBhbGwgZXhlY3V0aW9uIGFuZCBub3QgcmV0cnkuXG4gKlxuICogQSBgbWVzc2FnZWAgbXVzdCBiZSBwcm92aWRlZCwgYW5kIGFuIG9wdGlvbmFsIGBjYXVzZWAgY2FuIGJlIHByb3ZpZGVkIHRvXG4gKiBwcm92aWRlIG1vcmUgY29udGV4dCB0byB0aGUgZXJyb3IuXG4gKlxuICogQHB1YmxpY1xuICovXG5jbGFzcyBOb25SZXRyaWFibGVFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50XG4gICAgICAgIHRoaXMuY2F1c2UgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2F1c2U7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiTm9uUmV0cmlhYmxlRXJyb3JcIjtcbiAgICB9XG59XG5leHBvcnRzLk5vblJldHJpYWJsZUVycm9yID0gTm9uUmV0cmlhYmxlRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Ob25SZXRyaWFibGVFcnJvci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/NonRetriableError.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/RetryAfterError.js":
/*!************************************************************!*\
  !*** ./node_modules/inngest/components/RetryAfterError.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RetryAfterError = void 0;\nconst ms_1 = __importDefault(__webpack_require__(/*! ms */ \"(rsc)/./node_modules/ms/index.js\"));\n/**\n * An error that, when thrown, indicates to Inngest that the function should be\n * retried after a given amount of time.\n *\n * A `message` must be provided, as well as a `retryAfter` parameter, which can\n * be a `number` of milliseconds, an `ms`-compatible time string, or a `Date`.\n *\n * An optional `cause` can be provided to provide more context to the error.\n *\n * @public\n */\nclass RetryAfterError extends Error {\n    constructor(message, \n    /**\n     * The time after which the function should be retried. Represents either a\n     * number of milliseconds or a RFC3339 date.\n     */\n    retryAfter, options) {\n        super(message);\n        if (retryAfter instanceof Date) {\n            this.retryAfter = retryAfter.toISOString();\n        }\n        else {\n            const seconds = `${Math.ceil((typeof retryAfter === \"string\" ? (0, ms_1.default)(retryAfter) : retryAfter) / 1000)}`;\n            if (!isFinite(Number(seconds))) {\n                throw new Error(\"retryAfter must be a number of milliseconds, a ms-compatible string, or a Date\");\n            }\n            this.retryAfter = seconds;\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        this.cause = options === null || options === void 0 ? void 0 : options.cause;\n    }\n}\nexports.RetryAfterError = RetryAfterError;\n//# sourceMappingURL=RetryAfterError.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL1JldHJ5QWZ0ZXJFcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHVCQUF1QjtBQUN2Qiw2QkFBNkIsbUJBQU8sQ0FBQyw0Q0FBSTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGdHQUFnRztBQUMvSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aXZlLXZpYmUtYWktbmV4dC8uL25vZGVfbW9kdWxlcy9pbm5nZXN0L2NvbXBvbmVudHMvUmV0cnlBZnRlckVycm9yLmpzPzA5OGEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJldHJ5QWZ0ZXJFcnJvciA9IHZvaWQgMDtcbmNvbnN0IG1zXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIm1zXCIpKTtcbi8qKlxuICogQW4gZXJyb3IgdGhhdCwgd2hlbiB0aHJvd24sIGluZGljYXRlcyB0byBJbm5nZXN0IHRoYXQgdGhlIGZ1bmN0aW9uIHNob3VsZCBiZVxuICogcmV0cmllZCBhZnRlciBhIGdpdmVuIGFtb3VudCBvZiB0aW1lLlxuICpcbiAqIEEgYG1lc3NhZ2VgIG11c3QgYmUgcHJvdmlkZWQsIGFzIHdlbGwgYXMgYSBgcmV0cnlBZnRlcmAgcGFyYW1ldGVyLCB3aGljaCBjYW5cbiAqIGJlIGEgYG51bWJlcmAgb2YgbWlsbGlzZWNvbmRzLCBhbiBgbXNgLWNvbXBhdGlibGUgdGltZSBzdHJpbmcsIG9yIGEgYERhdGVgLlxuICpcbiAqIEFuIG9wdGlvbmFsIGBjYXVzZWAgY2FuIGJlIHByb3ZpZGVkIHRvIHByb3ZpZGUgbW9yZSBjb250ZXh0IHRvIHRoZSBlcnJvci5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIFJldHJ5QWZ0ZXJFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBcbiAgICAvKipcbiAgICAgKiBUaGUgdGltZSBhZnRlciB3aGljaCB0aGUgZnVuY3Rpb24gc2hvdWxkIGJlIHJldHJpZWQuIFJlcHJlc2VudHMgZWl0aGVyIGFcbiAgICAgKiBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIG9yIGEgUkZDMzMzOSBkYXRlLlxuICAgICAqL1xuICAgIHJldHJ5QWZ0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIGlmIChyZXRyeUFmdGVyIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5yZXRyeUFmdGVyID0gcmV0cnlBZnRlci50b0lTT1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc2Vjb25kcyA9IGAke01hdGguY2VpbCgodHlwZW9mIHJldHJ5QWZ0ZXIgPT09IFwic3RyaW5nXCIgPyAoMCwgbXNfMS5kZWZhdWx0KShyZXRyeUFmdGVyKSA6IHJldHJ5QWZ0ZXIpIC8gMTAwMCl9YDtcbiAgICAgICAgICAgIGlmICghaXNGaW5pdGUoTnVtYmVyKHNlY29uZHMpKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInJldHJ5QWZ0ZXIgbXVzdCBiZSBhIG51bWJlciBvZiBtaWxsaXNlY29uZHMsIGEgbXMtY29tcGF0aWJsZSBzdHJpbmcsIG9yIGEgRGF0ZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmV0cnlBZnRlciA9IHNlY29uZHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgICAgICB0aGlzLmNhdXNlID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNhdXNlO1xuICAgIH1cbn1cbmV4cG9ydHMuUmV0cnlBZnRlckVycm9yID0gUmV0cnlBZnRlckVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmV0cnlBZnRlckVycm9yLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/RetryAfterError.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/StepError.js":
/*!******************************************************!*\
  !*** ./node_modules/inngest/components/StepError.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.StepError = void 0;\nconst errors_js_1 = __webpack_require__(/*! ../helpers/errors.js */ \"(rsc)/./node_modules/inngest/helpers/errors.js\");\nconst types_js_1 = __webpack_require__(/*! ../types.js */ \"(rsc)/./node_modules/inngest/types.js\");\n/**\n * An error that represents a step exhausting all retries and failing. This is\n * thrown by an Inngest step if it fails.\n *\n * It's synonymous with an `Error`, with the addition of the `stepId` that\n * failed.\n *\n * @public\n */\nclass StepError extends Error {\n    constructor(\n    /**\n     * The ID of the step that failed.\n     */\n    stepId, err) {\n        var _a;\n        const parsedErr = types_js_1.jsonErrorSchema.parse(err);\n        super(parsedErr.message);\n        this.stepId = stepId;\n        this.name = parsedErr.name;\n        this.stepId = stepId;\n        // Don't show the internal stack trace if we don't have one.\n        this.stack = (_a = parsedErr.stack) !== null && _a !== void 0 ? _a : undefined;\n        // Try setting the cause if we have one\n        this.cause = parsedErr.cause\n            ? (0, errors_js_1.deserializeError)(parsedErr.cause, true)\n            : undefined;\n    }\n}\nexports.StepError = StepError;\n//# sourceMappingURL=StepError.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL1N0ZXBFcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUI7QUFDakIsb0JBQW9CLG1CQUFPLENBQUMsNEVBQXNCO0FBQ2xELG1CQUFtQixtQkFBTyxDQUFDLDBEQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aXZlLXZpYmUtYWktbmV4dC8uL25vZGVfbW9kdWxlcy9pbm5nZXN0L2NvbXBvbmVudHMvU3RlcEVycm9yLmpzP2ZmNWEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlN0ZXBFcnJvciA9IHZvaWQgMDtcbmNvbnN0IGVycm9yc19qc18xID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvZXJyb3JzLmpzXCIpO1xuY29uc3QgdHlwZXNfanNfMSA9IHJlcXVpcmUoXCIuLi90eXBlcy5qc1wiKTtcbi8qKlxuICogQW4gZXJyb3IgdGhhdCByZXByZXNlbnRzIGEgc3RlcCBleGhhdXN0aW5nIGFsbCByZXRyaWVzIGFuZCBmYWlsaW5nLiBUaGlzIGlzXG4gKiB0aHJvd24gYnkgYW4gSW5uZ2VzdCBzdGVwIGlmIGl0IGZhaWxzLlxuICpcbiAqIEl0J3Mgc3lub255bW91cyB3aXRoIGFuIGBFcnJvcmAsIHdpdGggdGhlIGFkZGl0aW9uIG9mIHRoZSBgc3RlcElkYCB0aGF0XG4gKiBmYWlsZWQuXG4gKlxuICogQHB1YmxpY1xuICovXG5jbGFzcyBTdGVwRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgICogVGhlIElEIG9mIHRoZSBzdGVwIHRoYXQgZmFpbGVkLlxuICAgICAqL1xuICAgIHN0ZXBJZCwgZXJyKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgcGFyc2VkRXJyID0gdHlwZXNfanNfMS5qc29uRXJyb3JTY2hlbWEucGFyc2UoZXJyKTtcbiAgICAgICAgc3VwZXIocGFyc2VkRXJyLm1lc3NhZ2UpO1xuICAgICAgICB0aGlzLnN0ZXBJZCA9IHN0ZXBJZDtcbiAgICAgICAgdGhpcy5uYW1lID0gcGFyc2VkRXJyLm5hbWU7XG4gICAgICAgIHRoaXMuc3RlcElkID0gc3RlcElkO1xuICAgICAgICAvLyBEb24ndCBzaG93IHRoZSBpbnRlcm5hbCBzdGFjayB0cmFjZSBpZiB3ZSBkb24ndCBoYXZlIG9uZS5cbiAgICAgICAgdGhpcy5zdGFjayA9IChfYSA9IHBhcnNlZEVyci5zdGFjaykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdW5kZWZpbmVkO1xuICAgICAgICAvLyBUcnkgc2V0dGluZyB0aGUgY2F1c2UgaWYgd2UgaGF2ZSBvbmVcbiAgICAgICAgdGhpcy5jYXVzZSA9IHBhcnNlZEVyci5jYXVzZVxuICAgICAgICAgICAgPyAoMCwgZXJyb3JzX2pzXzEuZGVzZXJpYWxpemVFcnJvcikocGFyc2VkRXJyLmNhdXNlLCB0cnVlKVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxufVxuZXhwb3J0cy5TdGVwRXJyb3IgPSBTdGVwRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdGVwRXJyb3IuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/StepError.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/execution/InngestExecution.js":
/*!***********************************************************************!*\
  !*** ./node_modules/inngest/components/execution/InngestExecution.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InngestExecution = exports.PREFERRED_EXECUTION_VERSION = exports.ExecutionVersion = void 0;\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\"));\nconst consts_js_1 = __webpack_require__(/*! ../../helpers/consts.js */ \"(rsc)/./node_modules/inngest/helpers/consts.js\");\n/**\n * The execution models the SDK is aware of.\n *\n * This is used in a number of places to ensure all execution versions are\n * accounted for for a given operation.\n */\nvar ExecutionVersion;\n(function (ExecutionVersion) {\n    ExecutionVersion[ExecutionVersion[\"V0\"] = 0] = \"V0\";\n    ExecutionVersion[ExecutionVersion[\"V1\"] = 1] = \"V1\";\n    ExecutionVersion[ExecutionVersion[\"V2\"] = 2] = \"V2\";\n})(ExecutionVersion || (exports.ExecutionVersion = ExecutionVersion = {}));\n/**\n * The preferred execution version that will be used by the SDK when handling\n * brand new runs where the Executor is allowing us to choose.\n *\n * Changing this should not ever be a breaking change, as this will only change\n * new runs, not existing ones.\n */\nexports.PREFERRED_EXECUTION_VERSION = ExecutionVersion.V1;\nclass InngestExecution {\n    constructor(options) {\n        this.options = options;\n        this.debug = (0, debug_1.default)(`${consts_js_1.debugPrefix}:${this.options.runId}`);\n    }\n}\nexports.InngestExecution = InngestExecution;\n//# sourceMappingURL=InngestExecution.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL2V4ZWN1dGlvbi9Jbm5nZXN0RXhlY3V0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0JBQXdCLEdBQUcsbUNBQW1DLEdBQUcsd0JBQXdCO0FBQ3pGLGdDQUFnQyxtQkFBTyxDQUFDLHNEQUFPO0FBQy9DLG9CQUFvQixtQkFBTyxDQUFDLCtFQUF5QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx1QkFBdUIsd0JBQXdCLHdCQUF3QjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsd0JBQXdCLEdBQUcsbUJBQW1CO0FBQzNGO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aXZlLXZpYmUtYWktbmV4dC8uL25vZGVfbW9kdWxlcy9pbm5nZXN0L2NvbXBvbmVudHMvZXhlY3V0aW9uL0lubmdlc3RFeGVjdXRpb24uanM/ZDg0MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSW5uZ2VzdEV4ZWN1dGlvbiA9IGV4cG9ydHMuUFJFRkVSUkVEX0VYRUNVVElPTl9WRVJTSU9OID0gZXhwb3J0cy5FeGVjdXRpb25WZXJzaW9uID0gdm9pZCAwO1xuY29uc3QgZGVidWdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZGVidWdcIikpO1xuY29uc3QgY29uc3RzX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vaGVscGVycy9jb25zdHMuanNcIik7XG4vKipcbiAqIFRoZSBleGVjdXRpb24gbW9kZWxzIHRoZSBTREsgaXMgYXdhcmUgb2YuXG4gKlxuICogVGhpcyBpcyB1c2VkIGluIGEgbnVtYmVyIG9mIHBsYWNlcyB0byBlbnN1cmUgYWxsIGV4ZWN1dGlvbiB2ZXJzaW9ucyBhcmVcbiAqIGFjY291bnRlZCBmb3IgZm9yIGEgZ2l2ZW4gb3BlcmF0aW9uLlxuICovXG52YXIgRXhlY3V0aW9uVmVyc2lvbjtcbihmdW5jdGlvbiAoRXhlY3V0aW9uVmVyc2lvbikge1xuICAgIEV4ZWN1dGlvblZlcnNpb25bRXhlY3V0aW9uVmVyc2lvbltcIlYwXCJdID0gMF0gPSBcIlYwXCI7XG4gICAgRXhlY3V0aW9uVmVyc2lvbltFeGVjdXRpb25WZXJzaW9uW1wiVjFcIl0gPSAxXSA9IFwiVjFcIjtcbiAgICBFeGVjdXRpb25WZXJzaW9uW0V4ZWN1dGlvblZlcnNpb25bXCJWMlwiXSA9IDJdID0gXCJWMlwiO1xufSkoRXhlY3V0aW9uVmVyc2lvbiB8fCAoZXhwb3J0cy5FeGVjdXRpb25WZXJzaW9uID0gRXhlY3V0aW9uVmVyc2lvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSBwcmVmZXJyZWQgZXhlY3V0aW9uIHZlcnNpb24gdGhhdCB3aWxsIGJlIHVzZWQgYnkgdGhlIFNESyB3aGVuIGhhbmRsaW5nXG4gKiBicmFuZCBuZXcgcnVucyB3aGVyZSB0aGUgRXhlY3V0b3IgaXMgYWxsb3dpbmcgdXMgdG8gY2hvb3NlLlxuICpcbiAqIENoYW5naW5nIHRoaXMgc2hvdWxkIG5vdCBldmVyIGJlIGEgYnJlYWtpbmcgY2hhbmdlLCBhcyB0aGlzIHdpbGwgb25seSBjaGFuZ2VcbiAqIG5ldyBydW5zLCBub3QgZXhpc3Rpbmcgb25lcy5cbiAqL1xuZXhwb3J0cy5QUkVGRVJSRURfRVhFQ1VUSU9OX1ZFUlNJT04gPSBFeGVjdXRpb25WZXJzaW9uLlYxO1xuY2xhc3MgSW5uZ2VzdEV4ZWN1dGlvbiB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmRlYnVnID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoYCR7Y29uc3RzX2pzXzEuZGVidWdQcmVmaXh9OiR7dGhpcy5vcHRpb25zLnJ1bklkfWApO1xuICAgIH1cbn1cbmV4cG9ydHMuSW5uZ2VzdEV4ZWN1dGlvbiA9IElubmdlc3RFeGVjdXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Jbm5nZXN0RXhlY3V0aW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/execution/InngestExecution.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/execution/als.js":
/*!**********************************************************!*\
  !*** ./node_modules/inngest/components/execution/als.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getAsyncLocalStorage = exports.getAsyncCtx = void 0;\n/**\n * A local-only symbol used as a key in global state to store the async local\n * storage instance.\n */\nconst alsSymbol = Symbol.for(\"inngest:als\");\n/**\n * Retrieve the async context for the current execution.\n */\nconst getAsyncCtx = async () => {\n    return (0, exports.getAsyncLocalStorage)().then((als) => als.getStore());\n};\nexports.getAsyncCtx = getAsyncCtx;\n/**\n * Get a singleton instance of `AsyncLocalStorage` used to store and retrieve\n * async context for the current execution.\n */\nconst getAsyncLocalStorage = async () => {\n    var _a;\n    var _b;\n    (_a = (_b = globalThis)[alsSymbol]) !== null && _a !== void 0 ? _a : (_b[alsSymbol] = new Promise(\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises, no-async-promise-executor\n    async (resolve) => {\n        try {\n            const { AsyncLocalStorage } = await Promise.resolve().then(() => __importStar(__webpack_require__(/*! node:async_hooks */ \"node:async_hooks\")));\n            resolve(new AsyncLocalStorage());\n        }\n        catch (err) {\n            console.warn(\"node:async_hooks is not supported in this runtime. Experimental async context is disabled.\");\n            resolve({\n                getStore: () => undefined,\n                run: (_, fn) => fn(),\n            });\n        }\n    }));\n    return globalThis[alsSymbol];\n};\nexports.getAsyncLocalStorage = getAsyncLocalStorage;\n//# sourceMappingURL=als.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL2V4ZWN1dGlvbi9hbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxjQUFjO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNEJBQTRCLEdBQUcsbUJBQW1CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0Isa0RBQWtELG1CQUFPLENBQUMsMENBQWtCO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aXZlLXZpYmUtYWktbmV4dC8uL25vZGVfbW9kdWxlcy9pbm5nZXN0L2NvbXBvbmVudHMvZXhlY3V0aW9uL2Fscy5qcz8wYjA5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBvd25LZXlzID0gZnVuY3Rpb24obykge1xuICAgICAgICBvd25LZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgIHZhciBhciA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgayBpbiBvKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIGspKSBhclthci5sZW5ndGhdID0gaztcbiAgICAgICAgICAgIHJldHVybiBhcjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG93bktleXMobyk7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG1vZCkge1xuICAgICAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayA9IG93bktleXMobW9kKSwgaSA9IDA7IGkgPCBrLmxlbmd0aDsgaSsrKSBpZiAoa1tpXSAhPT0gXCJkZWZhdWx0XCIpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwga1tpXSk7XG4gICAgICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldEFzeW5jTG9jYWxTdG9yYWdlID0gZXhwb3J0cy5nZXRBc3luY0N0eCA9IHZvaWQgMDtcbi8qKlxuICogQSBsb2NhbC1vbmx5IHN5bWJvbCB1c2VkIGFzIGEga2V5IGluIGdsb2JhbCBzdGF0ZSB0byBzdG9yZSB0aGUgYXN5bmMgbG9jYWxcbiAqIHN0b3JhZ2UgaW5zdGFuY2UuXG4gKi9cbmNvbnN0IGFsc1N5bWJvbCA9IFN5bWJvbC5mb3IoXCJpbm5nZXN0OmFsc1wiKTtcbi8qKlxuICogUmV0cmlldmUgdGhlIGFzeW5jIGNvbnRleHQgZm9yIHRoZSBjdXJyZW50IGV4ZWN1dGlvbi5cbiAqL1xuY29uc3QgZ2V0QXN5bmNDdHggPSBhc3luYyAoKSA9PiB7XG4gICAgcmV0dXJuICgwLCBleHBvcnRzLmdldEFzeW5jTG9jYWxTdG9yYWdlKSgpLnRoZW4oKGFscykgPT4gYWxzLmdldFN0b3JlKCkpO1xufTtcbmV4cG9ydHMuZ2V0QXN5bmNDdHggPSBnZXRBc3luY0N0eDtcbi8qKlxuICogR2V0IGEgc2luZ2xldG9uIGluc3RhbmNlIG9mIGBBc3luY0xvY2FsU3RvcmFnZWAgdXNlZCB0byBzdG9yZSBhbmQgcmV0cmlldmVcbiAqIGFzeW5jIGNvbnRleHQgZm9yIHRoZSBjdXJyZW50IGV4ZWN1dGlvbi5cbiAqL1xuY29uc3QgZ2V0QXN5bmNMb2NhbFN0b3JhZ2UgPSBhc3luYyAoKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIHZhciBfYjtcbiAgICAoX2EgPSAoX2IgPSBnbG9iYWxUaGlzKVthbHNTeW1ib2xdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoX2JbYWxzU3ltYm9sXSA9IG5ldyBQcm9taXNlKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbWlzdXNlZC1wcm9taXNlcywgbm8tYXN5bmMtcHJvbWlzZS1leGVjdXRvclxuICAgIGFzeW5jIChyZXNvbHZlKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7IEFzeW5jTG9jYWxTdG9yYWdlIH0gPSBhd2FpdCBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IF9faW1wb3J0U3RhcihyZXF1aXJlKFwibm9kZTphc3luY19ob29rc1wiKSkpO1xuICAgICAgICAgICAgcmVzb2x2ZShuZXcgQXN5bmNMb2NhbFN0b3JhZ2UoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwibm9kZTphc3luY19ob29rcyBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgcnVudGltZS4gRXhwZXJpbWVudGFsIGFzeW5jIGNvbnRleHQgaXMgZGlzYWJsZWQuXCIpO1xuICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgZ2V0U3RvcmU6ICgpID0+IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBydW46IChfLCBmbikgPT4gZm4oKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSkpO1xuICAgIHJldHVybiBnbG9iYWxUaGlzW2Fsc1N5bWJvbF07XG59O1xuZXhwb3J0cy5nZXRBc3luY0xvY2FsU3RvcmFnZSA9IGdldEFzeW5jTG9jYWxTdG9yYWdlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/execution/als.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/execution/otel/access.js":
/*!******************************************************************!*\
  !*** ./node_modules/inngest/components/execution/otel/access.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/**\n * A file used to access client processors safely without also importing any\n * otel-specific libraries. Useful for ensuring that the otel libraries can be\n * tree-shaken if they're not used directly by the user.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.clientProcessorMap = void 0;\n/**\n * A map of Inngest clients to their OTel span processors. This is used to\n * ensure that we only create one span processor per client, and that we can\n * access the span processor from the client without exposing the OTel\n * libraries to the user.\n */\nexports.clientProcessorMap = new WeakMap();\n//# sourceMappingURL=access.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL2V4ZWN1dGlvbi9vdGVsL2FjY2Vzcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQiIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpdmUtdmliZS1haS1uZXh0Ly4vbm9kZV9tb2R1bGVzL2lubmdlc3QvY29tcG9uZW50cy9leGVjdXRpb24vb3RlbC9hY2Nlc3MuanM/MzRmMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQSBmaWxlIHVzZWQgdG8gYWNjZXNzIGNsaWVudCBwcm9jZXNzb3JzIHNhZmVseSB3aXRob3V0IGFsc28gaW1wb3J0aW5nIGFueVxuICogb3RlbC1zcGVjaWZpYyBsaWJyYXJpZXMuIFVzZWZ1bCBmb3IgZW5zdXJpbmcgdGhhdCB0aGUgb3RlbCBsaWJyYXJpZXMgY2FuIGJlXG4gKiB0cmVlLXNoYWtlbiBpZiB0aGV5J3JlIG5vdCB1c2VkIGRpcmVjdGx5IGJ5IHRoZSB1c2VyLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNsaWVudFByb2Nlc3Nvck1hcCA9IHZvaWQgMDtcbi8qKlxuICogQSBtYXAgb2YgSW5uZ2VzdCBjbGllbnRzIHRvIHRoZWlyIE9UZWwgc3BhbiBwcm9jZXNzb3JzLiBUaGlzIGlzIHVzZWQgdG9cbiAqIGVuc3VyZSB0aGF0IHdlIG9ubHkgY3JlYXRlIG9uZSBzcGFuIHByb2Nlc3NvciBwZXIgY2xpZW50LCBhbmQgdGhhdCB3ZSBjYW5cbiAqIGFjY2VzcyB0aGUgc3BhbiBwcm9jZXNzb3IgZnJvbSB0aGUgY2xpZW50IHdpdGhvdXQgZXhwb3NpbmcgdGhlIE9UZWxcbiAqIGxpYnJhcmllcyB0byB0aGUgdXNlci5cbiAqL1xuZXhwb3J0cy5jbGllbnRQcm9jZXNzb3JNYXAgPSBuZXcgV2Vha01hcCgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWNjZXNzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/execution/otel/access.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/execution/otel/consts.js":
/*!******************************************************************!*\
  !*** ./node_modules/inngest/components/execution/otel/consts.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Attribute = exports.TraceStateKey = exports.debugPrefix = void 0;\nexports.debugPrefix = \"inngest:otel\";\nvar TraceStateKey;\n(function (TraceStateKey) {\n    TraceStateKey[\"AppId\"] = \"inngest@app\";\n    TraceStateKey[\"FunctionId\"] = \"inngest@fn\";\n})(TraceStateKey || (exports.TraceStateKey = TraceStateKey = {}));\nvar Attribute;\n(function (Attribute) {\n    Attribute[\"InngestTraceparent\"] = \"inngest.traceparent\";\n    Attribute[\"InngestRunId\"] = \"sdk.run.id\";\n    Attribute[\"InngestAppId1\"] = \"sdk.app.id\";\n    Attribute[\"InngestAppId2\"] = \"sys.app.id\";\n    Attribute[\"InngestFunctionId\"] = \"sys.function.id\";\n})(Attribute || (exports.Attribute = Attribute = {}));\n//# sourceMappingURL=consts.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL2V4ZWN1dGlvbi9vdGVsL2NvbnN0cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUIsR0FBRyxxQkFBcUIsR0FBRyxtQkFBbUI7QUFDL0QsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQkFBb0IscUJBQXFCLHFCQUFxQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0JBQWdCLGlCQUFpQixpQkFBaUI7QUFDbkQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aXZlLXZpYmUtYWktbmV4dC8uL25vZGVfbW9kdWxlcy9pbm5nZXN0L2NvbXBvbmVudHMvZXhlY3V0aW9uL290ZWwvY29uc3RzLmpzPzM5NzIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkF0dHJpYnV0ZSA9IGV4cG9ydHMuVHJhY2VTdGF0ZUtleSA9IGV4cG9ydHMuZGVidWdQcmVmaXggPSB2b2lkIDA7XG5leHBvcnRzLmRlYnVnUHJlZml4ID0gXCJpbm5nZXN0Om90ZWxcIjtcbnZhciBUcmFjZVN0YXRlS2V5O1xuKGZ1bmN0aW9uIChUcmFjZVN0YXRlS2V5KSB7XG4gICAgVHJhY2VTdGF0ZUtleVtcIkFwcElkXCJdID0gXCJpbm5nZXN0QGFwcFwiO1xuICAgIFRyYWNlU3RhdGVLZXlbXCJGdW5jdGlvbklkXCJdID0gXCJpbm5nZXN0QGZuXCI7XG59KShUcmFjZVN0YXRlS2V5IHx8IChleHBvcnRzLlRyYWNlU3RhdGVLZXkgPSBUcmFjZVN0YXRlS2V5ID0ge30pKTtcbnZhciBBdHRyaWJ1dGU7XG4oZnVuY3Rpb24gKEF0dHJpYnV0ZSkge1xuICAgIEF0dHJpYnV0ZVtcIklubmdlc3RUcmFjZXBhcmVudFwiXSA9IFwiaW5uZ2VzdC50cmFjZXBhcmVudFwiO1xuICAgIEF0dHJpYnV0ZVtcIklubmdlc3RSdW5JZFwiXSA9IFwic2RrLnJ1bi5pZFwiO1xuICAgIEF0dHJpYnV0ZVtcIklubmdlc3RBcHBJZDFcIl0gPSBcInNkay5hcHAuaWRcIjtcbiAgICBBdHRyaWJ1dGVbXCJJbm5nZXN0QXBwSWQyXCJdID0gXCJzeXMuYXBwLmlkXCI7XG4gICAgQXR0cmlidXRlW1wiSW5uZ2VzdEZ1bmN0aW9uSWRcIl0gPSBcInN5cy5mdW5jdGlvbi5pZFwiO1xufSkoQXR0cmlidXRlIHx8IChleHBvcnRzLkF0dHJpYnV0ZSA9IEF0dHJpYnV0ZSA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/execution/otel/consts.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/execution/otel/middleware.js":
/*!**********************************************************************!*\
  !*** ./node_modules/inngest/components/execution/otel/middleware.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nvar _InngestOtelDiagLogger_logger;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.otelMiddleware = void 0;\nconst api_1 = __webpack_require__(/*! @opentelemetry/api */ \"(rsc)/./node_modules/@opentelemetry/api/build/esm/index.js\");\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\"));\nconst version_js_1 = __webpack_require__(/*! ../../../version.js */ \"(rsc)/./node_modules/inngest/version.js\");\nconst InngestMiddleware_js_1 = __webpack_require__(/*! ../../InngestMiddleware.js */ \"(rsc)/./node_modules/inngest/components/InngestMiddleware.js\");\nconst access_js_1 = __webpack_require__(/*! ./access.js */ \"(rsc)/./node_modules/inngest/components/execution/otel/access.js\");\nconst consts_js_1 = __webpack_require__(/*! ./consts.js */ \"(rsc)/./node_modules/inngest/components/execution/otel/consts.js\");\nconst util_js_1 = __webpack_require__(/*! ./util.js */ \"(rsc)/./node_modules/inngest/components/execution/otel/util.js\");\nconst debug = (0, debug_1.default)(`${consts_js_1.debugPrefix}:middleware`);\nclass InngestOtelDiagLogger {\n    constructor() {\n        _InngestOtelDiagLogger_logger.set(this, (0, debug_1.default)(`${consts_js_1.debugPrefix}:diag`));\n        this.debug = __classPrivateFieldGet(this, _InngestOtelDiagLogger_logger, \"f\");\n        this.error = __classPrivateFieldGet(this, _InngestOtelDiagLogger_logger, \"f\");\n        this.info = __classPrivateFieldGet(this, _InngestOtelDiagLogger_logger, \"f\");\n        this.verbose = __classPrivateFieldGet(this, _InngestOtelDiagLogger_logger, \"f\");\n        this.warn = __classPrivateFieldGet(this, _InngestOtelDiagLogger_logger, \"f\");\n    }\n}\n_InngestOtelDiagLogger_logger = new WeakMap();\n/**\n * Middleware the captures and exports spans relevant to Inngest runs using\n * OTel.\n *\n * This can be used to attach additional spans and data to the existing traces\n * in your Inngest dashboard (or Dev Server).\n */\nconst otelMiddleware = ({ behaviour = \"auto\", instrumentations, logLevel = api_1.DiagLogLevel.ERROR, } = {}) => {\n    debug(\"behaviour:\", behaviour);\n    let processor;\n    switch (behaviour) {\n        case \"auto\": {\n            const extended = (0, util_js_1.extendProvider)(behaviour);\n            if (extended.success) {\n                debug(\"extended existing provider\");\n                processor = extended.processor;\n                break;\n            }\n            const created = (0, util_js_1.createProvider)(behaviour, instrumentations);\n            if (created.success) {\n                debug(\"created new provider\");\n                processor = created.processor;\n                break;\n            }\n            console.warn(\"no provider found to extend and unable to create one\");\n            break;\n        }\n        case \"createProvider\": {\n            const created = (0, util_js_1.createProvider)(behaviour, instrumentations);\n            if (created.success) {\n                debug(\"created new provider\");\n                processor = created.processor;\n                break;\n            }\n            console.warn(\"unable to create provider, OTel middleware will not work\");\n            break;\n        }\n        case \"extendProvider\": {\n            const extended = (0, util_js_1.extendProvider)(behaviour);\n            if (extended.success) {\n                debug(\"extended existing provider\");\n                processor = extended.processor;\n                break;\n            }\n            console.warn('unable to extend provider, OTel middleware will not work. Either allow the middleware to create a provider by setting `behaviour: \"createProvider\"` or `behaviour: \"auto\"`, or make sure that the provider is created and imported before the middleware is used.');\n            break;\n        }\n        case \"off\": {\n            break;\n        }\n        default: {\n            // unknown\n            console.warn(`unknown behaviour ${JSON.stringify(behaviour)}, defaulting to \"off\"`);\n        }\n    }\n    return new InngestMiddleware_js_1.InngestMiddleware({\n        name: \"Inngest: OTel\",\n        init({ client }) {\n            // Set the logger for our otel processors and exporters.\n            // If this is called multiple times (for example by the user in some other\n            // custom code), then only the first call is set, so we don't have to\n            // worry about overwriting it here accidentally.\n            //\n            debug(\"set otel diagLogger:\", api_1.diag.setLogger(new InngestOtelDiagLogger(), logLevel));\n            if (processor) {\n                access_js_1.clientProcessorMap.set(client, processor);\n            }\n            return {\n                onFunctionRun() {\n                    return {\n                        transformInput() {\n                            return {\n                                ctx: {\n                                    /**\n                                     * A tracer that can be used to create spans within a step\n                                     * that will be displayed on the Inngest dashboard (or Dev\n                                     * Server).\n                                     *\n                                     * Note that creating spans outside of steps when the function\n                                     * contains `step.*()` calls is not currently supported.\n                                     */\n                                    tracer: api_1.trace.getTracer(\"inngest\", version_js_1.version),\n                                },\n                            };\n                        },\n                        async beforeResponse() {\n                            // Should this be awaited? And is it fine to flush after every\n                            // execution?\n                            await (processor === null || processor === void 0 ? void 0 : processor.forceFlush());\n                        },\n                    };\n                },\n            };\n        },\n    });\n};\nexports.otelMiddleware = otelMiddleware;\n//# sourceMappingURL=middleware.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL2V4ZWN1dGlvbi9vdGVsL21pZGRsZXdhcmUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0I7QUFDdEIsY0FBYyxtQkFBTyxDQUFDLHNGQUFvQjtBQUMxQyxnQ0FBZ0MsbUJBQU8sQ0FBQyxzREFBTztBQUMvQyxxQkFBcUIsbUJBQU8sQ0FBQyxvRUFBcUI7QUFDbEQsK0JBQStCLG1CQUFPLENBQUMsZ0dBQTRCO0FBQ25FLG9CQUFvQixtQkFBTyxDQUFDLHFGQUFhO0FBQ3pDLG9CQUFvQixtQkFBTyxDQUFDLHFGQUFhO0FBQ3pDLGtCQUFrQixtQkFBTyxDQUFDLGlGQUFXO0FBQ3JDLHNDQUFzQyx3QkFBd0I7QUFDOUQ7QUFDQTtBQUNBLHdFQUF3RSx3QkFBd0I7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDZFQUE2RSxJQUFJO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsMEJBQTBCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQSxzQkFBc0I7QUFDdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aXZlLXZpYmUtYWktbmV4dC8uL25vZGVfbW9kdWxlcy9pbm5nZXN0L2NvbXBvbmVudHMvZXhlY3V0aW9uL290ZWwvbWlkZGxld2FyZS5qcz9kZGJiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRHZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRHZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG52YXIgX0lubmdlc3RPdGVsRGlhZ0xvZ2dlcl9sb2dnZXI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm90ZWxNaWRkbGV3YXJlID0gdm9pZCAwO1xuY29uc3QgYXBpXzEgPSByZXF1aXJlKFwiQG9wZW50ZWxlbWV0cnkvYXBpXCIpO1xuY29uc3QgZGVidWdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZGVidWdcIikpO1xuY29uc3QgdmVyc2lvbl9qc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3ZlcnNpb24uanNcIik7XG5jb25zdCBJbm5nZXN0TWlkZGxld2FyZV9qc18xID0gcmVxdWlyZShcIi4uLy4uL0lubmdlc3RNaWRkbGV3YXJlLmpzXCIpO1xuY29uc3QgYWNjZXNzX2pzXzEgPSByZXF1aXJlKFwiLi9hY2Nlc3MuanNcIik7XG5jb25zdCBjb25zdHNfanNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0cy5qc1wiKTtcbmNvbnN0IHV0aWxfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWwuanNcIik7XG5jb25zdCBkZWJ1ZyA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKGAke2NvbnN0c19qc18xLmRlYnVnUHJlZml4fTptaWRkbGV3YXJlYCk7XG5jbGFzcyBJbm5nZXN0T3RlbERpYWdMb2dnZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBfSW5uZ2VzdE90ZWxEaWFnTG9nZ2VyX2xvZ2dlci5zZXQodGhpcywgKDAsIGRlYnVnXzEuZGVmYXVsdCkoYCR7Y29uc3RzX2pzXzEuZGVidWdQcmVmaXh9OmRpYWdgKSk7XG4gICAgICAgIHRoaXMuZGVidWcgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Jbm5nZXN0T3RlbERpYWdMb2dnZXJfbG9nZ2VyLCBcImZcIik7XG4gICAgICAgIHRoaXMuZXJyb3IgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Jbm5nZXN0T3RlbERpYWdMb2dnZXJfbG9nZ2VyLCBcImZcIik7XG4gICAgICAgIHRoaXMuaW5mbyA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0lubmdlc3RPdGVsRGlhZ0xvZ2dlcl9sb2dnZXIsIFwiZlwiKTtcbiAgICAgICAgdGhpcy52ZXJib3NlID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSW5uZ2VzdE90ZWxEaWFnTG9nZ2VyX2xvZ2dlciwgXCJmXCIpO1xuICAgICAgICB0aGlzLndhcm4gPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Jbm5nZXN0T3RlbERpYWdMb2dnZXJfbG9nZ2VyLCBcImZcIik7XG4gICAgfVxufVxuX0lubmdlc3RPdGVsRGlhZ0xvZ2dlcl9sb2dnZXIgPSBuZXcgV2Vha01hcCgpO1xuLyoqXG4gKiBNaWRkbGV3YXJlIHRoZSBjYXB0dXJlcyBhbmQgZXhwb3J0cyBzcGFucyByZWxldmFudCB0byBJbm5nZXN0IHJ1bnMgdXNpbmdcbiAqIE9UZWwuXG4gKlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBhdHRhY2ggYWRkaXRpb25hbCBzcGFucyBhbmQgZGF0YSB0byB0aGUgZXhpc3RpbmcgdHJhY2VzXG4gKiBpbiB5b3VyIElubmdlc3QgZGFzaGJvYXJkIChvciBEZXYgU2VydmVyKS5cbiAqL1xuY29uc3Qgb3RlbE1pZGRsZXdhcmUgPSAoeyBiZWhhdmlvdXIgPSBcImF1dG9cIiwgaW5zdHJ1bWVudGF0aW9ucywgbG9nTGV2ZWwgPSBhcGlfMS5EaWFnTG9nTGV2ZWwuRVJST1IsIH0gPSB7fSkgPT4ge1xuICAgIGRlYnVnKFwiYmVoYXZpb3VyOlwiLCBiZWhhdmlvdXIpO1xuICAgIGxldCBwcm9jZXNzb3I7XG4gICAgc3dpdGNoIChiZWhhdmlvdXIpIHtcbiAgICAgICAgY2FzZSBcImF1dG9cIjoge1xuICAgICAgICAgICAgY29uc3QgZXh0ZW5kZWQgPSAoMCwgdXRpbF9qc18xLmV4dGVuZFByb3ZpZGVyKShiZWhhdmlvdXIpO1xuICAgICAgICAgICAgaWYgKGV4dGVuZGVkLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcImV4dGVuZGVkIGV4aXN0aW5nIHByb3ZpZGVyXCIpO1xuICAgICAgICAgICAgICAgIHByb2Nlc3NvciA9IGV4dGVuZGVkLnByb2Nlc3NvcjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNyZWF0ZWQgPSAoMCwgdXRpbF9qc18xLmNyZWF0ZVByb3ZpZGVyKShiZWhhdmlvdXIsIGluc3RydW1lbnRhdGlvbnMpO1xuICAgICAgICAgICAgaWYgKGNyZWF0ZWQuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwiY3JlYXRlZCBuZXcgcHJvdmlkZXJcIik7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc29yID0gY3JlYXRlZC5wcm9jZXNzb3I7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJubyBwcm92aWRlciBmb3VuZCB0byBleHRlbmQgYW5kIHVuYWJsZSB0byBjcmVhdGUgb25lXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImNyZWF0ZVByb3ZpZGVyXCI6IHtcbiAgICAgICAgICAgIGNvbnN0IGNyZWF0ZWQgPSAoMCwgdXRpbF9qc18xLmNyZWF0ZVByb3ZpZGVyKShiZWhhdmlvdXIsIGluc3RydW1lbnRhdGlvbnMpO1xuICAgICAgICAgICAgaWYgKGNyZWF0ZWQuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwiY3JlYXRlZCBuZXcgcHJvdmlkZXJcIik7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc29yID0gY3JlYXRlZC5wcm9jZXNzb3I7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJ1bmFibGUgdG8gY3JlYXRlIHByb3ZpZGVyLCBPVGVsIG1pZGRsZXdhcmUgd2lsbCBub3Qgd29ya1wiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJleHRlbmRQcm92aWRlclwiOiB7XG4gICAgICAgICAgICBjb25zdCBleHRlbmRlZCA9ICgwLCB1dGlsX2pzXzEuZXh0ZW5kUHJvdmlkZXIpKGJlaGF2aW91cik7XG4gICAgICAgICAgICBpZiAoZXh0ZW5kZWQuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwiZXh0ZW5kZWQgZXhpc3RpbmcgcHJvdmlkZXJcIik7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc29yID0gZXh0ZW5kZWQucHJvY2Vzc29yO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc29sZS53YXJuKCd1bmFibGUgdG8gZXh0ZW5kIHByb3ZpZGVyLCBPVGVsIG1pZGRsZXdhcmUgd2lsbCBub3Qgd29yay4gRWl0aGVyIGFsbG93IHRoZSBtaWRkbGV3YXJlIHRvIGNyZWF0ZSBhIHByb3ZpZGVyIGJ5IHNldHRpbmcgYGJlaGF2aW91cjogXCJjcmVhdGVQcm92aWRlclwiYCBvciBgYmVoYXZpb3VyOiBcImF1dG9cImAsIG9yIG1ha2Ugc3VyZSB0aGF0IHRoZSBwcm92aWRlciBpcyBjcmVhdGVkIGFuZCBpbXBvcnRlZCBiZWZvcmUgdGhlIG1pZGRsZXdhcmUgaXMgdXNlZC4nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJvZmZcIjoge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgLy8gdW5rbm93blxuICAgICAgICAgICAgY29uc29sZS53YXJuKGB1bmtub3duIGJlaGF2aW91ciAke0pTT04uc3RyaW5naWZ5KGJlaGF2aW91cil9LCBkZWZhdWx0aW5nIHRvIFwib2ZmXCJgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IElubmdlc3RNaWRkbGV3YXJlX2pzXzEuSW5uZ2VzdE1pZGRsZXdhcmUoe1xuICAgICAgICBuYW1lOiBcIklubmdlc3Q6IE9UZWxcIixcbiAgICAgICAgaW5pdCh7IGNsaWVudCB9KSB7XG4gICAgICAgICAgICAvLyBTZXQgdGhlIGxvZ2dlciBmb3Igb3VyIG90ZWwgcHJvY2Vzc29ycyBhbmQgZXhwb3J0ZXJzLlxuICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBjYWxsZWQgbXVsdGlwbGUgdGltZXMgKGZvciBleGFtcGxlIGJ5IHRoZSB1c2VyIGluIHNvbWUgb3RoZXJcbiAgICAgICAgICAgIC8vIGN1c3RvbSBjb2RlKSwgdGhlbiBvbmx5IHRoZSBmaXJzdCBjYWxsIGlzIHNldCwgc28gd2UgZG9uJ3QgaGF2ZSB0b1xuICAgICAgICAgICAgLy8gd29ycnkgYWJvdXQgb3ZlcndyaXRpbmcgaXQgaGVyZSBhY2NpZGVudGFsbHkuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgZGVidWcoXCJzZXQgb3RlbCBkaWFnTG9nZ2VyOlwiLCBhcGlfMS5kaWFnLnNldExvZ2dlcihuZXcgSW5uZ2VzdE90ZWxEaWFnTG9nZ2VyKCksIGxvZ0xldmVsKSk7XG4gICAgICAgICAgICBpZiAocHJvY2Vzc29yKSB7XG4gICAgICAgICAgICAgICAgYWNjZXNzX2pzXzEuY2xpZW50UHJvY2Vzc29yTWFwLnNldChjbGllbnQsIHByb2Nlc3Nvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG9uRnVuY3Rpb25SdW4oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1JbnB1dCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHg6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQSB0cmFjZXIgdGhhdCBjYW4gYmUgdXNlZCB0byBjcmVhdGUgc3BhbnMgd2l0aGluIGEgc3RlcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogdGhhdCB3aWxsIGJlIGRpc3BsYXllZCBvbiB0aGUgSW5uZ2VzdCBkYXNoYm9hcmQgKG9yIERldlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogU2VydmVyKS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBOb3RlIHRoYXQgY3JlYXRpbmcgc3BhbnMgb3V0c2lkZSBvZiBzdGVwcyB3aGVuIHRoZSBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogY29udGFpbnMgYHN0ZXAuKigpYCBjYWxscyBpcyBub3QgY3VycmVudGx5IHN1cHBvcnRlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2VyOiBhcGlfMS50cmFjZS5nZXRUcmFjZXIoXCJpbm5nZXN0XCIsIHZlcnNpb25fanNfMS52ZXJzaW9uKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzeW5jIGJlZm9yZVJlc3BvbnNlKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNob3VsZCB0aGlzIGJlIGF3YWl0ZWQ/IEFuZCBpcyBpdCBmaW5lIHRvIGZsdXNoIGFmdGVyIGV2ZXJ5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXhlY3V0aW9uP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IChwcm9jZXNzb3IgPT09IG51bGwgfHwgcHJvY2Vzc29yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm9jZXNzb3IuZm9yY2VGbHVzaCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgfSk7XG59O1xuZXhwb3J0cy5vdGVsTWlkZGxld2FyZSA9IG90ZWxNaWRkbGV3YXJlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWlkZGxld2FyZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/execution/otel/middleware.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/execution/otel/processor.js":
/*!*********************************************************************!*\
  !*** ./node_modules/inngest/components/execution/otel/processor.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nvar _InngestSpanProcessor_batcher, _InngestSpanProcessor_spansToExport, _InngestSpanProcessor_traceParents, _InngestSpanProcessor_spanCleanup;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PublicInngestSpanProcessor = exports.InngestSpanProcessor = void 0;\nconst exporter_trace_otlp_http_1 = __webpack_require__(/*! @opentelemetry/exporter-trace-otlp-http */ \"(rsc)/./node_modules/@opentelemetry/exporter-trace-otlp-http/build/esm/index.js\");\nconst resources_1 = __webpack_require__(/*! @opentelemetry/resources */ \"(rsc)/./node_modules/@opentelemetry/resources/build/esm/index.js\");\nconst sdk_trace_base_1 = __webpack_require__(/*! @opentelemetry/sdk-trace-base */ \"(rsc)/./node_modules/@opentelemetry/sdk-trace-base/build/esm/index.js\");\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\"));\nconst consts_js_1 = __webpack_require__(/*! ../../../helpers/consts.js */ \"(rsc)/./node_modules/inngest/helpers/consts.js\");\nconst devserver_js_1 = __webpack_require__(/*! ../../../helpers/devserver.js */ \"(rsc)/./node_modules/inngest/helpers/devserver.js\");\nconst env_js_1 = __webpack_require__(/*! ../../../helpers/env.js */ \"(rsc)/./node_modules/inngest/helpers/env.js\");\nconst als_js_1 = __webpack_require__(/*! ../als.js */ \"(rsc)/./node_modules/inngest/components/execution/als.js\");\nconst access_js_1 = __webpack_require__(/*! ./access.js */ \"(rsc)/./node_modules/inngest/components/execution/otel/access.js\");\nconst consts_js_2 = __webpack_require__(/*! ./consts.js */ \"(rsc)/./node_modules/inngest/components/execution/otel/consts.js\");\nconst processorDebug = (0, debug_1.default)(`${consts_js_2.debugPrefix}:InngestSpanProcessor`);\n/**\n * A set of resource attributes that are used to identify the Inngest app and\n *  the function that is being executed. This is used to store the resource\n * attributes for the spans that are exported to the Inngest endpoint, and cache\n *  them for later use.\n */\nlet _resourceAttributes;\n/**\n * An OTel span processor that is used to export spans to the Inngest endpoint.\n * This is used to track spans that are created within an Inngest run and export\n * them to the Inngest endpoint for tracing.\n *\n * It's careful to only pick relevant spans to export and will not send any\n * irrelevant spans to the Inngest endpoint.\n *\n * THIS IS THE INTERNAL IMPLEMENTATION OF THE SPAN PROCESSOR AND SHOULD NOT BE\n * USED BY USERS DIRECTLY. USE THE {@link PublicInngestSpanProcessor} CLASS\n * INSTEAD.\n */\nclass InngestSpanProcessor {\n    /**\n     * An OTel span processor that is used to export spans to the Inngest endpoint.\n     * This is used to track spans that are created within an Inngest run and export\n     * them to the Inngest endpoint for tracing.\n     *\n     * It's careful to only pick relevant spans to export and will not send any\n     * irrelevant spans to the Inngest endpoint.\n     */\n    constructor(\n    /**\n     * The app that this span processor is associated with. This is used to\n     * determine the Inngest endpoint to export spans to.\n     *\n     * It is optional here as this is the private constructor and only used\n     * internally; we set `app` elsewhere as when we create the processor (as\n     * early as possible when the process starts) we don't necessarily have the\n     * app available yet.\n     *\n     * So, internally we can delay setting ths until later.\n     */\n    app) {\n        /**\n         * A `BatchSpanProcessor` that is used to export spans to the Inngest\n         * endpoint. This is created lazily to avoid creating it until the Inngest App\n         * has been initialized and has had a chance to receive environment variables,\n         * which may be from an incoming request.\n         */\n        _InngestSpanProcessor_batcher.set(this, void 0);\n        /**\n         * A set of spans used to track spans that we care about, so that we can\n         * export them to the OTel endpoint.\n         *\n         * If a span falls out of reference, it will be removed from this set as we'll\n         * never get a chance to export it or remove it anyway.\n         */\n        _InngestSpanProcessor_spansToExport.set(this, new WeakSet());\n        /**\n         * A map of span IDs to their parent state, which includes a block of\n         * information that can be used and pushed back to the Inngest endpoint to\n         * ingest spans.\n         */\n        _InngestSpanProcessor_traceParents.set(this, new Map());\n        /**\n         * A registry used to clean up items from the `traceParents` map when spans\n         * fall out of reference. This is used to avoid memory leaks in the case where\n         * a span is not exported, remains unended, and is left in memory before being\n         * GC'd.\n         */\n        _InngestSpanProcessor_spanCleanup.set(this, new FinalizationRegistry((spanId) => {\n            if (spanId) {\n                __classPrivateFieldGet(this, _InngestSpanProcessor_traceParents, \"f\").delete(spanId);\n            }\n        }));\n        if (app) {\n            access_js_1.clientProcessorMap.set(app, this);\n        }\n    }\n    /**\n     * In order to only capture a subset of spans, we need to declare the initial\n     * span that we care about and then export its children.\n     *\n     * Call this method (ideally just before execution starts) with that initial\n     * span to trigger capturing all following children as well as initialize the\n     * batcher.\n     */\n    declareStartingSpan({ span, runId, traceparent, tracestate, }) {\n        // Upsert the batcher ready for later. We do this here to bootstrap it with\n        // the correct async context as soon as we can. As this method is only\n        // called just before execution, we know we're all set up.\n        //\n        // Waiting to call this until we actually need the batcher would mean that\n        // we might not have the correct async context set up, as we'd likely be in\n        // some span lifecycle method that doesn't have the same chain of execution.\n        void this.ensureBatcherInitialized();\n        // If we don't have a traceparent, then we can't track this span. This is\n        // likely a span that we don't care about, so we can ignore it.\n        if (!traceparent) {\n            return processorDebug(\"no traceparent found for span\", span.spanContext().spanId, \"so skipping it\");\n        }\n        // We also attempt to use `tracestate`. The values we fetch from these\n        // should be optional, as it's likely the Executor won't need us to parrot\n        // them back in later versions.\n        let appId;\n        let functionId;\n        if (tracestate) {\n            try {\n                const entries = Object.fromEntries(tracestate.split(\",\").map((kv) => kv.split(\"=\")));\n                appId = entries[consts_js_2.TraceStateKey.AppId];\n                functionId = entries[consts_js_2.TraceStateKey.FunctionId];\n            }\n            catch (err) {\n                processorDebug(\"failed to parse tracestate\", tracestate, \"so skipping it;\", err);\n            }\n        }\n        // This is a span that we care about, so let's make sure it and its\n        // children are exported.\n        processorDebug.extend(\"declareStartingSpan\")(\"declaring:\", span.spanContext().spanId, \"for traceparent\", traceparent);\n        // Set a load of attributes on this span so that we can nicely identify\n        // runtime, paths, etc. Only this span will have these attributes.\n        span.setAttributes(InngestSpanProcessor.resourceAttributes.attributes);\n        this.trackSpan({\n            appId,\n            functionId,\n            runId,\n            traceparent,\n        }, span);\n    }\n    /**\n     * A getter for retrieving resource attributes for the current process. This\n     * is used to set the resource attributes for the spans that are exported to\n     * the Inngest endpoint, and cache them for later use.\n     */\n    static get resourceAttributes() {\n        if (!_resourceAttributes) {\n            _resourceAttributes = (0, resources_1.detectResourcesSync)({\n                detectors: [\n                    resources_1.osDetectorSync,\n                    resources_1.envDetectorSync,\n                    resources_1.hostDetectorSync,\n                    resources_1.processDetectorSync,\n                    resources_1.serviceInstanceIdDetectorSync,\n                ],\n            });\n        }\n        return _resourceAttributes;\n    }\n    /**\n     * The batcher is a singleton that is used to export spans to the OTel\n     * endpoint. It is created lazily to avoid creating it until the Inngest App\n     * has been initialized and has had a chance to receive environment variables,\n     * which may be from an incoming request.\n     *\n     * The batcher is only referenced once we've found a span we're interested in,\n     * so this should always have everything it needs on the app by then.\n     */\n    ensureBatcherInitialized() {\n        if (!__classPrivateFieldGet(this, _InngestSpanProcessor_batcher, \"f\")) {\n            // eslint-disable-next-line @typescript-eslint/no-misused-promises, no-async-promise-executor\n            __classPrivateFieldSet(this, _InngestSpanProcessor_batcher, new Promise(async (resolve, reject) => {\n                var _a;\n                try {\n                    // We retrieve the app from the async context, so we must make sure\n                    // that this function is called from the correct chain.\n                    const store = await (0, als_js_1.getAsyncCtx)();\n                    if (!store) {\n                        throw new Error(\"No async context found; cannot create batcher to export traces\");\n                    }\n                    const app = store.app;\n                    // Fetch the URL for the Inngest endpoint using the app's config.\n                    let url;\n                    const path = \"/v1/traces/userland\";\n                    if (app.apiBaseUrl) {\n                        url = new URL(path, app.apiBaseUrl);\n                    }\n                    else {\n                        url = new URL(path, consts_js_1.defaultInngestApiBaseUrl);\n                        if (app[\"mode\"] && app[\"mode\"].isDev && app[\"mode\"].isInferred) {\n                            const devHost = (0, env_js_1.devServerHost)() || consts_js_1.defaultDevServerHost;\n                            const hasDevServer = await (0, devserver_js_1.devServerAvailable)(devHost, app[\"fetch\"]);\n                            if (hasDevServer) {\n                                url = new URL(path, devHost);\n                            }\n                        }\n                        else if ((_a = app[\"mode\"]) === null || _a === void 0 ? void 0 : _a.explicitDevUrl) {\n                            url = new URL(path, app[\"mode\"].explicitDevUrl.href);\n                        }\n                    }\n                    processorDebug(\"batcher lazily accessed; creating new batcher with URL\", url);\n                    const exporter = new exporter_trace_otlp_http_1.OTLPTraceExporter({\n                        url: url.href,\n                        headers: {\n                            Authorization: `Bearer ${app[\"inngestApi\"][\"signingKey\"]}`,\n                        },\n                    });\n                    resolve(new sdk_trace_base_1.BatchSpanProcessor(exporter));\n                }\n                catch (err) {\n                    reject(err);\n                }\n            }), \"f\");\n        }\n        return __classPrivateFieldGet(this, _InngestSpanProcessor_batcher, \"f\");\n    }\n    /**\n     * Mark a span as being tracked by this processor, meaning it will be exported\n     * to the Inggest endpoint when it ends.\n     */\n    trackSpan(parentState, span) {\n        const spanId = span.spanContext().spanId;\n        __classPrivateFieldGet(this, _InngestSpanProcessor_spanCleanup, \"f\").register(span, spanId, span);\n        __classPrivateFieldGet(this, _InngestSpanProcessor_spansToExport, \"f\").add(span);\n        __classPrivateFieldGet(this, _InngestSpanProcessor_traceParents, \"f\").set(spanId, parentState);\n        span.setAttribute(consts_js_2.Attribute.InngestTraceparent, parentState.traceparent);\n        span.setAttribute(consts_js_2.Attribute.InngestRunId, parentState.runId);\n        // Setting app ID is optional; it's likely in future versions of the\n        // Executor that we don't need to parrot this back.\n        if (parentState.appId) {\n            span.setAttribute(consts_js_2.Attribute.InngestAppId1, parentState.appId);\n            span.setAttribute(consts_js_2.Attribute.InngestAppId2, parentState.appId);\n        }\n        // Setting function ID is optional; it's likely in future versions of the\n        // Executor that we don't need to parrot this back.\n        if (parentState.functionId) {\n            span.setAttribute(consts_js_2.Attribute.InngestFunctionId, parentState.functionId);\n        }\n    }\n    /**\n     * Clean up any references to a span that has ended. This is used to avoid\n     * memory leaks in the case where a span is not exported, remains unended, and\n     * is left in memory before being GC'd.\n     */\n    cleanupSpan(span) {\n        const spanId = span.spanContext().spanId;\n        // This span is no longer in use, so we can remove it from the cleanup\n        // registry.\n        __classPrivateFieldGet(this, _InngestSpanProcessor_spanCleanup, \"f\").unregister(span);\n        __classPrivateFieldGet(this, _InngestSpanProcessor_spansToExport, \"f\").delete(span);\n        __classPrivateFieldGet(this, _InngestSpanProcessor_traceParents, \"f\").delete(spanId);\n    }\n    /**\n     * An implementation of the `onStart` method from the `SpanProcessor`\n     * interface. This is called when a span is started, and is used to track\n     * spans that are children of spans we care about.\n     */\n    onStart(span) {\n        const debug = processorDebug.extend(\"onStart\");\n        const spanId = span.spanContext().spanId;\n        //  It seems to work\n        const parentSpanId = span.parentSpanId;\n        // The root span isn't captured here, but we can capture children of it\n        // here.\n        if (!parentSpanId) {\n            // All spans that Inngest cares about will have a parent, so ignore this\n            debug(\"no parent span ID for\", spanId, \"so skipping it\");\n            return;\n        }\n        const parentState = __classPrivateFieldGet(this, _InngestSpanProcessor_traceParents, \"f\").get(parentSpanId);\n        if (parentState) {\n            // This span is a child of a span we care about, so add it to the list of\n            // tracked spans so that we also capture its children\n            debug(\"found traceparent\", parentState, \"in span ID\", parentSpanId, \"so adding\", spanId);\n            this.trackSpan(parentState, span);\n        }\n    }\n    /**\n     * An implementation of the `onEnd` method from the `SpanProcessor` interface.\n     * This is called when a span ends, and is used to export spans to the Inngest\n     * endpoint.\n     */\n    onEnd(span) {\n        const debug = processorDebug.extend(\"onEnd\");\n        const spanId = span.spanContext().spanId;\n        try {\n            if (__classPrivateFieldGet(this, _InngestSpanProcessor_spansToExport, \"f\").has(span)) {\n                if (!__classPrivateFieldGet(this, _InngestSpanProcessor_batcher, \"f\")) {\n                    return debug(\"batcher not initialized, so failed exporting span\", spanId);\n                }\n                debug(\"exporting span\", spanId);\n                return void __classPrivateFieldGet(this, _InngestSpanProcessor_batcher, \"f\").then((batcher) => batcher.onEnd(span));\n            }\n            debug(\"not exporting span\", spanId, \"as we don't care about it\");\n        }\n        finally {\n            this.cleanupSpan(span);\n        }\n    }\n    /**\n     * An implementation of the `forceFlush` method from the `SpanProcessor`\n     * interface. This is called to force the processor to flush any spans that\n     * are currently in the batcher. This is used to ensure that spans are\n     * exported to the Inngest endpoint before the process exits.\n     *\n     * Notably, we call this in the `beforeResponse` middleware hook to ensure\n     * that spans for a run as exported as soon as possible and before the\n     * serverless process is killed.\n     */\n    async forceFlush() {\n        var _a;\n        const flushDebug = processorDebug.extend(\"forceFlush\");\n        flushDebug(\"force flushing batcher\");\n        return (_a = __classPrivateFieldGet(this, _InngestSpanProcessor_batcher, \"f\")) === null || _a === void 0 ? void 0 : _a.then((batcher) => batcher.forceFlush()).catch((err) => {\n            flushDebug(\"error flushing batcher\", err, \"ignoring\");\n        });\n    }\n    async shutdown() {\n        var _a;\n        processorDebug.extend(\"shutdown\")(\"shutting down batcher\");\n        return (_a = __classPrivateFieldGet(this, _InngestSpanProcessor_batcher, \"f\")) === null || _a === void 0 ? void 0 : _a.then((batcher) => batcher.shutdown());\n    }\n}\nexports.InngestSpanProcessor = InngestSpanProcessor;\n_InngestSpanProcessor_batcher = new WeakMap(), _InngestSpanProcessor_spansToExport = new WeakMap(), _InngestSpanProcessor_traceParents = new WeakMap(), _InngestSpanProcessor_spanCleanup = new WeakMap();\n/**\n * An OTel span processor that is used to export spans to the Inngest endpoint.\n * This is used to track spans that are created within an Inngest run and export\n * them to the Inngest endpoint for tracing.\n *\n * It's careful to only pick relevant spans to export and will not send any\n * irrelevant spans to the Inngest endpoint.\n */\nclass PublicInngestSpanProcessor extends InngestSpanProcessor {\n    constructor(\n    /**\n     * The app that this span processor is associated with. This is used to\n     * determine the Inngest endpoint to export spans to.\n     */\n    app) {\n        super(app);\n    }\n}\nexports.PublicInngestSpanProcessor = PublicInngestSpanProcessor;\n//# sourceMappingURL=processor.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL2V4ZWN1dGlvbi9vdGVsL3Byb2Nlc3Nvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtDQUFrQyxHQUFHLDRCQUE0QjtBQUNqRSxtQ0FBbUMsbUJBQU8sQ0FBQyxnSUFBeUM7QUFDcEYsb0JBQW9CLG1CQUFPLENBQUMsa0dBQTBCO0FBQ3RELHlCQUF5QixtQkFBTyxDQUFDLDRHQUErQjtBQUNoRSxnQ0FBZ0MsbUJBQU8sQ0FBQyxzREFBTztBQUMvQyxvQkFBb0IsbUJBQU8sQ0FBQyxrRkFBNEI7QUFDeEQsdUJBQXVCLG1CQUFPLENBQUMsd0ZBQStCO0FBQzlELGlCQUFpQixtQkFBTyxDQUFDLDRFQUF5QjtBQUNsRCxpQkFBaUIsbUJBQU8sQ0FBQywyRUFBVztBQUNwQyxvQkFBb0IsbUJBQU8sQ0FBQyxxRkFBYTtBQUN6QyxvQkFBb0IsbUJBQU8sQ0FBQyxxRkFBYTtBQUN6QywrQ0FBK0Msd0JBQXdCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGtDQUFrQztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1Q0FBdUM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUY7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxnQ0FBZ0M7QUFDckYseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aXZlLXZpYmUtYWktbmV4dC8uL25vZGVfbW9kdWxlcy9pbm5nZXN0L2NvbXBvbmVudHMvZXhlY3V0aW9uL290ZWwvcHJvY2Vzc29yLmpzPzkwOTQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufTtcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG52YXIgX0lubmdlc3RTcGFuUHJvY2Vzc29yX2JhdGNoZXIsIF9Jbm5nZXN0U3BhblByb2Nlc3Nvcl9zcGFuc1RvRXhwb3J0LCBfSW5uZ2VzdFNwYW5Qcm9jZXNzb3JfdHJhY2VQYXJlbnRzLCBfSW5uZ2VzdFNwYW5Qcm9jZXNzb3Jfc3BhbkNsZWFudXA7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlB1YmxpY0lubmdlc3RTcGFuUHJvY2Vzc29yID0gZXhwb3J0cy5Jbm5nZXN0U3BhblByb2Nlc3NvciA9IHZvaWQgMDtcbmNvbnN0IGV4cG9ydGVyX3RyYWNlX290bHBfaHR0cF8xID0gcmVxdWlyZShcIkBvcGVudGVsZW1ldHJ5L2V4cG9ydGVyLXRyYWNlLW90bHAtaHR0cFwiKTtcbmNvbnN0IHJlc291cmNlc18xID0gcmVxdWlyZShcIkBvcGVudGVsZW1ldHJ5L3Jlc291cmNlc1wiKTtcbmNvbnN0IHNka190cmFjZV9iYXNlXzEgPSByZXF1aXJlKFwiQG9wZW50ZWxlbWV0cnkvc2RrLXRyYWNlLWJhc2VcIik7XG5jb25zdCBkZWJ1Z18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWJ1Z1wiKSk7XG5jb25zdCBjb25zdHNfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9oZWxwZXJzL2NvbnN0cy5qc1wiKTtcbmNvbnN0IGRldnNlcnZlcl9qc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL2hlbHBlcnMvZGV2c2VydmVyLmpzXCIpO1xuY29uc3QgZW52X2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vaGVscGVycy9lbnYuanNcIik7XG5jb25zdCBhbHNfanNfMSA9IHJlcXVpcmUoXCIuLi9hbHMuanNcIik7XG5jb25zdCBhY2Nlc3NfanNfMSA9IHJlcXVpcmUoXCIuL2FjY2Vzcy5qc1wiKTtcbmNvbnN0IGNvbnN0c19qc18yID0gcmVxdWlyZShcIi4vY29uc3RzLmpzXCIpO1xuY29uc3QgcHJvY2Vzc29yRGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KShgJHtjb25zdHNfanNfMi5kZWJ1Z1ByZWZpeH06SW5uZ2VzdFNwYW5Qcm9jZXNzb3JgKTtcbi8qKlxuICogQSBzZXQgb2YgcmVzb3VyY2UgYXR0cmlidXRlcyB0aGF0IGFyZSB1c2VkIHRvIGlkZW50aWZ5IHRoZSBJbm5nZXN0IGFwcCBhbmRcbiAqICB0aGUgZnVuY3Rpb24gdGhhdCBpcyBiZWluZyBleGVjdXRlZC4gVGhpcyBpcyB1c2VkIHRvIHN0b3JlIHRoZSByZXNvdXJjZVxuICogYXR0cmlidXRlcyBmb3IgdGhlIHNwYW5zIHRoYXQgYXJlIGV4cG9ydGVkIHRvIHRoZSBJbm5nZXN0IGVuZHBvaW50LCBhbmQgY2FjaGVcbiAqICB0aGVtIGZvciBsYXRlciB1c2UuXG4gKi9cbmxldCBfcmVzb3VyY2VBdHRyaWJ1dGVzO1xuLyoqXG4gKiBBbiBPVGVsIHNwYW4gcHJvY2Vzc29yIHRoYXQgaXMgdXNlZCB0byBleHBvcnQgc3BhbnMgdG8gdGhlIElubmdlc3QgZW5kcG9pbnQuXG4gKiBUaGlzIGlzIHVzZWQgdG8gdHJhY2sgc3BhbnMgdGhhdCBhcmUgY3JlYXRlZCB3aXRoaW4gYW4gSW5uZ2VzdCBydW4gYW5kIGV4cG9ydFxuICogdGhlbSB0byB0aGUgSW5uZ2VzdCBlbmRwb2ludCBmb3IgdHJhY2luZy5cbiAqXG4gKiBJdCdzIGNhcmVmdWwgdG8gb25seSBwaWNrIHJlbGV2YW50IHNwYW5zIHRvIGV4cG9ydCBhbmQgd2lsbCBub3Qgc2VuZCBhbnlcbiAqIGlycmVsZXZhbnQgc3BhbnMgdG8gdGhlIElubmdlc3QgZW5kcG9pbnQuXG4gKlxuICogVEhJUyBJUyBUSEUgSU5URVJOQUwgSU1QTEVNRU5UQVRJT04gT0YgVEhFIFNQQU4gUFJPQ0VTU09SIEFORCBTSE9VTEQgTk9UIEJFXG4gKiBVU0VEIEJZIFVTRVJTIERJUkVDVExZLiBVU0UgVEhFIHtAbGluayBQdWJsaWNJbm5nZXN0U3BhblByb2Nlc3Nvcn0gQ0xBU1NcbiAqIElOU1RFQUQuXG4gKi9cbmNsYXNzIElubmdlc3RTcGFuUHJvY2Vzc29yIHtcbiAgICAvKipcbiAgICAgKiBBbiBPVGVsIHNwYW4gcHJvY2Vzc29yIHRoYXQgaXMgdXNlZCB0byBleHBvcnQgc3BhbnMgdG8gdGhlIElubmdlc3QgZW5kcG9pbnQuXG4gICAgICogVGhpcyBpcyB1c2VkIHRvIHRyYWNrIHNwYW5zIHRoYXQgYXJlIGNyZWF0ZWQgd2l0aGluIGFuIElubmdlc3QgcnVuIGFuZCBleHBvcnRcbiAgICAgKiB0aGVtIHRvIHRoZSBJbm5nZXN0IGVuZHBvaW50IGZvciB0cmFjaW5nLlxuICAgICAqXG4gICAgICogSXQncyBjYXJlZnVsIHRvIG9ubHkgcGljayByZWxldmFudCBzcGFucyB0byBleHBvcnQgYW5kIHdpbGwgbm90IHNlbmQgYW55XG4gICAgICogaXJyZWxldmFudCBzcGFucyB0byB0aGUgSW5uZ2VzdCBlbmRwb2ludC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICAgKiBUaGUgYXBwIHRoYXQgdGhpcyBzcGFuIHByb2Nlc3NvciBpcyBhc3NvY2lhdGVkIHdpdGguIFRoaXMgaXMgdXNlZCB0b1xuICAgICAqIGRldGVybWluZSB0aGUgSW5uZ2VzdCBlbmRwb2ludCB0byBleHBvcnQgc3BhbnMgdG8uXG4gICAgICpcbiAgICAgKiBJdCBpcyBvcHRpb25hbCBoZXJlIGFzIHRoaXMgaXMgdGhlIHByaXZhdGUgY29uc3RydWN0b3IgYW5kIG9ubHkgdXNlZFxuICAgICAqIGludGVybmFsbHk7IHdlIHNldCBgYXBwYCBlbHNld2hlcmUgYXMgd2hlbiB3ZSBjcmVhdGUgdGhlIHByb2Nlc3NvciAoYXNcbiAgICAgKiBlYXJseSBhcyBwb3NzaWJsZSB3aGVuIHRoZSBwcm9jZXNzIHN0YXJ0cykgd2UgZG9uJ3QgbmVjZXNzYXJpbHkgaGF2ZSB0aGVcbiAgICAgKiBhcHAgYXZhaWxhYmxlIHlldC5cbiAgICAgKlxuICAgICAqIFNvLCBpbnRlcm5hbGx5IHdlIGNhbiBkZWxheSBzZXR0aW5nIHRocyB1bnRpbCBsYXRlci5cbiAgICAgKi9cbiAgICBhcHApIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgYEJhdGNoU3BhblByb2Nlc3NvcmAgdGhhdCBpcyB1c2VkIHRvIGV4cG9ydCBzcGFucyB0byB0aGUgSW5uZ2VzdFxuICAgICAgICAgKiBlbmRwb2ludC4gVGhpcyBpcyBjcmVhdGVkIGxhemlseSB0byBhdm9pZCBjcmVhdGluZyBpdCB1bnRpbCB0aGUgSW5uZ2VzdCBBcHBcbiAgICAgICAgICogaGFzIGJlZW4gaW5pdGlhbGl6ZWQgYW5kIGhhcyBoYWQgYSBjaGFuY2UgdG8gcmVjZWl2ZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMsXG4gICAgICAgICAqIHdoaWNoIG1heSBiZSBmcm9tIGFuIGluY29taW5nIHJlcXVlc3QuXG4gICAgICAgICAqL1xuICAgICAgICBfSW5uZ2VzdFNwYW5Qcm9jZXNzb3JfYmF0Y2hlci5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgc2V0IG9mIHNwYW5zIHVzZWQgdG8gdHJhY2sgc3BhbnMgdGhhdCB3ZSBjYXJlIGFib3V0LCBzbyB0aGF0IHdlIGNhblxuICAgICAgICAgKiBleHBvcnQgdGhlbSB0byB0aGUgT1RlbCBlbmRwb2ludC5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgYSBzcGFuIGZhbGxzIG91dCBvZiByZWZlcmVuY2UsIGl0IHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoaXMgc2V0IGFzIHdlJ2xsXG4gICAgICAgICAqIG5ldmVyIGdldCBhIGNoYW5jZSB0byBleHBvcnQgaXQgb3IgcmVtb3ZlIGl0IGFueXdheS5cbiAgICAgICAgICovXG4gICAgICAgIF9Jbm5nZXN0U3BhblByb2Nlc3Nvcl9zcGFuc1RvRXhwb3J0LnNldCh0aGlzLCBuZXcgV2Vha1NldCgpKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbWFwIG9mIHNwYW4gSURzIHRvIHRoZWlyIHBhcmVudCBzdGF0ZSwgd2hpY2ggaW5jbHVkZXMgYSBibG9jayBvZlxuICAgICAgICAgKiBpbmZvcm1hdGlvbiB0aGF0IGNhbiBiZSB1c2VkIGFuZCBwdXNoZWQgYmFjayB0byB0aGUgSW5uZ2VzdCBlbmRwb2ludCB0b1xuICAgICAgICAgKiBpbmdlc3Qgc3BhbnMuXG4gICAgICAgICAqL1xuICAgICAgICBfSW5uZ2VzdFNwYW5Qcm9jZXNzb3JfdHJhY2VQYXJlbnRzLnNldCh0aGlzLCBuZXcgTWFwKCkpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSByZWdpc3RyeSB1c2VkIHRvIGNsZWFuIHVwIGl0ZW1zIGZyb20gdGhlIGB0cmFjZVBhcmVudHNgIG1hcCB3aGVuIHNwYW5zXG4gICAgICAgICAqIGZhbGwgb3V0IG9mIHJlZmVyZW5jZS4gVGhpcyBpcyB1c2VkIHRvIGF2b2lkIG1lbW9yeSBsZWFrcyBpbiB0aGUgY2FzZSB3aGVyZVxuICAgICAgICAgKiBhIHNwYW4gaXMgbm90IGV4cG9ydGVkLCByZW1haW5zIHVuZW5kZWQsIGFuZCBpcyBsZWZ0IGluIG1lbW9yeSBiZWZvcmUgYmVpbmdcbiAgICAgICAgICogR0MnZC5cbiAgICAgICAgICovXG4gICAgICAgIF9Jbm5nZXN0U3BhblByb2Nlc3Nvcl9zcGFuQ2xlYW51cC5zZXQodGhpcywgbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KChzcGFuSWQpID0+IHtcbiAgICAgICAgICAgIGlmIChzcGFuSWQpIHtcbiAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Jbm5nZXN0U3BhblByb2Nlc3Nvcl90cmFjZVBhcmVudHMsIFwiZlwiKS5kZWxldGUoc3BhbklkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICBpZiAoYXBwKSB7XG4gICAgICAgICAgICBhY2Nlc3NfanNfMS5jbGllbnRQcm9jZXNzb3JNYXAuc2V0KGFwcCwgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSW4gb3JkZXIgdG8gb25seSBjYXB0dXJlIGEgc3Vic2V0IG9mIHNwYW5zLCB3ZSBuZWVkIHRvIGRlY2xhcmUgdGhlIGluaXRpYWxcbiAgICAgKiBzcGFuIHRoYXQgd2UgY2FyZSBhYm91dCBhbmQgdGhlbiBleHBvcnQgaXRzIGNoaWxkcmVuLlxuICAgICAqXG4gICAgICogQ2FsbCB0aGlzIG1ldGhvZCAoaWRlYWxseSBqdXN0IGJlZm9yZSBleGVjdXRpb24gc3RhcnRzKSB3aXRoIHRoYXQgaW5pdGlhbFxuICAgICAqIHNwYW4gdG8gdHJpZ2dlciBjYXB0dXJpbmcgYWxsIGZvbGxvd2luZyBjaGlsZHJlbiBhcyB3ZWxsIGFzIGluaXRpYWxpemUgdGhlXG4gICAgICogYmF0Y2hlci5cbiAgICAgKi9cbiAgICBkZWNsYXJlU3RhcnRpbmdTcGFuKHsgc3BhbiwgcnVuSWQsIHRyYWNlcGFyZW50LCB0cmFjZXN0YXRlLCB9KSB7XG4gICAgICAgIC8vIFVwc2VydCB0aGUgYmF0Y2hlciByZWFkeSBmb3IgbGF0ZXIuIFdlIGRvIHRoaXMgaGVyZSB0byBib290c3RyYXAgaXQgd2l0aFxuICAgICAgICAvLyB0aGUgY29ycmVjdCBhc3luYyBjb250ZXh0IGFzIHNvb24gYXMgd2UgY2FuLiBBcyB0aGlzIG1ldGhvZCBpcyBvbmx5XG4gICAgICAgIC8vIGNhbGxlZCBqdXN0IGJlZm9yZSBleGVjdXRpb24sIHdlIGtub3cgd2UncmUgYWxsIHNldCB1cC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gV2FpdGluZyB0byBjYWxsIHRoaXMgdW50aWwgd2UgYWN0dWFsbHkgbmVlZCB0aGUgYmF0Y2hlciB3b3VsZCBtZWFuIHRoYXRcbiAgICAgICAgLy8gd2UgbWlnaHQgbm90IGhhdmUgdGhlIGNvcnJlY3QgYXN5bmMgY29udGV4dCBzZXQgdXAsIGFzIHdlJ2QgbGlrZWx5IGJlIGluXG4gICAgICAgIC8vIHNvbWUgc3BhbiBsaWZlY3ljbGUgbWV0aG9kIHRoYXQgZG9lc24ndCBoYXZlIHRoZSBzYW1lIGNoYWluIG9mIGV4ZWN1dGlvbi5cbiAgICAgICAgdm9pZCB0aGlzLmVuc3VyZUJhdGNoZXJJbml0aWFsaXplZCgpO1xuICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgdHJhY2VwYXJlbnQsIHRoZW4gd2UgY2FuJ3QgdHJhY2sgdGhpcyBzcGFuLiBUaGlzIGlzXG4gICAgICAgIC8vIGxpa2VseSBhIHNwYW4gdGhhdCB3ZSBkb24ndCBjYXJlIGFib3V0LCBzbyB3ZSBjYW4gaWdub3JlIGl0LlxuICAgICAgICBpZiAoIXRyYWNlcGFyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvY2Vzc29yRGVidWcoXCJubyB0cmFjZXBhcmVudCBmb3VuZCBmb3Igc3BhblwiLCBzcGFuLnNwYW5Db250ZXh0KCkuc3BhbklkLCBcInNvIHNraXBwaW5nIGl0XCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGFsc28gYXR0ZW1wdCB0byB1c2UgYHRyYWNlc3RhdGVgLiBUaGUgdmFsdWVzIHdlIGZldGNoIGZyb20gdGhlc2VcbiAgICAgICAgLy8gc2hvdWxkIGJlIG9wdGlvbmFsLCBhcyBpdCdzIGxpa2VseSB0aGUgRXhlY3V0b3Igd29uJ3QgbmVlZCB1cyB0byBwYXJyb3RcbiAgICAgICAgLy8gdGhlbSBiYWNrIGluIGxhdGVyIHZlcnNpb25zLlxuICAgICAgICBsZXQgYXBwSWQ7XG4gICAgICAgIGxldCBmdW5jdGlvbklkO1xuICAgICAgICBpZiAodHJhY2VzdGF0ZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbnRyaWVzID0gT2JqZWN0LmZyb21FbnRyaWVzKHRyYWNlc3RhdGUuc3BsaXQoXCIsXCIpLm1hcCgoa3YpID0+IGt2LnNwbGl0KFwiPVwiKSkpO1xuICAgICAgICAgICAgICAgIGFwcElkID0gZW50cmllc1tjb25zdHNfanNfMi5UcmFjZVN0YXRlS2V5LkFwcElkXTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbklkID0gZW50cmllc1tjb25zdHNfanNfMi5UcmFjZVN0YXRlS2V5LkZ1bmN0aW9uSWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHByb2Nlc3NvckRlYnVnKFwiZmFpbGVkIHRvIHBhcnNlIHRyYWNlc3RhdGVcIiwgdHJhY2VzdGF0ZSwgXCJzbyBza2lwcGluZyBpdDtcIiwgZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUaGlzIGlzIGEgc3BhbiB0aGF0IHdlIGNhcmUgYWJvdXQsIHNvIGxldCdzIG1ha2Ugc3VyZSBpdCBhbmQgaXRzXG4gICAgICAgIC8vIGNoaWxkcmVuIGFyZSBleHBvcnRlZC5cbiAgICAgICAgcHJvY2Vzc29yRGVidWcuZXh0ZW5kKFwiZGVjbGFyZVN0YXJ0aW5nU3BhblwiKShcImRlY2xhcmluZzpcIiwgc3Bhbi5zcGFuQ29udGV4dCgpLnNwYW5JZCwgXCJmb3IgdHJhY2VwYXJlbnRcIiwgdHJhY2VwYXJlbnQpO1xuICAgICAgICAvLyBTZXQgYSBsb2FkIG9mIGF0dHJpYnV0ZXMgb24gdGhpcyBzcGFuIHNvIHRoYXQgd2UgY2FuIG5pY2VseSBpZGVudGlmeVxuICAgICAgICAvLyBydW50aW1lLCBwYXRocywgZXRjLiBPbmx5IHRoaXMgc3BhbiB3aWxsIGhhdmUgdGhlc2UgYXR0cmlidXRlcy5cbiAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGVzKElubmdlc3RTcGFuUHJvY2Vzc29yLnJlc291cmNlQXR0cmlidXRlcy5hdHRyaWJ1dGVzKTtcbiAgICAgICAgdGhpcy50cmFja1NwYW4oe1xuICAgICAgICAgICAgYXBwSWQsXG4gICAgICAgICAgICBmdW5jdGlvbklkLFxuICAgICAgICAgICAgcnVuSWQsXG4gICAgICAgICAgICB0cmFjZXBhcmVudCxcbiAgICAgICAgfSwgc3Bhbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgZ2V0dGVyIGZvciByZXRyaWV2aW5nIHJlc291cmNlIGF0dHJpYnV0ZXMgZm9yIHRoZSBjdXJyZW50IHByb2Nlc3MuIFRoaXNcbiAgICAgKiBpcyB1c2VkIHRvIHNldCB0aGUgcmVzb3VyY2UgYXR0cmlidXRlcyBmb3IgdGhlIHNwYW5zIHRoYXQgYXJlIGV4cG9ydGVkIHRvXG4gICAgICogdGhlIElubmdlc3QgZW5kcG9pbnQsIGFuZCBjYWNoZSB0aGVtIGZvciBsYXRlciB1c2UuXG4gICAgICovXG4gICAgc3RhdGljIGdldCByZXNvdXJjZUF0dHJpYnV0ZXMoKSB7XG4gICAgICAgIGlmICghX3Jlc291cmNlQXR0cmlidXRlcykge1xuICAgICAgICAgICAgX3Jlc291cmNlQXR0cmlidXRlcyA9ICgwLCByZXNvdXJjZXNfMS5kZXRlY3RSZXNvdXJjZXNTeW5jKSh7XG4gICAgICAgICAgICAgICAgZGV0ZWN0b3JzOiBbXG4gICAgICAgICAgICAgICAgICAgIHJlc291cmNlc18xLm9zRGV0ZWN0b3JTeW5jLFxuICAgICAgICAgICAgICAgICAgICByZXNvdXJjZXNfMS5lbnZEZXRlY3RvclN5bmMsXG4gICAgICAgICAgICAgICAgICAgIHJlc291cmNlc18xLmhvc3REZXRlY3RvclN5bmMsXG4gICAgICAgICAgICAgICAgICAgIHJlc291cmNlc18xLnByb2Nlc3NEZXRlY3RvclN5bmMsXG4gICAgICAgICAgICAgICAgICAgIHJlc291cmNlc18xLnNlcnZpY2VJbnN0YW5jZUlkRGV0ZWN0b3JTeW5jLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Jlc291cmNlQXR0cmlidXRlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGJhdGNoZXIgaXMgYSBzaW5nbGV0b24gdGhhdCBpcyB1c2VkIHRvIGV4cG9ydCBzcGFucyB0byB0aGUgT1RlbFxuICAgICAqIGVuZHBvaW50LiBJdCBpcyBjcmVhdGVkIGxhemlseSB0byBhdm9pZCBjcmVhdGluZyBpdCB1bnRpbCB0aGUgSW5uZ2VzdCBBcHBcbiAgICAgKiBoYXMgYmVlbiBpbml0aWFsaXplZCBhbmQgaGFzIGhhZCBhIGNoYW5jZSB0byByZWNlaXZlIGVudmlyb25tZW50IHZhcmlhYmxlcyxcbiAgICAgKiB3aGljaCBtYXkgYmUgZnJvbSBhbiBpbmNvbWluZyByZXF1ZXN0LlxuICAgICAqXG4gICAgICogVGhlIGJhdGNoZXIgaXMgb25seSByZWZlcmVuY2VkIG9uY2Ugd2UndmUgZm91bmQgYSBzcGFuIHdlJ3JlIGludGVyZXN0ZWQgaW4sXG4gICAgICogc28gdGhpcyBzaG91bGQgYWx3YXlzIGhhdmUgZXZlcnl0aGluZyBpdCBuZWVkcyBvbiB0aGUgYXBwIGJ5IHRoZW4uXG4gICAgICovXG4gICAgZW5zdXJlQmF0Y2hlckluaXRpYWxpemVkKCkge1xuICAgICAgICBpZiAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0lubmdlc3RTcGFuUHJvY2Vzc29yX2JhdGNoZXIsIFwiZlwiKSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1taXN1c2VkLXByb21pc2VzLCBuby1hc3luYy1wcm9taXNlLWV4ZWN1dG9yXG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9Jbm5nZXN0U3BhblByb2Nlc3Nvcl9iYXRjaGVyLCBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIHJldHJpZXZlIHRoZSBhcHAgZnJvbSB0aGUgYXN5bmMgY29udGV4dCwgc28gd2UgbXVzdCBtYWtlIHN1cmVcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhhdCB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBmcm9tIHRoZSBjb3JyZWN0IGNoYWluLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdG9yZSA9IGF3YWl0ICgwLCBhbHNfanNfMS5nZXRBc3luY0N0eCkoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdG9yZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gYXN5bmMgY29udGV4dCBmb3VuZDsgY2Fubm90IGNyZWF0ZSBiYXRjaGVyIHRvIGV4cG9ydCB0cmFjZXNcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXBwID0gc3RvcmUuYXBwO1xuICAgICAgICAgICAgICAgICAgICAvLyBGZXRjaCB0aGUgVVJMIGZvciB0aGUgSW5uZ2VzdCBlbmRwb2ludCB1c2luZyB0aGUgYXBwJ3MgY29uZmlnLlxuICAgICAgICAgICAgICAgICAgICBsZXQgdXJsO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXRoID0gXCIvdjEvdHJhY2VzL3VzZXJsYW5kXCI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcHAuYXBpQmFzZVVybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gbmV3IFVSTChwYXRoLCBhcHAuYXBpQmFzZVVybCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBuZXcgVVJMKHBhdGgsIGNvbnN0c19qc18xLmRlZmF1bHRJbm5nZXN0QXBpQmFzZVVybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXBwW1wibW9kZVwiXSAmJiBhcHBbXCJtb2RlXCJdLmlzRGV2ICYmIGFwcFtcIm1vZGVcIl0uaXNJbmZlcnJlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRldkhvc3QgPSAoMCwgZW52X2pzXzEuZGV2U2VydmVySG9zdCkoKSB8fCBjb25zdHNfanNfMS5kZWZhdWx0RGV2U2VydmVySG9zdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBoYXNEZXZTZXJ2ZXIgPSBhd2FpdCAoMCwgZGV2c2VydmVyX2pzXzEuZGV2U2VydmVyQXZhaWxhYmxlKShkZXZIb3N0LCBhcHBbXCJmZXRjaFwiXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc0RldlNlcnZlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBuZXcgVVJMKHBhdGgsIGRldkhvc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKChfYSA9IGFwcFtcIm1vZGVcIl0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5leHBsaWNpdERldlVybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IG5ldyBVUkwocGF0aCwgYXBwW1wibW9kZVwiXS5leHBsaWNpdERldlVybC5ocmVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzb3JEZWJ1ZyhcImJhdGNoZXIgbGF6aWx5IGFjY2Vzc2VkOyBjcmVhdGluZyBuZXcgYmF0Y2hlciB3aXRoIFVSTFwiLCB1cmwpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBleHBvcnRlciA9IG5ldyBleHBvcnRlcl90cmFjZV9vdGxwX2h0dHBfMS5PVExQVHJhY2VFeHBvcnRlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHVybC5ocmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHthcHBbXCJpbm5nZXN0QXBpXCJdW1wic2lnbmluZ0tleVwiXX1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUobmV3IHNka190cmFjZV9iYXNlXzEuQmF0Y2hTcGFuUHJvY2Vzc29yKGV4cG9ydGVyKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksIFwiZlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSW5uZ2VzdFNwYW5Qcm9jZXNzb3JfYmF0Y2hlciwgXCJmXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXJrIGEgc3BhbiBhcyBiZWluZyB0cmFja2VkIGJ5IHRoaXMgcHJvY2Vzc29yLCBtZWFuaW5nIGl0IHdpbGwgYmUgZXhwb3J0ZWRcbiAgICAgKiB0byB0aGUgSW5nZ2VzdCBlbmRwb2ludCB3aGVuIGl0IGVuZHMuXG4gICAgICovXG4gICAgdHJhY2tTcGFuKHBhcmVudFN0YXRlLCBzcGFuKSB7XG4gICAgICAgIGNvbnN0IHNwYW5JZCA9IHNwYW4uc3BhbkNvbnRleHQoKS5zcGFuSWQ7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0lubmdlc3RTcGFuUHJvY2Vzc29yX3NwYW5DbGVhbnVwLCBcImZcIikucmVnaXN0ZXIoc3Bhbiwgc3BhbklkLCBzcGFuKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSW5uZ2VzdFNwYW5Qcm9jZXNzb3Jfc3BhbnNUb0V4cG9ydCwgXCJmXCIpLmFkZChzcGFuKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSW5uZ2VzdFNwYW5Qcm9jZXNzb3JfdHJhY2VQYXJlbnRzLCBcImZcIikuc2V0KHNwYW5JZCwgcGFyZW50U3RhdGUpO1xuICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShjb25zdHNfanNfMi5BdHRyaWJ1dGUuSW5uZ2VzdFRyYWNlcGFyZW50LCBwYXJlbnRTdGF0ZS50cmFjZXBhcmVudCk7XG4gICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKGNvbnN0c19qc18yLkF0dHJpYnV0ZS5Jbm5nZXN0UnVuSWQsIHBhcmVudFN0YXRlLnJ1bklkKTtcbiAgICAgICAgLy8gU2V0dGluZyBhcHAgSUQgaXMgb3B0aW9uYWw7IGl0J3MgbGlrZWx5IGluIGZ1dHVyZSB2ZXJzaW9ucyBvZiB0aGVcbiAgICAgICAgLy8gRXhlY3V0b3IgdGhhdCB3ZSBkb24ndCBuZWVkIHRvIHBhcnJvdCB0aGlzIGJhY2suXG4gICAgICAgIGlmIChwYXJlbnRTdGF0ZS5hcHBJZCkge1xuICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoY29uc3RzX2pzXzIuQXR0cmlidXRlLklubmdlc3RBcHBJZDEsIHBhcmVudFN0YXRlLmFwcElkKTtcbiAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKGNvbnN0c19qc18yLkF0dHJpYnV0ZS5Jbm5nZXN0QXBwSWQyLCBwYXJlbnRTdGF0ZS5hcHBJZCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0dGluZyBmdW5jdGlvbiBJRCBpcyBvcHRpb25hbDsgaXQncyBsaWtlbHkgaW4gZnV0dXJlIHZlcnNpb25zIG9mIHRoZVxuICAgICAgICAvLyBFeGVjdXRvciB0aGF0IHdlIGRvbid0IG5lZWQgdG8gcGFycm90IHRoaXMgYmFjay5cbiAgICAgICAgaWYgKHBhcmVudFN0YXRlLmZ1bmN0aW9uSWQpIHtcbiAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKGNvbnN0c19qc18yLkF0dHJpYnV0ZS5Jbm5nZXN0RnVuY3Rpb25JZCwgcGFyZW50U3RhdGUuZnVuY3Rpb25JZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYW4gdXAgYW55IHJlZmVyZW5jZXMgdG8gYSBzcGFuIHRoYXQgaGFzIGVuZGVkLiBUaGlzIGlzIHVzZWQgdG8gYXZvaWRcbiAgICAgKiBtZW1vcnkgbGVha3MgaW4gdGhlIGNhc2Ugd2hlcmUgYSBzcGFuIGlzIG5vdCBleHBvcnRlZCwgcmVtYWlucyB1bmVuZGVkLCBhbmRcbiAgICAgKiBpcyBsZWZ0IGluIG1lbW9yeSBiZWZvcmUgYmVpbmcgR0MnZC5cbiAgICAgKi9cbiAgICBjbGVhbnVwU3BhbihzcGFuKSB7XG4gICAgICAgIGNvbnN0IHNwYW5JZCA9IHNwYW4uc3BhbkNvbnRleHQoKS5zcGFuSWQ7XG4gICAgICAgIC8vIFRoaXMgc3BhbiBpcyBubyBsb25nZXIgaW4gdXNlLCBzbyB3ZSBjYW4gcmVtb3ZlIGl0IGZyb20gdGhlIGNsZWFudXBcbiAgICAgICAgLy8gcmVnaXN0cnkuXG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0lubmdlc3RTcGFuUHJvY2Vzc29yX3NwYW5DbGVhbnVwLCBcImZcIikudW5yZWdpc3RlcihzcGFuKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSW5uZ2VzdFNwYW5Qcm9jZXNzb3Jfc3BhbnNUb0V4cG9ydCwgXCJmXCIpLmRlbGV0ZShzcGFuKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSW5uZ2VzdFNwYW5Qcm9jZXNzb3JfdHJhY2VQYXJlbnRzLCBcImZcIikuZGVsZXRlKHNwYW5JZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFuIGltcGxlbWVudGF0aW9uIG9mIHRoZSBgb25TdGFydGAgbWV0aG9kIGZyb20gdGhlIGBTcGFuUHJvY2Vzc29yYFxuICAgICAqIGludGVyZmFjZS4gVGhpcyBpcyBjYWxsZWQgd2hlbiBhIHNwYW4gaXMgc3RhcnRlZCwgYW5kIGlzIHVzZWQgdG8gdHJhY2tcbiAgICAgKiBzcGFucyB0aGF0IGFyZSBjaGlsZHJlbiBvZiBzcGFucyB3ZSBjYXJlIGFib3V0LlxuICAgICAqL1xuICAgIG9uU3RhcnQoc3Bhbikge1xuICAgICAgICBjb25zdCBkZWJ1ZyA9IHByb2Nlc3NvckRlYnVnLmV4dGVuZChcIm9uU3RhcnRcIik7XG4gICAgICAgIGNvbnN0IHNwYW5JZCA9IHNwYW4uc3BhbkNvbnRleHQoKS5zcGFuSWQ7XG4gICAgICAgIC8vIPCfpKsgSXQgc2VlbXMgdG8gd29ya1xuICAgICAgICBjb25zdCBwYXJlbnRTcGFuSWQgPSBzcGFuLnBhcmVudFNwYW5JZDtcbiAgICAgICAgLy8gVGhlIHJvb3Qgc3BhbiBpc24ndCBjYXB0dXJlZCBoZXJlLCBidXQgd2UgY2FuIGNhcHR1cmUgY2hpbGRyZW4gb2YgaXRcbiAgICAgICAgLy8gaGVyZS5cbiAgICAgICAgaWYgKCFwYXJlbnRTcGFuSWQpIHtcbiAgICAgICAgICAgIC8vIEFsbCBzcGFucyB0aGF0IElubmdlc3QgY2FyZXMgYWJvdXQgd2lsbCBoYXZlIGEgcGFyZW50LCBzbyBpZ25vcmUgdGhpc1xuICAgICAgICAgICAgZGVidWcoXCJubyBwYXJlbnQgc3BhbiBJRCBmb3JcIiwgc3BhbklkLCBcInNvIHNraXBwaW5nIGl0XCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmVudFN0YXRlID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSW5uZ2VzdFNwYW5Qcm9jZXNzb3JfdHJhY2VQYXJlbnRzLCBcImZcIikuZ2V0KHBhcmVudFNwYW5JZCk7XG4gICAgICAgIGlmIChwYXJlbnRTdGF0ZSkge1xuICAgICAgICAgICAgLy8gVGhpcyBzcGFuIGlzIGEgY2hpbGQgb2YgYSBzcGFuIHdlIGNhcmUgYWJvdXQsIHNvIGFkZCBpdCB0byB0aGUgbGlzdCBvZlxuICAgICAgICAgICAgLy8gdHJhY2tlZCBzcGFucyBzbyB0aGF0IHdlIGFsc28gY2FwdHVyZSBpdHMgY2hpbGRyZW5cbiAgICAgICAgICAgIGRlYnVnKFwiZm91bmQgdHJhY2VwYXJlbnRcIiwgcGFyZW50U3RhdGUsIFwiaW4gc3BhbiBJRFwiLCBwYXJlbnRTcGFuSWQsIFwic28gYWRkaW5nXCIsIHNwYW5JZCk7XG4gICAgICAgICAgICB0aGlzLnRyYWNrU3BhbihwYXJlbnRTdGF0ZSwgc3Bhbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQW4gaW1wbGVtZW50YXRpb24gb2YgdGhlIGBvbkVuZGAgbWV0aG9kIGZyb20gdGhlIGBTcGFuUHJvY2Vzc29yYCBpbnRlcmZhY2UuXG4gICAgICogVGhpcyBpcyBjYWxsZWQgd2hlbiBhIHNwYW4gZW5kcywgYW5kIGlzIHVzZWQgdG8gZXhwb3J0IHNwYW5zIHRvIHRoZSBJbm5nZXN0XG4gICAgICogZW5kcG9pbnQuXG4gICAgICovXG4gICAgb25FbmQoc3Bhbikge1xuICAgICAgICBjb25zdCBkZWJ1ZyA9IHByb2Nlc3NvckRlYnVnLmV4dGVuZChcIm9uRW5kXCIpO1xuICAgICAgICBjb25zdCBzcGFuSWQgPSBzcGFuLnNwYW5Db250ZXh0KCkuc3BhbklkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0lubmdlc3RTcGFuUHJvY2Vzc29yX3NwYW5zVG9FeHBvcnQsIFwiZlwiKS5oYXMoc3BhbikpIHtcbiAgICAgICAgICAgICAgICBpZiAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0lubmdlc3RTcGFuUHJvY2Vzc29yX2JhdGNoZXIsIFwiZlwiKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVidWcoXCJiYXRjaGVyIG5vdCBpbml0aWFsaXplZCwgc28gZmFpbGVkIGV4cG9ydGluZyBzcGFuXCIsIHNwYW5JZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlYnVnKFwiZXhwb3J0aW5nIHNwYW5cIiwgc3BhbklkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdm9pZCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Jbm5nZXN0U3BhblByb2Nlc3Nvcl9iYXRjaGVyLCBcImZcIikudGhlbigoYmF0Y2hlcikgPT4gYmF0Y2hlci5vbkVuZChzcGFuKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWJ1ZyhcIm5vdCBleHBvcnRpbmcgc3BhblwiLCBzcGFuSWQsIFwiYXMgd2UgZG9uJ3QgY2FyZSBhYm91dCBpdFwiKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMuY2xlYW51cFNwYW4oc3Bhbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQW4gaW1wbGVtZW50YXRpb24gb2YgdGhlIGBmb3JjZUZsdXNoYCBtZXRob2QgZnJvbSB0aGUgYFNwYW5Qcm9jZXNzb3JgXG4gICAgICogaW50ZXJmYWNlLiBUaGlzIGlzIGNhbGxlZCB0byBmb3JjZSB0aGUgcHJvY2Vzc29yIHRvIGZsdXNoIGFueSBzcGFucyB0aGF0XG4gICAgICogYXJlIGN1cnJlbnRseSBpbiB0aGUgYmF0Y2hlci4gVGhpcyBpcyB1c2VkIHRvIGVuc3VyZSB0aGF0IHNwYW5zIGFyZVxuICAgICAqIGV4cG9ydGVkIHRvIHRoZSBJbm5nZXN0IGVuZHBvaW50IGJlZm9yZSB0aGUgcHJvY2VzcyBleGl0cy5cbiAgICAgKlxuICAgICAqIE5vdGFibHksIHdlIGNhbGwgdGhpcyBpbiB0aGUgYGJlZm9yZVJlc3BvbnNlYCBtaWRkbGV3YXJlIGhvb2sgdG8gZW5zdXJlXG4gICAgICogdGhhdCBzcGFucyBmb3IgYSBydW4gYXMgZXhwb3J0ZWQgYXMgc29vbiBhcyBwb3NzaWJsZSBhbmQgYmVmb3JlIHRoZVxuICAgICAqIHNlcnZlcmxlc3MgcHJvY2VzcyBpcyBraWxsZWQuXG4gICAgICovXG4gICAgYXN5bmMgZm9yY2VGbHVzaCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBmbHVzaERlYnVnID0gcHJvY2Vzc29yRGVidWcuZXh0ZW5kKFwiZm9yY2VGbHVzaFwiKTtcbiAgICAgICAgZmx1c2hEZWJ1ZyhcImZvcmNlIGZsdXNoaW5nIGJhdGNoZXJcIik7XG4gICAgICAgIHJldHVybiAoX2EgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Jbm5nZXN0U3BhblByb2Nlc3Nvcl9iYXRjaGVyLCBcImZcIikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50aGVuKChiYXRjaGVyKSA9PiBiYXRjaGVyLmZvcmNlRmx1c2goKSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgZmx1c2hEZWJ1ZyhcImVycm9yIGZsdXNoaW5nIGJhdGNoZXJcIiwgZXJyLCBcImlnbm9yaW5nXCIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgc2h1dGRvd24oKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcHJvY2Vzc29yRGVidWcuZXh0ZW5kKFwic2h1dGRvd25cIikoXCJzaHV0dGluZyBkb3duIGJhdGNoZXJcIik7XG4gICAgICAgIHJldHVybiAoX2EgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Jbm5nZXN0U3BhblByb2Nlc3Nvcl9iYXRjaGVyLCBcImZcIikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50aGVuKChiYXRjaGVyKSA9PiBiYXRjaGVyLnNodXRkb3duKCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuSW5uZ2VzdFNwYW5Qcm9jZXNzb3IgPSBJbm5nZXN0U3BhblByb2Nlc3Nvcjtcbl9Jbm5nZXN0U3BhblByb2Nlc3Nvcl9iYXRjaGVyID0gbmV3IFdlYWtNYXAoKSwgX0lubmdlc3RTcGFuUHJvY2Vzc29yX3NwYW5zVG9FeHBvcnQgPSBuZXcgV2Vha01hcCgpLCBfSW5uZ2VzdFNwYW5Qcm9jZXNzb3JfdHJhY2VQYXJlbnRzID0gbmV3IFdlYWtNYXAoKSwgX0lubmdlc3RTcGFuUHJvY2Vzc29yX3NwYW5DbGVhbnVwID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuICogQW4gT1RlbCBzcGFuIHByb2Nlc3NvciB0aGF0IGlzIHVzZWQgdG8gZXhwb3J0IHNwYW5zIHRvIHRoZSBJbm5nZXN0IGVuZHBvaW50LlxuICogVGhpcyBpcyB1c2VkIHRvIHRyYWNrIHNwYW5zIHRoYXQgYXJlIGNyZWF0ZWQgd2l0aGluIGFuIElubmdlc3QgcnVuIGFuZCBleHBvcnRcbiAqIHRoZW0gdG8gdGhlIElubmdlc3QgZW5kcG9pbnQgZm9yIHRyYWNpbmcuXG4gKlxuICogSXQncyBjYXJlZnVsIHRvIG9ubHkgcGljayByZWxldmFudCBzcGFucyB0byBleHBvcnQgYW5kIHdpbGwgbm90IHNlbmQgYW55XG4gKiBpcnJlbGV2YW50IHNwYW5zIHRvIHRoZSBJbm5nZXN0IGVuZHBvaW50LlxuICovXG5jbGFzcyBQdWJsaWNJbm5nZXN0U3BhblByb2Nlc3NvciBleHRlbmRzIElubmdlc3RTcGFuUHJvY2Vzc29yIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICAgKiBUaGUgYXBwIHRoYXQgdGhpcyBzcGFuIHByb2Nlc3NvciBpcyBhc3NvY2lhdGVkIHdpdGguIFRoaXMgaXMgdXNlZCB0b1xuICAgICAqIGRldGVybWluZSB0aGUgSW5uZ2VzdCBlbmRwb2ludCB0byBleHBvcnQgc3BhbnMgdG8uXG4gICAgICovXG4gICAgYXBwKSB7XG4gICAgICAgIHN1cGVyKGFwcCk7XG4gICAgfVxufVxuZXhwb3J0cy5QdWJsaWNJbm5nZXN0U3BhblByb2Nlc3NvciA9IFB1YmxpY0lubmdlc3RTcGFuUHJvY2Vzc29yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvY2Vzc29yLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/execution/otel/processor.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/execution/otel/util.js":
/*!****************************************************************!*\
  !*** ./node_modules/inngest/components/execution/otel/util.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.extendProvider = exports.createProvider = void 0;\nconst api_1 = __webpack_require__(/*! @opentelemetry/api */ \"(rsc)/./node_modules/@opentelemetry/api/build/esm/index.js\");\nconst auto_instrumentations_node_1 = __webpack_require__(/*! @opentelemetry/auto-instrumentations-node */ \"(rsc)/./node_modules/@opentelemetry/auto-instrumentations-node/build/src/index.js\");\nconst context_async_hooks_1 = __webpack_require__(/*! @opentelemetry/context-async-hooks */ \"(rsc)/./node_modules/@opentelemetry/context-async-hooks/build/src/index.js\");\nconst instrumentation_1 = __webpack_require__(/*! @opentelemetry/instrumentation */ \"(rsc)/./node_modules/@opentelemetry/instrumentation/build/esm/index.js\");\nconst sdk_trace_base_1 = __webpack_require__(/*! @opentelemetry/sdk-trace-base */ \"(rsc)/./node_modules/@opentelemetry/sdk-trace-base/build/esm/index.js\");\nconst processor_js_1 = __webpack_require__(/*! ./processor.js */ \"(rsc)/./node_modules/inngest/components/execution/otel/processor.js\");\nconst createProvider = (behaviour, instrumentations = []) => {\n    // TODO Check if there's an existing provider\n    const processor = new processor_js_1.InngestSpanProcessor();\n    const p = new sdk_trace_base_1.BasicTracerProvider({\n        spanProcessors: [processor],\n    });\n    const instrList = [\n        ...instrumentations,\n        ...(0, auto_instrumentations_node_1.getNodeAutoInstrumentations)(),\n    ];\n    (0, instrumentation_1.registerInstrumentations)({\n        instrumentations: instrList,\n    });\n    p.register({\n        contextManager: new context_async_hooks_1.AsyncHooksContextManager().enable(),\n    });\n    return { success: true, processor };\n};\nexports.createProvider = createProvider;\n/**\n * Attempts to extend the existing OTel provider with our processor. Returns true\n * if the provider was extended, false if it was not.\n */\nconst extendProvider = (behaviour) => {\n    // Attempt to add our processor and export to the existing provider\n    const existingProvider = api_1.trace.getTracerProvider();\n    if (!existingProvider) {\n        if (behaviour !== \"auto\") {\n            console.warn('No existing OTel provider found and behaviour is \"extendProvider\". Inngest\\'s OTel middleware will not work. Either allow the middleware to create a provider by setting `behaviour: \"createProvider\"` or `behaviour: \"auto\"`, or make sure that the provider is created and imported before the middleware is used.');\n        }\n        return { success: false };\n    }\n    if (!(\"addSpanProcessor\" in existingProvider) ||\n        typeof existingProvider.addSpanProcessor !== \"function\") {\n        // TODO Could we also add a function the user can provide that takes the\n        // processor and adds it? That way they could support many different\n        // providers.\n        if (behaviour !== \"auto\") {\n            console.warn(\"Existing OTel provider is not a BasicTracerProvider. Inngest's OTel middleware will not work, as it can only extend an existing processor if it's a BasicTracerProvider.\");\n        }\n        return { success: false };\n    }\n    const processor = new processor_js_1.InngestSpanProcessor();\n    existingProvider.addSpanProcessor(processor);\n    return { success: true, processor };\n};\nexports.extendProvider = extendProvider;\n//# sourceMappingURL=util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL2V4ZWN1dGlvbi9vdGVsL3V0aWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0JBQXNCLEdBQUcsc0JBQXNCO0FBQy9DLGNBQWMsbUJBQU8sQ0FBQyxzRkFBb0I7QUFDMUMscUNBQXFDLG1CQUFPLENBQUMsb0lBQTJDO0FBQ3hGLDhCQUE4QixtQkFBTyxDQUFDLHNIQUFvQztBQUMxRSwwQkFBMEIsbUJBQU8sQ0FBQyw4R0FBZ0M7QUFDbEUseUJBQXlCLG1CQUFPLENBQUMsNEdBQStCO0FBQ2hFLHVCQUF1QixtQkFBTyxDQUFDLDJGQUFnQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLGFBQWE7QUFDYjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxzQkFBc0I7QUFDdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aXZlLXZpYmUtYWktbmV4dC8uL25vZGVfbW9kdWxlcy9pbm5nZXN0L2NvbXBvbmVudHMvZXhlY3V0aW9uL290ZWwvdXRpbC5qcz8xYWMzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5leHRlbmRQcm92aWRlciA9IGV4cG9ydHMuY3JlYXRlUHJvdmlkZXIgPSB2b2lkIDA7XG5jb25zdCBhcGlfMSA9IHJlcXVpcmUoXCJAb3BlbnRlbGVtZXRyeS9hcGlcIik7XG5jb25zdCBhdXRvX2luc3RydW1lbnRhdGlvbnNfbm9kZV8xID0gcmVxdWlyZShcIkBvcGVudGVsZW1ldHJ5L2F1dG8taW5zdHJ1bWVudGF0aW9ucy1ub2RlXCIpO1xuY29uc3QgY29udGV4dF9hc3luY19ob29rc18xID0gcmVxdWlyZShcIkBvcGVudGVsZW1ldHJ5L2NvbnRleHQtYXN5bmMtaG9va3NcIik7XG5jb25zdCBpbnN0cnVtZW50YXRpb25fMSA9IHJlcXVpcmUoXCJAb3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb25cIik7XG5jb25zdCBzZGtfdHJhY2VfYmFzZV8xID0gcmVxdWlyZShcIkBvcGVudGVsZW1ldHJ5L3Nkay10cmFjZS1iYXNlXCIpO1xuY29uc3QgcHJvY2Vzc29yX2pzXzEgPSByZXF1aXJlKFwiLi9wcm9jZXNzb3IuanNcIik7XG5jb25zdCBjcmVhdGVQcm92aWRlciA9IChiZWhhdmlvdXIsIGluc3RydW1lbnRhdGlvbnMgPSBbXSkgPT4ge1xuICAgIC8vIFRPRE8gQ2hlY2sgaWYgdGhlcmUncyBhbiBleGlzdGluZyBwcm92aWRlclxuICAgIGNvbnN0IHByb2Nlc3NvciA9IG5ldyBwcm9jZXNzb3JfanNfMS5Jbm5nZXN0U3BhblByb2Nlc3NvcigpO1xuICAgIGNvbnN0IHAgPSBuZXcgc2RrX3RyYWNlX2Jhc2VfMS5CYXNpY1RyYWNlclByb3ZpZGVyKHtcbiAgICAgICAgc3BhblByb2Nlc3NvcnM6IFtwcm9jZXNzb3JdLFxuICAgIH0pO1xuICAgIGNvbnN0IGluc3RyTGlzdCA9IFtcbiAgICAgICAgLi4uaW5zdHJ1bWVudGF0aW9ucyxcbiAgICAgICAgLi4uKDAsIGF1dG9faW5zdHJ1bWVudGF0aW9uc19ub2RlXzEuZ2V0Tm9kZUF1dG9JbnN0cnVtZW50YXRpb25zKSgpLFxuICAgIF07XG4gICAgKDAsIGluc3RydW1lbnRhdGlvbl8xLnJlZ2lzdGVySW5zdHJ1bWVudGF0aW9ucykoe1xuICAgICAgICBpbnN0cnVtZW50YXRpb25zOiBpbnN0ckxpc3QsXG4gICAgfSk7XG4gICAgcC5yZWdpc3Rlcih7XG4gICAgICAgIGNvbnRleHRNYW5hZ2VyOiBuZXcgY29udGV4dF9hc3luY19ob29rc18xLkFzeW5jSG9va3NDb250ZXh0TWFuYWdlcigpLmVuYWJsZSgpLFxuICAgIH0pO1xuICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIHByb2Nlc3NvciB9O1xufTtcbmV4cG9ydHMuY3JlYXRlUHJvdmlkZXIgPSBjcmVhdGVQcm92aWRlcjtcbi8qKlxuICogQXR0ZW1wdHMgdG8gZXh0ZW5kIHRoZSBleGlzdGluZyBPVGVsIHByb3ZpZGVyIHdpdGggb3VyIHByb2Nlc3Nvci4gUmV0dXJucyB0cnVlXG4gKiBpZiB0aGUgcHJvdmlkZXIgd2FzIGV4dGVuZGVkLCBmYWxzZSBpZiBpdCB3YXMgbm90LlxuICovXG5jb25zdCBleHRlbmRQcm92aWRlciA9IChiZWhhdmlvdXIpID0+IHtcbiAgICAvLyBBdHRlbXB0IHRvIGFkZCBvdXIgcHJvY2Vzc29yIGFuZCBleHBvcnQgdG8gdGhlIGV4aXN0aW5nIHByb3ZpZGVyXG4gICAgY29uc3QgZXhpc3RpbmdQcm92aWRlciA9IGFwaV8xLnRyYWNlLmdldFRyYWNlclByb3ZpZGVyKCk7XG4gICAgaWYgKCFleGlzdGluZ1Byb3ZpZGVyKSB7XG4gICAgICAgIGlmIChiZWhhdmlvdXIgIT09IFwiYXV0b1wiKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ05vIGV4aXN0aW5nIE9UZWwgcHJvdmlkZXIgZm91bmQgYW5kIGJlaGF2aW91ciBpcyBcImV4dGVuZFByb3ZpZGVyXCIuIElubmdlc3RcXCdzIE9UZWwgbWlkZGxld2FyZSB3aWxsIG5vdCB3b3JrLiBFaXRoZXIgYWxsb3cgdGhlIG1pZGRsZXdhcmUgdG8gY3JlYXRlIGEgcHJvdmlkZXIgYnkgc2V0dGluZyBgYmVoYXZpb3VyOiBcImNyZWF0ZVByb3ZpZGVyXCJgIG9yIGBiZWhhdmlvdXI6IFwiYXV0b1wiYCwgb3IgbWFrZSBzdXJlIHRoYXQgdGhlIHByb3ZpZGVyIGlzIGNyZWF0ZWQgYW5kIGltcG9ydGVkIGJlZm9yZSB0aGUgbWlkZGxld2FyZSBpcyB1c2VkLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlIH07XG4gICAgfVxuICAgIGlmICghKFwiYWRkU3BhblByb2Nlc3NvclwiIGluIGV4aXN0aW5nUHJvdmlkZXIpIHx8XG4gICAgICAgIHR5cGVvZiBleGlzdGluZ1Byb3ZpZGVyLmFkZFNwYW5Qcm9jZXNzb3IgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAvLyBUT0RPIENvdWxkIHdlIGFsc28gYWRkIGEgZnVuY3Rpb24gdGhlIHVzZXIgY2FuIHByb3ZpZGUgdGhhdCB0YWtlcyB0aGVcbiAgICAgICAgLy8gcHJvY2Vzc29yIGFuZCBhZGRzIGl0PyBUaGF0IHdheSB0aGV5IGNvdWxkIHN1cHBvcnQgbWFueSBkaWZmZXJlbnRcbiAgICAgICAgLy8gcHJvdmlkZXJzLlxuICAgICAgICBpZiAoYmVoYXZpb3VyICE9PSBcImF1dG9cIikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRXhpc3RpbmcgT1RlbCBwcm92aWRlciBpcyBub3QgYSBCYXNpY1RyYWNlclByb3ZpZGVyLiBJbm5nZXN0J3MgT1RlbCBtaWRkbGV3YXJlIHdpbGwgbm90IHdvcmssIGFzIGl0IGNhbiBvbmx5IGV4dGVuZCBhbiBleGlzdGluZyBwcm9jZXNzb3IgaWYgaXQncyBhIEJhc2ljVHJhY2VyUHJvdmlkZXIuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlIH07XG4gICAgfVxuICAgIGNvbnN0IHByb2Nlc3NvciA9IG5ldyBwcm9jZXNzb3JfanNfMS5Jbm5nZXN0U3BhblByb2Nlc3NvcigpO1xuICAgIGV4aXN0aW5nUHJvdmlkZXIuYWRkU3BhblByb2Nlc3Nvcihwcm9jZXNzb3IpO1xuICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIHByb2Nlc3NvciB9O1xufTtcbmV4cG9ydHMuZXh0ZW5kUHJvdmlkZXIgPSBleHRlbmRQcm92aWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWwuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/execution/otel/util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/execution/v0.js":
/*!*********************************************************!*\
  !*** ./node_modules/inngest/components/execution/v0.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports._internals = exports.V0InngestExecution = exports.createV0InngestExecution = void 0;\nconst canonicalize_1 = __importDefault(__webpack_require__(/*! canonicalize */ \"(rsc)/./node_modules/canonicalize/lib/canonicalize.js\"));\nconst hash_js_1 = __webpack_require__(/*! hash.js */ \"(rsc)/./node_modules/hash.js/lib/hash.js\");\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/inngest/node_modules/zod/lib/index.js\");\nconst errors_js_1 = __webpack_require__(/*! ../../helpers/errors.js */ \"(rsc)/./node_modules/inngest/helpers/errors.js\");\nconst functions_js_1 = __webpack_require__(/*! ../../helpers/functions.js */ \"(rsc)/./node_modules/inngest/helpers/functions.js\");\nconst promises_js_1 = __webpack_require__(/*! ../../helpers/promises.js */ \"(rsc)/./node_modules/inngest/helpers/promises.js\");\nconst types_js_1 = __webpack_require__(/*! ../../types.js */ \"(rsc)/./node_modules/inngest/types.js\");\nconst InngestMiddleware_js_1 = __webpack_require__(/*! ../InngestMiddleware.js */ \"(rsc)/./node_modules/inngest/components/InngestMiddleware.js\");\nconst InngestStepTools_js_1 = __webpack_require__(/*! ../InngestStepTools.js */ \"(rsc)/./node_modules/inngest/components/InngestStepTools.js\");\nconst NonRetriableError_js_1 = __webpack_require__(/*! ../NonRetriableError.js */ \"(rsc)/./node_modules/inngest/components/NonRetriableError.js\");\nconst RetryAfterError_js_1 = __webpack_require__(/*! ../RetryAfterError.js */ \"(rsc)/./node_modules/inngest/components/RetryAfterError.js\");\nconst InngestExecution_js_1 = __webpack_require__(/*! ./InngestExecution.js */ \"(rsc)/./node_modules/inngest/components/execution/InngestExecution.js\");\nconst createV0InngestExecution = (options) => {\n    return new V0InngestExecution(options);\n};\nexports.createV0InngestExecution = createV0InngestExecution;\nclass V0InngestExecution extends InngestExecution_js_1.InngestExecution {\n    constructor(options) {\n        super(options);\n        this.userFnToRun = this.getUserFnToRun();\n        this.state = this.createExecutionState();\n        this.fnArg = this.createFnArg();\n    }\n    start() {\n        var _a;\n        this.debug(\"starting V0 execution\");\n        return ((_a = this.execution) !== null && _a !== void 0 ? _a : (this.execution = this._start().then((result) => {\n            this.debug(\"result:\", result);\n            return result;\n        })));\n    }\n    async _start() {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;\n        this.state.hooks = await this.initializeMiddleware();\n        try {\n            await this.transformInput();\n            await ((_b = (_a = this.state.hooks).beforeMemoization) === null || _b === void 0 ? void 0 : _b.call(_a));\n            if (this.state.opStack.length === 0 && !this.options.requestedRunStep) {\n                await ((_d = (_c = this.state.hooks).afterMemoization) === null || _d === void 0 ? void 0 : _d.call(_c));\n                await ((_f = (_e = this.state.hooks).beforeExecution) === null || _f === void 0 ? void 0 : _f.call(_e));\n            }\n            const userFnPromise = (0, promises_js_1.runAsPromise)(() => this.userFnToRun(this.fnArg));\n            let pos = -1;\n            do {\n                if (pos >= 0) {\n                    if (!this.options.requestedRunStep &&\n                        pos === this.state.opStack.length - 1) {\n                        await ((_h = (_g = this.state.hooks).afterMemoization) === null || _h === void 0 ? void 0 : _h.call(_g));\n                        await ((_k = (_j = this.state.hooks).beforeExecution) === null || _k === void 0 ? void 0 : _k.call(_j));\n                    }\n                    this.state.tickOps = {};\n                    const incomingOp = this.state.opStack[pos];\n                    this.state.currentOp = this.state.allFoundOps[incomingOp.id];\n                    if (!this.state.currentOp) {\n                        /**\n                         * We're trying to resume the function, but we can't find where to go.\n                         *\n                         * This means that either the function has changed or there are async\n                         * actions in-between steps that we haven't noticed in previous\n                         * executions.\n                         *\n                         * Whichever the case, this is bad and we can't continue in this\n                         * undefined state.\n                         */\n                        throw new NonRetriableError_js_1.NonRetriableError((0, errors_js_1.prettyError)({\n                            whatHappened: \" Your function was stopped from running\",\n                            why: \"We couldn't resume your function's state because it may have changed since the run started or there are async actions in-between steps that we haven't noticed in previous executions.\",\n                            consequences: \"Continuing to run the function may result in unexpected behaviour, so we've stopped your function to ensure nothing unexpected happened!\",\n                            toFixNow: \"Ensure that your function is either entirely step-based or entirely non-step-based, by either wrapping all asynchronous logic in `step.run()` calls or by removing all `step.*()` calls.\",\n                            otherwise: \"For more information on why step functions work in this manner, see https://www.inngest.com/docs/functions/multi-step#gotchas\",\n                            stack: true,\n                            code: errors_js_1.ErrCode.NON_DETERMINISTIC_FUNCTION,\n                        }));\n                    }\n                    this.state.currentOp.fulfilled = true;\n                    if (typeof incomingOp.data !== \"undefined\") {\n                        this.state.currentOp.resolve(incomingOp.data);\n                    }\n                    else {\n                        this.state.currentOp.reject(incomingOp.error);\n                    }\n                }\n                await (0, promises_js_1.resolveAfterPending)();\n                this.state.reset();\n                pos++;\n            } while (pos < this.state.opStack.length);\n            await ((_m = (_l = this.state.hooks).afterMemoization) === null || _m === void 0 ? void 0 : _m.call(_l));\n            const discoveredOps = Object.values(this.state.tickOps).map(tickOpToOutgoing);\n            const runStep = this.options.requestedRunStep ||\n                this.getEarlyExecRunStep(discoveredOps);\n            if (runStep) {\n                const userFnOp = this.state.allFoundOps[runStep];\n                const stepToRun = userFnOp === null || userFnOp === void 0 ? void 0 : userFnOp.fn;\n                if (!stepToRun) {\n                    throw new Error(`Bad stack; executor requesting to run unknown step \"${runStep}\"`);\n                }\n                const outgoingUserFnOp = Object.assign(Object.assign({}, tickOpToOutgoing(userFnOp)), { op: types_js_1.StepOpCode.Step });\n                await ((_p = (_o = this.state.hooks).beforeExecution) === null || _p === void 0 ? void 0 : _p.call(_o));\n                this.state.executingStep = true;\n                const result = await (0, promises_js_1.runAsPromise)(stepToRun)\n                    .finally(() => {\n                    this.state.executingStep = false;\n                })\n                    .catch(async (error) => {\n                    return await this.transformOutput({ error }, outgoingUserFnOp);\n                })\n                    .then(async (data) => {\n                    var _a, _b;\n                    await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.afterExecution) === null || _b === void 0 ? void 0 : _b.call(_a));\n                    return await this.transformOutput({ data }, outgoingUserFnOp);\n                });\n                const { type: _type } = result, rest = __rest(result, [\"type\"]);\n                return {\n                    type: \"step-ran\",\n                    ctx: this.fnArg,\n                    ops: this.ops,\n                    step: Object.assign(Object.assign({}, outgoingUserFnOp), rest),\n                };\n            }\n            if (!discoveredOps.length) {\n                const fnRet = await Promise.race([\n                    userFnPromise.then((data) => ({ type: \"complete\", data })),\n                    (0, promises_js_1.resolveNextTick)().then(() => ({ type: \"incomplete\" })),\n                ]);\n                if (fnRet.type === \"complete\") {\n                    await ((_r = (_q = this.state.hooks).afterExecution) === null || _r === void 0 ? void 0 : _r.call(_q));\n                    const allOpsFulfilled = Object.values(this.state.allFoundOps).every((op) => {\n                        return op.fulfilled;\n                    });\n                    if (allOpsFulfilled) {\n                        return await this.transformOutput({ data: fnRet.data });\n                    }\n                }\n                else if (!this.state.hasUsedTools) {\n                    this.state.nonStepFnDetected = true;\n                    const data = await userFnPromise;\n                    await ((_t = (_s = this.state.hooks).afterExecution) === null || _t === void 0 ? void 0 : _t.call(_s));\n                    return await this.transformOutput({ data });\n                }\n                else {\n                    const hasOpsPending = Object.values(this.state.allFoundOps).some((op) => {\n                        return op.fulfilled === false;\n                    });\n                    if (!hasOpsPending) {\n                        throw new NonRetriableError_js_1.NonRetriableError((0, errors_js_1.functionStoppedRunningErr)(errors_js_1.ErrCode.ASYNC_DETECTED_AFTER_MEMOIZATION));\n                    }\n                }\n            }\n            await ((_v = (_u = this.state.hooks).afterExecution) === null || _v === void 0 ? void 0 : _v.call(_u));\n            return {\n                type: \"steps-found\",\n                ctx: this.fnArg,\n                ops: this.ops,\n                steps: discoveredOps,\n            };\n        }\n        catch (error) {\n            return await this.transformOutput({ error });\n        }\n        finally {\n            await ((_x = (_w = this.state.hooks).beforeResponse) === null || _x === void 0 ? void 0 : _x.call(_w));\n        }\n    }\n    async initializeMiddleware() {\n        const ctx = this.options.data;\n        const hooks = await (0, InngestMiddleware_js_1.getHookStack)(this.options.fn[\"middleware\"], \"onFunctionRun\", {\n            ctx,\n            fn: this.options.fn,\n            steps: Object.values(this.options.stepState),\n            reqArgs: this.options.reqArgs,\n        }, {\n            transformInput: (prev, output) => {\n                return {\n                    ctx: Object.assign(Object.assign({}, prev.ctx), output === null || output === void 0 ? void 0 : output.ctx),\n                    fn: this.options.fn,\n                    steps: prev.steps.map((step, i) => {\n                        var _a;\n                        return (Object.assign(Object.assign({}, step), (_a = output === null || output === void 0 ? void 0 : output.steps) === null || _a === void 0 ? void 0 : _a[i]));\n                    }),\n                    reqArgs: prev.reqArgs,\n                };\n            },\n            transformOutput: (prev, output) => {\n                return {\n                    result: Object.assign(Object.assign({}, prev.result), output === null || output === void 0 ? void 0 : output.result),\n                    step: prev.step,\n                };\n            },\n        });\n        return hooks;\n    }\n    createExecutionState() {\n        const state = {\n            allFoundOps: {},\n            tickOps: {},\n            tickOpHashes: {},\n            currentOp: undefined,\n            hasUsedTools: false,\n            reset: () => {\n                state.tickOpHashes = {};\n                state.allFoundOps = Object.assign(Object.assign({}, state.allFoundOps), state.tickOps);\n            },\n            nonStepFnDetected: false,\n            executingStep: false,\n            opStack: this.options.stepCompletionOrder.reduce((acc, stepId) => {\n                const stepState = this.options.stepState[stepId];\n                if (!stepState) {\n                    return acc;\n                }\n                return [...acc, stepState];\n            }, []),\n        };\n        return state;\n    }\n    get ops() {\n        return Object.fromEntries(Object.entries(this.state.allFoundOps).map(([id, op]) => [\n            id,\n            {\n                id: op.id,\n                rawArgs: op.rawArgs,\n                data: op.data,\n                error: op.error,\n                fulfilled: op.fulfilled,\n                seen: true,\n            },\n        ]));\n    }\n    getUserFnToRun() {\n        if (!this.options.isFailureHandler) {\n            return this.options.fn[\"fn\"];\n        }\n        if (!this.options.fn[\"onFailureFn\"]) {\n            /**\n             * Somehow, we've ended up detecting that this is a failure handler but\n             * doesn't have an `onFailure` function. This should never happen.\n             */\n            throw new Error(\"Cannot find function `onFailure` handler\");\n        }\n        // TODO: Review; inferred types results in an `any` here!\n        return this.options.fn[\"onFailureFn\"];\n    }\n    createFnArg() {\n        var _a, _b, _c, _d;\n        // Start referencing everything\n        this.state.tickOps = this.state.allFoundOps;\n        /**\n         * Create a unique hash of an operation using only a subset of the operation's\n         * properties; will never use `data` and will guarantee the order of the\n         * object so we don't rely on individual tools for that.\n         *\n         * If the operation already contains an ID, the current ID will be used\n         * instead, so that users can provide their own IDs.\n         */\n        const hashOp = (\n        /**\n         * The op to generate a hash from. We only use a subset of the op's\n         * properties when creating the hash.\n         */\n        op) => {\n            var _a, _b, _c, _d;\n            /**\n             * It's difficult for v0 to understand whether or not an op has\n             * historically contained a custom ID, as all step usage now require them.\n             *\n             * For this reason, we make the assumption that steps in v0 do not have a\n             * custom ID and generate one for them as we would in all recommendations\n             * and examples.\n             */\n            const obj = {\n                parent: (_b = (_a = this.state.currentOp) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : null,\n                op: op.op,\n                name: op.name,\n                // Historically, no v0 runs could have options for `step.run()` call,\n                // but this object can be specified in future versions.\n                //\n                // For this purpose, we change this to always use `null` if the op is\n                // that of a `step.run()`.\n                opts: op.op === types_js_1.StepOpCode.StepPlanned ? null : (_c = op.opts) !== null && _c !== void 0 ? _c : null,\n            };\n            const collisionHash = exports._internals.hashData(obj);\n            const pos = (this.state.tickOpHashes[collisionHash] =\n                ((_d = this.state.tickOpHashes[collisionHash]) !== null && _d !== void 0 ? _d : -1) + 1);\n            return Object.assign(Object.assign({}, op), { id: exports._internals.hashData(Object.assign({ pos }, obj)) });\n        };\n        const stepHandler = ({ args, matchOp, opts }) => {\n            if (this.state.nonStepFnDetected) {\n                throw new NonRetriableError_js_1.NonRetriableError((0, errors_js_1.functionStoppedRunningErr)(errors_js_1.ErrCode.STEP_USED_AFTER_ASYNC));\n            }\n            if (this.state.executingStep) {\n                throw new NonRetriableError_js_1.NonRetriableError((0, errors_js_1.prettyError)({\n                    whatHappened: \"Your function was stopped from running\",\n                    why: \"We detected that you have nested `step.*` tooling.\",\n                    consequences: \"Nesting `step.*` tooling is not supported.\",\n                    stack: true,\n                    toFixNow: \"Make sure you're not using `step.*` tooling inside of other `step.*` tooling. If you need to compose steps together, you can create a new async function and call it from within your step function, or use promise chaining.\",\n                    otherwise: \"For more information on step functions with Inngest, see https://www.inngest.com/docs/functions/multi-step\",\n                    code: errors_js_1.ErrCode.NESTING_STEPS,\n                }));\n            }\n            this.state.hasUsedTools = true;\n            const stepOptions = (0, InngestStepTools_js_1.getStepOptions)(args[0]);\n            const opId = hashOp(matchOp(stepOptions, ...args.slice(1)));\n            return new Promise((resolve, reject) => {\n                this.state.tickOps[opId.id] = Object.assign(Object.assign(Object.assign({}, opId), ((opts === null || opts === void 0 ? void 0 : opts.fn) ? { fn: () => { var _a; return (_a = opts.fn) === null || _a === void 0 ? void 0 : _a.call(opts, ...args); } } : {})), { rawArgs: args, resolve,\n                    reject, fulfilled: false });\n            });\n        };\n        const step = (0, InngestStepTools_js_1.createStepTools)(this.options.client, this, stepHandler);\n        let fnArg = Object.assign(Object.assign({}, this.options.data), { step });\n        if (this.options.isFailureHandler) {\n            const eventData = zod_1.z\n                .object({ error: types_js_1.jsonErrorSchema })\n                .parse((_a = fnArg.event) === null || _a === void 0 ? void 0 : _a.data);\n            fnArg = Object.assign(Object.assign({}, fnArg), { error: (0, errors_js_1.deserializeError)(eventData.error) });\n        }\n        return (_d = (_c = (_b = this.options).transformCtx) === null || _c === void 0 ? void 0 : _c.call(_b, fnArg)) !== null && _d !== void 0 ? _d : fnArg;\n    }\n    /**\n     * Using middleware, transform input before running.\n     */\n    async transformInput() {\n        var _a, _b;\n        const inputMutations = await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.transformInput) === null || _b === void 0 ? void 0 : _b.call(_a, {\n            ctx: Object.assign({}, this.fnArg),\n            steps: Object.values(this.options.stepState),\n            fn: this.options.fn,\n            reqArgs: this.options.reqArgs,\n        }));\n        if (inputMutations === null || inputMutations === void 0 ? void 0 : inputMutations.ctx) {\n            this.fnArg = inputMutations.ctx;\n        }\n        if (inputMutations === null || inputMutations === void 0 ? void 0 : inputMutations.steps) {\n            this.state.opStack = [...inputMutations.steps];\n        }\n    }\n    getEarlyExecRunStep(ops) {\n        if (ops.length !== 1)\n            return;\n        const op = ops[0];\n        if (op &&\n            op.op === types_js_1.StepOpCode.StepPlanned\n        // TODO We must individually check properties here that we do not want to\n        // execute on, such as retry counts. Nothing exists here that falls in to\n        // this case, but should be accounted for when we add them.\n        // && typeof op.opts === \"undefined\"\n        ) {\n            return op.id;\n        }\n    }\n    /**\n     * Using middleware, transform output before returning.\n     */\n    async transformOutput(dataOrError, step) {\n        var _a, _b, _c, _d;\n        const output = Object.assign({}, dataOrError);\n        if (typeof output.error !== \"undefined\") {\n            output.data = (0, errors_js_1.serializeError)(output.error);\n        }\n        const transformedOutput = await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.transformOutput) === null || _b === void 0 ? void 0 : _b.call(_a, {\n            result: Object.assign({}, output),\n            step,\n        }));\n        const { data, error } = Object.assign(Object.assign({}, output), transformedOutput === null || transformedOutput === void 0 ? void 0 : transformedOutput.result);\n        if (!step) {\n            await ((_d = (_c = this.state.hooks) === null || _c === void 0 ? void 0 : _c.finished) === null || _d === void 0 ? void 0 : _d.call(_c, {\n                result: Object.assign({}, (typeof error !== \"undefined\" ? { error } : { data })),\n            }));\n        }\n        if (typeof error !== \"undefined\") {\n            /**\n             * Ensure we give middleware the chance to decide on retriable behaviour\n             * by looking at the error returned from output transformation.\n             */\n            let retriable = !(error instanceof NonRetriableError_js_1.NonRetriableError);\n            if (retriable && error instanceof RetryAfterError_js_1.RetryAfterError) {\n                retriable = error.retryAfter;\n            }\n            const serializedError = (0, errors_js_1.serializeError)(error);\n            return {\n                type: \"function-rejected\",\n                ctx: this.fnArg,\n                ops: this.ops,\n                error: serializedError,\n                retriable,\n            };\n        }\n        return {\n            type: \"function-resolved\",\n            ctx: this.fnArg,\n            ops: this.ops,\n            data: (0, functions_js_1.undefinedToNull)(data),\n        };\n    }\n}\nexports.V0InngestExecution = V0InngestExecution;\nconst tickOpToOutgoing = (op) => {\n    return {\n        op: op.op,\n        id: op.id,\n        name: op.name,\n        opts: op.opts,\n    };\n};\nconst hashData = (op) => {\n    return (0, hash_js_1.sha1)().update((0, canonicalize_1.default)(op)).digest(\"hex\");\n};\n/**\n * Exported for testing.\n */\nexports._internals = { hashData };\n//# sourceMappingURL=v0.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL2V4ZWN1dGlvbi92MC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsY0FBYztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCLEdBQUcsMEJBQTBCLEdBQUcsZ0NBQWdDO0FBQ2xGLHVDQUF1QyxtQkFBTyxDQUFDLDJFQUFjO0FBQzdELGtCQUFrQixtQkFBTyxDQUFDLHlEQUFTO0FBQ25DLGNBQWMsbUJBQU8sQ0FBQyx1RUFBSztBQUMzQixvQkFBb0IsbUJBQU8sQ0FBQywrRUFBeUI7QUFDckQsdUJBQXVCLG1CQUFPLENBQUMscUZBQTRCO0FBQzNELHNCQUFzQixtQkFBTyxDQUFDLG1GQUEyQjtBQUN6RCxtQkFBbUIsbUJBQU8sQ0FBQyw2REFBZ0I7QUFDM0MsK0JBQStCLG1CQUFPLENBQUMsNkZBQXlCO0FBQ2hFLDhCQUE4QixtQkFBTyxDQUFDLDJGQUF3QjtBQUM5RCwrQkFBK0IsbUJBQU8sQ0FBQyw2RkFBeUI7QUFDaEUsNkJBQTZCLG1CQUFPLENBQUMseUZBQXVCO0FBQzVELDhCQUE4QixtQkFBTyxDQUFDLG9HQUF1QjtBQUM3RDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0EsU0FBUztBQUNULGdCQUFnQixjQUFjLGdDQUFnQztBQUM5RDtBQUNBO0FBQ0Esd0NBQXdDLG9DQUFvQyxRQUFRLElBQUksTUFBTTtBQUM5RixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsS0FBSztBQUN2QiIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpdmUtdmliZS1haS1uZXh0Ly4vbm9kZV9tb2R1bGVzL2lubmdlc3QvY29tcG9uZW50cy9leGVjdXRpb24vdjAuanM/MTU5OCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX3Jlc3QgPSAodGhpcyAmJiB0aGlzLl9fcmVzdCkgfHwgZnVuY3Rpb24gKHMsIGUpIHtcbiAgICB2YXIgdCA9IHt9O1xuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxuICAgICAgICB0W3BdID0gc1twXTtcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcbiAgICAgICAgfVxuICAgIHJldHVybiB0O1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuX2ludGVybmFscyA9IGV4cG9ydHMuVjBJbm5nZXN0RXhlY3V0aW9uID0gZXhwb3J0cy5jcmVhdGVWMElubmdlc3RFeGVjdXRpb24gPSB2b2lkIDA7XG5jb25zdCBjYW5vbmljYWxpemVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiY2Fub25pY2FsaXplXCIpKTtcbmNvbnN0IGhhc2hfanNfMSA9IHJlcXVpcmUoXCJoYXNoLmpzXCIpO1xuY29uc3Qgem9kXzEgPSByZXF1aXJlKFwiem9kXCIpO1xuY29uc3QgZXJyb3JzX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vaGVscGVycy9lcnJvcnMuanNcIik7XG5jb25zdCBmdW5jdGlvbnNfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi9oZWxwZXJzL2Z1bmN0aW9ucy5qc1wiKTtcbmNvbnN0IHByb21pc2VzX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vaGVscGVycy9wcm9taXNlcy5qc1wiKTtcbmNvbnN0IHR5cGVzX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vdHlwZXMuanNcIik7XG5jb25zdCBJbm5nZXN0TWlkZGxld2FyZV9qc18xID0gcmVxdWlyZShcIi4uL0lubmdlc3RNaWRkbGV3YXJlLmpzXCIpO1xuY29uc3QgSW5uZ2VzdFN0ZXBUb29sc19qc18xID0gcmVxdWlyZShcIi4uL0lubmdlc3RTdGVwVG9vbHMuanNcIik7XG5jb25zdCBOb25SZXRyaWFibGVFcnJvcl9qc18xID0gcmVxdWlyZShcIi4uL05vblJldHJpYWJsZUVycm9yLmpzXCIpO1xuY29uc3QgUmV0cnlBZnRlckVycm9yX2pzXzEgPSByZXF1aXJlKFwiLi4vUmV0cnlBZnRlckVycm9yLmpzXCIpO1xuY29uc3QgSW5uZ2VzdEV4ZWN1dGlvbl9qc18xID0gcmVxdWlyZShcIi4vSW5uZ2VzdEV4ZWN1dGlvbi5qc1wiKTtcbmNvbnN0IGNyZWF0ZVYwSW5uZ2VzdEV4ZWN1dGlvbiA9IChvcHRpb25zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBWMElubmdlc3RFeGVjdXRpb24ob3B0aW9ucyk7XG59O1xuZXhwb3J0cy5jcmVhdGVWMElubmdlc3RFeGVjdXRpb24gPSBjcmVhdGVWMElubmdlc3RFeGVjdXRpb247XG5jbGFzcyBWMElubmdlc3RFeGVjdXRpb24gZXh0ZW5kcyBJbm5nZXN0RXhlY3V0aW9uX2pzXzEuSW5uZ2VzdEV4ZWN1dGlvbiB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zKTtcbiAgICAgICAgdGhpcy51c2VyRm5Ub1J1biA9IHRoaXMuZ2V0VXNlckZuVG9SdW4oKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuY3JlYXRlRXhlY3V0aW9uU3RhdGUoKTtcbiAgICAgICAgdGhpcy5mbkFyZyA9IHRoaXMuY3JlYXRlRm5BcmcoKTtcbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5kZWJ1ZyhcInN0YXJ0aW5nIFYwIGV4ZWN1dGlvblwiKTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSB0aGlzLmV4ZWN1dGlvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKHRoaXMuZXhlY3V0aW9uID0gdGhpcy5fc3RhcnQoKS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGVidWcoXCJyZXN1bHQ6XCIsIHJlc3VsdCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KSkpO1xuICAgIH1cbiAgICBhc3luYyBfc3RhcnQoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qLCBfaywgX2wsIF9tLCBfbywgX3AsIF9xLCBfciwgX3MsIF90LCBfdSwgX3YsIF93LCBfeDtcbiAgICAgICAgdGhpcy5zdGF0ZS5ob29rcyA9IGF3YWl0IHRoaXMuaW5pdGlhbGl6ZU1pZGRsZXdhcmUoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMudHJhbnNmb3JtSW5wdXQoKTtcbiAgICAgICAgICAgIGF3YWl0ICgoX2IgPSAoX2EgPSB0aGlzLnN0YXRlLmhvb2tzKS5iZWZvcmVNZW1vaXphdGlvbikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLm9wU3RhY2subGVuZ3RoID09PSAwICYmICF0aGlzLm9wdGlvbnMucmVxdWVzdGVkUnVuU3RlcCkge1xuICAgICAgICAgICAgICAgIGF3YWl0ICgoX2QgPSAoX2MgPSB0aGlzLnN0YXRlLmhvb2tzKS5hZnRlck1lbW9pemF0aW9uKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuY2FsbChfYykpO1xuICAgICAgICAgICAgICAgIGF3YWl0ICgoX2YgPSAoX2UgPSB0aGlzLnN0YXRlLmhvb2tzKS5iZWZvcmVFeGVjdXRpb24pID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5jYWxsKF9lKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB1c2VyRm5Qcm9taXNlID0gKDAsIHByb21pc2VzX2pzXzEucnVuQXNQcm9taXNlKSgoKSA9PiB0aGlzLnVzZXJGblRvUnVuKHRoaXMuZm5BcmcpKTtcbiAgICAgICAgICAgIGxldCBwb3MgPSAtMTtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBpZiAocG9zID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMucmVxdWVzdGVkUnVuU3RlcCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zID09PSB0aGlzLnN0YXRlLm9wU3RhY2subGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgKChfaCA9IChfZyA9IHRoaXMuc3RhdGUuaG9va3MpLmFmdGVyTWVtb2l6YXRpb24pID09PSBudWxsIHx8IF9oID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaC5jYWxsKF9nKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCAoKF9rID0gKF9qID0gdGhpcy5zdGF0ZS5ob29rcykuYmVmb3JlRXhlY3V0aW9uKSA9PT0gbnVsbCB8fCBfayA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2suY2FsbChfaikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUudGlja09wcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmNvbWluZ09wID0gdGhpcy5zdGF0ZS5vcFN0YWNrW3Bvc107XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuY3VycmVudE9wID0gdGhpcy5zdGF0ZS5hbGxGb3VuZE9wc1tpbmNvbWluZ09wLmlkXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnN0YXRlLmN1cnJlbnRPcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBXZSdyZSB0cnlpbmcgdG8gcmVzdW1lIHRoZSBmdW5jdGlvbiwgYnV0IHdlIGNhbid0IGZpbmQgd2hlcmUgdG8gZ28uXG4gICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogVGhpcyBtZWFucyB0aGF0IGVpdGhlciB0aGUgZnVuY3Rpb24gaGFzIGNoYW5nZWQgb3IgdGhlcmUgYXJlIGFzeW5jXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBhY3Rpb25zIGluLWJldHdlZW4gc3RlcHMgdGhhdCB3ZSBoYXZlbid0IG5vdGljZWQgaW4gcHJldmlvdXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIGV4ZWN1dGlvbnMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogV2hpY2hldmVyIHRoZSBjYXNlLCB0aGlzIGlzIGJhZCBhbmQgd2UgY2FuJ3QgY29udGludWUgaW4gdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICogdW5kZWZpbmVkIHN0YXRlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm9uUmV0cmlhYmxlRXJyb3JfanNfMS5Ob25SZXRyaWFibGVFcnJvcigoMCwgZXJyb3JzX2pzXzEucHJldHR5RXJyb3IpKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGF0SGFwcGVuZWQ6IFwiIFlvdXIgZnVuY3Rpb24gd2FzIHN0b3BwZWQgZnJvbSBydW5uaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2h5OiBcIldlIGNvdWxkbid0IHJlc3VtZSB5b3VyIGZ1bmN0aW9uJ3Mgc3RhdGUgYmVjYXVzZSBpdCBtYXkgaGF2ZSBjaGFuZ2VkIHNpbmNlIHRoZSBydW4gc3RhcnRlZCBvciB0aGVyZSBhcmUgYXN5bmMgYWN0aW9ucyBpbi1iZXR3ZWVuIHN0ZXBzIHRoYXQgd2UgaGF2ZW4ndCBub3RpY2VkIGluIHByZXZpb3VzIGV4ZWN1dGlvbnMuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc2VxdWVuY2VzOiBcIkNvbnRpbnVpbmcgdG8gcnVuIHRoZSBmdW5jdGlvbiBtYXkgcmVzdWx0IGluIHVuZXhwZWN0ZWQgYmVoYXZpb3VyLCBzbyB3ZSd2ZSBzdG9wcGVkIHlvdXIgZnVuY3Rpb24gdG8gZW5zdXJlIG5vdGhpbmcgdW5leHBlY3RlZCBoYXBwZW5lZCFcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b0ZpeE5vdzogXCJFbnN1cmUgdGhhdCB5b3VyIGZ1bmN0aW9uIGlzIGVpdGhlciBlbnRpcmVseSBzdGVwLWJhc2VkIG9yIGVudGlyZWx5IG5vbi1zdGVwLWJhc2VkLCBieSBlaXRoZXIgd3JhcHBpbmcgYWxsIGFzeW5jaHJvbm91cyBsb2dpYyBpbiBgc3RlcC5ydW4oKWAgY2FsbHMgb3IgYnkgcmVtb3ZpbmcgYWxsIGBzdGVwLiooKWAgY2FsbHMuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXJ3aXNlOiBcIkZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHdoeSBzdGVwIGZ1bmN0aW9ucyB3b3JrIGluIHRoaXMgbWFubmVyLCBzZWUgaHR0cHM6Ly93d3cuaW5uZ2VzdC5jb20vZG9jcy9mdW5jdGlvbnMvbXVsdGktc3RlcCNnb3RjaGFzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2s6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogZXJyb3JzX2pzXzEuRXJyQ29kZS5OT05fREVURVJNSU5JU1RJQ19GVU5DVElPTixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmN1cnJlbnRPcC5mdWxmaWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGluY29taW5nT3AuZGF0YSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5jdXJyZW50T3AucmVzb2x2ZShpbmNvbWluZ09wLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5jdXJyZW50T3AucmVqZWN0KGluY29taW5nT3AuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGF3YWl0ICgwLCBwcm9taXNlc19qc18xLnJlc29sdmVBZnRlclBlbmRpbmcpKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5yZXNldCgpO1xuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgfSB3aGlsZSAocG9zIDwgdGhpcy5zdGF0ZS5vcFN0YWNrLmxlbmd0aCk7XG4gICAgICAgICAgICBhd2FpdCAoKF9tID0gKF9sID0gdGhpcy5zdGF0ZS5ob29rcykuYWZ0ZXJNZW1vaXphdGlvbikgPT09IG51bGwgfHwgX20gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9tLmNhbGwoX2wpKTtcbiAgICAgICAgICAgIGNvbnN0IGRpc2NvdmVyZWRPcHMgPSBPYmplY3QudmFsdWVzKHRoaXMuc3RhdGUudGlja09wcykubWFwKHRpY2tPcFRvT3V0Z29pbmcpO1xuICAgICAgICAgICAgY29uc3QgcnVuU3RlcCA9IHRoaXMub3B0aW9ucy5yZXF1ZXN0ZWRSdW5TdGVwIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5nZXRFYXJseUV4ZWNSdW5TdGVwKGRpc2NvdmVyZWRPcHMpO1xuICAgICAgICAgICAgaWYgKHJ1blN0ZXApIHtcbiAgICAgICAgICAgICAgICBjb25zdCB1c2VyRm5PcCA9IHRoaXMuc3RhdGUuYWxsRm91bmRPcHNbcnVuU3RlcF07XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RlcFRvUnVuID0gdXNlckZuT3AgPT09IG51bGwgfHwgdXNlckZuT3AgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHVzZXJGbk9wLmZuO1xuICAgICAgICAgICAgICAgIGlmICghc3RlcFRvUnVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQmFkIHN0YWNrOyBleGVjdXRvciByZXF1ZXN0aW5nIHRvIHJ1biB1bmtub3duIHN0ZXAgXCIke3J1blN0ZXB9XCJgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgb3V0Z29pbmdVc2VyRm5PcCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGlja09wVG9PdXRnb2luZyh1c2VyRm5PcCkpLCB7IG9wOiB0eXBlc19qc18xLlN0ZXBPcENvZGUuU3RlcCB9KTtcbiAgICAgICAgICAgICAgICBhd2FpdCAoKF9wID0gKF9vID0gdGhpcy5zdGF0ZS5ob29rcykuYmVmb3JlRXhlY3V0aW9uKSA9PT0gbnVsbCB8fCBfcCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3AuY2FsbChfbykpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuZXhlY3V0aW5nU3RlcCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgKDAsIHByb21pc2VzX2pzXzEucnVuQXNQcm9taXNlKShzdGVwVG9SdW4pXG4gICAgICAgICAgICAgICAgICAgIC5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5leGVjdXRpbmdTdGVwID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGFzeW5jIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc2Zvcm1PdXRwdXQoeyBlcnJvciB9LCBvdXRnb2luZ1VzZXJGbk9wKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAudGhlbihhc3luYyAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCAoKF9iID0gKF9hID0gdGhpcy5zdGF0ZS5ob29rcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFmdGVyRXhlY3V0aW9uKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc2Zvcm1PdXRwdXQoeyBkYXRhIH0sIG91dGdvaW5nVXNlckZuT3ApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgdHlwZTogX3R5cGUgfSA9IHJlc3VsdCwgcmVzdCA9IF9fcmVzdChyZXN1bHQsIFtcInR5cGVcIl0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RlcC1yYW5cIixcbiAgICAgICAgICAgICAgICAgICAgY3R4OiB0aGlzLmZuQXJnLFxuICAgICAgICAgICAgICAgICAgICBvcHM6IHRoaXMub3BzLFxuICAgICAgICAgICAgICAgICAgICBzdGVwOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG91dGdvaW5nVXNlckZuT3ApLCByZXN0KSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkaXNjb3ZlcmVkT3BzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZuUmV0ID0gYXdhaXQgUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgICAgICAgICAgICAgdXNlckZuUHJvbWlzZS50aGVuKChkYXRhKSA9PiAoeyB0eXBlOiBcImNvbXBsZXRlXCIsIGRhdGEgfSkpLFxuICAgICAgICAgICAgICAgICAgICAoMCwgcHJvbWlzZXNfanNfMS5yZXNvbHZlTmV4dFRpY2spKCkudGhlbigoKSA9PiAoeyB0eXBlOiBcImluY29tcGxldGVcIiB9KSksXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgaWYgKGZuUmV0LnR5cGUgPT09IFwiY29tcGxldGVcIikge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCAoKF9yID0gKF9xID0gdGhpcy5zdGF0ZS5ob29rcykuYWZ0ZXJFeGVjdXRpb24pID09PSBudWxsIHx8IF9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfci5jYWxsKF9xKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFsbE9wc0Z1bGZpbGxlZCA9IE9iamVjdC52YWx1ZXModGhpcy5zdGF0ZS5hbGxGb3VuZE9wcykuZXZlcnkoKG9wKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3AuZnVsZmlsbGVkO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFsbE9wc0Z1bGZpbGxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNmb3JtT3V0cHV0KHsgZGF0YTogZm5SZXQuZGF0YSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghdGhpcy5zdGF0ZS5oYXNVc2VkVG9vbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5ub25TdGVwRm5EZXRlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB1c2VyRm5Qcm9taXNlO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCAoKF90ID0gKF9zID0gdGhpcy5zdGF0ZS5ob29rcykuYWZ0ZXJFeGVjdXRpb24pID09PSBudWxsIHx8IF90ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdC5jYWxsKF9zKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zZm9ybU91dHB1dCh7IGRhdGEgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoYXNPcHNQZW5kaW5nID0gT2JqZWN0LnZhbHVlcyh0aGlzLnN0YXRlLmFsbEZvdW5kT3BzKS5zb21lKChvcCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wLmZ1bGZpbGxlZCA9PT0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWhhc09wc1BlbmRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb25SZXRyaWFibGVFcnJvcl9qc18xLk5vblJldHJpYWJsZUVycm9yKCgwLCBlcnJvcnNfanNfMS5mdW5jdGlvblN0b3BwZWRSdW5uaW5nRXJyKShlcnJvcnNfanNfMS5FcnJDb2RlLkFTWU5DX0RFVEVDVEVEX0FGVEVSX01FTU9JWkFUSU9OKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCAoKF92ID0gKF91ID0gdGhpcy5zdGF0ZS5ob29rcykuYWZ0ZXJFeGVjdXRpb24pID09PSBudWxsIHx8IF92ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdi5jYWxsKF91KSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwic3RlcHMtZm91bmRcIixcbiAgICAgICAgICAgICAgICBjdHg6IHRoaXMuZm5BcmcsXG4gICAgICAgICAgICAgICAgb3BzOiB0aGlzLm9wcyxcbiAgICAgICAgICAgICAgICBzdGVwczogZGlzY292ZXJlZE9wcyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc2Zvcm1PdXRwdXQoeyBlcnJvciB9KTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGF3YWl0ICgoX3ggPSAoX3cgPSB0aGlzLnN0YXRlLmhvb2tzKS5iZWZvcmVSZXNwb25zZSkgPT09IG51bGwgfHwgX3ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF94LmNhbGwoX3cpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBpbml0aWFsaXplTWlkZGxld2FyZSgpIHtcbiAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5vcHRpb25zLmRhdGE7XG4gICAgICAgIGNvbnN0IGhvb2tzID0gYXdhaXQgKDAsIElubmdlc3RNaWRkbGV3YXJlX2pzXzEuZ2V0SG9va1N0YWNrKSh0aGlzLm9wdGlvbnMuZm5bXCJtaWRkbGV3YXJlXCJdLCBcIm9uRnVuY3Rpb25SdW5cIiwge1xuICAgICAgICAgICAgY3R4LFxuICAgICAgICAgICAgZm46IHRoaXMub3B0aW9ucy5mbixcbiAgICAgICAgICAgIHN0ZXBzOiBPYmplY3QudmFsdWVzKHRoaXMub3B0aW9ucy5zdGVwU3RhdGUpLFxuICAgICAgICAgICAgcmVxQXJnczogdGhpcy5vcHRpb25zLnJlcUFyZ3MsXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybUlucHV0OiAocHJldiwgb3V0cHV0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4OiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHByZXYuY3R4KSwgb3V0cHV0ID09PSBudWxsIHx8IG91dHB1dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3V0cHV0LmN0eCksXG4gICAgICAgICAgICAgICAgICAgIGZuOiB0aGlzLm9wdGlvbnMuZm4sXG4gICAgICAgICAgICAgICAgICAgIHN0ZXBzOiBwcmV2LnN0ZXBzLm1hcCgoc3RlcCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0ZXApLCAoX2EgPSBvdXRwdXQgPT09IG51bGwgfHwgb3V0cHV0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvdXRwdXQuc3RlcHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtpXSkpO1xuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgcmVxQXJnczogcHJldi5yZXFBcmdzLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHJhbnNmb3JtT3V0cHV0OiAocHJldiwgb3V0cHV0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHByZXYucmVzdWx0KSwgb3V0cHV0ID09PSBudWxsIHx8IG91dHB1dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3V0cHV0LnJlc3VsdCksXG4gICAgICAgICAgICAgICAgICAgIHN0ZXA6IHByZXYuc3RlcCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBob29rcztcbiAgICB9XG4gICAgY3JlYXRlRXhlY3V0aW9uU3RhdGUoKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0ge1xuICAgICAgICAgICAgYWxsRm91bmRPcHM6IHt9LFxuICAgICAgICAgICAgdGlja09wczoge30sXG4gICAgICAgICAgICB0aWNrT3BIYXNoZXM6IHt9LFxuICAgICAgICAgICAgY3VycmVudE9wOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBoYXNVc2VkVG9vbHM6IGZhbHNlLFxuICAgICAgICAgICAgcmVzZXQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBzdGF0ZS50aWNrT3BIYXNoZXMgPSB7fTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5hbGxGb3VuZE9wcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuYWxsRm91bmRPcHMpLCBzdGF0ZS50aWNrT3BzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBub25TdGVwRm5EZXRlY3RlZDogZmFsc2UsXG4gICAgICAgICAgICBleGVjdXRpbmdTdGVwOiBmYWxzZSxcbiAgICAgICAgICAgIG9wU3RhY2s6IHRoaXMub3B0aW9ucy5zdGVwQ29tcGxldGlvbk9yZGVyLnJlZHVjZSgoYWNjLCBzdGVwSWQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGVwU3RhdGUgPSB0aGlzLm9wdGlvbnMuc3RlcFN0YXRlW3N0ZXBJZF07XG4gICAgICAgICAgICAgICAgaWYgKCFzdGVwU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsuLi5hY2MsIHN0ZXBTdGF0ZV07XG4gICAgICAgICAgICB9LCBbXSksXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gICAgZ2V0IG9wcygpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyh0aGlzLnN0YXRlLmFsbEZvdW5kT3BzKS5tYXAoKFtpZCwgb3BdKSA9PiBbXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZDogb3AuaWQsXG4gICAgICAgICAgICAgICAgcmF3QXJnczogb3AucmF3QXJncyxcbiAgICAgICAgICAgICAgICBkYXRhOiBvcC5kYXRhLFxuICAgICAgICAgICAgICAgIGVycm9yOiBvcC5lcnJvcixcbiAgICAgICAgICAgICAgICBmdWxmaWxsZWQ6IG9wLmZ1bGZpbGxlZCxcbiAgICAgICAgICAgICAgICBzZWVuOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSkpO1xuICAgIH1cbiAgICBnZXRVc2VyRm5Ub1J1bigpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuaXNGYWlsdXJlSGFuZGxlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5mbltcImZuXCJdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmZuW1wib25GYWlsdXJlRm5cIl0pIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU29tZWhvdywgd2UndmUgZW5kZWQgdXAgZGV0ZWN0aW5nIHRoYXQgdGhpcyBpcyBhIGZhaWx1cmUgaGFuZGxlciBidXRcbiAgICAgICAgICAgICAqIGRvZXNuJ3QgaGF2ZSBhbiBgb25GYWlsdXJlYCBmdW5jdGlvbi4gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBmdW5jdGlvbiBgb25GYWlsdXJlYCBoYW5kbGVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IFJldmlldzsgaW5mZXJyZWQgdHlwZXMgcmVzdWx0cyBpbiBhbiBgYW55YCBoZXJlIVxuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmZuW1wib25GYWlsdXJlRm5cIl07XG4gICAgfVxuICAgIGNyZWF0ZUZuQXJnKCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIC8vIFN0YXJ0IHJlZmVyZW5jaW5nIGV2ZXJ5dGhpbmdcbiAgICAgICAgdGhpcy5zdGF0ZS50aWNrT3BzID0gdGhpcy5zdGF0ZS5hbGxGb3VuZE9wcztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIHVuaXF1ZSBoYXNoIG9mIGFuIG9wZXJhdGlvbiB1c2luZyBvbmx5IGEgc3Vic2V0IG9mIHRoZSBvcGVyYXRpb24nc1xuICAgICAgICAgKiBwcm9wZXJ0aWVzOyB3aWxsIG5ldmVyIHVzZSBgZGF0YWAgYW5kIHdpbGwgZ3VhcmFudGVlIHRoZSBvcmRlciBvZiB0aGVcbiAgICAgICAgICogb2JqZWN0IHNvIHdlIGRvbid0IHJlbHkgb24gaW5kaXZpZHVhbCB0b29scyBmb3IgdGhhdC5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgdGhlIG9wZXJhdGlvbiBhbHJlYWR5IGNvbnRhaW5zIGFuIElELCB0aGUgY3VycmVudCBJRCB3aWxsIGJlIHVzZWRcbiAgICAgICAgICogaW5zdGVhZCwgc28gdGhhdCB1c2VycyBjYW4gcHJvdmlkZSB0aGVpciBvd24gSURzLlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgaGFzaE9wID0gKFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG9wIHRvIGdlbmVyYXRlIGEgaGFzaCBmcm9tLiBXZSBvbmx5IHVzZSBhIHN1YnNldCBvZiB0aGUgb3Anc1xuICAgICAgICAgKiBwcm9wZXJ0aWVzIHdoZW4gY3JlYXRpbmcgdGhlIGhhc2guXG4gICAgICAgICAqL1xuICAgICAgICBvcCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJdCdzIGRpZmZpY3VsdCBmb3IgdjAgdG8gdW5kZXJzdGFuZCB3aGV0aGVyIG9yIG5vdCBhbiBvcCBoYXNcbiAgICAgICAgICAgICAqIGhpc3RvcmljYWxseSBjb250YWluZWQgYSBjdXN0b20gSUQsIGFzIGFsbCBzdGVwIHVzYWdlIG5vdyByZXF1aXJlIHRoZW0uXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogRm9yIHRoaXMgcmVhc29uLCB3ZSBtYWtlIHRoZSBhc3N1bXB0aW9uIHRoYXQgc3RlcHMgaW4gdjAgZG8gbm90IGhhdmUgYVxuICAgICAgICAgICAgICogY3VzdG9tIElEIGFuZCBnZW5lcmF0ZSBvbmUgZm9yIHRoZW0gYXMgd2Ugd291bGQgaW4gYWxsIHJlY29tbWVuZGF0aW9uc1xuICAgICAgICAgICAgICogYW5kIGV4YW1wbGVzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zdCBvYmogPSB7XG4gICAgICAgICAgICAgICAgcGFyZW50OiAoX2IgPSAoX2EgPSB0aGlzLnN0YXRlLmN1cnJlbnRPcCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlkKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBudWxsLFxuICAgICAgICAgICAgICAgIG9wOiBvcC5vcCxcbiAgICAgICAgICAgICAgICBuYW1lOiBvcC5uYW1lLFxuICAgICAgICAgICAgICAgIC8vIEhpc3RvcmljYWxseSwgbm8gdjAgcnVucyBjb3VsZCBoYXZlIG9wdGlvbnMgZm9yIGBzdGVwLnJ1bigpYCBjYWxsLFxuICAgICAgICAgICAgICAgIC8vIGJ1dCB0aGlzIG9iamVjdCBjYW4gYmUgc3BlY2lmaWVkIGluIGZ1dHVyZSB2ZXJzaW9ucy5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIEZvciB0aGlzIHB1cnBvc2UsIHdlIGNoYW5nZSB0aGlzIHRvIGFsd2F5cyB1c2UgYG51bGxgIGlmIHRoZSBvcCBpc1xuICAgICAgICAgICAgICAgIC8vIHRoYXQgb2YgYSBgc3RlcC5ydW4oKWAuXG4gICAgICAgICAgICAgICAgb3B0czogb3Aub3AgPT09IHR5cGVzX2pzXzEuU3RlcE9wQ29kZS5TdGVwUGxhbm5lZCA/IG51bGwgOiAoX2MgPSBvcC5vcHRzKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBudWxsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGNvbGxpc2lvbkhhc2ggPSBleHBvcnRzLl9pbnRlcm5hbHMuaGFzaERhdGEob2JqKTtcbiAgICAgICAgICAgIGNvbnN0IHBvcyA9ICh0aGlzLnN0YXRlLnRpY2tPcEhhc2hlc1tjb2xsaXNpb25IYXNoXSA9XG4gICAgICAgICAgICAgICAgKChfZCA9IHRoaXMuc3RhdGUudGlja09wSGFzaGVzW2NvbGxpc2lvbkhhc2hdKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAtMSkgKyAxKTtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wKSwgeyBpZDogZXhwb3J0cy5faW50ZXJuYWxzLmhhc2hEYXRhKE9iamVjdC5hc3NpZ24oeyBwb3MgfSwgb2JqKSkgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHN0ZXBIYW5kbGVyID0gKHsgYXJncywgbWF0Y2hPcCwgb3B0cyB9KSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5ub25TdGVwRm5EZXRlY3RlZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb25SZXRyaWFibGVFcnJvcl9qc18xLk5vblJldHJpYWJsZUVycm9yKCgwLCBlcnJvcnNfanNfMS5mdW5jdGlvblN0b3BwZWRSdW5uaW5nRXJyKShlcnJvcnNfanNfMS5FcnJDb2RlLlNURVBfVVNFRF9BRlRFUl9BU1lOQykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuZXhlY3V0aW5nU3RlcCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb25SZXRyaWFibGVFcnJvcl9qc18xLk5vblJldHJpYWJsZUVycm9yKCgwLCBlcnJvcnNfanNfMS5wcmV0dHlFcnJvcikoe1xuICAgICAgICAgICAgICAgICAgICB3aGF0SGFwcGVuZWQ6IFwiWW91ciBmdW5jdGlvbiB3YXMgc3RvcHBlZCBmcm9tIHJ1bm5pbmdcIixcbiAgICAgICAgICAgICAgICAgICAgd2h5OiBcIldlIGRldGVjdGVkIHRoYXQgeW91IGhhdmUgbmVzdGVkIGBzdGVwLipgIHRvb2xpbmcuXCIsXG4gICAgICAgICAgICAgICAgICAgIGNvbnNlcXVlbmNlczogXCJOZXN0aW5nIGBzdGVwLipgIHRvb2xpbmcgaXMgbm90IHN1cHBvcnRlZC5cIixcbiAgICAgICAgICAgICAgICAgICAgc3RhY2s6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHRvRml4Tm93OiBcIk1ha2Ugc3VyZSB5b3UncmUgbm90IHVzaW5nIGBzdGVwLipgIHRvb2xpbmcgaW5zaWRlIG9mIG90aGVyIGBzdGVwLipgIHRvb2xpbmcuIElmIHlvdSBuZWVkIHRvIGNvbXBvc2Ugc3RlcHMgdG9nZXRoZXIsIHlvdSBjYW4gY3JlYXRlIGEgbmV3IGFzeW5jIGZ1bmN0aW9uIGFuZCBjYWxsIGl0IGZyb20gd2l0aGluIHlvdXIgc3RlcCBmdW5jdGlvbiwgb3IgdXNlIHByb21pc2UgY2hhaW5pbmcuXCIsXG4gICAgICAgICAgICAgICAgICAgIG90aGVyd2lzZTogXCJGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBzdGVwIGZ1bmN0aW9ucyB3aXRoIElubmdlc3QsIHNlZSBodHRwczovL3d3dy5pbm5nZXN0LmNvbS9kb2NzL2Z1bmN0aW9ucy9tdWx0aS1zdGVwXCIsXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IGVycm9yc19qc18xLkVyckNvZGUuTkVTVElOR19TVEVQUyxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0YXRlLmhhc1VzZWRUb29scyA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCBzdGVwT3B0aW9ucyA9ICgwLCBJbm5nZXN0U3RlcFRvb2xzX2pzXzEuZ2V0U3RlcE9wdGlvbnMpKGFyZ3NbMF0pO1xuICAgICAgICAgICAgY29uc3Qgb3BJZCA9IGhhc2hPcChtYXRjaE9wKHN0ZXBPcHRpb25zLCAuLi5hcmdzLnNsaWNlKDEpKSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUudGlja09wc1tvcElkLmlkXSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcElkKSwgKChvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMuZm4pID8geyBmbjogKCkgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSBvcHRzLmZuKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChvcHRzLCAuLi5hcmdzKTsgfSB9IDoge30pKSwgeyByYXdBcmdzOiBhcmdzLCByZXNvbHZlLFxuICAgICAgICAgICAgICAgICAgICByZWplY3QsIGZ1bGZpbGxlZDogZmFsc2UgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc3RlcCA9ICgwLCBJbm5nZXN0U3RlcFRvb2xzX2pzXzEuY3JlYXRlU3RlcFRvb2xzKSh0aGlzLm9wdGlvbnMuY2xpZW50LCB0aGlzLCBzdGVwSGFuZGxlcik7XG4gICAgICAgIGxldCBmbkFyZyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRpb25zLmRhdGEpLCB7IHN0ZXAgfSk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaXNGYWlsdXJlSGFuZGxlcikge1xuICAgICAgICAgICAgY29uc3QgZXZlbnREYXRhID0gem9kXzEuelxuICAgICAgICAgICAgICAgIC5vYmplY3QoeyBlcnJvcjogdHlwZXNfanNfMS5qc29uRXJyb3JTY2hlbWEgfSlcbiAgICAgICAgICAgICAgICAucGFyc2UoKF9hID0gZm5BcmcuZXZlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kYXRhKTtcbiAgICAgICAgICAgIGZuQXJnID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBmbkFyZyksIHsgZXJyb3I6ICgwLCBlcnJvcnNfanNfMS5kZXNlcmlhbGl6ZUVycm9yKShldmVudERhdGEuZXJyb3IpIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoX2QgPSAoX2MgPSAoX2IgPSB0aGlzLm9wdGlvbnMpLnRyYW5zZm9ybUN0eCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhbGwoX2IsIGZuQXJnKSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogZm5Bcmc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzaW5nIG1pZGRsZXdhcmUsIHRyYW5zZm9ybSBpbnB1dCBiZWZvcmUgcnVubmluZy5cbiAgICAgKi9cbiAgICBhc3luYyB0cmFuc2Zvcm1JbnB1dCgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgaW5wdXRNdXRhdGlvbnMgPSBhd2FpdCAoKF9iID0gKF9hID0gdGhpcy5zdGF0ZS5ob29rcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRyYW5zZm9ybUlucHV0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwge1xuICAgICAgICAgICAgY3R4OiBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmZuQXJnKSxcbiAgICAgICAgICAgIHN0ZXBzOiBPYmplY3QudmFsdWVzKHRoaXMub3B0aW9ucy5zdGVwU3RhdGUpLFxuICAgICAgICAgICAgZm46IHRoaXMub3B0aW9ucy5mbixcbiAgICAgICAgICAgIHJlcUFyZ3M6IHRoaXMub3B0aW9ucy5yZXFBcmdzLFxuICAgICAgICB9KSk7XG4gICAgICAgIGlmIChpbnB1dE11dGF0aW9ucyA9PT0gbnVsbCB8fCBpbnB1dE11dGF0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5wdXRNdXRhdGlvbnMuY3R4KSB7XG4gICAgICAgICAgICB0aGlzLmZuQXJnID0gaW5wdXRNdXRhdGlvbnMuY3R4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnB1dE11dGF0aW9ucyA9PT0gbnVsbCB8fCBpbnB1dE11dGF0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5wdXRNdXRhdGlvbnMuc3RlcHMpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUub3BTdGFjayA9IFsuLi5pbnB1dE11dGF0aW9ucy5zdGVwc107XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0RWFybHlFeGVjUnVuU3RlcChvcHMpIHtcbiAgICAgICAgaWYgKG9wcy5sZW5ndGggIT09IDEpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IG9wID0gb3BzWzBdO1xuICAgICAgICBpZiAob3AgJiZcbiAgICAgICAgICAgIG9wLm9wID09PSB0eXBlc19qc18xLlN0ZXBPcENvZGUuU3RlcFBsYW5uZWRcbiAgICAgICAgLy8gVE9ETyBXZSBtdXN0IGluZGl2aWR1YWxseSBjaGVjayBwcm9wZXJ0aWVzIGhlcmUgdGhhdCB3ZSBkbyBub3Qgd2FudCB0b1xuICAgICAgICAvLyBleGVjdXRlIG9uLCBzdWNoIGFzIHJldHJ5IGNvdW50cy4gTm90aGluZyBleGlzdHMgaGVyZSB0aGF0IGZhbGxzIGluIHRvXG4gICAgICAgIC8vIHRoaXMgY2FzZSwgYnV0IHNob3VsZCBiZSBhY2NvdW50ZWQgZm9yIHdoZW4gd2UgYWRkIHRoZW0uXG4gICAgICAgIC8vICYmIHR5cGVvZiBvcC5vcHRzID09PSBcInVuZGVmaW5lZFwiXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIG9wLmlkO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzaW5nIG1pZGRsZXdhcmUsIHRyYW5zZm9ybSBvdXRwdXQgYmVmb3JlIHJldHVybmluZy5cbiAgICAgKi9cbiAgICBhc3luYyB0cmFuc2Zvcm1PdXRwdXQoZGF0YU9yRXJyb3IsIHN0ZXApIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBPYmplY3QuYXNzaWduKHt9LCBkYXRhT3JFcnJvcik7XG4gICAgICAgIGlmICh0eXBlb2Ygb3V0cHV0LmVycm9yICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBvdXRwdXQuZGF0YSA9ICgwLCBlcnJvcnNfanNfMS5zZXJpYWxpemVFcnJvcikob3V0cHV0LmVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZE91dHB1dCA9IGF3YWl0ICgoX2IgPSAoX2EgPSB0aGlzLnN0YXRlLmhvb2tzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudHJhbnNmb3JtT3V0cHV0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwge1xuICAgICAgICAgICAgcmVzdWx0OiBPYmplY3QuYXNzaWduKHt9LCBvdXRwdXQpLFxuICAgICAgICAgICAgc3RlcCxcbiAgICAgICAgfSkpO1xuICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG91dHB1dCksIHRyYW5zZm9ybWVkT3V0cHV0ID09PSBudWxsIHx8IHRyYW5zZm9ybWVkT3V0cHV0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0cmFuc2Zvcm1lZE91dHB1dC5yZXN1bHQpO1xuICAgICAgICBpZiAoIXN0ZXApIHtcbiAgICAgICAgICAgIGF3YWl0ICgoX2QgPSAoX2MgPSB0aGlzLnN0YXRlLmhvb2tzKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZmluaXNoZWQpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jYWxsKF9jLCB7XG4gICAgICAgICAgICAgICAgcmVzdWx0OiBPYmplY3QuYXNzaWduKHt9LCAodHlwZW9mIGVycm9yICE9PSBcInVuZGVmaW5lZFwiID8geyBlcnJvciB9IDogeyBkYXRhIH0pKSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGVycm9yICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEVuc3VyZSB3ZSBnaXZlIG1pZGRsZXdhcmUgdGhlIGNoYW5jZSB0byBkZWNpZGUgb24gcmV0cmlhYmxlIGJlaGF2aW91clxuICAgICAgICAgICAgICogYnkgbG9va2luZyBhdCB0aGUgZXJyb3IgcmV0dXJuZWQgZnJvbSBvdXRwdXQgdHJhbnNmb3JtYXRpb24uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGxldCByZXRyaWFibGUgPSAhKGVycm9yIGluc3RhbmNlb2YgTm9uUmV0cmlhYmxlRXJyb3JfanNfMS5Ob25SZXRyaWFibGVFcnJvcik7XG4gICAgICAgICAgICBpZiAocmV0cmlhYmxlICYmIGVycm9yIGluc3RhbmNlb2YgUmV0cnlBZnRlckVycm9yX2pzXzEuUmV0cnlBZnRlckVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0cmlhYmxlID0gZXJyb3IucmV0cnlBZnRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNlcmlhbGl6ZWRFcnJvciA9ICgwLCBlcnJvcnNfanNfMS5zZXJpYWxpemVFcnJvcikoZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uLXJlamVjdGVkXCIsXG4gICAgICAgICAgICAgICAgY3R4OiB0aGlzLmZuQXJnLFxuICAgICAgICAgICAgICAgIG9wczogdGhpcy5vcHMsXG4gICAgICAgICAgICAgICAgZXJyb3I6IHNlcmlhbGl6ZWRFcnJvcixcbiAgICAgICAgICAgICAgICByZXRyaWFibGUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uLXJlc29sdmVkXCIsXG4gICAgICAgICAgICBjdHg6IHRoaXMuZm5BcmcsXG4gICAgICAgICAgICBvcHM6IHRoaXMub3BzLFxuICAgICAgICAgICAgZGF0YTogKDAsIGZ1bmN0aW9uc19qc18xLnVuZGVmaW5lZFRvTnVsbCkoZGF0YSksXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5WMElubmdlc3RFeGVjdXRpb24gPSBWMElubmdlc3RFeGVjdXRpb247XG5jb25zdCB0aWNrT3BUb091dGdvaW5nID0gKG9wKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgb3A6IG9wLm9wLFxuICAgICAgICBpZDogb3AuaWQsXG4gICAgICAgIG5hbWU6IG9wLm5hbWUsXG4gICAgICAgIG9wdHM6IG9wLm9wdHMsXG4gICAgfTtcbn07XG5jb25zdCBoYXNoRGF0YSA9IChvcCkgPT4ge1xuICAgIHJldHVybiAoMCwgaGFzaF9qc18xLnNoYTEpKCkudXBkYXRlKCgwLCBjYW5vbmljYWxpemVfMS5kZWZhdWx0KShvcCkpLmRpZ2VzdChcImhleFwiKTtcbn07XG4vKipcbiAqIEV4cG9ydGVkIGZvciB0ZXN0aW5nLlxuICovXG5leHBvcnRzLl9pbnRlcm5hbHMgPSB7IGhhc2hEYXRhIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD12MC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/execution/v0.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/execution/v1.js":
/*!*********************************************************!*\
  !*** ./node_modules/inngest/components/execution/v1.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __asyncValues = (this && this.__asyncValues) || function (o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n};\nvar __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports._internals = exports.createV1InngestExecution = void 0;\nconst api_1 = __webpack_require__(/*! @opentelemetry/api */ \"(rsc)/./node_modules/@opentelemetry/api/build/esm/index.js\");\nconst hash_js_1 = __webpack_require__(/*! hash.js */ \"(rsc)/./node_modules/hash.js/lib/hash.js\");\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/inngest/node_modules/zod/lib/index.js\");\nconst consts_js_1 = __webpack_require__(/*! ../../helpers/consts.js */ \"(rsc)/./node_modules/inngest/helpers/consts.js\");\nconst errors_js_1 = __webpack_require__(/*! ../../helpers/errors.js */ \"(rsc)/./node_modules/inngest/helpers/errors.js\");\nconst functions_js_1 = __webpack_require__(/*! ../../helpers/functions.js */ \"(rsc)/./node_modules/inngest/helpers/functions.js\");\nconst promises_js_1 = __webpack_require__(/*! ../../helpers/promises.js */ \"(rsc)/./node_modules/inngest/helpers/promises.js\");\nconst types_js_1 = __webpack_require__(/*! ../../types.js */ \"(rsc)/./node_modules/inngest/types.js\");\nconst version_js_1 = __webpack_require__(/*! ../../version.js */ \"(rsc)/./node_modules/inngest/version.js\");\nconst InngestMiddleware_js_1 = __webpack_require__(/*! ../InngestMiddleware.js */ \"(rsc)/./node_modules/inngest/components/InngestMiddleware.js\");\nconst InngestStepTools_js_1 = __webpack_require__(/*! ../InngestStepTools.js */ \"(rsc)/./node_modules/inngest/components/InngestStepTools.js\");\nconst NonRetriableError_js_1 = __webpack_require__(/*! ../NonRetriableError.js */ \"(rsc)/./node_modules/inngest/components/NonRetriableError.js\");\nconst RetryAfterError_js_1 = __webpack_require__(/*! ../RetryAfterError.js */ \"(rsc)/./node_modules/inngest/components/RetryAfterError.js\");\nconst StepError_js_1 = __webpack_require__(/*! ../StepError.js */ \"(rsc)/./node_modules/inngest/components/StepError.js\");\nconst InngestExecution_js_1 = __webpack_require__(/*! ./InngestExecution.js */ \"(rsc)/./node_modules/inngest/components/execution/InngestExecution.js\");\nconst als_js_1 = __webpack_require__(/*! ./als.js */ \"(rsc)/./node_modules/inngest/components/execution/als.js\");\nconst access_js_1 = __webpack_require__(/*! ./otel/access.js */ \"(rsc)/./node_modules/inngest/components/execution/otel/access.js\");\nconst createV1InngestExecution = (options) => {\n    return new V1InngestExecution(options);\n};\nexports.createV1InngestExecution = createV1InngestExecution;\nclass V1InngestExecution extends InngestExecution_js_1.InngestExecution {\n    constructor(options) {\n        super(options);\n        this.timeoutDuration = 1000 * 10;\n        this.userFnToRun = this.getUserFnToRun();\n        this.state = this.createExecutionState();\n        this.fnArg = this.createFnArg();\n        this.checkpointHandlers = this.createCheckpointHandlers();\n        this.initializeTimer(this.state);\n        this.debug(\"created new V1 execution for run;\", this.options.requestedRunStep\n            ? `wanting to run step \"${this.options.requestedRunStep}\"`\n            : \"discovering steps\");\n        this.debug(\"existing state keys:\", Object.keys(this.state.stepState));\n    }\n    /**\n     * Idempotently start the execution of the user's function.\n     */\n    start() {\n        if (!this.execution) {\n            this.debug(\"starting V1 execution\");\n            const tracer = api_1.trace.getTracer(\"inngest\", version_js_1.version);\n            this.execution = (0, als_js_1.getAsyncLocalStorage)().then((als) => {\n                return als.run({ app: this.options.client, ctx: this.fnArg }, async () => {\n                    return tracer.startActiveSpan(\"inngest.execution\", (span) => {\n                        var _a;\n                        (_a = access_js_1.clientProcessorMap.get(this.options.client)) === null || _a === void 0 ? void 0 : _a.declareStartingSpan({\n                            span,\n                            runId: this.options.runId,\n                            traceparent: this.options.headers[consts_js_1.headerKeys.TraceParent],\n                            tracestate: this.options.headers[consts_js_1.headerKeys.TraceState],\n                        });\n                        return this._start()\n                            .then((result) => {\n                            this.debug(\"result:\", result);\n                            return result;\n                        })\n                            .finally(() => {\n                            span.end();\n                        });\n                    });\n                });\n            });\n        }\n        return this.execution;\n    }\n    /**\n     * Starts execution of the user's function and the core loop.\n     */\n    async _start() {\n        var _a, e_1, _b, _c;\n        var _d, _e;\n        try {\n            const allCheckpointHandler = this.getCheckpointHandler(\"\");\n            this.state.hooks = await this.initializeMiddleware();\n            await this.startExecution();\n            try {\n                for (var _f = true, _g = __asyncValues(this.state.loop), _h; _h = await _g.next(), _a = _h.done, !_a; _f = true) {\n                    _c = _h.value;\n                    _f = false;\n                    const checkpoint = _c;\n                    await allCheckpointHandler(checkpoint);\n                    const handler = this.getCheckpointHandler(checkpoint.type);\n                    const result = await handler(checkpoint);\n                    if (result) {\n                        return result;\n                    }\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (!_f && !_a && (_b = _g.return)) await _b.call(_g);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n        }\n        catch (error) {\n            return await this.transformOutput({ error });\n        }\n        finally {\n            void this.state.loop.return();\n            await ((_e = (_d = this.state.hooks) === null || _d === void 0 ? void 0 : _d.beforeResponse) === null || _e === void 0 ? void 0 : _e.call(_d));\n        }\n        /**\n         * If we're here, the generator somehow finished without returning a value.\n         * This should never happen.\n         */\n        throw new Error(\"Core loop finished without returning a value\");\n    }\n    /**\n     * Creates a handler for every checkpoint type, defining what to do when we\n     * reach that checkpoint in the core loop.\n     */\n    createCheckpointHandlers() {\n        return {\n            /**\n             * Run for all checkpoints. Best used for logging or common actions.\n             * Use other handlers to return values and interrupt the core loop.\n             */\n            \"\": (checkpoint) => {\n                this.debug(\"checkpoint:\", checkpoint);\n            },\n            /**\n             * The user's function has completed and returned a value.\n             */\n            \"function-resolved\": async (checkpoint) => {\n                return await this.transformOutput({ data: checkpoint.data });\n            },\n            /**\n             * The user's function has thrown an error.\n             */\n            \"function-rejected\": async (checkpoint) => {\n                return await this.transformOutput({ error: checkpoint.error });\n            },\n            /**\n             * We've found one or more steps. Here we may want to run a step or report\n             * them back to Inngest.\n             */\n            \"steps-found\": async ({ steps }) => {\n                const stepResult = await this.tryExecuteStep(steps);\n                if (stepResult) {\n                    const transformResult = await this.transformOutput(stepResult);\n                    /**\n                     * Transforming output will always return either function rejection or\n                     * resolution. In most cases, this can be immediately returned, but in\n                     * this particular case we want to handle it differently.\n                     */\n                    if (transformResult.type === \"function-resolved\") {\n                        return {\n                            type: \"step-ran\",\n                            ctx: transformResult.ctx,\n                            ops: transformResult.ops,\n                            step: exports._internals.hashOp(Object.assign(Object.assign({}, stepResult), { data: transformResult.data })),\n                        };\n                    }\n                    else if (transformResult.type === \"function-rejected\") {\n                        return {\n                            type: \"step-ran\",\n                            ctx: transformResult.ctx,\n                            ops: transformResult.ops,\n                            step: exports._internals.hashOp(Object.assign(Object.assign({}, stepResult), { error: transformResult.error })),\n                            retriable: transformResult.retriable,\n                        };\n                    }\n                    return transformResult;\n                }\n                const newSteps = await this.filterNewSteps(Array.from(this.state.steps.values()));\n                if (newSteps) {\n                    return {\n                        type: \"steps-found\",\n                        ctx: this.fnArg,\n                        ops: this.ops,\n                        steps: newSteps,\n                    };\n                }\n            },\n            /**\n             * While trying to find a step that Inngest has told us to run, we've\n             * timed out or have otherwise decided that it doesn't exist.\n             */\n            \"step-not-found\": ({ step }) => {\n                return { type: \"step-not-found\", ctx: this.fnArg, ops: this.ops, step };\n            },\n        };\n    }\n    getCheckpointHandler(type) {\n        return this.checkpointHandlers[type];\n    }\n    async tryExecuteStep(steps) {\n        var _a;\n        const hashedStepIdToRun = this.options.requestedRunStep || this.getEarlyExecRunStep(steps);\n        if (!hashedStepIdToRun) {\n            return;\n        }\n        const step = steps.find((step) => step.hashedId === hashedStepIdToRun && step.fn);\n        if (step) {\n            return await this.executeStep(step);\n        }\n        /**\n         * Ensure we reset the timeout if we have a requested run step but couldn't\n         * find it, but also that we don't reset if we found and executed it.\n         */\n        void ((_a = this.timeout) === null || _a === void 0 ? void 0 : _a.reset());\n    }\n    /**\n     * Given a list of outgoing ops, decide if we can execute an op early and\n     * return the ID of the step to execute if we can.\n     */\n    getEarlyExecRunStep(steps) {\n        /**\n         * We may have been disabled due to parallelism, in which case we can't\n         * immediately execute unless explicitly requested.\n         */\n        if (this.options.disableImmediateExecution)\n            return;\n        const unfulfilledSteps = steps.filter((step) => !step.fulfilled);\n        if (unfulfilledSteps.length !== 1)\n            return;\n        const op = unfulfilledSteps[0];\n        if (op &&\n            op.op === types_js_1.StepOpCode.StepPlanned\n        // TODO We must individually check properties here that we do not want to\n        // execute on, such as retry counts. Nothing exists here that falls in to\n        // this case, but should be accounted for when we add them.\n        // && typeof op.opts === \"undefined\"\n        ) {\n            return op.hashedId;\n        }\n    }\n    async filterNewSteps(foundSteps) {\n        var _a, _b, _c, _d, _e, _f;\n        if (this.options.requestedRunStep) {\n            return;\n        }\n        /**\n         * Gather any steps that aren't memoized and report them.\n         */\n        const newSteps = foundSteps.filter((step) => !step.fulfilled);\n        if (!newSteps.length) {\n            return;\n        }\n        /**\n         * Warn if we've found new steps but haven't yet seen all previous\n         * steps. This may indicate that step presence isn't determinate.\n         */\n        let knownSteps = 0;\n        for (const step of foundSteps) {\n            if (step.fulfilled) {\n                knownSteps++;\n            }\n        }\n        const foundAllCompletedSteps = this.state.stepsToFulfill === knownSteps;\n        if (!foundAllCompletedSteps) {\n            // TODO Tag\n            console.warn((0, errors_js_1.prettyError)({\n                type: \"warn\",\n                whatHappened: \"Function may be indeterminate\",\n                why: \"We found new steps before seeing all previous steps, which may indicate that the function is non-deterministic.\",\n                consequences: \"This may cause unexpected behaviour as Inngest executes your function.\",\n                reassurance: \"This is expected if a function is updated in the middle of a run, but may indicate a bug if not.\",\n            }));\n        }\n        /**\n         * We're finishing up; let's trigger the last of the hooks.\n         */\n        await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.afterMemoization) === null || _b === void 0 ? void 0 : _b.call(_a));\n        await ((_d = (_c = this.state.hooks) === null || _c === void 0 ? void 0 : _c.beforeExecution) === null || _d === void 0 ? void 0 : _d.call(_c));\n        await ((_f = (_e = this.state.hooks) === null || _e === void 0 ? void 0 : _e.afterExecution) === null || _f === void 0 ? void 0 : _f.call(_e));\n        const stepList = newSteps.map((step) => ({\n            displayName: step.displayName,\n            op: step.op,\n            id: step.hashedId,\n            name: step.name,\n            opts: step.opts,\n        }));\n        /**\n         * We also run `onSendEvent` middleware hooks against `step.invoke()` steps\n         * to ensure that their `data` is transformed correctly.\n         */\n        return await this.transformNewSteps(stepList);\n    }\n    /**\n     * Using middleware, transform any newly-found steps before returning them to\n     * an Inngest Server.\n     */\n    async transformNewSteps(steps) {\n        return Promise.all(steps.map(async (step) => {\n            var _a, _b, _c, _d, _e, _f, _g;\n            if (step.op !== types_js_1.StepOpCode.InvokeFunction) {\n                return step;\n            }\n            const onSendEventHooks = await (0, InngestMiddleware_js_1.getHookStack)(this.options.fn[\"middleware\"], \"onSendEvent\", undefined, {\n                transformInput: (prev, output) => {\n                    return Object.assign(Object.assign({}, prev), output);\n                },\n                transformOutput: (prev, output) => {\n                    return {\n                        result: Object.assign(Object.assign({}, prev.result), output === null || output === void 0 ? void 0 : output.result),\n                    };\n                },\n            });\n            /**\n             * For each event being sent, create a new `onSendEvent` hook stack to\n             * process it. We do this as middleware hooks are intended to run once\n             * during each lifecycle (onFunctionRun or onSendEvent) and here, a hook\n             * is run for every single event.\n             *\n             * This is done because a developer can use this hook to filter out\n             * events entirely; if we batch all of the events together, we can't\n             * tell which ones were filtered out if we're processing >1 invocation\n             * here.\n             */\n            const transformedPayload = await ((_a = onSendEventHooks.transformInput) === null || _a === void 0 ? void 0 : _a.call(onSendEventHooks, {\n                payloads: [\n                    Object.assign(Object.assign({}, ((_c = (_b = step.opts) === null || _b === void 0 ? void 0 : _b.payload) !== null && _c !== void 0 ? _c : {})), { name: consts_js_1.internalEvents.FunctionInvoked }),\n                ],\n            }));\n            const newPayload = InngestStepTools_js_1.invokePayloadSchema.parse((_e = (_d = transformedPayload === null || transformedPayload === void 0 ? void 0 : transformedPayload.payloads) === null || _d === void 0 ? void 0 : _d[0]) !== null && _e !== void 0 ? _e : {});\n            return Object.assign(Object.assign({}, step), { opts: Object.assign(Object.assign({}, step.opts), { payload: Object.assign(Object.assign({}, ((_g = (_f = step.opts) === null || _f === void 0 ? void 0 : _f.payload) !== null && _g !== void 0 ? _g : {})), newPayload) }) });\n        }));\n    }\n    async executeStep({ id, name, opts, fn, displayName, }) {\n        var _a, _b, _c, _d, _e;\n        (_a = this.timeout) === null || _a === void 0 ? void 0 : _a.clear();\n        await ((_c = (_b = this.state.hooks) === null || _b === void 0 ? void 0 : _b.afterMemoization) === null || _c === void 0 ? void 0 : _c.call(_b));\n        await ((_e = (_d = this.state.hooks) === null || _d === void 0 ? void 0 : _d.beforeExecution) === null || _e === void 0 ? void 0 : _e.call(_d));\n        const outgoingOp = {\n            id,\n            op: types_js_1.StepOpCode.StepRun,\n            name,\n            opts,\n            displayName,\n        };\n        this.state.executingStep = outgoingOp;\n        const store = await (0, als_js_1.getAsyncCtx)();\n        if (store) {\n            store.executingStep = {\n                id,\n                name: displayName,\n            };\n        }\n        this.debug(`executing step \"${id}\"`);\n        return ((0, promises_js_1.runAsPromise)(fn)\n            // eslint-disable-next-line @typescript-eslint/no-misused-promises\n            .finally(async () => {\n            var _a, _b;\n            if (store) {\n                delete store.executingStep;\n            }\n            await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.afterExecution) === null || _b === void 0 ? void 0 : _b.call(_a));\n        })\n            .then((data) => {\n            return Object.assign(Object.assign({}, outgoingOp), { data });\n        })\n            .catch((error) => {\n            return Object.assign(Object.assign({}, outgoingOp), { op: types_js_1.StepOpCode.StepError, \n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                error });\n        }));\n    }\n    /**\n     * Starts execution of the user's function, including triggering checkpoints\n     * and middleware hooks where appropriate.\n     */\n    async startExecution() {\n        var _a, _b, _c, _d, _e, _f, _g;\n        /**\n         * Mutate input as neccessary based on middleware.\n         */\n        await this.transformInput();\n        /**\n         * Start the timer to time out the run if needed.\n         */\n        void ((_a = this.timeout) === null || _a === void 0 ? void 0 : _a.start());\n        await ((_c = (_b = this.state.hooks) === null || _b === void 0 ? void 0 : _b.beforeMemoization) === null || _c === void 0 ? void 0 : _c.call(_b));\n        /**\n         * If we had no state to begin with, immediately end the memoization phase.\n         */\n        if (this.state.allStateUsed()) {\n            await ((_e = (_d = this.state.hooks) === null || _d === void 0 ? void 0 : _d.afterMemoization) === null || _e === void 0 ? void 0 : _e.call(_d));\n            await ((_g = (_f = this.state.hooks) === null || _f === void 0 ? void 0 : _f.beforeExecution) === null || _g === void 0 ? void 0 : _g.call(_f));\n        }\n        /**\n         * Trigger the user's function.\n         */\n        (0, promises_js_1.runAsPromise)(() => this.userFnToRun(this.fnArg))\n            // eslint-disable-next-line @typescript-eslint/no-misused-promises\n            .finally(async () => {\n            var _a, _b, _c, _d, _e, _f;\n            await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.afterMemoization) === null || _b === void 0 ? void 0 : _b.call(_a));\n            await ((_d = (_c = this.state.hooks) === null || _c === void 0 ? void 0 : _c.beforeExecution) === null || _d === void 0 ? void 0 : _d.call(_c));\n            await ((_f = (_e = this.state.hooks) === null || _e === void 0 ? void 0 : _e.afterExecution) === null || _f === void 0 ? void 0 : _f.call(_e));\n        })\n            .then((data) => {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            this.state.setCheckpoint({ type: \"function-resolved\", data });\n        })\n            .catch((error) => {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            this.state.setCheckpoint({ type: \"function-rejected\", error });\n        });\n    }\n    /**\n     * Using middleware, transform input before running.\n     */\n    async transformInput() {\n        var _a, _b;\n        const inputMutations = await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.transformInput) === null || _b === void 0 ? void 0 : _b.call(_a, {\n            ctx: Object.assign({}, this.fnArg),\n            steps: Object.values(this.state.stepState),\n            fn: this.options.fn,\n            reqArgs: this.options.reqArgs,\n        }));\n        if (inputMutations === null || inputMutations === void 0 ? void 0 : inputMutations.ctx) {\n            this.fnArg = inputMutations.ctx;\n        }\n        if (inputMutations === null || inputMutations === void 0 ? void 0 : inputMutations.steps) {\n            this.state.stepState = Object.fromEntries(inputMutations.steps.map((step) => [step.id, step]));\n        }\n    }\n    /**\n     * Using middleware, transform output before returning.\n     */\n    async transformOutput(dataOrError) {\n        var _a, _b, _c, _d;\n        const output = Object.assign({}, dataOrError);\n        /**\n         * If we've been given an error and it's one that we just threw from a step,\n         * we should return a `NonRetriableError` to stop execution.\n         */\n        if (typeof output.error !== \"undefined\") {\n            output.data = (0, errors_js_1.serializeError)(output.error);\n        }\n        const isStepExecution = Boolean(this.state.executingStep);\n        const transformedOutput = await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.transformOutput) === null || _b === void 0 ? void 0 : _b.call(_a, {\n            result: Object.assign({}, output),\n            step: this.state.executingStep,\n        }));\n        const { data, error } = Object.assign(Object.assign({}, output), transformedOutput === null || transformedOutput === void 0 ? void 0 : transformedOutput.result);\n        if (!isStepExecution) {\n            await ((_d = (_c = this.state.hooks) === null || _c === void 0 ? void 0 : _c.finished) === null || _d === void 0 ? void 0 : _d.call(_c, {\n                result: Object.assign({}, (typeof error !== \"undefined\" ? { error } : { data })),\n            }));\n        }\n        if (typeof error !== \"undefined\") {\n            /**\n             * Ensure we give middleware the chance to decide on retriable behaviour\n             * by looking at the error returned from output transformation.\n             */\n            let retriable = !(error instanceof NonRetriableError_js_1.NonRetriableError || error instanceof StepError_js_1.StepError);\n            if (retriable && error instanceof RetryAfterError_js_1.RetryAfterError) {\n                retriable = error.retryAfter;\n            }\n            const serializedError = (0, errors_js_1.minifyPrettyError)((0, errors_js_1.serializeError)(error));\n            return {\n                type: \"function-rejected\",\n                ctx: this.fnArg,\n                ops: this.ops,\n                error: serializedError,\n                retriable,\n            };\n        }\n        return {\n            type: \"function-resolved\",\n            ctx: this.fnArg,\n            ops: this.ops,\n            data: (0, functions_js_1.undefinedToNull)(data),\n        };\n    }\n    createExecutionState() {\n        const d = (0, promises_js_1.createDeferredPromiseWithStack)();\n        let checkpointResolve = d.deferred.resolve;\n        const checkpointResults = d.results;\n        const loop = (function (cleanUp) {\n            return __asyncGenerator(this, arguments, function* () {\n                try {\n                    while (true) {\n                        const res = (yield __await(checkpointResults.next())).value;\n                        if (res) {\n                            yield yield __await(res);\n                        }\n                    }\n                }\n                finally {\n                    cleanUp === null || cleanUp === void 0 ? void 0 : cleanUp();\n                }\n            });\n        })(() => {\n            var _a;\n            (_a = this.timeout) === null || _a === void 0 ? void 0 : _a.clear();\n            void checkpointResults.return();\n        });\n        const stepsToFulfill = Object.keys(this.options.stepState).length;\n        const state = {\n            stepState: this.options.stepState,\n            stepsToFulfill,\n            steps: new Map(),\n            loop,\n            hasSteps: Boolean(stepsToFulfill),\n            stepCompletionOrder: [...this.options.stepCompletionOrder],\n            remainingStepsToBeSeen: new Set(this.options.stepCompletionOrder),\n            setCheckpoint: (checkpoint) => {\n                ({ resolve: checkpointResolve } = checkpointResolve(checkpoint));\n            },\n            allStateUsed: () => {\n                return this.state.remainingStepsToBeSeen.size === 0;\n            },\n        };\n        return state;\n    }\n    get ops() {\n        return Object.fromEntries(this.state.steps);\n    }\n    createFnArg() {\n        var _a, _b, _c, _d;\n        const step = this.createStepTools();\n        let fnArg = Object.assign(Object.assign({}, this.options.data), { step });\n        /**\n         * Handle use of the `onFailure` option by deserializing the error.\n         */\n        if (this.options.isFailureHandler) {\n            const eventData = zod_1.z\n                .object({ error: types_js_1.jsonErrorSchema })\n                .parse((_a = fnArg.event) === null || _a === void 0 ? void 0 : _a.data);\n            fnArg = Object.assign(Object.assign({}, fnArg), { error: (0, errors_js_1.deserializeError)(eventData.error) });\n        }\n        return (_d = (_c = (_b = this.options).transformCtx) === null || _c === void 0 ? void 0 : _c.call(_b, fnArg)) !== null && _d !== void 0 ? _d : fnArg;\n    }\n    createStepTools() {\n        /**\n         * A list of steps that have been found and are being rolled up before being\n         * reported to the core loop.\n         */\n        const foundStepsToReport = new Map();\n        /**\n         * A map of the subset of found steps to report that have not yet been\n         * handled. Used for fast access to steps that need to be handled in order.\n         */\n        const unhandledFoundStepsToReport = new Map();\n        /**\n         * A map of the latest sequential step indexes found for each step ID. Used\n         * to ensure that we don't index steps in parallel.\n         *\n         * Note that these must be sequential; if we've seen or assigned `a:1`,\n         * `a:2` and `a:4`, the latest sequential step index is `2`.\n         *\n         */\n        const expectedNextStepIndexes = new Map();\n        /**\n         * An ordered list of step IDs that have yet to be handled in this\n         * execution. Used to ensure that we handle steps in the order they were\n         * found and based on the `stepCompletionOrder` in this execution's state.\n         */\n        const remainingStepCompletionOrder = this.state.stepCompletionOrder.slice();\n        /**\n         * A promise that's used to ensure that step reporting cannot be run more than\n         * once in a given asynchronous time span.\n         */\n        let foundStepsReportPromise;\n        /**\n         * A promise that's used to represent middleware hooks running before\n         * execution.\n         */\n        let beforeExecHooksPromise;\n        /**\n         * A flag used to ensure that we only warn about parallel indexing once per\n         * execution to avoid spamming the console.\n         */\n        let warnOfParallelIndexing = false;\n        /**\n         * Counts the number of times we've extended this tick.\n         */\n        let tickExtensionCount = 0;\n        /**\n         * Given a colliding step ID, maybe warn the user about parallel indexing.\n         */\n        const maybeWarnOfParallelIndexing = (collisionId) => {\n            if (warnOfParallelIndexing) {\n                return;\n            }\n            const stepExists = this.state.steps.has(collisionId);\n            if (stepExists) {\n                const stepFoundThisTick = foundStepsToReport.has(collisionId);\n                if (!stepFoundThisTick) {\n                    warnOfParallelIndexing = true;\n                    console.warn((0, errors_js_1.prettyError)({\n                        type: \"warn\",\n                        whatHappened: \"We detected that you have multiple steps with the same ID.\",\n                        code: errors_js_1.ErrCode.AUTOMATIC_PARALLEL_INDEXING,\n                        why: `This can happen if you're using the same ID for multiple steps across different chains of parallel work. We found the issue with step \"${collisionId}\".`,\n                        reassurance: \"Your function is still running, though it may exhibit unexpected behaviour.\",\n                        consequences: \"Using the same IDs across parallel chains of work can cause unexpected behaviour.\",\n                        toFixNow: \"We recommend using a unique ID for each step, especially those happening in parallel.\",\n                    }));\n                }\n            }\n        };\n        /**\n         * A helper used to report steps to the core loop. Used after adding an item\n         * to `foundStepsToReport`.\n         */\n        const reportNextTick = () => {\n            // Being explicit instead of using `??=` to appease TypeScript.\n            if (foundStepsReportPromise) {\n                return;\n            }\n            let extensionPromise;\n            if (++tickExtensionCount >= 10) {\n                tickExtensionCount = 0;\n                extensionPromise = new Promise((resolve) => setTimeout(resolve));\n            }\n            else {\n                extensionPromise = (0, promises_js_1.resolveAfterPending)();\n            }\n            foundStepsReportPromise = extensionPromise\n                /**\n                 * Ensure that we wait for this promise to resolve before continuing.\n                 *\n                 * The groups in which steps are reported can affect how we detect some\n                 * more complex determinism issues like parallel indexing. This promise\n                 * can represent middleware hooks being run early, in the middle of\n                 * ingesting steps to report.\n                 *\n                 * Because of this, it's important we wait for this middleware to resolve\n                 * before continuing to report steps to ensure that all steps have a\n                 * chance to be reported throughout this asynchronous action.\n                 */\n                .then(() => beforeExecHooksPromise)\n                .then(() => {\n                var _a;\n                foundStepsReportPromise = undefined;\n                for (let i = 0; i < remainingStepCompletionOrder.length; i++) {\n                    const nextStepId = remainingStepCompletionOrder[i];\n                    if (!nextStepId) {\n                        // Strange - skip this empty index\n                        continue;\n                    }\n                    const handled = (_a = unhandledFoundStepsToReport\n                        .get(nextStepId)) === null || _a === void 0 ? void 0 : _a.handle();\n                    if (handled) {\n                        remainingStepCompletionOrder.splice(i, 1);\n                        unhandledFoundStepsToReport.delete(nextStepId);\n                        return void reportNextTick();\n                    }\n                }\n                // If we've handled no steps in this \"tick,\" roll up everything we've\n                // found and report it.\n                const steps = [...foundStepsToReport.values()];\n                foundStepsToReport.clear();\n                unhandledFoundStepsToReport.clear();\n                return void this.state.setCheckpoint({\n                    type: \"steps-found\",\n                    steps: steps,\n                });\n            });\n        };\n        /**\n         * A helper used to push a step to the list of steps to report.\n         */\n        const pushStepToReport = (step) => {\n            foundStepsToReport.set(step.id, step);\n            unhandledFoundStepsToReport.set(step.hashedId, step);\n            reportNextTick();\n        };\n        const stepHandler = async ({ args, matchOp, opts, }) => {\n            var _a, _b, _c, _d;\n            await beforeExecHooksPromise;\n            const stepOptions = (0, InngestStepTools_js_1.getStepOptions)(args[0]);\n            const opId = matchOp(stepOptions, ...args.slice(1));\n            if (this.state.executingStep) {\n                /**\n                 * If a step is found after asynchronous actions during another step's\n                 * execution, everything is fine. The problem here is if we've found\n                 * that a step nested inside another a step, which is something we don't\n                 * support at the time of writing.\n                 *\n                 * In this case, we could use something like Async Hooks to understand\n                 * how the step is being triggered, though this isn't available in all\n                 * environments.\n                 *\n                 * Therefore, we'll only show a warning here to indicate that this is\n                 * potentially an issue.\n                 */\n                console.warn((0, errors_js_1.prettyError)({\n                    whatHappened: `We detected that you have nested \\`step.*\\` tooling in \\`${(_a = opId.displayName) !== null && _a !== void 0 ? _a : opId.id}\\``,\n                    consequences: \"Nesting `step.*` tooling is not supported.\",\n                    type: \"warn\",\n                    reassurance: \"It's possible to see this warning if steps are separated by regular asynchronous calls, which is fine.\",\n                    stack: true,\n                    toFixNow: \"Make sure you're not using `step.*` tooling inside of other `step.*` tooling. If you need to compose steps together, you can create a new async function and call it from within your step function, or use promise chaining.\",\n                    code: errors_js_1.ErrCode.NESTING_STEPS,\n                }));\n            }\n            if (this.state.steps.has(opId.id)) {\n                const originalId = opId.id;\n                maybeWarnOfParallelIndexing(originalId);\n                const expectedNextIndex = (_b = expectedNextStepIndexes.get(originalId)) !== null && _b !== void 0 ? _b : 1;\n                for (let i = expectedNextIndex;; i++) {\n                    const newId = originalId + InngestStepTools_js_1.STEP_INDEXING_SUFFIX + i;\n                    if (!this.state.steps.has(newId)) {\n                        expectedNextStepIndexes.set(originalId, i + 1);\n                        opId.id = newId;\n                        break;\n                    }\n                }\n            }\n            const { promise, resolve, reject } = (0, promises_js_1.createDeferredPromise)();\n            const hashedId = exports._internals.hashId(opId.id);\n            const stepState = this.state.stepState[hashedId];\n            let isFulfilled = false;\n            if (stepState) {\n                stepState.seen = true;\n                this.state.remainingStepsToBeSeen.delete(hashedId);\n                if (typeof stepState.input === \"undefined\") {\n                    isFulfilled = true;\n                }\n            }\n            let extraOpts;\n            let fnArgs = [...args];\n            if (typeof (stepState === null || stepState === void 0 ? void 0 : stepState.input) !== \"undefined\" &&\n                Array.isArray(stepState.input)) {\n                switch (opId.op) {\n                    // `step.run()` has its function input affected\n                    case types_js_1.StepOpCode.StepPlanned: {\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                        fnArgs = [...args.slice(0, 2), ...stepState.input];\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                        extraOpts = { input: [...stepState.input] };\n                        break;\n                    }\n                    // `step.ai.infer()` has its body affected\n                    case types_js_1.StepOpCode.AiGateway: {\n                        extraOpts = {\n                            body: Object.assign(Object.assign({}, (typeof ((_c = opId.opts) === null || _c === void 0 ? void 0 : _c.body) === \"object\"\n                                ? Object.assign({}, opId.opts.body) : {})), stepState.input[0]),\n                        };\n                        break;\n                    }\n                }\n            }\n            const step = Object.assign(Object.assign({}, opId), { opts: Object.assign(Object.assign({}, opId.opts), extraOpts), rawArgs: fnArgs, // TODO What is the right value here? Should this be raw args without affected input?\n                hashedId, input: stepState === null || stepState === void 0 ? void 0 : stepState.input, \n                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n                fn: (opts === null || opts === void 0 ? void 0 : opts.fn) ? () => { var _a; return (_a = opts.fn) === null || _a === void 0 ? void 0 : _a.call(opts, ...fnArgs); } : undefined, promise, fulfilled: isFulfilled, hasStepState: Boolean(stepState), displayName: (_d = opId.displayName) !== null && _d !== void 0 ? _d : opId.id, handled: false, handle: () => {\n                    if (step.handled) {\n                        return false;\n                    }\n                    step.handled = true;\n                    if (isFulfilled && stepState) {\n                        stepState.fulfilled = true;\n                        // For some execution scenarios such as testing, `data`, `error`,\n                        // and `input` may be `Promises`. This could also be the case for\n                        // future middleware applications. For this reason, we'll make sure\n                        // the values are fully resolved before continuing.\n                        void Promise.all([\n                            stepState.data,\n                            stepState.error,\n                            stepState.input,\n                        ]).then(() => {\n                            if (typeof stepState.data !== \"undefined\") {\n                                resolve(stepState.data);\n                            }\n                            else {\n                                this.state.recentlyRejectedStepError = new StepError_js_1.StepError(opId.id, stepState.error);\n                                reject(this.state.recentlyRejectedStepError);\n                            }\n                        });\n                    }\n                    return true;\n                } });\n            this.state.steps.set(opId.id, step);\n            this.state.hasSteps = true;\n            pushStepToReport(step);\n            /**\n             * If this is the last piece of state we had, we've now finished\n             * memoizing.\n             */\n            if (!beforeExecHooksPromise && this.state.allStateUsed()) {\n                await (beforeExecHooksPromise = (async () => {\n                    var _a, _b, _c, _d;\n                    await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.afterMemoization) === null || _b === void 0 ? void 0 : _b.call(_a));\n                    await ((_d = (_c = this.state.hooks) === null || _c === void 0 ? void 0 : _c.beforeExecution) === null || _d === void 0 ? void 0 : _d.call(_c));\n                })());\n            }\n            return promise;\n        };\n        return (0, InngestStepTools_js_1.createStepTools)(this.options.client, this, stepHandler);\n    }\n    getUserFnToRun() {\n        if (!this.options.isFailureHandler) {\n            return this.options.fn[\"fn\"];\n        }\n        if (!this.options.fn[\"onFailureFn\"]) {\n            /**\n             * Somehow, we've ended up detecting that this is a failure handler but\n             * doesn't have an `onFailure` function. This should never happen.\n             */\n            throw new Error(\"Cannot find function `onFailure` handler\");\n        }\n        return this.options.fn[\"onFailureFn\"];\n    }\n    initializeTimer(state) {\n        if (!this.options.requestedRunStep) {\n            return;\n        }\n        this.timeout = (0, promises_js_1.createTimeoutPromise)(this.timeoutDuration);\n        void this.timeout.then(async () => {\n            var _a, _b, _c, _d, _e, _f;\n            await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.afterMemoization) === null || _b === void 0 ? void 0 : _b.call(_a));\n            await ((_d = (_c = this.state.hooks) === null || _c === void 0 ? void 0 : _c.beforeExecution) === null || _d === void 0 ? void 0 : _d.call(_c));\n            await ((_f = (_e = this.state.hooks) === null || _e === void 0 ? void 0 : _e.afterExecution) === null || _f === void 0 ? void 0 : _f.call(_e));\n            state.setCheckpoint({\n                type: \"step-not-found\",\n                step: {\n                    id: this.options.requestedRunStep,\n                    op: types_js_1.StepOpCode.StepNotFound,\n                },\n            });\n        });\n    }\n    async initializeMiddleware() {\n        const ctx = this.options.data;\n        const hooks = await (0, InngestMiddleware_js_1.getHookStack)(this.options.fn[\"middleware\"], \"onFunctionRun\", {\n            ctx,\n            fn: this.options.fn,\n            steps: Object.values(this.options.stepState),\n            reqArgs: this.options.reqArgs,\n        }, {\n            transformInput: (prev, output) => {\n                return {\n                    ctx: Object.assign(Object.assign({}, prev.ctx), output === null || output === void 0 ? void 0 : output.ctx),\n                    fn: this.options.fn,\n                    steps: prev.steps.map((step, i) => {\n                        var _a;\n                        return (Object.assign(Object.assign({}, step), (_a = output === null || output === void 0 ? void 0 : output.steps) === null || _a === void 0 ? void 0 : _a[i]));\n                    }),\n                    reqArgs: prev.reqArgs,\n                };\n            },\n            transformOutput: (prev, output) => {\n                return {\n                    result: Object.assign(Object.assign({}, prev.result), output === null || output === void 0 ? void 0 : output.result),\n                    step: prev.step,\n                };\n            },\n        });\n        return hooks;\n    }\n}\nconst hashId = (id) => {\n    return (0, hash_js_1.sha1)().update(id).digest(\"hex\");\n};\nconst hashOp = (op) => {\n    return Object.assign(Object.assign({}, op), { id: hashId(op.id) });\n};\n/**\n * Exported for testing.\n */\nexports._internals = { hashOp, hashId };\n//# sourceMappingURL=v1.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL2V4ZWN1dGlvbi92MS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDJHQUEyRyx1RkFBdUYsY0FBYztBQUNoTix1QkFBdUIsOEJBQThCLGdEQUFnRCx3REFBd0Q7QUFDN0osNkNBQTZDLHNDQUFzQyxVQUFVLG1CQUFtQixJQUFJO0FBQ3BIO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLDBNQUEwTSxjQUFjO0FBQ3hOLDhCQUE4QixzQkFBc0I7QUFDcEQsMEJBQTBCLFlBQVksc0JBQXNCLHFDQUFxQywyQ0FBMkMsTUFBTTtBQUNsSiw0QkFBNEIsTUFBTSxpQkFBaUIsWUFBWTtBQUMvRCx1QkFBdUI7QUFDdkIsOEJBQThCO0FBQzlCLDZCQUE2QjtBQUM3Qiw0QkFBNEI7QUFDNUI7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCLEdBQUcsZ0NBQWdDO0FBQ3JELGNBQWMsbUJBQU8sQ0FBQyxzRkFBb0I7QUFDMUMsa0JBQWtCLG1CQUFPLENBQUMseURBQVM7QUFDbkMsY0FBYyxtQkFBTyxDQUFDLHVFQUFLO0FBQzNCLG9CQUFvQixtQkFBTyxDQUFDLCtFQUF5QjtBQUNyRCxvQkFBb0IsbUJBQU8sQ0FBQywrRUFBeUI7QUFDckQsdUJBQXVCLG1CQUFPLENBQUMscUZBQTRCO0FBQzNELHNCQUFzQixtQkFBTyxDQUFDLG1GQUEyQjtBQUN6RCxtQkFBbUIsbUJBQU8sQ0FBQyw2REFBZ0I7QUFDM0MscUJBQXFCLG1CQUFPLENBQUMsaUVBQWtCO0FBQy9DLCtCQUErQixtQkFBTyxDQUFDLDZGQUF5QjtBQUNoRSw4QkFBOEIsbUJBQU8sQ0FBQywyRkFBd0I7QUFDOUQsK0JBQStCLG1CQUFPLENBQUMsNkZBQXlCO0FBQ2hFLDZCQUE2QixtQkFBTyxDQUFDLHlGQUF1QjtBQUM1RCx1QkFBdUIsbUJBQU8sQ0FBQyw2RUFBaUI7QUFDaEQsOEJBQThC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aS1uZXh0Ly4vbm9kZV9tb2R1bGVzL2lubmdlc3QvY29tcG9uZW50cy9leGVjdXRpb24vdjEuanM/MWFjYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2FzeW5jVmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX2FzeW5jVmFsdWVzKSB8fCBmdW5jdGlvbiAobykge1xuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxuICAgIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cbn07XG52YXIgX19hd2FpdCA9ICh0aGlzICYmIHRoaXMuX19hd2FpdCkgfHwgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7IH1cbnZhciBfX2FzeW5jR2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2FzeW5jR2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xuICAgIHJldHVybiBpID0gT2JqZWN0LmNyZWF0ZSgodHlwZW9mIEFzeW5jSXRlcmF0b3IgPT09IFwiZnVuY3Rpb25cIiA/IEFzeW5jSXRlcmF0b3IgOiBPYmplY3QpLnByb3RvdHlwZSksIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiwgYXdhaXRSZXR1cm4pLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XG4gICAgZnVuY3Rpb24gYXdhaXRSZXR1cm4oZikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGYsIHJlamVjdCk7IH07IH1cbiAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaWYgKGdbbl0pIHsgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgaWYgKGYpIGlbbl0gPSBmKGlbbl0pOyB9IH1cbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XG4gICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxuICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5faW50ZXJuYWxzID0gZXhwb3J0cy5jcmVhdGVWMUlubmdlc3RFeGVjdXRpb24gPSB2b2lkIDA7XG5jb25zdCBhcGlfMSA9IHJlcXVpcmUoXCJAb3BlbnRlbGVtZXRyeS9hcGlcIik7XG5jb25zdCBoYXNoX2pzXzEgPSByZXF1aXJlKFwiaGFzaC5qc1wiKTtcbmNvbnN0IHpvZF8xID0gcmVxdWlyZShcInpvZFwiKTtcbmNvbnN0IGNvbnN0c19qc18xID0gcmVxdWlyZShcIi4uLy4uL2hlbHBlcnMvY29uc3RzLmpzXCIpO1xuY29uc3QgZXJyb3JzX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vaGVscGVycy9lcnJvcnMuanNcIik7XG5jb25zdCBmdW5jdGlvbnNfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi9oZWxwZXJzL2Z1bmN0aW9ucy5qc1wiKTtcbmNvbnN0IHByb21pc2VzX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vaGVscGVycy9wcm9taXNlcy5qc1wiKTtcbmNvbnN0IHR5cGVzX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vdHlwZXMuanNcIik7XG5jb25zdCB2ZXJzaW9uX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vdmVyc2lvbi5qc1wiKTtcbmNvbnN0IElubmdlc3RNaWRkbGV3YXJlX2pzXzEgPSByZXF1aXJlKFwiLi4vSW5uZ2VzdE1pZGRsZXdhcmUuanNcIik7XG5jb25zdCBJbm5nZXN0U3RlcFRvb2xzX2pzXzEgPSByZXF1aXJlKFwiLi4vSW5uZ2VzdFN0ZXBUb29scy5qc1wiKTtcbmNvbnN0IE5vblJldHJpYWJsZUVycm9yX2pzXzEgPSByZXF1aXJlKFwiLi4vTm9uUmV0cmlhYmxlRXJyb3IuanNcIik7XG5jb25zdCBSZXRyeUFmdGVyRXJyb3JfanNfMSA9IHJlcXVpcmUoXCIuLi9SZXRyeUFmdGVyRXJyb3IuanNcIik7XG5jb25zdCBTdGVwRXJyb3JfanNfMSA9IHJlcXVpcmUoXCIuLi9TdGVwRXJyb3IuanNcIik7XG5jb25zdCBJbm5nZXN0RXhlY3V0aW9uX2pzXzEgPSByZXF1aXJlKFwiLi9Jbm5nZXN0RXhlY3V0aW9uLmpzXCIpO1xuY29uc3QgYWxzX2pzXzEgPSByZXF1aXJlKFwiLi9hbHMuanNcIik7XG5jb25zdCBhY2Nlc3NfanNfMSA9IHJlcXVpcmUoXCIuL290ZWwvYWNjZXNzLmpzXCIpO1xuY29uc3QgY3JlYXRlVjFJbm5nZXN0RXhlY3V0aW9uID0gKG9wdGlvbnMpID0+IHtcbiAgICByZXR1cm4gbmV3IFYxSW5uZ2VzdEV4ZWN1dGlvbihvcHRpb25zKTtcbn07XG5leHBvcnRzLmNyZWF0ZVYxSW5uZ2VzdEV4ZWN1dGlvbiA9IGNyZWF0ZVYxSW5uZ2VzdEV4ZWN1dGlvbjtcbmNsYXNzIFYxSW5uZ2VzdEV4ZWN1dGlvbiBleHRlbmRzIElubmdlc3RFeGVjdXRpb25fanNfMS5Jbm5nZXN0RXhlY3V0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnRpbWVvdXREdXJhdGlvbiA9IDEwMDAgKiAxMDtcbiAgICAgICAgdGhpcy51c2VyRm5Ub1J1biA9IHRoaXMuZ2V0VXNlckZuVG9SdW4oKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuY3JlYXRlRXhlY3V0aW9uU3RhdGUoKTtcbiAgICAgICAgdGhpcy5mbkFyZyA9IHRoaXMuY3JlYXRlRm5BcmcoKTtcbiAgICAgICAgdGhpcy5jaGVja3BvaW50SGFuZGxlcnMgPSB0aGlzLmNyZWF0ZUNoZWNrcG9pbnRIYW5kbGVycygpO1xuICAgICAgICB0aGlzLmluaXRpYWxpemVUaW1lcih0aGlzLnN0YXRlKTtcbiAgICAgICAgdGhpcy5kZWJ1ZyhcImNyZWF0ZWQgbmV3IFYxIGV4ZWN1dGlvbiBmb3IgcnVuO1wiLCB0aGlzLm9wdGlvbnMucmVxdWVzdGVkUnVuU3RlcFxuICAgICAgICAgICAgPyBgd2FudGluZyB0byBydW4gc3RlcCBcIiR7dGhpcy5vcHRpb25zLnJlcXVlc3RlZFJ1blN0ZXB9XCJgXG4gICAgICAgICAgICA6IFwiZGlzY292ZXJpbmcgc3RlcHNcIik7XG4gICAgICAgIHRoaXMuZGVidWcoXCJleGlzdGluZyBzdGF0ZSBrZXlzOlwiLCBPYmplY3Qua2V5cyh0aGlzLnN0YXRlLnN0ZXBTdGF0ZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZGVtcG90ZW50bHkgc3RhcnQgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgdXNlcidzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHN0YXJ0KCkge1xuICAgICAgICBpZiAoIXRoaXMuZXhlY3V0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmRlYnVnKFwic3RhcnRpbmcgVjEgZXhlY3V0aW9uXCIpO1xuICAgICAgICAgICAgY29uc3QgdHJhY2VyID0gYXBpXzEudHJhY2UuZ2V0VHJhY2VyKFwiaW5uZ2VzdFwiLCB2ZXJzaW9uX2pzXzEudmVyc2lvbik7XG4gICAgICAgICAgICB0aGlzLmV4ZWN1dGlvbiA9ICgwLCBhbHNfanNfMS5nZXRBc3luY0xvY2FsU3RvcmFnZSkoKS50aGVuKChhbHMpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWxzLnJ1bih7IGFwcDogdGhpcy5vcHRpb25zLmNsaWVudCwgY3R4OiB0aGlzLmZuQXJnIH0sIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyYWNlci5zdGFydEFjdGl2ZVNwYW4oXCJpbm5nZXN0LmV4ZWN1dGlvblwiLCAoc3BhbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICAgICAgKF9hID0gYWNjZXNzX2pzXzEuY2xpZW50UHJvY2Vzc29yTWFwLmdldCh0aGlzLm9wdGlvbnMuY2xpZW50KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRlY2xhcmVTdGFydGluZ1NwYW4oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwYW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVuSWQ6IHRoaXMub3B0aW9ucy5ydW5JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFjZXBhcmVudDogdGhpcy5vcHRpb25zLmhlYWRlcnNbY29uc3RzX2pzXzEuaGVhZGVyS2V5cy5UcmFjZVBhcmVudF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2VzdGF0ZTogdGhpcy5vcHRpb25zLmhlYWRlcnNbY29uc3RzX2pzXzEuaGVhZGVyS2V5cy5UcmFjZVN0YXRlXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXJ0KClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWJ1ZyhcInJlc3VsdDpcIiwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmluYWxseSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Bhbi5lbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGlvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnRzIGV4ZWN1dGlvbiBvZiB0aGUgdXNlcidzIGZ1bmN0aW9uIGFuZCB0aGUgY29yZSBsb29wLlxuICAgICAqL1xuICAgIGFzeW5jIF9zdGFydCgpIHtcbiAgICAgICAgdmFyIF9hLCBlXzEsIF9iLCBfYztcbiAgICAgICAgdmFyIF9kLCBfZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGFsbENoZWNrcG9pbnRIYW5kbGVyID0gdGhpcy5nZXRDaGVja3BvaW50SGFuZGxlcihcIlwiKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuaG9va3MgPSBhd2FpdCB0aGlzLmluaXRpYWxpemVNaWRkbGV3YXJlKCk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnN0YXJ0RXhlY3V0aW9uKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9mID0gdHJ1ZSwgX2cgPSBfX2FzeW5jVmFsdWVzKHRoaXMuc3RhdGUubG9vcCksIF9oOyBfaCA9IGF3YWl0IF9nLm5leHQoKSwgX2EgPSBfaC5kb25lLCAhX2E7IF9mID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBfYyA9IF9oLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBfZiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGVja3BvaW50ID0gX2M7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGFsbENoZWNrcG9pbnRIYW5kbGVyKGNoZWNrcG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGVyID0gdGhpcy5nZXRDaGVja3BvaW50SGFuZGxlcihjaGVja3BvaW50LnR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBoYW5kbGVyKGNoZWNrcG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghX2YgJiYgIV9hICYmIChfYiA9IF9nLnJldHVybikpIGF3YWl0IF9iLmNhbGwoX2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc2Zvcm1PdXRwdXQoeyBlcnJvciB9KTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHZvaWQgdGhpcy5zdGF0ZS5sb29wLnJldHVybigpO1xuICAgICAgICAgICAgYXdhaXQgKChfZSA9IChfZCA9IHRoaXMuc3RhdGUuaG9va3MpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5iZWZvcmVSZXNwb25zZSkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmNhbGwoX2QpKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgd2UncmUgaGVyZSwgdGhlIGdlbmVyYXRvciBzb21laG93IGZpbmlzaGVkIHdpdGhvdXQgcmV0dXJuaW5nIGEgdmFsdWUuXG4gICAgICAgICAqIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbi5cbiAgICAgICAgICovXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvcmUgbG9vcCBmaW5pc2hlZCB3aXRob3V0IHJldHVybmluZyBhIHZhbHVlXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgaGFuZGxlciBmb3IgZXZlcnkgY2hlY2twb2ludCB0eXBlLCBkZWZpbmluZyB3aGF0IHRvIGRvIHdoZW4gd2VcbiAgICAgKiByZWFjaCB0aGF0IGNoZWNrcG9pbnQgaW4gdGhlIGNvcmUgbG9vcC5cbiAgICAgKi9cbiAgICBjcmVhdGVDaGVja3BvaW50SGFuZGxlcnMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJ1biBmb3IgYWxsIGNoZWNrcG9pbnRzLiBCZXN0IHVzZWQgZm9yIGxvZ2dpbmcgb3IgY29tbW9uIGFjdGlvbnMuXG4gICAgICAgICAgICAgKiBVc2Ugb3RoZXIgaGFuZGxlcnMgdG8gcmV0dXJuIHZhbHVlcyBhbmQgaW50ZXJydXB0IHRoZSBjb3JlIGxvb3AuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwiXCI6IChjaGVja3BvaW50KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWJ1ZyhcImNoZWNrcG9pbnQ6XCIsIGNoZWNrcG9pbnQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIHVzZXIncyBmdW5jdGlvbiBoYXMgY29tcGxldGVkIGFuZCByZXR1cm5lZCBhIHZhbHVlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcImZ1bmN0aW9uLXJlc29sdmVkXCI6IGFzeW5jIChjaGVja3BvaW50KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNmb3JtT3V0cHV0KHsgZGF0YTogY2hlY2twb2ludC5kYXRhIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIHVzZXIncyBmdW5jdGlvbiBoYXMgdGhyb3duIGFuIGVycm9yLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcImZ1bmN0aW9uLXJlamVjdGVkXCI6IGFzeW5jIChjaGVja3BvaW50KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNmb3JtT3V0cHV0KHsgZXJyb3I6IGNoZWNrcG9pbnQuZXJyb3IgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXZSd2ZSBmb3VuZCBvbmUgb3IgbW9yZSBzdGVwcy4gSGVyZSB3ZSBtYXkgd2FudCB0byBydW4gYSBzdGVwIG9yIHJlcG9ydFxuICAgICAgICAgICAgICogdGhlbSBiYWNrIHRvIElubmdlc3QuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwic3RlcHMtZm91bmRcIjogYXN5bmMgKHsgc3RlcHMgfSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0ZXBSZXN1bHQgPSBhd2FpdCB0aGlzLnRyeUV4ZWN1dGVTdGVwKHN0ZXBzKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RlcFJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1SZXN1bHQgPSBhd2FpdCB0aGlzLnRyYW5zZm9ybU91dHB1dChzdGVwUmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIFRyYW5zZm9ybWluZyBvdXRwdXQgd2lsbCBhbHdheXMgcmV0dXJuIGVpdGhlciBmdW5jdGlvbiByZWplY3Rpb24gb3JcbiAgICAgICAgICAgICAgICAgICAgICogcmVzb2x1dGlvbi4gSW4gbW9zdCBjYXNlcywgdGhpcyBjYW4gYmUgaW1tZWRpYXRlbHkgcmV0dXJuZWQsIGJ1dCBpblxuICAgICAgICAgICAgICAgICAgICAgKiB0aGlzIHBhcnRpY3VsYXIgY2FzZSB3ZSB3YW50IHRvIGhhbmRsZSBpdCBkaWZmZXJlbnRseS5cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmFuc2Zvcm1SZXN1bHQudHlwZSA9PT0gXCJmdW5jdGlvbi1yZXNvbHZlZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RlcC1yYW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHg6IHRyYW5zZm9ybVJlc3VsdC5jdHgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BzOiB0cmFuc2Zvcm1SZXN1bHQub3BzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXA6IGV4cG9ydHMuX2ludGVybmFscy5oYXNoT3AoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdGVwUmVzdWx0KSwgeyBkYXRhOiB0cmFuc2Zvcm1SZXN1bHQuZGF0YSB9KSksXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRyYW5zZm9ybVJlc3VsdC50eXBlID09PSBcImZ1bmN0aW9uLXJlamVjdGVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdGVwLXJhblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eDogdHJhbnNmb3JtUmVzdWx0LmN0eCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHM6IHRyYW5zZm9ybVJlc3VsdC5vcHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RlcDogZXhwb3J0cy5faW50ZXJuYWxzLmhhc2hPcChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0ZXBSZXN1bHQpLCB7IGVycm9yOiB0cmFuc2Zvcm1SZXN1bHQuZXJyb3IgfSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHJpYWJsZTogdHJhbnNmb3JtUmVzdWx0LnJldHJpYWJsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybVJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3U3RlcHMgPSBhd2FpdCB0aGlzLmZpbHRlck5ld1N0ZXBzKEFycmF5LmZyb20odGhpcy5zdGF0ZS5zdGVwcy52YWx1ZXMoKSkpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdTdGVwcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdGVwcy1mb3VuZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4OiB0aGlzLmZuQXJnLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3BzOiB0aGlzLm9wcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXBzOiBuZXdTdGVwcyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXaGlsZSB0cnlpbmcgdG8gZmluZCBhIHN0ZXAgdGhhdCBJbm5nZXN0IGhhcyB0b2xkIHVzIHRvIHJ1biwgd2UndmVcbiAgICAgICAgICAgICAqIHRpbWVkIG91dCBvciBoYXZlIG90aGVyd2lzZSBkZWNpZGVkIHRoYXQgaXQgZG9lc24ndCBleGlzdC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJzdGVwLW5vdC1mb3VuZFwiOiAoeyBzdGVwIH0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcInN0ZXAtbm90LWZvdW5kXCIsIGN0eDogdGhpcy5mbkFyZywgb3BzOiB0aGlzLm9wcywgc3RlcCB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0Q2hlY2twb2ludEhhbmRsZXIodHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGVja3BvaW50SGFuZGxlcnNbdHlwZV07XG4gICAgfVxuICAgIGFzeW5jIHRyeUV4ZWN1dGVTdGVwKHN0ZXBzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgaGFzaGVkU3RlcElkVG9SdW4gPSB0aGlzLm9wdGlvbnMucmVxdWVzdGVkUnVuU3RlcCB8fCB0aGlzLmdldEVhcmx5RXhlY1J1blN0ZXAoc3RlcHMpO1xuICAgICAgICBpZiAoIWhhc2hlZFN0ZXBJZFRvUnVuKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RlcCA9IHN0ZXBzLmZpbmQoKHN0ZXApID0+IHN0ZXAuaGFzaGVkSWQgPT09IGhhc2hlZFN0ZXBJZFRvUnVuICYmIHN0ZXAuZm4pO1xuICAgICAgICBpZiAoc3RlcCkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZXhlY3V0ZVN0ZXAoc3RlcCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuc3VyZSB3ZSByZXNldCB0aGUgdGltZW91dCBpZiB3ZSBoYXZlIGEgcmVxdWVzdGVkIHJ1biBzdGVwIGJ1dCBjb3VsZG4ndFxuICAgICAgICAgKiBmaW5kIGl0LCBidXQgYWxzbyB0aGF0IHdlIGRvbid0IHJlc2V0IGlmIHdlIGZvdW5kIGFuZCBleGVjdXRlZCBpdC5cbiAgICAgICAgICovXG4gICAgICAgIHZvaWQgKChfYSA9IHRoaXMudGltZW91dCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlc2V0KCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIGxpc3Qgb2Ygb3V0Z29pbmcgb3BzLCBkZWNpZGUgaWYgd2UgY2FuIGV4ZWN1dGUgYW4gb3AgZWFybHkgYW5kXG4gICAgICogcmV0dXJuIHRoZSBJRCBvZiB0aGUgc3RlcCB0byBleGVjdXRlIGlmIHdlIGNhbi5cbiAgICAgKi9cbiAgICBnZXRFYXJseUV4ZWNSdW5TdGVwKHN0ZXBzKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXZSBtYXkgaGF2ZSBiZWVuIGRpc2FibGVkIGR1ZSB0byBwYXJhbGxlbGlzbSwgaW4gd2hpY2ggY2FzZSB3ZSBjYW4ndFxuICAgICAgICAgKiBpbW1lZGlhdGVseSBleGVjdXRlIHVubGVzcyBleHBsaWNpdGx5IHJlcXVlc3RlZC5cbiAgICAgICAgICovXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGlzYWJsZUltbWVkaWF0ZUV4ZWN1dGlvbilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgdW5mdWxmaWxsZWRTdGVwcyA9IHN0ZXBzLmZpbHRlcigoc3RlcCkgPT4gIXN0ZXAuZnVsZmlsbGVkKTtcbiAgICAgICAgaWYgKHVuZnVsZmlsbGVkU3RlcHMubGVuZ3RoICE9PSAxKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBvcCA9IHVuZnVsZmlsbGVkU3RlcHNbMF07XG4gICAgICAgIGlmIChvcCAmJlxuICAgICAgICAgICAgb3Aub3AgPT09IHR5cGVzX2pzXzEuU3RlcE9wQ29kZS5TdGVwUGxhbm5lZFxuICAgICAgICAvLyBUT0RPIFdlIG11c3QgaW5kaXZpZHVhbGx5IGNoZWNrIHByb3BlcnRpZXMgaGVyZSB0aGF0IHdlIGRvIG5vdCB3YW50IHRvXG4gICAgICAgIC8vIGV4ZWN1dGUgb24sIHN1Y2ggYXMgcmV0cnkgY291bnRzLiBOb3RoaW5nIGV4aXN0cyBoZXJlIHRoYXQgZmFsbHMgaW4gdG9cbiAgICAgICAgLy8gdGhpcyBjYXNlLCBidXQgc2hvdWxkIGJlIGFjY291bnRlZCBmb3Igd2hlbiB3ZSBhZGQgdGhlbS5cbiAgICAgICAgLy8gJiYgdHlwZW9mIG9wLm9wdHMgPT09IFwidW5kZWZpbmVkXCJcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gb3AuaGFzaGVkSWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZmlsdGVyTmV3U3RlcHMoZm91bmRTdGVwcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZXF1ZXN0ZWRSdW5TdGVwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdhdGhlciBhbnkgc3RlcHMgdGhhdCBhcmVuJ3QgbWVtb2l6ZWQgYW5kIHJlcG9ydCB0aGVtLlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgbmV3U3RlcHMgPSBmb3VuZFN0ZXBzLmZpbHRlcigoc3RlcCkgPT4gIXN0ZXAuZnVsZmlsbGVkKTtcbiAgICAgICAgaWYgKCFuZXdTdGVwcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogV2FybiBpZiB3ZSd2ZSBmb3VuZCBuZXcgc3RlcHMgYnV0IGhhdmVuJ3QgeWV0IHNlZW4gYWxsIHByZXZpb3VzXG4gICAgICAgICAqIHN0ZXBzLiBUaGlzIG1heSBpbmRpY2F0ZSB0aGF0IHN0ZXAgcHJlc2VuY2UgaXNuJ3QgZGV0ZXJtaW5hdGUuXG4gICAgICAgICAqL1xuICAgICAgICBsZXQga25vd25TdGVwcyA9IDA7XG4gICAgICAgIGZvciAoY29uc3Qgc3RlcCBvZiBmb3VuZFN0ZXBzKSB7XG4gICAgICAgICAgICBpZiAoc3RlcC5mdWxmaWxsZWQpIHtcbiAgICAgICAgICAgICAgICBrbm93blN0ZXBzKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZm91bmRBbGxDb21wbGV0ZWRTdGVwcyA9IHRoaXMuc3RhdGUuc3RlcHNUb0Z1bGZpbGwgPT09IGtub3duU3RlcHM7XG4gICAgICAgIGlmICghZm91bmRBbGxDb21wbGV0ZWRTdGVwcykge1xuICAgICAgICAgICAgLy8gVE9ETyBUYWdcbiAgICAgICAgICAgIGNvbnNvbGUud2FybigoMCwgZXJyb3JzX2pzXzEucHJldHR5RXJyb3IpKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIndhcm5cIixcbiAgICAgICAgICAgICAgICB3aGF0SGFwcGVuZWQ6IFwiRnVuY3Rpb24gbWF5IGJlIGluZGV0ZXJtaW5hdGVcIixcbiAgICAgICAgICAgICAgICB3aHk6IFwiV2UgZm91bmQgbmV3IHN0ZXBzIGJlZm9yZSBzZWVpbmcgYWxsIHByZXZpb3VzIHN0ZXBzLCB3aGljaCBtYXkgaW5kaWNhdGUgdGhhdCB0aGUgZnVuY3Rpb24gaXMgbm9uLWRldGVybWluaXN0aWMuXCIsXG4gICAgICAgICAgICAgICAgY29uc2VxdWVuY2VzOiBcIlRoaXMgbWF5IGNhdXNlIHVuZXhwZWN0ZWQgYmVoYXZpb3VyIGFzIElubmdlc3QgZXhlY3V0ZXMgeW91ciBmdW5jdGlvbi5cIixcbiAgICAgICAgICAgICAgICByZWFzc3VyYW5jZTogXCJUaGlzIGlzIGV4cGVjdGVkIGlmIGEgZnVuY3Rpb24gaXMgdXBkYXRlZCBpbiB0aGUgbWlkZGxlIG9mIGEgcnVuLCBidXQgbWF5IGluZGljYXRlIGEgYnVnIGlmIG5vdC5cIixcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogV2UncmUgZmluaXNoaW5nIHVwOyBsZXQncyB0cmlnZ2VyIHRoZSBsYXN0IG9mIHRoZSBob29rcy5cbiAgICAgICAgICovXG4gICAgICAgIGF3YWl0ICgoX2IgPSAoX2EgPSB0aGlzLnN0YXRlLmhvb2tzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWZ0ZXJNZW1vaXphdGlvbikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpKTtcbiAgICAgICAgYXdhaXQgKChfZCA9IChfYyA9IHRoaXMuc3RhdGUuaG9va3MpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5iZWZvcmVFeGVjdXRpb24pID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jYWxsKF9jKSk7XG4gICAgICAgIGF3YWl0ICgoX2YgPSAoX2UgPSB0aGlzLnN0YXRlLmhvb2tzKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UuYWZ0ZXJFeGVjdXRpb24pID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5jYWxsKF9lKSk7XG4gICAgICAgIGNvbnN0IHN0ZXBMaXN0ID0gbmV3U3RlcHMubWFwKChzdGVwKSA9PiAoe1xuICAgICAgICAgICAgZGlzcGxheU5hbWU6IHN0ZXAuZGlzcGxheU5hbWUsXG4gICAgICAgICAgICBvcDogc3RlcC5vcCxcbiAgICAgICAgICAgIGlkOiBzdGVwLmhhc2hlZElkLFxuICAgICAgICAgICAgbmFtZTogc3RlcC5uYW1lLFxuICAgICAgICAgICAgb3B0czogc3RlcC5vcHRzLFxuICAgICAgICB9KSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXZSBhbHNvIHJ1biBgb25TZW5kRXZlbnRgIG1pZGRsZXdhcmUgaG9va3MgYWdhaW5zdCBgc3RlcC5pbnZva2UoKWAgc3RlcHNcbiAgICAgICAgICogdG8gZW5zdXJlIHRoYXQgdGhlaXIgYGRhdGFgIGlzIHRyYW5zZm9ybWVkIGNvcnJlY3RseS5cbiAgICAgICAgICovXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zZm9ybU5ld1N0ZXBzKHN0ZXBMaXN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNpbmcgbWlkZGxld2FyZSwgdHJhbnNmb3JtIGFueSBuZXdseS1mb3VuZCBzdGVwcyBiZWZvcmUgcmV0dXJuaW5nIHRoZW0gdG9cbiAgICAgKiBhbiBJbm5nZXN0IFNlcnZlci5cbiAgICAgKi9cbiAgICBhc3luYyB0cmFuc2Zvcm1OZXdTdGVwcyhzdGVwcykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoc3RlcHMubWFwKGFzeW5jIChzdGVwKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2c7XG4gICAgICAgICAgICBpZiAoc3RlcC5vcCAhPT0gdHlwZXNfanNfMS5TdGVwT3BDb2RlLkludm9rZUZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvblNlbmRFdmVudEhvb2tzID0gYXdhaXQgKDAsIElubmdlc3RNaWRkbGV3YXJlX2pzXzEuZ2V0SG9va1N0YWNrKSh0aGlzLm9wdGlvbnMuZm5bXCJtaWRkbGV3YXJlXCJdLCBcIm9uU2VuZEV2ZW50XCIsIHVuZGVmaW5lZCwge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybUlucHV0OiAocHJldiwgb3V0cHV0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHByZXYpLCBvdXRwdXQpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtT3V0cHV0OiAocHJldiwgb3V0cHV0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJldi5yZXN1bHQpLCBvdXRwdXQgPT09IG51bGwgfHwgb3V0cHV0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvdXRwdXQucmVzdWx0KSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEZvciBlYWNoIGV2ZW50IGJlaW5nIHNlbnQsIGNyZWF0ZSBhIG5ldyBgb25TZW5kRXZlbnRgIGhvb2sgc3RhY2sgdG9cbiAgICAgICAgICAgICAqIHByb2Nlc3MgaXQuIFdlIGRvIHRoaXMgYXMgbWlkZGxld2FyZSBob29rcyBhcmUgaW50ZW5kZWQgdG8gcnVuIG9uY2VcbiAgICAgICAgICAgICAqIGR1cmluZyBlYWNoIGxpZmVjeWNsZSAob25GdW5jdGlvblJ1biBvciBvblNlbmRFdmVudCkgYW5kIGhlcmUsIGEgaG9va1xuICAgICAgICAgICAgICogaXMgcnVuIGZvciBldmVyeSBzaW5nbGUgZXZlbnQuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogVGhpcyBpcyBkb25lIGJlY2F1c2UgYSBkZXZlbG9wZXIgY2FuIHVzZSB0aGlzIGhvb2sgdG8gZmlsdGVyIG91dFxuICAgICAgICAgICAgICogZXZlbnRzIGVudGlyZWx5OyBpZiB3ZSBiYXRjaCBhbGwgb2YgdGhlIGV2ZW50cyB0b2dldGhlciwgd2UgY2FuJ3RcbiAgICAgICAgICAgICAqIHRlbGwgd2hpY2ggb25lcyB3ZXJlIGZpbHRlcmVkIG91dCBpZiB3ZSdyZSBwcm9jZXNzaW5nID4xIGludm9jYXRpb25cbiAgICAgICAgICAgICAqIGhlcmUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkUGF5bG9hZCA9IGF3YWl0ICgoX2EgPSBvblNlbmRFdmVudEhvb2tzLnRyYW5zZm9ybUlucHV0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChvblNlbmRFdmVudEhvb2tzLCB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZHM6IFtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAoKF9jID0gKF9iID0gc3RlcC5vcHRzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucGF5bG9hZCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDoge30pKSwgeyBuYW1lOiBjb25zdHNfanNfMS5pbnRlcm5hbEV2ZW50cy5GdW5jdGlvbkludm9rZWQgfSksXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1BheWxvYWQgPSBJbm5nZXN0U3RlcFRvb2xzX2pzXzEuaW52b2tlUGF5bG9hZFNjaGVtYS5wYXJzZSgoX2UgPSAoX2QgPSB0cmFuc2Zvcm1lZFBheWxvYWQgPT09IG51bGwgfHwgdHJhbnNmb3JtZWRQYXlsb2FkID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0cmFuc2Zvcm1lZFBheWxvYWQucGF5bG9hZHMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZFswXSkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDoge30pO1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RlcCksIHsgb3B0czogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdGVwLm9wdHMpLCB7IHBheWxvYWQ6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKChfZyA9IChfZiA9IHN0ZXAub3B0cykgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLnBheWxvYWQpICE9PSBudWxsICYmIF9nICE9PSB2b2lkIDAgPyBfZyA6IHt9KSksIG5ld1BheWxvYWQpIH0pIH0pO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGFzeW5jIGV4ZWN1dGVTdGVwKHsgaWQsIG5hbWUsIG9wdHMsIGZuLCBkaXNwbGF5TmFtZSwgfSkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgICAgICAoX2EgPSB0aGlzLnRpbWVvdXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbGVhcigpO1xuICAgICAgICBhd2FpdCAoKF9jID0gKF9iID0gdGhpcy5zdGF0ZS5ob29rcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFmdGVyTWVtb2l6YXRpb24pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYWxsKF9iKSk7XG4gICAgICAgIGF3YWl0ICgoX2UgPSAoX2QgPSB0aGlzLnN0YXRlLmhvb2tzKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYmVmb3JlRXhlY3V0aW9uKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UuY2FsbChfZCkpO1xuICAgICAgICBjb25zdCBvdXRnb2luZ09wID0ge1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBvcDogdHlwZXNfanNfMS5TdGVwT3BDb2RlLlN0ZXBSdW4sXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgb3B0cyxcbiAgICAgICAgICAgIGRpc3BsYXlOYW1lLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnN0YXRlLmV4ZWN1dGluZ1N0ZXAgPSBvdXRnb2luZ09wO1xuICAgICAgICBjb25zdCBzdG9yZSA9IGF3YWl0ICgwLCBhbHNfanNfMS5nZXRBc3luY0N0eCkoKTtcbiAgICAgICAgaWYgKHN0b3JlKSB7XG4gICAgICAgICAgICBzdG9yZS5leGVjdXRpbmdTdGVwID0ge1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIG5hbWU6IGRpc3BsYXlOYW1lLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlYnVnKGBleGVjdXRpbmcgc3RlcCBcIiR7aWR9XCJgKTtcbiAgICAgICAgcmV0dXJuICgoMCwgcHJvbWlzZXNfanNfMS5ydW5Bc1Byb21pc2UpKGZuKVxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1taXN1c2VkLXByb21pc2VzXG4gICAgICAgICAgICAuZmluYWxseShhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgaWYgKHN0b3JlKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHN0b3JlLmV4ZWN1dGluZ1N0ZXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCAoKF9iID0gKF9hID0gdGhpcy5zdGF0ZS5ob29rcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFmdGVyRXhlY3V0aW9uKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSkpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG91dGdvaW5nT3ApLCB7IGRhdGEgfSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvdXRnb2luZ09wKSwgeyBvcDogdHlwZXNfanNfMS5TdGVwT3BDb2RlLlN0ZXBFcnJvciwgXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgICAgICAgICAgICAgIGVycm9yIH0pO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0cyBleGVjdXRpb24gb2YgdGhlIHVzZXIncyBmdW5jdGlvbiwgaW5jbHVkaW5nIHRyaWdnZXJpbmcgY2hlY2twb2ludHNcbiAgICAgKiBhbmQgbWlkZGxld2FyZSBob29rcyB3aGVyZSBhcHByb3ByaWF0ZS5cbiAgICAgKi9cbiAgICBhc3luYyBzdGFydEV4ZWN1dGlvbigpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nO1xuICAgICAgICAvKipcbiAgICAgICAgICogTXV0YXRlIGlucHV0IGFzIG5lY2Nlc3NhcnkgYmFzZWQgb24gbWlkZGxld2FyZS5cbiAgICAgICAgICovXG4gICAgICAgIGF3YWl0IHRoaXMudHJhbnNmb3JtSW5wdXQoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0YXJ0IHRoZSB0aW1lciB0byB0aW1lIG91dCB0aGUgcnVuIGlmIG5lZWRlZC5cbiAgICAgICAgICovXG4gICAgICAgIHZvaWQgKChfYSA9IHRoaXMudGltZW91dCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0YXJ0KCkpO1xuICAgICAgICBhd2FpdCAoKF9jID0gKF9iID0gdGhpcy5zdGF0ZS5ob29rcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmJlZm9yZU1lbW9pemF0aW9uKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY2FsbChfYikpO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgd2UgaGFkIG5vIHN0YXRlIHRvIGJlZ2luIHdpdGgsIGltbWVkaWF0ZWx5IGVuZCB0aGUgbWVtb2l6YXRpb24gcGhhc2UuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5hbGxTdGF0ZVVzZWQoKSkge1xuICAgICAgICAgICAgYXdhaXQgKChfZSA9IChfZCA9IHRoaXMuc3RhdGUuaG9va3MpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hZnRlck1lbW9pemF0aW9uKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UuY2FsbChfZCkpO1xuICAgICAgICAgICAgYXdhaXQgKChfZyA9IChfZiA9IHRoaXMuc3RhdGUuaG9va3MpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5iZWZvcmVFeGVjdXRpb24pID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy5jYWxsKF9mKSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyaWdnZXIgdGhlIHVzZXIncyBmdW5jdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgICgwLCBwcm9taXNlc19qc18xLnJ1bkFzUHJvbWlzZSkoKCkgPT4gdGhpcy51c2VyRm5Ub1J1bih0aGlzLmZuQXJnKSlcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbWlzdXNlZC1wcm9taXNlc1xuICAgICAgICAgICAgLmZpbmFsbHkoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICAgICAgICBhd2FpdCAoKF9iID0gKF9hID0gdGhpcy5zdGF0ZS5ob29rcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFmdGVyTWVtb2l6YXRpb24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKSk7XG4gICAgICAgICAgICBhd2FpdCAoKF9kID0gKF9jID0gdGhpcy5zdGF0ZS5ob29rcykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmJlZm9yZUV4ZWN1dGlvbikgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmNhbGwoX2MpKTtcbiAgICAgICAgICAgIGF3YWl0ICgoX2YgPSAoX2UgPSB0aGlzLnN0YXRlLmhvb2tzKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UuYWZ0ZXJFeGVjdXRpb24pID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5jYWxsKF9lKSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZXRDaGVja3BvaW50KHsgdHlwZTogXCJmdW5jdGlvbi1yZXNvbHZlZFwiLCBkYXRhIH0pO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZXRDaGVja3BvaW50KHsgdHlwZTogXCJmdW5jdGlvbi1yZWplY3RlZFwiLCBlcnJvciB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzaW5nIG1pZGRsZXdhcmUsIHRyYW5zZm9ybSBpbnB1dCBiZWZvcmUgcnVubmluZy5cbiAgICAgKi9cbiAgICBhc3luYyB0cmFuc2Zvcm1JbnB1dCgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgaW5wdXRNdXRhdGlvbnMgPSBhd2FpdCAoKF9iID0gKF9hID0gdGhpcy5zdGF0ZS5ob29rcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRyYW5zZm9ybUlucHV0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwge1xuICAgICAgICAgICAgY3R4OiBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmZuQXJnKSxcbiAgICAgICAgICAgIHN0ZXBzOiBPYmplY3QudmFsdWVzKHRoaXMuc3RhdGUuc3RlcFN0YXRlKSxcbiAgICAgICAgICAgIGZuOiB0aGlzLm9wdGlvbnMuZm4sXG4gICAgICAgICAgICByZXFBcmdzOiB0aGlzLm9wdGlvbnMucmVxQXJncyxcbiAgICAgICAgfSkpO1xuICAgICAgICBpZiAoaW5wdXRNdXRhdGlvbnMgPT09IG51bGwgfHwgaW5wdXRNdXRhdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGlucHV0TXV0YXRpb25zLmN0eCkge1xuICAgICAgICAgICAgdGhpcy5mbkFyZyA9IGlucHV0TXV0YXRpb25zLmN0eDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5wdXRNdXRhdGlvbnMgPT09IG51bGwgfHwgaW5wdXRNdXRhdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGlucHV0TXV0YXRpb25zLnN0ZXBzKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLnN0ZXBTdGF0ZSA9IE9iamVjdC5mcm9tRW50cmllcyhpbnB1dE11dGF0aW9ucy5zdGVwcy5tYXAoKHN0ZXApID0+IFtzdGVwLmlkLCBzdGVwXSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzaW5nIG1pZGRsZXdhcmUsIHRyYW5zZm9ybSBvdXRwdXQgYmVmb3JlIHJldHVybmluZy5cbiAgICAgKi9cbiAgICBhc3luYyB0cmFuc2Zvcm1PdXRwdXQoZGF0YU9yRXJyb3IpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBPYmplY3QuYXNzaWduKHt9LCBkYXRhT3JFcnJvcik7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB3ZSd2ZSBiZWVuIGdpdmVuIGFuIGVycm9yIGFuZCBpdCdzIG9uZSB0aGF0IHdlIGp1c3QgdGhyZXcgZnJvbSBhIHN0ZXAsXG4gICAgICAgICAqIHdlIHNob3VsZCByZXR1cm4gYSBgTm9uUmV0cmlhYmxlRXJyb3JgIHRvIHN0b3AgZXhlY3V0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHR5cGVvZiBvdXRwdXQuZXJyb3IgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIG91dHB1dC5kYXRhID0gKDAsIGVycm9yc19qc18xLnNlcmlhbGl6ZUVycm9yKShvdXRwdXQuZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzU3RlcEV4ZWN1dGlvbiA9IEJvb2xlYW4odGhpcy5zdGF0ZS5leGVjdXRpbmdTdGVwKTtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtZWRPdXRwdXQgPSBhd2FpdCAoKF9iID0gKF9hID0gdGhpcy5zdGF0ZS5ob29rcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRyYW5zZm9ybU91dHB1dCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIHtcbiAgICAgICAgICAgIHJlc3VsdDogT2JqZWN0LmFzc2lnbih7fSwgb3V0cHV0KSxcbiAgICAgICAgICAgIHN0ZXA6IHRoaXMuc3RhdGUuZXhlY3V0aW5nU3RlcCxcbiAgICAgICAgfSkpO1xuICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG91dHB1dCksIHRyYW5zZm9ybWVkT3V0cHV0ID09PSBudWxsIHx8IHRyYW5zZm9ybWVkT3V0cHV0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0cmFuc2Zvcm1lZE91dHB1dC5yZXN1bHQpO1xuICAgICAgICBpZiAoIWlzU3RlcEV4ZWN1dGlvbikge1xuICAgICAgICAgICAgYXdhaXQgKChfZCA9IChfYyA9IHRoaXMuc3RhdGUuaG9va3MpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5maW5pc2hlZCkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmNhbGwoX2MsIHtcbiAgICAgICAgICAgICAgICByZXN1bHQ6IE9iamVjdC5hc3NpZ24oe30sICh0eXBlb2YgZXJyb3IgIT09IFwidW5kZWZpbmVkXCIgPyB7IGVycm9yIH0gOiB7IGRhdGEgfSkpLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZXJyb3IgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRW5zdXJlIHdlIGdpdmUgbWlkZGxld2FyZSB0aGUgY2hhbmNlIHRvIGRlY2lkZSBvbiByZXRyaWFibGUgYmVoYXZpb3VyXG4gICAgICAgICAgICAgKiBieSBsb29raW5nIGF0IHRoZSBlcnJvciByZXR1cm5lZCBmcm9tIG91dHB1dCB0cmFuc2Zvcm1hdGlvbi5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgbGV0IHJldHJpYWJsZSA9ICEoZXJyb3IgaW5zdGFuY2VvZiBOb25SZXRyaWFibGVFcnJvcl9qc18xLk5vblJldHJpYWJsZUVycm9yIHx8IGVycm9yIGluc3RhbmNlb2YgU3RlcEVycm9yX2pzXzEuU3RlcEVycm9yKTtcbiAgICAgICAgICAgIGlmIChyZXRyaWFibGUgJiYgZXJyb3IgaW5zdGFuY2VvZiBSZXRyeUFmdGVyRXJyb3JfanNfMS5SZXRyeUFmdGVyRXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXRyaWFibGUgPSBlcnJvci5yZXRyeUFmdGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2VyaWFsaXplZEVycm9yID0gKDAsIGVycm9yc19qc18xLm1pbmlmeVByZXR0eUVycm9yKSgoMCwgZXJyb3JzX2pzXzEuc2VyaWFsaXplRXJyb3IpKGVycm9yKSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb24tcmVqZWN0ZWRcIixcbiAgICAgICAgICAgICAgICBjdHg6IHRoaXMuZm5BcmcsXG4gICAgICAgICAgICAgICAgb3BzOiB0aGlzLm9wcyxcbiAgICAgICAgICAgICAgICBlcnJvcjogc2VyaWFsaXplZEVycm9yLFxuICAgICAgICAgICAgICAgIHJldHJpYWJsZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb24tcmVzb2x2ZWRcIixcbiAgICAgICAgICAgIGN0eDogdGhpcy5mbkFyZyxcbiAgICAgICAgICAgIG9wczogdGhpcy5vcHMsXG4gICAgICAgICAgICBkYXRhOiAoMCwgZnVuY3Rpb25zX2pzXzEudW5kZWZpbmVkVG9OdWxsKShkYXRhKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY3JlYXRlRXhlY3V0aW9uU3RhdGUoKSB7XG4gICAgICAgIGNvbnN0IGQgPSAoMCwgcHJvbWlzZXNfanNfMS5jcmVhdGVEZWZlcnJlZFByb21pc2VXaXRoU3RhY2spKCk7XG4gICAgICAgIGxldCBjaGVja3BvaW50UmVzb2x2ZSA9IGQuZGVmZXJyZWQucmVzb2x2ZTtcbiAgICAgICAgY29uc3QgY2hlY2twb2ludFJlc3VsdHMgPSBkLnJlc3VsdHM7XG4gICAgICAgIGNvbnN0IGxvb3AgPSAoZnVuY3Rpb24gKGNsZWFuVXApIHtcbiAgICAgICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzID0gKHlpZWxkIF9fYXdhaXQoY2hlY2twb2ludFJlc3VsdHMubmV4dCgpKSkudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdChyZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhblVwID09PSBudWxsIHx8IGNsZWFuVXAgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNsZWFuVXAoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkoKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgKF9hID0gdGhpcy50aW1lb3V0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xlYXIoKTtcbiAgICAgICAgICAgIHZvaWQgY2hlY2twb2ludFJlc3VsdHMucmV0dXJuKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBzdGVwc1RvRnVsZmlsbCA9IE9iamVjdC5rZXlzKHRoaXMub3B0aW9ucy5zdGVwU3RhdGUpLmxlbmd0aDtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB7XG4gICAgICAgICAgICBzdGVwU3RhdGU6IHRoaXMub3B0aW9ucy5zdGVwU3RhdGUsXG4gICAgICAgICAgICBzdGVwc1RvRnVsZmlsbCxcbiAgICAgICAgICAgIHN0ZXBzOiBuZXcgTWFwKCksXG4gICAgICAgICAgICBsb29wLFxuICAgICAgICAgICAgaGFzU3RlcHM6IEJvb2xlYW4oc3RlcHNUb0Z1bGZpbGwpLFxuICAgICAgICAgICAgc3RlcENvbXBsZXRpb25PcmRlcjogWy4uLnRoaXMub3B0aW9ucy5zdGVwQ29tcGxldGlvbk9yZGVyXSxcbiAgICAgICAgICAgIHJlbWFpbmluZ1N0ZXBzVG9CZVNlZW46IG5ldyBTZXQodGhpcy5vcHRpb25zLnN0ZXBDb21wbGV0aW9uT3JkZXIpLFxuICAgICAgICAgICAgc2V0Q2hlY2twb2ludDogKGNoZWNrcG9pbnQpID0+IHtcbiAgICAgICAgICAgICAgICAoeyByZXNvbHZlOiBjaGVja3BvaW50UmVzb2x2ZSB9ID0gY2hlY2twb2ludFJlc29sdmUoY2hlY2twb2ludCkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFsbFN0YXRlVXNlZDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXRlLnJlbWFpbmluZ1N0ZXBzVG9CZVNlZW4uc2l6ZSA9PT0gMDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gICAgZ2V0IG9wcygpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyh0aGlzLnN0YXRlLnN0ZXBzKTtcbiAgICB9XG4gICAgY3JlYXRlRm5BcmcoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgY29uc3Qgc3RlcCA9IHRoaXMuY3JlYXRlU3RlcFRvb2xzKCk7XG4gICAgICAgIGxldCBmbkFyZyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRpb25zLmRhdGEpLCB7IHN0ZXAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIYW5kbGUgdXNlIG9mIHRoZSBgb25GYWlsdXJlYCBvcHRpb24gYnkgZGVzZXJpYWxpemluZyB0aGUgZXJyb3IuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmlzRmFpbHVyZUhhbmRsZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50RGF0YSA9IHpvZF8xLnpcbiAgICAgICAgICAgICAgICAub2JqZWN0KHsgZXJyb3I6IHR5cGVzX2pzXzEuanNvbkVycm9yU2NoZW1hIH0pXG4gICAgICAgICAgICAgICAgLnBhcnNlKChfYSA9IGZuQXJnLmV2ZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGF0YSk7XG4gICAgICAgICAgICBmbkFyZyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZm5BcmcpLCB7IGVycm9yOiAoMCwgZXJyb3JzX2pzXzEuZGVzZXJpYWxpemVFcnJvcikoZXZlbnREYXRhLmVycm9yKSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKF9kID0gKF9jID0gKF9iID0gdGhpcy5vcHRpb25zKS50cmFuc2Zvcm1DdHgpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYWxsKF9iLCBmbkFyZykpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IGZuQXJnO1xuICAgIH1cbiAgICBjcmVhdGVTdGVwVG9vbHMoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGxpc3Qgb2Ygc3RlcHMgdGhhdCBoYXZlIGJlZW4gZm91bmQgYW5kIGFyZSBiZWluZyByb2xsZWQgdXAgYmVmb3JlIGJlaW5nXG4gICAgICAgICAqIHJlcG9ydGVkIHRvIHRoZSBjb3JlIGxvb3AuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBmb3VuZFN0ZXBzVG9SZXBvcnQgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIG1hcCBvZiB0aGUgc3Vic2V0IG9mIGZvdW5kIHN0ZXBzIHRvIHJlcG9ydCB0aGF0IGhhdmUgbm90IHlldCBiZWVuXG4gICAgICAgICAqIGhhbmRsZWQuIFVzZWQgZm9yIGZhc3QgYWNjZXNzIHRvIHN0ZXBzIHRoYXQgbmVlZCB0byBiZSBoYW5kbGVkIGluIG9yZGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgdW5oYW5kbGVkRm91bmRTdGVwc1RvUmVwb3J0ID0gbmV3IE1hcCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBtYXAgb2YgdGhlIGxhdGVzdCBzZXF1ZW50aWFsIHN0ZXAgaW5kZXhlcyBmb3VuZCBmb3IgZWFjaCBzdGVwIElELiBVc2VkXG4gICAgICAgICAqIHRvIGVuc3VyZSB0aGF0IHdlIGRvbid0IGluZGV4IHN0ZXBzIGluIHBhcmFsbGVsLlxuICAgICAgICAgKlxuICAgICAgICAgKiBOb3RlIHRoYXQgdGhlc2UgbXVzdCBiZSBzZXF1ZW50aWFsOyBpZiB3ZSd2ZSBzZWVuIG9yIGFzc2lnbmVkIGBhOjFgLFxuICAgICAgICAgKiBgYToyYCBhbmQgYGE6NGAsIHRoZSBsYXRlc3Qgc2VxdWVudGlhbCBzdGVwIGluZGV4IGlzIGAyYC5cbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IGV4cGVjdGVkTmV4dFN0ZXBJbmRleGVzID0gbmV3IE1hcCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQW4gb3JkZXJlZCBsaXN0IG9mIHN0ZXAgSURzIHRoYXQgaGF2ZSB5ZXQgdG8gYmUgaGFuZGxlZCBpbiB0aGlzXG4gICAgICAgICAqIGV4ZWN1dGlvbi4gVXNlZCB0byBlbnN1cmUgdGhhdCB3ZSBoYW5kbGUgc3RlcHMgaW4gdGhlIG9yZGVyIHRoZXkgd2VyZVxuICAgICAgICAgKiBmb3VuZCBhbmQgYmFzZWQgb24gdGhlIGBzdGVwQ29tcGxldGlvbk9yZGVyYCBpbiB0aGlzIGV4ZWN1dGlvbidzIHN0YXRlLlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgcmVtYWluaW5nU3RlcENvbXBsZXRpb25PcmRlciA9IHRoaXMuc3RhdGUuc3RlcENvbXBsZXRpb25PcmRlci5zbGljZSgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBwcm9taXNlIHRoYXQncyB1c2VkIHRvIGVuc3VyZSB0aGF0IHN0ZXAgcmVwb3J0aW5nIGNhbm5vdCBiZSBydW4gbW9yZSB0aGFuXG4gICAgICAgICAqIG9uY2UgaW4gYSBnaXZlbiBhc3luY2hyb25vdXMgdGltZSBzcGFuLlxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IGZvdW5kU3RlcHNSZXBvcnRQcm9taXNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBwcm9taXNlIHRoYXQncyB1c2VkIHRvIHJlcHJlc2VudCBtaWRkbGV3YXJlIGhvb2tzIHJ1bm5pbmcgYmVmb3JlXG4gICAgICAgICAqIGV4ZWN1dGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIGxldCBiZWZvcmVFeGVjSG9va3NQcm9taXNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBmbGFnIHVzZWQgdG8gZW5zdXJlIHRoYXQgd2Ugb25seSB3YXJuIGFib3V0IHBhcmFsbGVsIGluZGV4aW5nIG9uY2UgcGVyXG4gICAgICAgICAqIGV4ZWN1dGlvbiB0byBhdm9pZCBzcGFtbWluZyB0aGUgY29uc29sZS5cbiAgICAgICAgICovXG4gICAgICAgIGxldCB3YXJuT2ZQYXJhbGxlbEluZGV4aW5nID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb3VudHMgdGhlIG51bWJlciBvZiB0aW1lcyB3ZSd2ZSBleHRlbmRlZCB0aGlzIHRpY2suXG4gICAgICAgICAqL1xuICAgICAgICBsZXQgdGlja0V4dGVuc2lvbkNvdW50ID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdpdmVuIGEgY29sbGlkaW5nIHN0ZXAgSUQsIG1heWJlIHdhcm4gdGhlIHVzZXIgYWJvdXQgcGFyYWxsZWwgaW5kZXhpbmcuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBtYXliZVdhcm5PZlBhcmFsbGVsSW5kZXhpbmcgPSAoY29sbGlzaW9uSWQpID0+IHtcbiAgICAgICAgICAgIGlmICh3YXJuT2ZQYXJhbGxlbEluZGV4aW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3RlcEV4aXN0cyA9IHRoaXMuc3RhdGUuc3RlcHMuaGFzKGNvbGxpc2lvbklkKTtcbiAgICAgICAgICAgIGlmIChzdGVwRXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RlcEZvdW5kVGhpc1RpY2sgPSBmb3VuZFN0ZXBzVG9SZXBvcnQuaGFzKGNvbGxpc2lvbklkKTtcbiAgICAgICAgICAgICAgICBpZiAoIXN0ZXBGb3VuZFRoaXNUaWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhcm5PZlBhcmFsbGVsSW5kZXhpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oKDAsIGVycm9yc19qc18xLnByZXR0eUVycm9yKSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIndhcm5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoYXRIYXBwZW5lZDogXCJXZSBkZXRlY3RlZCB0aGF0IHlvdSBoYXZlIG11bHRpcGxlIHN0ZXBzIHdpdGggdGhlIHNhbWUgSUQuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBlcnJvcnNfanNfMS5FcnJDb2RlLkFVVE9NQVRJQ19QQVJBTExFTF9JTkRFWElORyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoeTogYFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UncmUgdXNpbmcgdGhlIHNhbWUgSUQgZm9yIG11bHRpcGxlIHN0ZXBzIGFjcm9zcyBkaWZmZXJlbnQgY2hhaW5zIG9mIHBhcmFsbGVsIHdvcmsuIFdlIGZvdW5kIHRoZSBpc3N1ZSB3aXRoIHN0ZXAgXCIke2NvbGxpc2lvbklkfVwiLmAsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWFzc3VyYW5jZTogXCJZb3VyIGZ1bmN0aW9uIGlzIHN0aWxsIHJ1bm5pbmcsIHRob3VnaCBpdCBtYXkgZXhoaWJpdCB1bmV4cGVjdGVkIGJlaGF2aW91ci5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNlcXVlbmNlczogXCJVc2luZyB0aGUgc2FtZSBJRHMgYWNyb3NzIHBhcmFsbGVsIGNoYWlucyBvZiB3b3JrIGNhbiBjYXVzZSB1bmV4cGVjdGVkIGJlaGF2aW91ci5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvRml4Tm93OiBcIldlIHJlY29tbWVuZCB1c2luZyBhIHVuaXF1ZSBJRCBmb3IgZWFjaCBzdGVwLCBlc3BlY2lhbGx5IHRob3NlIGhhcHBlbmluZyBpbiBwYXJhbGxlbC5cIixcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgaGVscGVyIHVzZWQgdG8gcmVwb3J0IHN0ZXBzIHRvIHRoZSBjb3JlIGxvb3AuIFVzZWQgYWZ0ZXIgYWRkaW5nIGFuIGl0ZW1cbiAgICAgICAgICogdG8gYGZvdW5kU3RlcHNUb1JlcG9ydGAuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCByZXBvcnROZXh0VGljayA9ICgpID0+IHtcbiAgICAgICAgICAgIC8vIEJlaW5nIGV4cGxpY2l0IGluc3RlYWQgb2YgdXNpbmcgYD8/PWAgdG8gYXBwZWFzZSBUeXBlU2NyaXB0LlxuICAgICAgICAgICAgaWYgKGZvdW5kU3RlcHNSZXBvcnRQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGV4dGVuc2lvblByb21pc2U7XG4gICAgICAgICAgICBpZiAoKyt0aWNrRXh0ZW5zaW9uQ291bnQgPj0gMTApIHtcbiAgICAgICAgICAgICAgICB0aWNrRXh0ZW5zaW9uQ291bnQgPSAwO1xuICAgICAgICAgICAgICAgIGV4dGVuc2lvblByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBleHRlbnNpb25Qcm9taXNlID0gKDAsIHByb21pc2VzX2pzXzEucmVzb2x2ZUFmdGVyUGVuZGluZykoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvdW5kU3RlcHNSZXBvcnRQcm9taXNlID0gZXh0ZW5zaW9uUHJvbWlzZVxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEVuc3VyZSB0aGF0IHdlIHdhaXQgZm9yIHRoaXMgcHJvbWlzZSB0byByZXNvbHZlIGJlZm9yZSBjb250aW51aW5nLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogVGhlIGdyb3VwcyBpbiB3aGljaCBzdGVwcyBhcmUgcmVwb3J0ZWQgY2FuIGFmZmVjdCBob3cgd2UgZGV0ZWN0IHNvbWVcbiAgICAgICAgICAgICAgICAgKiBtb3JlIGNvbXBsZXggZGV0ZXJtaW5pc20gaXNzdWVzIGxpa2UgcGFyYWxsZWwgaW5kZXhpbmcuIFRoaXMgcHJvbWlzZVxuICAgICAgICAgICAgICAgICAqIGNhbiByZXByZXNlbnQgbWlkZGxld2FyZSBob29rcyBiZWluZyBydW4gZWFybHksIGluIHRoZSBtaWRkbGUgb2ZcbiAgICAgICAgICAgICAgICAgKiBpbmdlc3Rpbmcgc3RlcHMgdG8gcmVwb3J0LlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQmVjYXVzZSBvZiB0aGlzLCBpdCdzIGltcG9ydGFudCB3ZSB3YWl0IGZvciB0aGlzIG1pZGRsZXdhcmUgdG8gcmVzb2x2ZVxuICAgICAgICAgICAgICAgICAqIGJlZm9yZSBjb250aW51aW5nIHRvIHJlcG9ydCBzdGVwcyB0byBlbnN1cmUgdGhhdCBhbGwgc3RlcHMgaGF2ZSBhXG4gICAgICAgICAgICAgICAgICogY2hhbmNlIHRvIGJlIHJlcG9ydGVkIHRocm91Z2hvdXQgdGhpcyBhc3luY2hyb25vdXMgYWN0aW9uLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IGJlZm9yZUV4ZWNIb29rc1Byb21pc2UpXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICBmb3VuZFN0ZXBzUmVwb3J0UHJvbWlzZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlbWFpbmluZ1N0ZXBDb21wbGV0aW9uT3JkZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dFN0ZXBJZCA9IHJlbWFpbmluZ1N0ZXBDb21wbGV0aW9uT3JkZXJbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghbmV4dFN0ZXBJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RyYW5nZSAtIHNraXAgdGhpcyBlbXB0eSBpbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlZCA9IChfYSA9IHVuaGFuZGxlZEZvdW5kU3RlcHNUb1JlcG9ydFxuICAgICAgICAgICAgICAgICAgICAgICAgLmdldChuZXh0U3RlcElkKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhhbmRsZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtYWluaW5nU3RlcENvbXBsZXRpb25PcmRlci5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bmhhbmRsZWRGb3VuZFN0ZXBzVG9SZXBvcnQuZGVsZXRlKG5leHRTdGVwSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZvaWQgcmVwb3J0TmV4dFRpY2soKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSd2ZSBoYW5kbGVkIG5vIHN0ZXBzIGluIHRoaXMgXCJ0aWNrLFwiIHJvbGwgdXAgZXZlcnl0aGluZyB3ZSd2ZVxuICAgICAgICAgICAgICAgIC8vIGZvdW5kIGFuZCByZXBvcnQgaXQuXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RlcHMgPSBbLi4uZm91bmRTdGVwc1RvUmVwb3J0LnZhbHVlcygpXTtcbiAgICAgICAgICAgICAgICBmb3VuZFN0ZXBzVG9SZXBvcnQuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICB1bmhhbmRsZWRGb3VuZFN0ZXBzVG9SZXBvcnQuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdm9pZCB0aGlzLnN0YXRlLnNldENoZWNrcG9pbnQoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN0ZXBzLWZvdW5kXCIsXG4gICAgICAgICAgICAgICAgICAgIHN0ZXBzOiBzdGVwcyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBoZWxwZXIgdXNlZCB0byBwdXNoIGEgc3RlcCB0byB0aGUgbGlzdCBvZiBzdGVwcyB0byByZXBvcnQuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBwdXNoU3RlcFRvUmVwb3J0ID0gKHN0ZXApID0+IHtcbiAgICAgICAgICAgIGZvdW5kU3RlcHNUb1JlcG9ydC5zZXQoc3RlcC5pZCwgc3RlcCk7XG4gICAgICAgICAgICB1bmhhbmRsZWRGb3VuZFN0ZXBzVG9SZXBvcnQuc2V0KHN0ZXAuaGFzaGVkSWQsIHN0ZXApO1xuICAgICAgICAgICAgcmVwb3J0TmV4dFRpY2soKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc3RlcEhhbmRsZXIgPSBhc3luYyAoeyBhcmdzLCBtYXRjaE9wLCBvcHRzLCB9KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgICAgICBhd2FpdCBiZWZvcmVFeGVjSG9va3NQcm9taXNlO1xuICAgICAgICAgICAgY29uc3Qgc3RlcE9wdGlvbnMgPSAoMCwgSW5uZ2VzdFN0ZXBUb29sc19qc18xLmdldFN0ZXBPcHRpb25zKShhcmdzWzBdKTtcbiAgICAgICAgICAgIGNvbnN0IG9wSWQgPSBtYXRjaE9wKHN0ZXBPcHRpb25zLCAuLi5hcmdzLnNsaWNlKDEpKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmV4ZWN1dGluZ1N0ZXApIHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBJZiBhIHN0ZXAgaXMgZm91bmQgYWZ0ZXIgYXN5bmNocm9ub3VzIGFjdGlvbnMgZHVyaW5nIGFub3RoZXIgc3RlcCdzXG4gICAgICAgICAgICAgICAgICogZXhlY3V0aW9uLCBldmVyeXRoaW5nIGlzIGZpbmUuIFRoZSBwcm9ibGVtIGhlcmUgaXMgaWYgd2UndmUgZm91bmRcbiAgICAgICAgICAgICAgICAgKiB0aGF0IGEgc3RlcCBuZXN0ZWQgaW5zaWRlIGFub3RoZXIgYSBzdGVwLCB3aGljaCBpcyBzb21ldGhpbmcgd2UgZG9uJ3RcbiAgICAgICAgICAgICAgICAgKiBzdXBwb3J0IGF0IHRoZSB0aW1lIG9mIHdyaXRpbmcuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBJbiB0aGlzIGNhc2UsIHdlIGNvdWxkIHVzZSBzb21ldGhpbmcgbGlrZSBBc3luYyBIb29rcyB0byB1bmRlcnN0YW5kXG4gICAgICAgICAgICAgICAgICogaG93IHRoZSBzdGVwIGlzIGJlaW5nIHRyaWdnZXJlZCwgdGhvdWdoIHRoaXMgaXNuJ3QgYXZhaWxhYmxlIGluIGFsbFxuICAgICAgICAgICAgICAgICAqIGVudmlyb25tZW50cy5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIFRoZXJlZm9yZSwgd2UnbGwgb25seSBzaG93IGEgd2FybmluZyBoZXJlIHRvIGluZGljYXRlIHRoYXQgdGhpcyBpc1xuICAgICAgICAgICAgICAgICAqIHBvdGVudGlhbGx5IGFuIGlzc3VlLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybigoMCwgZXJyb3JzX2pzXzEucHJldHR5RXJyb3IpKHtcbiAgICAgICAgICAgICAgICAgICAgd2hhdEhhcHBlbmVkOiBgV2UgZGV0ZWN0ZWQgdGhhdCB5b3UgaGF2ZSBuZXN0ZWQgXFxgc3RlcC4qXFxgIHRvb2xpbmcgaW4gXFxgJHsoX2EgPSBvcElkLmRpc3BsYXlOYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBvcElkLmlkfVxcYGAsXG4gICAgICAgICAgICAgICAgICAgIGNvbnNlcXVlbmNlczogXCJOZXN0aW5nIGBzdGVwLipgIHRvb2xpbmcgaXMgbm90IHN1cHBvcnRlZC5cIixcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ3YXJuXCIsXG4gICAgICAgICAgICAgICAgICAgIHJlYXNzdXJhbmNlOiBcIkl0J3MgcG9zc2libGUgdG8gc2VlIHRoaXMgd2FybmluZyBpZiBzdGVwcyBhcmUgc2VwYXJhdGVkIGJ5IHJlZ3VsYXIgYXN5bmNocm9ub3VzIGNhbGxzLCB3aGljaCBpcyBmaW5lLlwiLFxuICAgICAgICAgICAgICAgICAgICBzdGFjazogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdG9GaXhOb3c6IFwiTWFrZSBzdXJlIHlvdSdyZSBub3QgdXNpbmcgYHN0ZXAuKmAgdG9vbGluZyBpbnNpZGUgb2Ygb3RoZXIgYHN0ZXAuKmAgdG9vbGluZy4gSWYgeW91IG5lZWQgdG8gY29tcG9zZSBzdGVwcyB0b2dldGhlciwgeW91IGNhbiBjcmVhdGUgYSBuZXcgYXN5bmMgZnVuY3Rpb24gYW5kIGNhbGwgaXQgZnJvbSB3aXRoaW4geW91ciBzdGVwIGZ1bmN0aW9uLCBvciB1c2UgcHJvbWlzZSBjaGFpbmluZy5cIixcbiAgICAgICAgICAgICAgICAgICAgY29kZTogZXJyb3JzX2pzXzEuRXJyQ29kZS5ORVNUSU5HX1NURVBTLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLnN0ZXBzLmhhcyhvcElkLmlkKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsSWQgPSBvcElkLmlkO1xuICAgICAgICAgICAgICAgIG1heWJlV2Fybk9mUGFyYWxsZWxJbmRleGluZyhvcmlnaW5hbElkKTtcbiAgICAgICAgICAgICAgICBjb25zdCBleHBlY3RlZE5leHRJbmRleCA9IChfYiA9IGV4cGVjdGVkTmV4dFN0ZXBJbmRleGVzLmdldChvcmlnaW5hbElkKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gZXhwZWN0ZWROZXh0SW5kZXg7OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3SWQgPSBvcmlnaW5hbElkICsgSW5uZ2VzdFN0ZXBUb29sc19qc18xLlNURVBfSU5ERVhJTkdfU1VGRklYICsgaTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnN0YXRlLnN0ZXBzLmhhcyhuZXdJZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkTmV4dFN0ZXBJbmRleGVzLnNldChvcmlnaW5hbElkLCBpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcElkLmlkID0gbmV3SWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgcHJvbWlzZSwgcmVzb2x2ZSwgcmVqZWN0IH0gPSAoMCwgcHJvbWlzZXNfanNfMS5jcmVhdGVEZWZlcnJlZFByb21pc2UpKCk7XG4gICAgICAgICAgICBjb25zdCBoYXNoZWRJZCA9IGV4cG9ydHMuX2ludGVybmFscy5oYXNoSWQob3BJZC5pZCk7XG4gICAgICAgICAgICBjb25zdCBzdGVwU3RhdGUgPSB0aGlzLnN0YXRlLnN0ZXBTdGF0ZVtoYXNoZWRJZF07XG4gICAgICAgICAgICBsZXQgaXNGdWxmaWxsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChzdGVwU3RhdGUpIHtcbiAgICAgICAgICAgICAgICBzdGVwU3RhdGUuc2VlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5yZW1haW5pbmdTdGVwc1RvQmVTZWVuLmRlbGV0ZShoYXNoZWRJZCk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzdGVwU3RhdGUuaW5wdXQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNGdWxmaWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBleHRyYU9wdHM7XG4gICAgICAgICAgICBsZXQgZm5BcmdzID0gWy4uLmFyZ3NdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAoc3RlcFN0YXRlID09PSBudWxsIHx8IHN0ZXBTdGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3RlcFN0YXRlLmlucHV0KSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkoc3RlcFN0YXRlLmlucHV0KSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAob3BJZC5vcCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBgc3RlcC5ydW4oKWAgaGFzIGl0cyBmdW5jdGlvbiBpbnB1dCBhZmZlY3RlZFxuICAgICAgICAgICAgICAgICAgICBjYXNlIHR5cGVzX2pzXzEuU3RlcE9wQ29kZS5TdGVwUGxhbm5lZDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgZm5BcmdzID0gWy4uLmFyZ3Muc2xpY2UoMCwgMiksIC4uLnN0ZXBTdGF0ZS5pbnB1dF07XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBleHRyYU9wdHMgPSB7IGlucHV0OiBbLi4uc3RlcFN0YXRlLmlucHV0XSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gYHN0ZXAuYWkuaW5mZXIoKWAgaGFzIGl0cyBib2R5IGFmZmVjdGVkXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgdHlwZXNfanNfMS5TdGVwT3BDb2RlLkFpR2F0ZXdheToge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFPcHRzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKHR5cGVvZiAoKF9jID0gb3BJZC5vcHRzKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuYm9keSkgPT09IFwib2JqZWN0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBPYmplY3QuYXNzaWduKHt9LCBvcElkLm9wdHMuYm9keSkgOiB7fSkpLCBzdGVwU3RhdGUuaW5wdXRbMF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3RlcCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3BJZCksIHsgb3B0czogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcElkLm9wdHMpLCBleHRyYU9wdHMpLCByYXdBcmdzOiBmbkFyZ3MsIC8vIFRPRE8gV2hhdCBpcyB0aGUgcmlnaHQgdmFsdWUgaGVyZT8gU2hvdWxkIHRoaXMgYmUgcmF3IGFyZ3Mgd2l0aG91dCBhZmZlY3RlZCBpbnB1dD9cbiAgICAgICAgICAgICAgICBoYXNoZWRJZCwgaW5wdXQ6IHN0ZXBTdGF0ZSA9PT0gbnVsbCB8fCBzdGVwU3RhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN0ZXBTdGF0ZS5pbnB1dCwgXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnRcbiAgICAgICAgICAgICAgICBmbjogKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5mbikgPyAoKSA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IG9wdHMuZm4pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKG9wdHMsIC4uLmZuQXJncyk7IH0gOiB1bmRlZmluZWQsIHByb21pc2UsIGZ1bGZpbGxlZDogaXNGdWxmaWxsZWQsIGhhc1N0ZXBTdGF0ZTogQm9vbGVhbihzdGVwU3RhdGUpLCBkaXNwbGF5TmFtZTogKF9kID0gb3BJZC5kaXNwbGF5TmFtZSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogb3BJZC5pZCwgaGFuZGxlZDogZmFsc2UsIGhhbmRsZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RlcC5oYW5kbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RlcC5oYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRnVsZmlsbGVkICYmIHN0ZXBTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RlcFN0YXRlLmZ1bGZpbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGb3Igc29tZSBleGVjdXRpb24gc2NlbmFyaW9zIHN1Y2ggYXMgdGVzdGluZywgYGRhdGFgLCBgZXJyb3JgLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIGBpbnB1dGAgbWF5IGJlIGBQcm9taXNlc2AuIFRoaXMgY291bGQgYWxzbyBiZSB0aGUgY2FzZSBmb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZ1dHVyZSBtaWRkbGV3YXJlIGFwcGxpY2F0aW9ucy4gRm9yIHRoaXMgcmVhc29uLCB3ZSdsbCBtYWtlIHN1cmVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSB2YWx1ZXMgYXJlIGZ1bGx5IHJlc29sdmVkIGJlZm9yZSBjb250aW51aW5nLlxuICAgICAgICAgICAgICAgICAgICAgICAgdm9pZCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RlcFN0YXRlLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RlcFN0YXRlLmVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXBTdGF0ZS5pbnB1dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RlcFN0YXRlLmRhdGEgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShzdGVwU3RhdGUuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnJlY2VudGx5UmVqZWN0ZWRTdGVwRXJyb3IgPSBuZXcgU3RlcEVycm9yX2pzXzEuU3RlcEVycm9yKG9wSWQuaWQsIHN0ZXBTdGF0ZS5lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdCh0aGlzLnN0YXRlLnJlY2VudGx5UmVqZWN0ZWRTdGVwRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0gfSk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLnN0ZXBzLnNldChvcElkLmlkLCBzdGVwKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuaGFzU3RlcHMgPSB0cnVlO1xuICAgICAgICAgICAgcHVzaFN0ZXBUb1JlcG9ydChzdGVwKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgdGhpcyBpcyB0aGUgbGFzdCBwaWVjZSBvZiBzdGF0ZSB3ZSBoYWQsIHdlJ3ZlIG5vdyBmaW5pc2hlZFxuICAgICAgICAgICAgICogbWVtb2l6aW5nLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoIWJlZm9yZUV4ZWNIb29rc1Byb21pc2UgJiYgdGhpcy5zdGF0ZS5hbGxTdGF0ZVVzZWQoKSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IChiZWZvcmVFeGVjSG9va3NQcm9taXNlID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCAoKF9iID0gKF9hID0gdGhpcy5zdGF0ZS5ob29rcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFmdGVyTWVtb2l6YXRpb24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKSk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0ICgoX2QgPSAoX2MgPSB0aGlzLnN0YXRlLmhvb2tzKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuYmVmb3JlRXhlY3V0aW9uKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuY2FsbChfYykpO1xuICAgICAgICAgICAgICAgIH0pKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiAoMCwgSW5uZ2VzdFN0ZXBUb29sc19qc18xLmNyZWF0ZVN0ZXBUb29scykodGhpcy5vcHRpb25zLmNsaWVudCwgdGhpcywgc3RlcEhhbmRsZXIpO1xuICAgIH1cbiAgICBnZXRVc2VyRm5Ub1J1bigpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuaXNGYWlsdXJlSGFuZGxlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5mbltcImZuXCJdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmZuW1wib25GYWlsdXJlRm5cIl0pIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU29tZWhvdywgd2UndmUgZW5kZWQgdXAgZGV0ZWN0aW5nIHRoYXQgdGhpcyBpcyBhIGZhaWx1cmUgaGFuZGxlciBidXRcbiAgICAgICAgICAgICAqIGRvZXNuJ3QgaGF2ZSBhbiBgb25GYWlsdXJlYCBmdW5jdGlvbi4gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBmdW5jdGlvbiBgb25GYWlsdXJlYCBoYW5kbGVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZm5bXCJvbkZhaWx1cmVGblwiXTtcbiAgICB9XG4gICAgaW5pdGlhbGl6ZVRpbWVyKHN0YXRlKSB7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLnJlcXVlc3RlZFJ1blN0ZXApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRpbWVvdXQgPSAoMCwgcHJvbWlzZXNfanNfMS5jcmVhdGVUaW1lb3V0UHJvbWlzZSkodGhpcy50aW1lb3V0RHVyYXRpb24pO1xuICAgICAgICB2b2lkIHRoaXMudGltZW91dC50aGVuKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgICAgICAgYXdhaXQgKChfYiA9IChfYSA9IHRoaXMuc3RhdGUuaG9va3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hZnRlck1lbW9pemF0aW9uKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSkpO1xuICAgICAgICAgICAgYXdhaXQgKChfZCA9IChfYyA9IHRoaXMuc3RhdGUuaG9va3MpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5iZWZvcmVFeGVjdXRpb24pID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jYWxsKF9jKSk7XG4gICAgICAgICAgICBhd2FpdCAoKF9mID0gKF9lID0gdGhpcy5zdGF0ZS5ob29rcykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmFmdGVyRXhlY3V0aW9uKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuY2FsbChfZSkpO1xuICAgICAgICAgICAgc3RhdGUuc2V0Q2hlY2twb2ludCh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJzdGVwLW5vdC1mb3VuZFwiLFxuICAgICAgICAgICAgICAgIHN0ZXA6IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHRoaXMub3B0aW9ucy5yZXF1ZXN0ZWRSdW5TdGVwLFxuICAgICAgICAgICAgICAgICAgICBvcDogdHlwZXNfanNfMS5TdGVwT3BDb2RlLlN0ZXBOb3RGb3VuZCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBpbml0aWFsaXplTWlkZGxld2FyZSgpIHtcbiAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5vcHRpb25zLmRhdGE7XG4gICAgICAgIGNvbnN0IGhvb2tzID0gYXdhaXQgKDAsIElubmdlc3RNaWRkbGV3YXJlX2pzXzEuZ2V0SG9va1N0YWNrKSh0aGlzLm9wdGlvbnMuZm5bXCJtaWRkbGV3YXJlXCJdLCBcIm9uRnVuY3Rpb25SdW5cIiwge1xuICAgICAgICAgICAgY3R4LFxuICAgICAgICAgICAgZm46IHRoaXMub3B0aW9ucy5mbixcbiAgICAgICAgICAgIHN0ZXBzOiBPYmplY3QudmFsdWVzKHRoaXMub3B0aW9ucy5zdGVwU3RhdGUpLFxuICAgICAgICAgICAgcmVxQXJnczogdGhpcy5vcHRpb25zLnJlcUFyZ3MsXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybUlucHV0OiAocHJldiwgb3V0cHV0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4OiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHByZXYuY3R4KSwgb3V0cHV0ID09PSBudWxsIHx8IG91dHB1dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3V0cHV0LmN0eCksXG4gICAgICAgICAgICAgICAgICAgIGZuOiB0aGlzLm9wdGlvbnMuZm4sXG4gICAgICAgICAgICAgICAgICAgIHN0ZXBzOiBwcmV2LnN0ZXBzLm1hcCgoc3RlcCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0ZXApLCAoX2EgPSBvdXRwdXQgPT09IG51bGwgfHwgb3V0cHV0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvdXRwdXQuc3RlcHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtpXSkpO1xuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgcmVxQXJnczogcHJldi5yZXFBcmdzLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHJhbnNmb3JtT3V0cHV0OiAocHJldiwgb3V0cHV0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHByZXYucmVzdWx0KSwgb3V0cHV0ID09PSBudWxsIHx8IG91dHB1dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3V0cHV0LnJlc3VsdCksXG4gICAgICAgICAgICAgICAgICAgIHN0ZXA6IHByZXYuc3RlcCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBob29rcztcbiAgICB9XG59XG5jb25zdCBoYXNoSWQgPSAoaWQpID0+IHtcbiAgICByZXR1cm4gKDAsIGhhc2hfanNfMS5zaGExKSgpLnVwZGF0ZShpZCkuZGlnZXN0KFwiaGV4XCIpO1xufTtcbmNvbnN0IGhhc2hPcCA9IChvcCkgPT4ge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wKSwgeyBpZDogaGFzaElkKG9wLmlkKSB9KTtcbn07XG4vKipcbiAqIEV4cG9ydGVkIGZvciB0ZXN0aW5nLlxuICovXG5leHBvcnRzLl9pbnRlcm5hbHMgPSB7IGhhc2hPcCwgaGFzaElkIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD12MS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/execution/v1.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/execution/v2.js":
/*!*********************************************************!*\
  !*** ./node_modules/inngest/components/execution/v2.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __asyncValues = (this && this.__asyncValues) || function (o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n};\nvar __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports._internals = exports.createV2InngestExecution = void 0;\nconst api_1 = __webpack_require__(/*! @opentelemetry/api */ \"(rsc)/./node_modules/@opentelemetry/api/build/esm/index.js\");\nconst hash_js_1 = __webpack_require__(/*! hash.js */ \"(rsc)/./node_modules/hash.js/lib/hash.js\");\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/inngest/node_modules/zod/lib/index.js\");\nconst consts_js_1 = __webpack_require__(/*! ../../helpers/consts.js */ \"(rsc)/./node_modules/inngest/helpers/consts.js\");\nconst errors_js_1 = __webpack_require__(/*! ../../helpers/errors.js */ \"(rsc)/./node_modules/inngest/helpers/errors.js\");\nconst functions_js_1 = __webpack_require__(/*! ../../helpers/functions.js */ \"(rsc)/./node_modules/inngest/helpers/functions.js\");\nconst promises_js_1 = __webpack_require__(/*! ../../helpers/promises.js */ \"(rsc)/./node_modules/inngest/helpers/promises.js\");\nconst types_js_1 = __webpack_require__(/*! ../../types.js */ \"(rsc)/./node_modules/inngest/types.js\");\nconst version_js_1 = __webpack_require__(/*! ../../version.js */ \"(rsc)/./node_modules/inngest/version.js\");\nconst InngestMiddleware_js_1 = __webpack_require__(/*! ../InngestMiddleware.js */ \"(rsc)/./node_modules/inngest/components/InngestMiddleware.js\");\nconst InngestStepTools_js_1 = __webpack_require__(/*! ../InngestStepTools.js */ \"(rsc)/./node_modules/inngest/components/InngestStepTools.js\");\nconst NonRetriableError_js_1 = __webpack_require__(/*! ../NonRetriableError.js */ \"(rsc)/./node_modules/inngest/components/NonRetriableError.js\");\nconst RetryAfterError_js_1 = __webpack_require__(/*! ../RetryAfterError.js */ \"(rsc)/./node_modules/inngest/components/RetryAfterError.js\");\nconst StepError_js_1 = __webpack_require__(/*! ../StepError.js */ \"(rsc)/./node_modules/inngest/components/StepError.js\");\nconst InngestExecution_js_1 = __webpack_require__(/*! ./InngestExecution.js */ \"(rsc)/./node_modules/inngest/components/execution/InngestExecution.js\");\nconst als_js_1 = __webpack_require__(/*! ./als.js */ \"(rsc)/./node_modules/inngest/components/execution/als.js\");\nconst access_js_1 = __webpack_require__(/*! ./otel/access.js */ \"(rsc)/./node_modules/inngest/components/execution/otel/access.js\");\nconst createV2InngestExecution = (options) => {\n    return new V2InngestExecution(options);\n};\nexports.createV2InngestExecution = createV2InngestExecution;\nclass V2InngestExecution extends InngestExecution_js_1.InngestExecution {\n    constructor(options) {\n        super(options);\n        this.timeoutDuration = 1000 * 10;\n        this.userFnToRun = this.getUserFnToRun();\n        this.state = this.createExecutionState();\n        this.fnArg = this.createFnArg();\n        this.checkpointHandlers = this.createCheckpointHandlers();\n        this.initializeTimer(this.state);\n        this.debug(\"created new V2 execution for run;\", this.options.requestedRunStep\n            ? `wanting to run step \"${this.options.requestedRunStep}\"`\n            : \"discovering steps\");\n        this.debug(\"existing state keys:\", Object.keys(this.state.stepState));\n    }\n    /**\n     * Idempotently start the execution of the user's function.\n     */\n    start() {\n        if (!this.execution) {\n            this.debug(\"starting V2 execution\");\n            const tracer = api_1.trace.getTracer(\"inngest\", version_js_1.version);\n            this.execution = (0, als_js_1.getAsyncLocalStorage)().then((als) => {\n                return als.run({ app: this.options.client, ctx: this.fnArg }, async () => {\n                    return tracer.startActiveSpan(\"inngest.execution\", (span) => {\n                        var _a;\n                        (_a = access_js_1.clientProcessorMap.get(this.options.client)) === null || _a === void 0 ? void 0 : _a.declareStartingSpan({\n                            span,\n                            runId: this.options.runId,\n                            traceparent: this.options.headers[consts_js_1.headerKeys.TraceParent],\n                            tracestate: this.options.headers[consts_js_1.headerKeys.TraceState],\n                        });\n                        return this._start()\n                            .then((result) => {\n                            this.debug(\"result:\", result);\n                            return result;\n                        })\n                            .finally(() => {\n                            span.end();\n                        });\n                    });\n                });\n            });\n        }\n        return this.execution;\n    }\n    /**\n     * Starts execution of the user's function and the core loop.\n     */\n    async _start() {\n        var _a, e_1, _b, _c;\n        var _d, _e;\n        try {\n            const allCheckpointHandler = this.getCheckpointHandler(\"\");\n            this.state.hooks = await this.initializeMiddleware();\n            await this.startExecution();\n            try {\n                for (var _f = true, _g = __asyncValues(this.state.loop), _h; _h = await _g.next(), _a = _h.done, !_a; _f = true) {\n                    _c = _h.value;\n                    _f = false;\n                    const checkpoint = _c;\n                    await allCheckpointHandler(checkpoint);\n                    const handler = this.getCheckpointHandler(checkpoint.type);\n                    const result = await handler(checkpoint);\n                    if (result) {\n                        return result;\n                    }\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (!_f && !_a && (_b = _g.return)) await _b.call(_g);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n        }\n        catch (error) {\n            return await this.transformOutput({ error });\n        }\n        finally {\n            void this.state.loop.return();\n            await ((_e = (_d = this.state.hooks) === null || _d === void 0 ? void 0 : _d.beforeResponse) === null || _e === void 0 ? void 0 : _e.call(_d));\n        }\n        /**\n         * If we're here, the generator somehow finished without returning a value.\n         * This should never happen.\n         */\n        throw new Error(\"Core loop finished without returning a value\");\n    }\n    /**\n     * Creates a handler for every checkpoint type, defining what to do when we\n     * reach that checkpoint in the core loop.\n     */\n    createCheckpointHandlers() {\n        return {\n            /**\n             * Run for all checkpoints. Best used for logging or common actions.\n             * Use other handlers to return values and interrupt the core loop.\n             */\n            \"\": (checkpoint) => {\n                this.debug(\"checkpoint:\", checkpoint);\n            },\n            /**\n             * The user's function has completed and returned a value.\n             */\n            \"function-resolved\": async (checkpoint) => {\n                return await this.transformOutput({ data: checkpoint.data });\n            },\n            /**\n             * The user's function has thrown an error.\n             */\n            \"function-rejected\": async (checkpoint) => {\n                return await this.transformOutput({ error: checkpoint.error });\n            },\n            /**\n             * We've found one or more steps. Here we may want to run a step or report\n             * them back to Inngest.\n             */\n            \"steps-found\": async ({ steps }) => {\n                const stepResult = await this.tryExecuteStep(steps);\n                if (stepResult) {\n                    const transformResult = await this.transformOutput(stepResult);\n                    /**\n                     * Transforming output will always return either function rejection or\n                     * resolution. In most cases, this can be immediately returned, but in\n                     * this particular case we want to handle it differently.\n                     */\n                    if (transformResult.type === \"function-resolved\") {\n                        return {\n                            type: \"step-ran\",\n                            ctx: transformResult.ctx,\n                            ops: transformResult.ops,\n                            step: exports._internals.hashOp(Object.assign(Object.assign({}, stepResult), { data: transformResult.data })),\n                        };\n                    }\n                    else if (transformResult.type === \"function-rejected\") {\n                        return {\n                            type: \"step-ran\",\n                            ctx: transformResult.ctx,\n                            ops: transformResult.ops,\n                            step: exports._internals.hashOp(Object.assign(Object.assign({}, stepResult), { error: transformResult.error })),\n                            retriable: transformResult.retriable,\n                        };\n                    }\n                    return transformResult;\n                }\n                const newSteps = await this.filterNewSteps(Array.from(this.state.steps.values()));\n                if (newSteps) {\n                    return {\n                        type: \"steps-found\",\n                        ctx: this.fnArg,\n                        ops: this.ops,\n                        steps: newSteps,\n                    };\n                }\n            },\n            /**\n             * While trying to find a step that Inngest has told us to run, we've\n             * timed out or have otherwise decided that it doesn't exist.\n             */\n            \"step-not-found\": ({ step }) => {\n                return { type: \"step-not-found\", ctx: this.fnArg, ops: this.ops, step };\n            },\n        };\n    }\n    getCheckpointHandler(type) {\n        return this.checkpointHandlers[type];\n    }\n    async tryExecuteStep(steps) {\n        var _a;\n        const hashedStepIdToRun = this.options.requestedRunStep || this.getEarlyExecRunStep(steps);\n        if (!hashedStepIdToRun) {\n            return;\n        }\n        const step = steps.find((step) => step.hashedId === hashedStepIdToRun && step.fn);\n        if (step) {\n            return await this.executeStep(step);\n        }\n        /**\n         * Ensure we reset the timeout if we have a requested run step but couldn't\n         * find it, but also that we don't reset if we found and executed it.\n         */\n        void ((_a = this.timeout) === null || _a === void 0 ? void 0 : _a.reset());\n    }\n    /**\n     * Given a list of outgoing ops, decide if we can execute an op early and\n     * return the ID of the step to execute if we can.\n     */\n    getEarlyExecRunStep(steps) {\n        /**\n         * We may have been disabled due to parallelism, in which case we can't\n         * immediately execute unless explicitly requested.\n         */\n        if (this.options.disableImmediateExecution)\n            return;\n        const unfulfilledSteps = steps.filter((step) => !step.fulfilled);\n        if (unfulfilledSteps.length !== 1)\n            return;\n        const op = unfulfilledSteps[0];\n        if (op &&\n            op.op === types_js_1.StepOpCode.StepPlanned\n        // TODO We must individually check properties here that we do not want to\n        // execute on, such as retry counts. Nothing exists here that falls in to\n        // this case, but should be accounted for when we add them.\n        // && typeof op.opts === \"undefined\"\n        ) {\n            return op.hashedId;\n        }\n    }\n    async filterNewSteps(foundSteps) {\n        var _a, _b, _c, _d, _e, _f;\n        if (this.options.requestedRunStep) {\n            return;\n        }\n        /**\n         * Gather any steps that aren't memoized and report them.\n         */\n        const newSteps = foundSteps.filter((step) => !step.fulfilled);\n        if (!newSteps.length) {\n            return;\n        }\n        /**\n         * Warn if we've found new steps but haven't yet seen all previous\n         * steps. This may indicate that step presence isn't determinate.\n         */\n        let knownSteps = 0;\n        for (const step of foundSteps) {\n            if (step.fulfilled) {\n                knownSteps++;\n            }\n        }\n        const foundAllCompletedSteps = this.state.stepsToFulfill === knownSteps;\n        if (!foundAllCompletedSteps) {\n            // TODO Tag\n            console.warn((0, errors_js_1.prettyError)({\n                type: \"warn\",\n                whatHappened: \"Function may be indeterminate\",\n                why: \"We found new steps before seeing all previous steps, which may indicate that the function is non-deterministic.\",\n                consequences: \"This may cause unexpected behaviour as Inngest executes your function.\",\n                reassurance: \"This is expected if a function is updated in the middle of a run, but may indicate a bug if not.\",\n            }));\n        }\n        /**\n         * We're finishing up; let's trigger the last of the hooks.\n         */\n        await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.afterMemoization) === null || _b === void 0 ? void 0 : _b.call(_a));\n        await ((_d = (_c = this.state.hooks) === null || _c === void 0 ? void 0 : _c.beforeExecution) === null || _d === void 0 ? void 0 : _d.call(_c));\n        await ((_f = (_e = this.state.hooks) === null || _e === void 0 ? void 0 : _e.afterExecution) === null || _f === void 0 ? void 0 : _f.call(_e));\n        const stepList = newSteps.map((step) => ({\n            displayName: step.displayName,\n            op: step.op,\n            id: step.hashedId,\n            name: step.name,\n            opts: step.opts,\n        }));\n        /**\n         * We also run `onSendEvent` middleware hooks against `step.invoke()` steps\n         * to ensure that their `data` is transformed correctly.\n         */\n        return await this.transformNewSteps(stepList);\n    }\n    /**\n     * Using middleware, transform any newly-found steps before returning them to\n     * an Inngest Server.\n     */\n    async transformNewSteps(steps) {\n        return Promise.all(steps.map(async (step) => {\n            var _a, _b, _c, _d, _e, _f, _g;\n            if (step.op !== types_js_1.StepOpCode.InvokeFunction) {\n                return step;\n            }\n            const onSendEventHooks = await (0, InngestMiddleware_js_1.getHookStack)(this.options.fn[\"middleware\"], \"onSendEvent\", undefined, {\n                transformInput: (prev, output) => {\n                    return Object.assign(Object.assign({}, prev), output);\n                },\n                transformOutput: (prev, output) => {\n                    return {\n                        result: Object.assign(Object.assign({}, prev.result), output === null || output === void 0 ? void 0 : output.result),\n                    };\n                },\n            });\n            /**\n             * For each event being sent, create a new `onSendEvent` hook stack to\n             * process it. We do this as middleware hooks are intended to run once\n             * during each lifecycle (onFunctionRun or onSendEvent) and here, a hook\n             * is run for every single event.\n             *\n             * This is done because a developer can use this hook to filter out\n             * events entirely; if we batch all of the events together, we can't\n             * tell which ones were filtered out if we're processing >1 invocation\n             * here.\n             */\n            const transformedPayload = await ((_a = onSendEventHooks.transformInput) === null || _a === void 0 ? void 0 : _a.call(onSendEventHooks, {\n                payloads: [\n                    Object.assign(Object.assign({}, ((_c = (_b = step.opts) === null || _b === void 0 ? void 0 : _b.payload) !== null && _c !== void 0 ? _c : {})), { name: consts_js_1.internalEvents.FunctionInvoked }),\n                ],\n            }));\n            const newPayload = InngestStepTools_js_1.invokePayloadSchema.parse((_e = (_d = transformedPayload === null || transformedPayload === void 0 ? void 0 : transformedPayload.payloads) === null || _d === void 0 ? void 0 : _d[0]) !== null && _e !== void 0 ? _e : {});\n            return Object.assign(Object.assign({}, step), { opts: Object.assign(Object.assign({}, step.opts), { payload: Object.assign(Object.assign({}, ((_g = (_f = step.opts) === null || _f === void 0 ? void 0 : _f.payload) !== null && _g !== void 0 ? _g : {})), newPayload) }) });\n        }));\n    }\n    async executeStep({ id, name, opts, fn, displayName, }) {\n        var _a, _b, _c, _d, _e;\n        (_a = this.timeout) === null || _a === void 0 ? void 0 : _a.clear();\n        await ((_c = (_b = this.state.hooks) === null || _b === void 0 ? void 0 : _b.afterMemoization) === null || _c === void 0 ? void 0 : _c.call(_b));\n        await ((_e = (_d = this.state.hooks) === null || _d === void 0 ? void 0 : _d.beforeExecution) === null || _e === void 0 ? void 0 : _e.call(_d));\n        const outgoingOp = {\n            id,\n            op: types_js_1.StepOpCode.StepRun,\n            name,\n            opts,\n            displayName,\n        };\n        this.state.executingStep = outgoingOp;\n        const store = await (0, als_js_1.getAsyncCtx)();\n        if (store) {\n            store.executingStep = {\n                id,\n                name: displayName,\n            };\n        }\n        this.debug(`executing step \"${id}\"`);\n        return ((0, promises_js_1.runAsPromise)(fn)\n            // eslint-disable-next-line @typescript-eslint/no-misused-promises\n            .finally(async () => {\n            var _a, _b;\n            if (store) {\n                delete store.executingStep;\n            }\n            await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.afterExecution) === null || _b === void 0 ? void 0 : _b.call(_a));\n        })\n            .then((data) => {\n            return Object.assign(Object.assign({}, outgoingOp), { data });\n        })\n            .catch((error) => {\n            return Object.assign(Object.assign({}, outgoingOp), { op: types_js_1.StepOpCode.StepError, \n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                error });\n        }));\n    }\n    /**\n     * Starts execution of the user's function, including triggering checkpoints\n     * and middleware hooks where appropriate.\n     */\n    async startExecution() {\n        var _a, _b, _c, _d, _e, _f, _g;\n        /**\n         * Mutate input as neccessary based on middleware.\n         */\n        await this.transformInput();\n        /**\n         * Start the timer to time out the run if needed.\n         */\n        void ((_a = this.timeout) === null || _a === void 0 ? void 0 : _a.start());\n        await ((_c = (_b = this.state.hooks) === null || _b === void 0 ? void 0 : _b.beforeMemoization) === null || _c === void 0 ? void 0 : _c.call(_b));\n        /**\n         * If we had no state to begin with, immediately end the memoization phase.\n         */\n        if (this.state.allStateUsed()) {\n            await ((_e = (_d = this.state.hooks) === null || _d === void 0 ? void 0 : _d.afterMemoization) === null || _e === void 0 ? void 0 : _e.call(_d));\n            await ((_g = (_f = this.state.hooks) === null || _f === void 0 ? void 0 : _f.beforeExecution) === null || _g === void 0 ? void 0 : _g.call(_f));\n        }\n        /**\n         * Trigger the user's function.\n         */\n        (0, promises_js_1.runAsPromise)(() => this.userFnToRun(this.fnArg))\n            // eslint-disable-next-line @typescript-eslint/no-misused-promises\n            .finally(async () => {\n            var _a, _b, _c, _d, _e, _f;\n            await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.afterMemoization) === null || _b === void 0 ? void 0 : _b.call(_a));\n            await ((_d = (_c = this.state.hooks) === null || _c === void 0 ? void 0 : _c.beforeExecution) === null || _d === void 0 ? void 0 : _d.call(_c));\n            await ((_f = (_e = this.state.hooks) === null || _e === void 0 ? void 0 : _e.afterExecution) === null || _f === void 0 ? void 0 : _f.call(_e));\n        })\n            .then((data) => {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            this.state.setCheckpoint({ type: \"function-resolved\", data });\n        })\n            .catch((error) => {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            this.state.setCheckpoint({ type: \"function-rejected\", error });\n        });\n    }\n    /**\n     * Using middleware, transform input before running.\n     */\n    async transformInput() {\n        var _a, _b;\n        const inputMutations = await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.transformInput) === null || _b === void 0 ? void 0 : _b.call(_a, {\n            ctx: Object.assign({}, this.fnArg),\n            steps: Object.values(this.state.stepState),\n            fn: this.options.fn,\n            reqArgs: this.options.reqArgs,\n        }));\n        if (inputMutations === null || inputMutations === void 0 ? void 0 : inputMutations.ctx) {\n            this.fnArg = inputMutations.ctx;\n        }\n        if (inputMutations === null || inputMutations === void 0 ? void 0 : inputMutations.steps) {\n            this.state.stepState = Object.fromEntries(inputMutations.steps.map((step) => [step.id, step]));\n        }\n    }\n    /**\n     * Using middleware, transform output before returning.\n     */\n    async transformOutput(dataOrError) {\n        var _a, _b, _c, _d;\n        const output = Object.assign({}, dataOrError);\n        /**\n         * If we've been given an error and it's one that we just threw from a step,\n         * we should return a `NonRetriableError` to stop execution.\n         */\n        if (typeof output.error !== \"undefined\") {\n            output.data = (0, errors_js_1.serializeError)(output.error);\n        }\n        const isStepExecution = Boolean(this.state.executingStep);\n        const transformedOutput = await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.transformOutput) === null || _b === void 0 ? void 0 : _b.call(_a, {\n            result: Object.assign({}, output),\n            step: this.state.executingStep,\n        }));\n        const { data, error } = Object.assign(Object.assign({}, output), transformedOutput === null || transformedOutput === void 0 ? void 0 : transformedOutput.result);\n        if (!isStepExecution) {\n            await ((_d = (_c = this.state.hooks) === null || _c === void 0 ? void 0 : _c.finished) === null || _d === void 0 ? void 0 : _d.call(_c, {\n                result: Object.assign({}, (typeof error !== \"undefined\" ? { error } : { data })),\n            }));\n        }\n        if (typeof error !== \"undefined\") {\n            /**\n             * Ensure we give middleware the chance to decide on retriable behaviour\n             * by looking at the error returned from output transformation.\n             */\n            let retriable = !(error instanceof NonRetriableError_js_1.NonRetriableError || error instanceof StepError_js_1.StepError);\n            if (retriable && error instanceof RetryAfterError_js_1.RetryAfterError) {\n                retriable = error.retryAfter;\n            }\n            const serializedError = (0, errors_js_1.minifyPrettyError)((0, errors_js_1.serializeError)(error));\n            return {\n                type: \"function-rejected\",\n                ctx: this.fnArg,\n                ops: this.ops,\n                error: serializedError,\n                retriable,\n            };\n        }\n        return {\n            type: \"function-resolved\",\n            ctx: this.fnArg,\n            ops: this.ops,\n            data: (0, functions_js_1.undefinedToNull)(data),\n        };\n    }\n    createExecutionState() {\n        const d = (0, promises_js_1.createDeferredPromiseWithStack)();\n        let checkpointResolve = d.deferred.resolve;\n        const checkpointResults = d.results;\n        const loop = (function (cleanUp) {\n            return __asyncGenerator(this, arguments, function* () {\n                try {\n                    while (true) {\n                        const res = (yield __await(checkpointResults.next())).value;\n                        if (res) {\n                            yield yield __await(res);\n                        }\n                    }\n                }\n                finally {\n                    cleanUp === null || cleanUp === void 0 ? void 0 : cleanUp();\n                }\n            });\n        })(() => {\n            var _a;\n            (_a = this.timeout) === null || _a === void 0 ? void 0 : _a.clear();\n            void checkpointResults.return();\n        });\n        const stepsToFulfill = Object.keys(this.options.stepState).length;\n        const state = {\n            stepState: this.options.stepState,\n            stepsToFulfill,\n            steps: new Map(),\n            loop,\n            hasSteps: Boolean(stepsToFulfill),\n            stepCompletionOrder: [...this.options.stepCompletionOrder],\n            remainingStepsToBeSeen: new Set(this.options.stepCompletionOrder),\n            setCheckpoint: (checkpoint) => {\n                ({ resolve: checkpointResolve } = checkpointResolve(checkpoint));\n            },\n            allStateUsed: () => {\n                return this.state.remainingStepsToBeSeen.size === 0;\n            },\n        };\n        return state;\n    }\n    get ops() {\n        return Object.fromEntries(this.state.steps);\n    }\n    createFnArg() {\n        var _a, _b, _c, _d;\n        const step = this.createStepTools();\n        let fnArg = Object.assign(Object.assign({}, this.options.data), { step });\n        /**\n         * Handle use of the `onFailure` option by deserializing the error.\n         */\n        if (this.options.isFailureHandler) {\n            const eventData = zod_1.z\n                .object({ error: types_js_1.jsonErrorSchema })\n                .parse((_a = fnArg.event) === null || _a === void 0 ? void 0 : _a.data);\n            fnArg = Object.assign(Object.assign({}, fnArg), { error: (0, errors_js_1.deserializeError)(eventData.error) });\n        }\n        return (_d = (_c = (_b = this.options).transformCtx) === null || _c === void 0 ? void 0 : _c.call(_b, fnArg)) !== null && _d !== void 0 ? _d : fnArg;\n    }\n    createStepTools() {\n        /**\n         * A list of steps that have been found and are being rolled up before being\n         * reported to the core loop.\n         */\n        const foundStepsToReport = new Map();\n        /**\n         * A map of the subset of found steps to report that have not yet been\n         * handled. Used for fast access to steps that need to be handled in order.\n         */\n        const unhandledFoundStepsToReport = new Map();\n        /**\n         * A map of the latest sequential step indexes found for each step ID. Used\n         * to ensure that we don't index steps in parallel.\n         *\n         * Note that these must be sequential; if we've seen or assigned `a:1`,\n         * `a:2` and `a:4`, the latest sequential step index is `2`.\n         *\n         */\n        const expectedNextStepIndexes = new Map();\n        /**\n         * A promise that's used to ensure that step reporting cannot be run more than\n         * once in a given asynchronous time span.\n         */\n        let foundStepsReportPromise;\n        /**\n         * A promise that's used to represent middleware hooks running before\n         * execution.\n         */\n        let beforeExecHooksPromise;\n        /**\n         * A helper used to report steps to the core loop. Used after adding an item\n         * to `foundStepsToReport`.\n         */\n        const reportNextTick = () => {\n            // Being explicit instead of using `??=` to appease TypeScript.\n            if (foundStepsReportPromise) {\n                return;\n            }\n            foundStepsReportPromise = new Promise((resolve) => setImmediate(resolve))\n                /**\n                 * Ensure that we wait for this promise to resolve before continuing.\n                 *\n                 * The groups in which steps are reported can affect how we detect some\n                 * more complex determinism issues like parallel indexing. This promise\n                 * can represent middleware hooks being run early, in the middle of\n                 * ingesting steps to report.\n                 *\n                 * Because of this, it's important we wait for this middleware to resolve\n                 * before continuing to report steps to ensure that all steps have a\n                 * chance to be reported throughout this asynchronous action.\n                 */\n                .then(() => beforeExecHooksPromise)\n                .then(() => {\n                foundStepsReportPromise = undefined;\n                for (const [hashedId, step] of unhandledFoundStepsToReport) {\n                    if (step.handle()) {\n                        unhandledFoundStepsToReport.delete(hashedId);\n                        if (step.fulfilled) {\n                            foundStepsToReport.delete(step.id);\n                        }\n                    }\n                }\n                if (foundStepsToReport.size) {\n                    const steps = [...foundStepsToReport.values()];\n                    foundStepsToReport.clear();\n                    return void this.state.setCheckpoint({\n                        type: \"steps-found\",\n                        steps: steps,\n                    });\n                }\n            });\n        };\n        /**\n         * A helper used to push a step to the list of steps to report.\n         */\n        const pushStepToReport = (step) => {\n            foundStepsToReport.set(step.id, step);\n            unhandledFoundStepsToReport.set(step.hashedId, step);\n            reportNextTick();\n        };\n        const stepHandler = async ({ args, matchOp, opts, }) => {\n            var _a, _b, _c, _d;\n            await beforeExecHooksPromise;\n            const stepOptions = (0, InngestStepTools_js_1.getStepOptions)(args[0]);\n            const opId = matchOp(stepOptions, ...args.slice(1));\n            if (this.state.executingStep) {\n                /**\n                 * If a step is found after asynchronous actions during another step's\n                 * execution, everything is fine. The problem here is if we've found\n                 * that a step nested inside another a step, which is something we don't\n                 * support at the time of writing.\n                 *\n                 * In this case, we could use something like Async Hooks to understand\n                 * how the step is being triggered, though this isn't available in all\n                 * environments.\n                 *\n                 * Therefore, we'll only show a warning here to indicate that this is\n                 * potentially an issue.\n                 */\n                console.warn((0, errors_js_1.prettyError)({\n                    whatHappened: `We detected that you have nested \\`step.*\\` tooling in \\`${(_a = opId.displayName) !== null && _a !== void 0 ? _a : opId.id}\\``,\n                    consequences: \"Nesting `step.*` tooling is not supported.\",\n                    type: \"warn\",\n                    reassurance: \"It's possible to see this warning if steps are separated by regular asynchronous calls, which is fine.\",\n                    stack: true,\n                    toFixNow: \"Make sure you're not using `step.*` tooling inside of other `step.*` tooling. If you need to compose steps together, you can create a new async function and call it from within your step function, or use promise chaining.\",\n                    code: errors_js_1.ErrCode.NESTING_STEPS,\n                }));\n            }\n            if (this.state.steps.has(opId.id)) {\n                const originalId = opId.id;\n                const expectedNextIndex = (_b = expectedNextStepIndexes.get(originalId)) !== null && _b !== void 0 ? _b : 1;\n                for (let i = expectedNextIndex;; i++) {\n                    const newId = originalId + InngestStepTools_js_1.STEP_INDEXING_SUFFIX + i;\n                    if (!this.state.steps.has(newId)) {\n                        expectedNextStepIndexes.set(originalId, i + 1);\n                        opId.id = newId;\n                        break;\n                    }\n                }\n            }\n            const { promise, resolve, reject } = (0, promises_js_1.createDeferredPromise)();\n            const hashedId = exports._internals.hashId(opId.id);\n            const stepState = this.state.stepState[hashedId];\n            let isFulfilled = false;\n            if (stepState) {\n                stepState.seen = true;\n                this.state.remainingStepsToBeSeen.delete(hashedId);\n                if (typeof stepState.input === \"undefined\") {\n                    isFulfilled = true;\n                }\n            }\n            let extraOpts;\n            let fnArgs = [...args];\n            if (typeof (stepState === null || stepState === void 0 ? void 0 : stepState.input) !== \"undefined\" &&\n                Array.isArray(stepState.input)) {\n                switch (opId.op) {\n                    // `step.run()` has its function input affected\n                    case types_js_1.StepOpCode.StepPlanned: {\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                        fnArgs = [...args.slice(0, 2), ...stepState.input];\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                        extraOpts = { input: [...stepState.input] };\n                        break;\n                    }\n                    // `step.ai.infer()` has its body affected\n                    case types_js_1.StepOpCode.AiGateway: {\n                        extraOpts = {\n                            body: Object.assign(Object.assign({}, (typeof ((_c = opId.opts) === null || _c === void 0 ? void 0 : _c.body) === \"object\"\n                                ? Object.assign({}, opId.opts.body) : {})), stepState.input[0]),\n                        };\n                        break;\n                    }\n                }\n            }\n            const step = Object.assign(Object.assign({}, opId), { opts: Object.assign(Object.assign({}, opId.opts), extraOpts), rawArgs: fnArgs, // TODO What is the right value here? Should this be raw args without affected input?\n                hashedId, input: stepState === null || stepState === void 0 ? void 0 : stepState.input, \n                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n                fn: (opts === null || opts === void 0 ? void 0 : opts.fn) ? () => { var _a; return (_a = opts.fn) === null || _a === void 0 ? void 0 : _a.call(opts, ...fnArgs); } : undefined, promise, fulfilled: isFulfilled, hasStepState: Boolean(stepState), displayName: (_d = opId.displayName) !== null && _d !== void 0 ? _d : opId.id, handled: false, handle: () => {\n                    if (step.handled) {\n                        return false;\n                    }\n                    step.handled = true;\n                    if (isFulfilled && stepState) {\n                        stepState.fulfilled = true;\n                        // For some execution scenarios such as testing, `data`, `error`,\n                        // and `input` may be `Promises`. This could also be the case for\n                        // future middleware applications. For this reason, we'll make sure\n                        // the values are fully resolved before continuing.\n                        void Promise.all([\n                            stepState.data,\n                            stepState.error,\n                            stepState.input,\n                        ]).then(() => {\n                            if (typeof stepState.data !== \"undefined\") {\n                                resolve(stepState.data);\n                            }\n                            else {\n                                this.state.recentlyRejectedStepError = new StepError_js_1.StepError(opId.id, stepState.error);\n                                reject(this.state.recentlyRejectedStepError);\n                            }\n                        });\n                    }\n                    return true;\n                } });\n            this.state.steps.set(opId.id, step);\n            this.state.hasSteps = true;\n            pushStepToReport(step);\n            /**\n             * If this is the last piece of state we had, we've now finished\n             * memoizing.\n             */\n            if (!beforeExecHooksPromise && this.state.allStateUsed()) {\n                await (beforeExecHooksPromise = (async () => {\n                    var _a, _b, _c, _d;\n                    await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.afterMemoization) === null || _b === void 0 ? void 0 : _b.call(_a));\n                    await ((_d = (_c = this.state.hooks) === null || _c === void 0 ? void 0 : _c.beforeExecution) === null || _d === void 0 ? void 0 : _d.call(_c));\n                })());\n            }\n            return promise;\n        };\n        return (0, InngestStepTools_js_1.createStepTools)(this.options.client, this, stepHandler);\n    }\n    getUserFnToRun() {\n        if (!this.options.isFailureHandler) {\n            return this.options.fn[\"fn\"];\n        }\n        if (!this.options.fn[\"onFailureFn\"]) {\n            /**\n             * Somehow, we've ended up detecting that this is a failure handler but\n             * doesn't have an `onFailure` function. This should never happen.\n             */\n            throw new Error(\"Cannot find function `onFailure` handler\");\n        }\n        return this.options.fn[\"onFailureFn\"];\n    }\n    initializeTimer(state) {\n        if (!this.options.requestedRunStep) {\n            return;\n        }\n        this.timeout = (0, promises_js_1.createTimeoutPromise)(this.timeoutDuration);\n        void this.timeout.then(async () => {\n            var _a, _b, _c, _d, _e, _f;\n            await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.afterMemoization) === null || _b === void 0 ? void 0 : _b.call(_a));\n            await ((_d = (_c = this.state.hooks) === null || _c === void 0 ? void 0 : _c.beforeExecution) === null || _d === void 0 ? void 0 : _d.call(_c));\n            await ((_f = (_e = this.state.hooks) === null || _e === void 0 ? void 0 : _e.afterExecution) === null || _f === void 0 ? void 0 : _f.call(_e));\n            state.setCheckpoint({\n                type: \"step-not-found\",\n                step: {\n                    id: this.options.requestedRunStep,\n                    op: types_js_1.StepOpCode.StepNotFound,\n                },\n            });\n        });\n    }\n    async initializeMiddleware() {\n        const ctx = this.options.data;\n        const hooks = await (0, InngestMiddleware_js_1.getHookStack)(this.options.fn[\"middleware\"], \"onFunctionRun\", {\n            ctx,\n            fn: this.options.fn,\n            steps: Object.values(this.options.stepState),\n            reqArgs: this.options.reqArgs,\n        }, {\n            transformInput: (prev, output) => {\n                return {\n                    ctx: Object.assign(Object.assign({}, prev.ctx), output === null || output === void 0 ? void 0 : output.ctx),\n                    fn: this.options.fn,\n                    steps: prev.steps.map((step, i) => {\n                        var _a;\n                        return (Object.assign(Object.assign({}, step), (_a = output === null || output === void 0 ? void 0 : output.steps) === null || _a === void 0 ? void 0 : _a[i]));\n                    }),\n                    reqArgs: prev.reqArgs,\n                };\n            },\n            transformOutput: (prev, output) => {\n                return {\n                    result: Object.assign(Object.assign({}, prev.result), output === null || output === void 0 ? void 0 : output.result),\n                    step: prev.step,\n                };\n            },\n        });\n        return hooks;\n    }\n}\nconst hashId = (id) => {\n    return (0, hash_js_1.sha1)().update(id).digest(\"hex\");\n};\nconst hashOp = (op) => {\n    return Object.assign(Object.assign({}, op), { id: hashId(op.id) });\n};\n/**\n * Exported for testing.\n */\nexports._internals = { hashOp, hashId };\n//# sourceMappingURL=v2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL2V4ZWN1dGlvbi92Mi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDJHQUEyRyx1RkFBdUYsY0FBYztBQUNoTix1QkFBdUIsOEJBQThCLGdEQUFnRCx3REFBd0Q7QUFDN0osNkNBQTZDLHNDQUFzQyxVQUFVLG1CQUFtQixJQUFJO0FBQ3BIO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLDBNQUEwTSxjQUFjO0FBQ3hOLDhCQUE4QixzQkFBc0I7QUFDcEQsMEJBQTBCLFlBQVksc0JBQXNCLHFDQUFxQywyQ0FBMkMsTUFBTTtBQUNsSiw0QkFBNEIsTUFBTSxpQkFBaUIsWUFBWTtBQUMvRCx1QkFBdUI7QUFDdkIsOEJBQThCO0FBQzlCLDZCQUE2QjtBQUM3Qiw0QkFBNEI7QUFDNUI7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCLEdBQUcsZ0NBQWdDO0FBQ3JELGNBQWMsbUJBQU8sQ0FBQyxzRkFBb0I7QUFDMUMsa0JBQWtCLG1CQUFPLENBQUMseURBQVM7QUFDbkMsY0FBYyxtQkFBTyxDQUFDLHVFQUFLO0FBQzNCLG9CQUFvQixtQkFBTyxDQUFDLCtFQUF5QjtBQUNyRCxvQkFBb0IsbUJBQU8sQ0FBQywrRUFBeUI7QUFDckQsdUJBQXVCLG1CQUFPLENBQUMscUZBQTRCO0FBQzNELHNCQUFzQixtQkFBTyxDQUFDLG1GQUEyQjtBQUN6RCxtQkFBbUIsbUJBQU8sQ0FBQyw2REFBZ0I7QUFDM0MscUJBQXFCLG1CQUFPLENBQUMsaUVBQWtCO0FBQy9DLCtCQUErQixtQkFBTyxDQUFDLDZGQUF5QjtBQUNoRSw4QkFBOEIsbUJBQU8sQ0FBQywyRkFBd0I7QUFDOUQsK0JBQStCLG1CQUFPLENBQUMsNkZBQXlCO0FBQ2hFLDZCQUE2QixtQkFBTyxDQUFDLHlGQUF1QjtBQUM1RCx1QkFBdUIsbUJBQU8sQ0FBQyw2RUFBaUI7QUFDaEQsOEJBQThC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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxTQUFTLG1CQUFtQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixLQUFLO0FBQ3ZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdml2ZS12aWJlLWFpLW5leHQvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL2V4ZWN1dGlvbi92Mi5qcz83OGI3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXN5bmNWYWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fYXN5bmNWYWx1ZXMpIHx8IGZ1bmN0aW9uIChvKSB7XG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxufTtcbnZhciBfX2F3YWl0ID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0KSB8fCBmdW5jdGlvbiAodikgeyByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTsgfVxudmFyIF9fYXN5bmNHZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fYXN5bmNHZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XG4gICAgcmV0dXJuIGkgPSBPYmplY3QuY3JlYXRlKCh0eXBlb2YgQXN5bmNJdGVyYXRvciA9PT0gXCJmdW5jdGlvblwiID8gQXN5bmNJdGVyYXRvciA6IE9iamVjdCkucHJvdG90eXBlKSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiLCBhd2FpdFJldHVybiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcbiAgICBmdW5jdGlvbiBhd2FpdFJldHVybihmKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZiwgcmVqZWN0KTsgfTsgfVxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpZiAoZ1tuXSkgeyBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyBpZiAoZikgaVtuXSA9IGYoaVtuXSk7IH0gfVxuICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cbiAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7IH1cbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XG4gICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxuICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLl9pbnRlcm5hbHMgPSBleHBvcnRzLmNyZWF0ZVYySW5uZ2VzdEV4ZWN1dGlvbiA9IHZvaWQgMDtcbmNvbnN0IGFwaV8xID0gcmVxdWlyZShcIkBvcGVudGVsZW1ldHJ5L2FwaVwiKTtcbmNvbnN0IGhhc2hfanNfMSA9IHJlcXVpcmUoXCJoYXNoLmpzXCIpO1xuY29uc3Qgem9kXzEgPSByZXF1aXJlKFwiem9kXCIpO1xuY29uc3QgY29uc3RzX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vaGVscGVycy9jb25zdHMuanNcIik7XG5jb25zdCBlcnJvcnNfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi9oZWxwZXJzL2Vycm9ycy5qc1wiKTtcbmNvbnN0IGZ1bmN0aW9uc19qc18xID0gcmVxdWlyZShcIi4uLy4uL2hlbHBlcnMvZnVuY3Rpb25zLmpzXCIpO1xuY29uc3QgcHJvbWlzZXNfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi9oZWxwZXJzL3Byb21pc2VzLmpzXCIpO1xuY29uc3QgdHlwZXNfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi90eXBlcy5qc1wiKTtcbmNvbnN0IHZlcnNpb25fanNfMSA9IHJlcXVpcmUoXCIuLi8uLi92ZXJzaW9uLmpzXCIpO1xuY29uc3QgSW5uZ2VzdE1pZGRsZXdhcmVfanNfMSA9IHJlcXVpcmUoXCIuLi9Jbm5nZXN0TWlkZGxld2FyZS5qc1wiKTtcbmNvbnN0IElubmdlc3RTdGVwVG9vbHNfanNfMSA9IHJlcXVpcmUoXCIuLi9Jbm5nZXN0U3RlcFRvb2xzLmpzXCIpO1xuY29uc3QgTm9uUmV0cmlhYmxlRXJyb3JfanNfMSA9IHJlcXVpcmUoXCIuLi9Ob25SZXRyaWFibGVFcnJvci5qc1wiKTtcbmNvbnN0IFJldHJ5QWZ0ZXJFcnJvcl9qc18xID0gcmVxdWlyZShcIi4uL1JldHJ5QWZ0ZXJFcnJvci5qc1wiKTtcbmNvbnN0IFN0ZXBFcnJvcl9qc18xID0gcmVxdWlyZShcIi4uL1N0ZXBFcnJvci5qc1wiKTtcbmNvbnN0IElubmdlc3RFeGVjdXRpb25fanNfMSA9IHJlcXVpcmUoXCIuL0lubmdlc3RFeGVjdXRpb24uanNcIik7XG5jb25zdCBhbHNfanNfMSA9IHJlcXVpcmUoXCIuL2Fscy5qc1wiKTtcbmNvbnN0IGFjY2Vzc19qc18xID0gcmVxdWlyZShcIi4vb3RlbC9hY2Nlc3MuanNcIik7XG5jb25zdCBjcmVhdGVWMklubmdlc3RFeGVjdXRpb24gPSAob3B0aW9ucykgPT4ge1xuICAgIHJldHVybiBuZXcgVjJJbm5nZXN0RXhlY3V0aW9uKG9wdGlvbnMpO1xufTtcbmV4cG9ydHMuY3JlYXRlVjJJbm5nZXN0RXhlY3V0aW9uID0gY3JlYXRlVjJJbm5nZXN0RXhlY3V0aW9uO1xuY2xhc3MgVjJJbm5nZXN0RXhlY3V0aW9uIGV4dGVuZHMgSW5uZ2VzdEV4ZWN1dGlvbl9qc18xLklubmdlc3RFeGVjdXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG4gICAgICAgIHRoaXMudGltZW91dER1cmF0aW9uID0gMTAwMCAqIDEwO1xuICAgICAgICB0aGlzLnVzZXJGblRvUnVuID0gdGhpcy5nZXRVc2VyRm5Ub1J1bigpO1xuICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5jcmVhdGVFeGVjdXRpb25TdGF0ZSgpO1xuICAgICAgICB0aGlzLmZuQXJnID0gdGhpcy5jcmVhdGVGbkFyZygpO1xuICAgICAgICB0aGlzLmNoZWNrcG9pbnRIYW5kbGVycyA9IHRoaXMuY3JlYXRlQ2hlY2twb2ludEhhbmRsZXJzKCk7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZVRpbWVyKHRoaXMuc3RhdGUpO1xuICAgICAgICB0aGlzLmRlYnVnKFwiY3JlYXRlZCBuZXcgVjIgZXhlY3V0aW9uIGZvciBydW47XCIsIHRoaXMub3B0aW9ucy5yZXF1ZXN0ZWRSdW5TdGVwXG4gICAgICAgICAgICA/IGB3YW50aW5nIHRvIHJ1biBzdGVwIFwiJHt0aGlzLm9wdGlvbnMucmVxdWVzdGVkUnVuU3RlcH1cImBcbiAgICAgICAgICAgIDogXCJkaXNjb3ZlcmluZyBzdGVwc1wiKTtcbiAgICAgICAgdGhpcy5kZWJ1ZyhcImV4aXN0aW5nIHN0YXRlIGtleXM6XCIsIE9iamVjdC5rZXlzKHRoaXMuc3RhdGUuc3RlcFN0YXRlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElkZW1wb3RlbnRseSBzdGFydCB0aGUgZXhlY3V0aW9uIG9mIHRoZSB1c2VyJ3MgZnVuY3Rpb24uXG4gICAgICovXG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5leGVjdXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuZGVidWcoXCJzdGFydGluZyBWMiBleGVjdXRpb25cIik7XG4gICAgICAgICAgICBjb25zdCB0cmFjZXIgPSBhcGlfMS50cmFjZS5nZXRUcmFjZXIoXCJpbm5nZXN0XCIsIHZlcnNpb25fanNfMS52ZXJzaW9uKTtcbiAgICAgICAgICAgIHRoaXMuZXhlY3V0aW9uID0gKDAsIGFsc19qc18xLmdldEFzeW5jTG9jYWxTdG9yYWdlKSgpLnRoZW4oKGFscykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBhbHMucnVuKHsgYXBwOiB0aGlzLm9wdGlvbnMuY2xpZW50LCBjdHg6IHRoaXMuZm5BcmcgfSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJhY2VyLnN0YXJ0QWN0aXZlU3BhbihcImlubmdlc3QuZXhlY3V0aW9uXCIsIChzcGFuKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgICAgICAoX2EgPSBhY2Nlc3NfanNfMS5jbGllbnRQcm9jZXNzb3JNYXAuZ2V0KHRoaXMub3B0aW9ucy5jbGllbnQpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGVjbGFyZVN0YXJ0aW5nU3Bhbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BhbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBydW5JZDogdGhpcy5vcHRpb25zLnJ1bklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNlcGFyZW50OiB0aGlzLm9wdGlvbnMuaGVhZGVyc1tjb25zdHNfanNfMS5oZWFkZXJLZXlzLlRyYWNlUGFyZW50XSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFjZXN0YXRlOiB0aGlzLm9wdGlvbnMuaGVhZGVyc1tjb25zdHNfanNfMS5oZWFkZXJLZXlzLlRyYWNlU3RhdGVdLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RhcnQoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYnVnKFwicmVzdWx0OlwiLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGFuLmVuZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydHMgZXhlY3V0aW9uIG9mIHRoZSB1c2VyJ3MgZnVuY3Rpb24gYW5kIHRoZSBjb3JlIGxvb3AuXG4gICAgICovXG4gICAgYXN5bmMgX3N0YXJ0KCkge1xuICAgICAgICB2YXIgX2EsIGVfMSwgX2IsIF9jO1xuICAgICAgICB2YXIgX2QsIF9lO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYWxsQ2hlY2twb2ludEhhbmRsZXIgPSB0aGlzLmdldENoZWNrcG9pbnRIYW5kbGVyKFwiXCIpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5ob29rcyA9IGF3YWl0IHRoaXMuaW5pdGlhbGl6ZU1pZGRsZXdhcmUoKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc3RhcnRFeGVjdXRpb24oKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2YgPSB0cnVlLCBfZyA9IF9fYXN5bmNWYWx1ZXModGhpcy5zdGF0ZS5sb29wKSwgX2g7IF9oID0gYXdhaXQgX2cubmV4dCgpLCBfYSA9IF9oLmRvbmUsICFfYTsgX2YgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jID0gX2gudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIF9mID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoZWNrcG9pbnQgPSBfYztcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgYWxsQ2hlY2twb2ludEhhbmRsZXIoY2hlY2twb2ludCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZXIgPSB0aGlzLmdldENoZWNrcG9pbnRIYW5kbGVyKGNoZWNrcG9pbnQudHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGhhbmRsZXIoY2hlY2twb2ludCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfZiAmJiAhX2EgJiYgKF9iID0gX2cucmV0dXJuKSkgYXdhaXQgX2IuY2FsbChfZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zZm9ybU91dHB1dCh7IGVycm9yIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdm9pZCB0aGlzLnN0YXRlLmxvb3AucmV0dXJuKCk7XG4gICAgICAgICAgICBhd2FpdCAoKF9lID0gKF9kID0gdGhpcy5zdGF0ZS5ob29rcykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmJlZm9yZVJlc3BvbnNlKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UuY2FsbChfZCkpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB3ZSdyZSBoZXJlLCB0aGUgZ2VuZXJhdG9yIHNvbWVob3cgZmluaXNoZWQgd2l0aG91dCByZXR1cm5pbmcgYSB2YWx1ZS5cbiAgICAgICAgICogVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29yZSBsb29wIGZpbmlzaGVkIHdpdGhvdXQgcmV0dXJuaW5nIGEgdmFsdWVcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBoYW5kbGVyIGZvciBldmVyeSBjaGVja3BvaW50IHR5cGUsIGRlZmluaW5nIHdoYXQgdG8gZG8gd2hlbiB3ZVxuICAgICAqIHJlYWNoIHRoYXQgY2hlY2twb2ludCBpbiB0aGUgY29yZSBsb29wLlxuICAgICAqL1xuICAgIGNyZWF0ZUNoZWNrcG9pbnRIYW5kbGVycygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUnVuIGZvciBhbGwgY2hlY2twb2ludHMuIEJlc3QgdXNlZCBmb3IgbG9nZ2luZyBvciBjb21tb24gYWN0aW9ucy5cbiAgICAgICAgICAgICAqIFVzZSBvdGhlciBoYW5kbGVycyB0byByZXR1cm4gdmFsdWVzIGFuZCBpbnRlcnJ1cHQgdGhlIGNvcmUgbG9vcC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJcIjogKGNoZWNrcG9pbnQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlYnVnKFwiY2hlY2twb2ludDpcIiwgY2hlY2twb2ludCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgdXNlcidzIGZ1bmN0aW9uIGhhcyBjb21wbGV0ZWQgYW5kIHJldHVybmVkIGEgdmFsdWUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwiZnVuY3Rpb24tcmVzb2x2ZWRcIjogYXN5bmMgKGNoZWNrcG9pbnQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc2Zvcm1PdXRwdXQoeyBkYXRhOiBjaGVja3BvaW50LmRhdGEgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgdXNlcidzIGZ1bmN0aW9uIGhhcyB0aHJvd24gYW4gZXJyb3IuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwiZnVuY3Rpb24tcmVqZWN0ZWRcIjogYXN5bmMgKGNoZWNrcG9pbnQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc2Zvcm1PdXRwdXQoeyBlcnJvcjogY2hlY2twb2ludC5lcnJvciB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFdlJ3ZlIGZvdW5kIG9uZSBvciBtb3JlIHN0ZXBzLiBIZXJlIHdlIG1heSB3YW50IHRvIHJ1biBhIHN0ZXAgb3IgcmVwb3J0XG4gICAgICAgICAgICAgKiB0aGVtIGJhY2sgdG8gSW5uZ2VzdC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJzdGVwcy1mb3VuZFwiOiBhc3luYyAoeyBzdGVwcyB9KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RlcFJlc3VsdCA9IGF3YWl0IHRoaXMudHJ5RXhlY3V0ZVN0ZXAoc3RlcHMpO1xuICAgICAgICAgICAgICAgIGlmIChzdGVwUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybVJlc3VsdCA9IGF3YWl0IHRoaXMudHJhbnNmb3JtT3V0cHV0KHN0ZXBSZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogVHJhbnNmb3JtaW5nIG91dHB1dCB3aWxsIGFsd2F5cyByZXR1cm4gZWl0aGVyIGZ1bmN0aW9uIHJlamVjdGlvbiBvclxuICAgICAgICAgICAgICAgICAgICAgKiByZXNvbHV0aW9uLiBJbiBtb3N0IGNhc2VzLCB0aGlzIGNhbiBiZSBpbW1lZGlhdGVseSByZXR1cm5lZCwgYnV0IGluXG4gICAgICAgICAgICAgICAgICAgICAqIHRoaXMgcGFydGljdWxhciBjYXNlIHdlIHdhbnQgdG8gaGFuZGxlIGl0IGRpZmZlcmVudGx5LlxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyYW5zZm9ybVJlc3VsdC50eXBlID09PSBcImZ1bmN0aW9uLXJlc29sdmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdGVwLXJhblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eDogdHJhbnNmb3JtUmVzdWx0LmN0eCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHM6IHRyYW5zZm9ybVJlc3VsdC5vcHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RlcDogZXhwb3J0cy5faW50ZXJuYWxzLmhhc2hPcChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0ZXBSZXN1bHQpLCB7IGRhdGE6IHRyYW5zZm9ybVJlc3VsdC5kYXRhIH0pKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHJhbnNmb3JtUmVzdWx0LnR5cGUgPT09IFwiZnVuY3Rpb24tcmVqZWN0ZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN0ZXAtcmFuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4OiB0cmFuc2Zvcm1SZXN1bHQuY3R4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wczogdHJhbnNmb3JtUmVzdWx0Lm9wcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGVwOiBleHBvcnRzLl9pbnRlcm5hbHMuaGFzaE9wKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RlcFJlc3VsdCksIHsgZXJyb3I6IHRyYW5zZm9ybVJlc3VsdC5lcnJvciB9KSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0cmlhYmxlOiB0cmFuc2Zvcm1SZXN1bHQucmV0cmlhYmxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtUmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBuZXdTdGVwcyA9IGF3YWl0IHRoaXMuZmlsdGVyTmV3U3RlcHMoQXJyYXkuZnJvbSh0aGlzLnN0YXRlLnN0ZXBzLnZhbHVlcygpKSk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld1N0ZXBzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN0ZXBzLWZvdW5kXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHg6IHRoaXMuZm5BcmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHM6IHRoaXMub3BzLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RlcHM6IG5ld1N0ZXBzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFdoaWxlIHRyeWluZyB0byBmaW5kIGEgc3RlcCB0aGF0IElubmdlc3QgaGFzIHRvbGQgdXMgdG8gcnVuLCB3ZSd2ZVxuICAgICAgICAgICAgICogdGltZWQgb3V0IG9yIGhhdmUgb3RoZXJ3aXNlIGRlY2lkZWQgdGhhdCBpdCBkb2Vzbid0IGV4aXN0LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcInN0ZXAtbm90LWZvdW5kXCI6ICh7IHN0ZXAgfSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwic3RlcC1ub3QtZm91bmRcIiwgY3R4OiB0aGlzLmZuQXJnLCBvcHM6IHRoaXMub3BzLCBzdGVwIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRDaGVja3BvaW50SGFuZGxlcih0eXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoZWNrcG9pbnRIYW5kbGVyc1t0eXBlXTtcbiAgICB9XG4gICAgYXN5bmMgdHJ5RXhlY3V0ZVN0ZXAoc3RlcHMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBoYXNoZWRTdGVwSWRUb1J1biA9IHRoaXMub3B0aW9ucy5yZXF1ZXN0ZWRSdW5TdGVwIHx8IHRoaXMuZ2V0RWFybHlFeGVjUnVuU3RlcChzdGVwcyk7XG4gICAgICAgIGlmICghaGFzaGVkU3RlcElkVG9SdW4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGVwID0gc3RlcHMuZmluZCgoc3RlcCkgPT4gc3RlcC5oYXNoZWRJZCA9PT0gaGFzaGVkU3RlcElkVG9SdW4gJiYgc3RlcC5mbik7XG4gICAgICAgIGlmIChzdGVwKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5leGVjdXRlU3RlcChzdGVwKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRW5zdXJlIHdlIHJlc2V0IHRoZSB0aW1lb3V0IGlmIHdlIGhhdmUgYSByZXF1ZXN0ZWQgcnVuIHN0ZXAgYnV0IGNvdWxkbid0XG4gICAgICAgICAqIGZpbmQgaXQsIGJ1dCBhbHNvIHRoYXQgd2UgZG9uJ3QgcmVzZXQgaWYgd2UgZm91bmQgYW5kIGV4ZWN1dGVkIGl0LlxuICAgICAgICAgKi9cbiAgICAgICAgdm9pZCAoKF9hID0gdGhpcy50aW1lb3V0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVzZXQoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgbGlzdCBvZiBvdXRnb2luZyBvcHMsIGRlY2lkZSBpZiB3ZSBjYW4gZXhlY3V0ZSBhbiBvcCBlYXJseSBhbmRcbiAgICAgKiByZXR1cm4gdGhlIElEIG9mIHRoZSBzdGVwIHRvIGV4ZWN1dGUgaWYgd2UgY2FuLlxuICAgICAqL1xuICAgIGdldEVhcmx5RXhlY1J1blN0ZXAoc3RlcHMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdlIG1heSBoYXZlIGJlZW4gZGlzYWJsZWQgZHVlIHRvIHBhcmFsbGVsaXNtLCBpbiB3aGljaCBjYXNlIHdlIGNhbid0XG4gICAgICAgICAqIGltbWVkaWF0ZWx5IGV4ZWN1dGUgdW5sZXNzIGV4cGxpY2l0bHkgcmVxdWVzdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kaXNhYmxlSW1tZWRpYXRlRXhlY3V0aW9uKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB1bmZ1bGZpbGxlZFN0ZXBzID0gc3RlcHMuZmlsdGVyKChzdGVwKSA9PiAhc3RlcC5mdWxmaWxsZWQpO1xuICAgICAgICBpZiAodW5mdWxmaWxsZWRTdGVwcy5sZW5ndGggIT09IDEpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IG9wID0gdW5mdWxmaWxsZWRTdGVwc1swXTtcbiAgICAgICAgaWYgKG9wICYmXG4gICAgICAgICAgICBvcC5vcCA9PT0gdHlwZXNfanNfMS5TdGVwT3BDb2RlLlN0ZXBQbGFubmVkXG4gICAgICAgIC8vIFRPRE8gV2UgbXVzdCBpbmRpdmlkdWFsbHkgY2hlY2sgcHJvcGVydGllcyBoZXJlIHRoYXQgd2UgZG8gbm90IHdhbnQgdG9cbiAgICAgICAgLy8gZXhlY3V0ZSBvbiwgc3VjaCBhcyByZXRyeSBjb3VudHMuIE5vdGhpbmcgZXhpc3RzIGhlcmUgdGhhdCBmYWxscyBpbiB0b1xuICAgICAgICAvLyB0aGlzIGNhc2UsIGJ1dCBzaG91bGQgYmUgYWNjb3VudGVkIGZvciB3aGVuIHdlIGFkZCB0aGVtLlxuICAgICAgICAvLyAmJiB0eXBlb2Ygb3Aub3B0cyA9PT0gXCJ1bmRlZmluZWRcIlxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBvcC5oYXNoZWRJZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBmaWx0ZXJOZXdTdGVwcyhmb3VuZFN0ZXBzKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJlcXVlc3RlZFJ1blN0ZXApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogR2F0aGVyIGFueSBzdGVwcyB0aGF0IGFyZW4ndCBtZW1vaXplZCBhbmQgcmVwb3J0IHRoZW0uXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBuZXdTdGVwcyA9IGZvdW5kU3RlcHMuZmlsdGVyKChzdGVwKSA9PiAhc3RlcC5mdWxmaWxsZWQpO1xuICAgICAgICBpZiAoIW5ld1N0ZXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXYXJuIGlmIHdlJ3ZlIGZvdW5kIG5ldyBzdGVwcyBidXQgaGF2ZW4ndCB5ZXQgc2VlbiBhbGwgcHJldmlvdXNcbiAgICAgICAgICogc3RlcHMuIFRoaXMgbWF5IGluZGljYXRlIHRoYXQgc3RlcCBwcmVzZW5jZSBpc24ndCBkZXRlcm1pbmF0ZS5cbiAgICAgICAgICovXG4gICAgICAgIGxldCBrbm93blN0ZXBzID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBzdGVwIG9mIGZvdW5kU3RlcHMpIHtcbiAgICAgICAgICAgIGlmIChzdGVwLmZ1bGZpbGxlZCkge1xuICAgICAgICAgICAgICAgIGtub3duU3RlcHMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmb3VuZEFsbENvbXBsZXRlZFN0ZXBzID0gdGhpcy5zdGF0ZS5zdGVwc1RvRnVsZmlsbCA9PT0ga25vd25TdGVwcztcbiAgICAgICAgaWYgKCFmb3VuZEFsbENvbXBsZXRlZFN0ZXBzKSB7XG4gICAgICAgICAgICAvLyBUT0RPIFRhZ1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCgwLCBlcnJvcnNfanNfMS5wcmV0dHlFcnJvcikoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwid2FyblwiLFxuICAgICAgICAgICAgICAgIHdoYXRIYXBwZW5lZDogXCJGdW5jdGlvbiBtYXkgYmUgaW5kZXRlcm1pbmF0ZVwiLFxuICAgICAgICAgICAgICAgIHdoeTogXCJXZSBmb3VuZCBuZXcgc3RlcHMgYmVmb3JlIHNlZWluZyBhbGwgcHJldmlvdXMgc3RlcHMsIHdoaWNoIG1heSBpbmRpY2F0ZSB0aGF0IHRoZSBmdW5jdGlvbiBpcyBub24tZGV0ZXJtaW5pc3RpYy5cIixcbiAgICAgICAgICAgICAgICBjb25zZXF1ZW5jZXM6IFwiVGhpcyBtYXkgY2F1c2UgdW5leHBlY3RlZCBiZWhhdmlvdXIgYXMgSW5uZ2VzdCBleGVjdXRlcyB5b3VyIGZ1bmN0aW9uLlwiLFxuICAgICAgICAgICAgICAgIHJlYXNzdXJhbmNlOiBcIlRoaXMgaXMgZXhwZWN0ZWQgaWYgYSBmdW5jdGlvbiBpcyB1cGRhdGVkIGluIHRoZSBtaWRkbGUgb2YgYSBydW4sIGJ1dCBtYXkgaW5kaWNhdGUgYSBidWcgaWYgbm90LlwiLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXZSdyZSBmaW5pc2hpbmcgdXA7IGxldCdzIHRyaWdnZXIgdGhlIGxhc3Qgb2YgdGhlIGhvb2tzLlxuICAgICAgICAgKi9cbiAgICAgICAgYXdhaXQgKChfYiA9IChfYSA9IHRoaXMuc3RhdGUuaG9va3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hZnRlck1lbW9pemF0aW9uKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSkpO1xuICAgICAgICBhd2FpdCAoKF9kID0gKF9jID0gdGhpcy5zdGF0ZS5ob29rcykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmJlZm9yZUV4ZWN1dGlvbikgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmNhbGwoX2MpKTtcbiAgICAgICAgYXdhaXQgKChfZiA9IChfZSA9IHRoaXMuc3RhdGUuaG9va3MpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5hZnRlckV4ZWN1dGlvbikgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmNhbGwoX2UpKTtcbiAgICAgICAgY29uc3Qgc3RlcExpc3QgPSBuZXdTdGVwcy5tYXAoKHN0ZXApID0+ICh7XG4gICAgICAgICAgICBkaXNwbGF5TmFtZTogc3RlcC5kaXNwbGF5TmFtZSxcbiAgICAgICAgICAgIG9wOiBzdGVwLm9wLFxuICAgICAgICAgICAgaWQ6IHN0ZXAuaGFzaGVkSWQsXG4gICAgICAgICAgICBuYW1lOiBzdGVwLm5hbWUsXG4gICAgICAgICAgICBvcHRzOiBzdGVwLm9wdHMsXG4gICAgICAgIH0pKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdlIGFsc28gcnVuIGBvblNlbmRFdmVudGAgbWlkZGxld2FyZSBob29rcyBhZ2FpbnN0IGBzdGVwLmludm9rZSgpYCBzdGVwc1xuICAgICAgICAgKiB0byBlbnN1cmUgdGhhdCB0aGVpciBgZGF0YWAgaXMgdHJhbnNmb3JtZWQgY29ycmVjdGx5LlxuICAgICAgICAgKi9cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNmb3JtTmV3U3RlcHMoc3RlcExpc3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2luZyBtaWRkbGV3YXJlLCB0cmFuc2Zvcm0gYW55IG5ld2x5LWZvdW5kIHN0ZXBzIGJlZm9yZSByZXR1cm5pbmcgdGhlbSB0b1xuICAgICAqIGFuIElubmdlc3QgU2VydmVyLlxuICAgICAqL1xuICAgIGFzeW5jIHRyYW5zZm9ybU5ld1N0ZXBzKHN0ZXBzKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChzdGVwcy5tYXAoYXN5bmMgKHN0ZXApID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZztcbiAgICAgICAgICAgIGlmIChzdGVwLm9wICE9PSB0eXBlc19qc18xLlN0ZXBPcENvZGUuSW52b2tlRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RlcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9uU2VuZEV2ZW50SG9va3MgPSBhd2FpdCAoMCwgSW5uZ2VzdE1pZGRsZXdhcmVfanNfMS5nZXRIb29rU3RhY2spKHRoaXMub3B0aW9ucy5mbltcIm1pZGRsZXdhcmVcIl0sIFwib25TZW5kRXZlbnRcIiwgdW5kZWZpbmVkLCB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtSW5wdXQ6IChwcmV2LCBvdXRwdXQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJldiksIG91dHB1dCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1PdXRwdXQ6IChwcmV2LCBvdXRwdXQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwcmV2LnJlc3VsdCksIG91dHB1dCA9PT0gbnVsbCB8fCBvdXRwdXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG91dHB1dC5yZXN1bHQpLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRm9yIGVhY2ggZXZlbnQgYmVpbmcgc2VudCwgY3JlYXRlIGEgbmV3IGBvblNlbmRFdmVudGAgaG9vayBzdGFjayB0b1xuICAgICAgICAgICAgICogcHJvY2VzcyBpdC4gV2UgZG8gdGhpcyBhcyBtaWRkbGV3YXJlIGhvb2tzIGFyZSBpbnRlbmRlZCB0byBydW4gb25jZVxuICAgICAgICAgICAgICogZHVyaW5nIGVhY2ggbGlmZWN5Y2xlIChvbkZ1bmN0aW9uUnVuIG9yIG9uU2VuZEV2ZW50KSBhbmQgaGVyZSwgYSBob29rXG4gICAgICAgICAgICAgKiBpcyBydW4gZm9yIGV2ZXJ5IHNpbmdsZSBldmVudC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBUaGlzIGlzIGRvbmUgYmVjYXVzZSBhIGRldmVsb3BlciBjYW4gdXNlIHRoaXMgaG9vayB0byBmaWx0ZXIgb3V0XG4gICAgICAgICAgICAgKiBldmVudHMgZW50aXJlbHk7IGlmIHdlIGJhdGNoIGFsbCBvZiB0aGUgZXZlbnRzIHRvZ2V0aGVyLCB3ZSBjYW4ndFxuICAgICAgICAgICAgICogdGVsbCB3aGljaCBvbmVzIHdlcmUgZmlsdGVyZWQgb3V0IGlmIHdlJ3JlIHByb2Nlc3NpbmcgPjEgaW52b2NhdGlvblxuICAgICAgICAgICAgICogaGVyZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtZWRQYXlsb2FkID0gYXdhaXQgKChfYSA9IG9uU2VuZEV2ZW50SG9va3MudHJhbnNmb3JtSW5wdXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKG9uU2VuZEV2ZW50SG9va3MsIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkczogW1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sICgoX2MgPSAoX2IgPSBzdGVwLm9wdHMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5wYXlsb2FkKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB7fSkpLCB7IG5hbWU6IGNvbnN0c19qc18xLmludGVybmFsRXZlbnRzLkZ1bmN0aW9uSW52b2tlZCB9KSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgY29uc3QgbmV3UGF5bG9hZCA9IElubmdlc3RTdGVwVG9vbHNfanNfMS5pbnZva2VQYXlsb2FkU2NoZW1hLnBhcnNlKChfZSA9IChfZCA9IHRyYW5zZm9ybWVkUGF5bG9hZCA9PT0gbnVsbCB8fCB0cmFuc2Zvcm1lZFBheWxvYWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRyYW5zZm9ybWVkUGF5bG9hZC5wYXlsb2FkcykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kWzBdKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiB7fSk7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdGVwKSwgeyBvcHRzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0ZXAub3B0cyksIHsgcGF5bG9hZDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAoKF9nID0gKF9mID0gc3RlcC5vcHRzKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YucGF5bG9hZCkgIT09IG51bGwgJiYgX2cgIT09IHZvaWQgMCA/IF9nIDoge30pKSwgbmV3UGF5bG9hZCkgfSkgfSk7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgYXN5bmMgZXhlY3V0ZVN0ZXAoeyBpZCwgbmFtZSwgb3B0cywgZm4sIGRpc3BsYXlOYW1lLCB9KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgICAgIChfYSA9IHRoaXMudGltZW91dCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNsZWFyKCk7XG4gICAgICAgIGF3YWl0ICgoX2MgPSAoX2IgPSB0aGlzLnN0YXRlLmhvb2tzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWZ0ZXJNZW1vaXphdGlvbikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhbGwoX2IpKTtcbiAgICAgICAgYXdhaXQgKChfZSA9IChfZCA9IHRoaXMuc3RhdGUuaG9va3MpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5iZWZvcmVFeGVjdXRpb24pID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5jYWxsKF9kKSk7XG4gICAgICAgIGNvbnN0IG91dGdvaW5nT3AgPSB7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIG9wOiB0eXBlc19qc18xLlN0ZXBPcENvZGUuU3RlcFJ1bixcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBvcHRzLFxuICAgICAgICAgICAgZGlzcGxheU5hbWUsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc3RhdGUuZXhlY3V0aW5nU3RlcCA9IG91dGdvaW5nT3A7XG4gICAgICAgIGNvbnN0IHN0b3JlID0gYXdhaXQgKDAsIGFsc19qc18xLmdldEFzeW5jQ3R4KSgpO1xuICAgICAgICBpZiAoc3RvcmUpIHtcbiAgICAgICAgICAgIHN0b3JlLmV4ZWN1dGluZ1N0ZXAgPSB7XG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgbmFtZTogZGlzcGxheU5hbWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVidWcoYGV4ZWN1dGluZyBzdGVwIFwiJHtpZH1cImApO1xuICAgICAgICByZXR1cm4gKCgwLCBwcm9taXNlc19qc18xLnJ1bkFzUHJvbWlzZSkoZm4pXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW1pc3VzZWQtcHJvbWlzZXNcbiAgICAgICAgICAgIC5maW5hbGx5KGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICBpZiAoc3RvcmUpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgc3RvcmUuZXhlY3V0aW5nU3RlcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0ICgoX2IgPSAoX2EgPSB0aGlzLnN0YXRlLmhvb2tzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWZ0ZXJFeGVjdXRpb24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3V0Z29pbmdPcCksIHsgZGF0YSB9KTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG91dGdvaW5nT3ApLCB7IG9wOiB0eXBlc19qc18xLlN0ZXBPcENvZGUuU3RlcEVycm9yLCBcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50XG4gICAgICAgICAgICAgICAgZXJyb3IgfSk7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnRzIGV4ZWN1dGlvbiBvZiB0aGUgdXNlcidzIGZ1bmN0aW9uLCBpbmNsdWRpbmcgdHJpZ2dlcmluZyBjaGVja3BvaW50c1xuICAgICAqIGFuZCBtaWRkbGV3YXJlIGhvb2tzIHdoZXJlIGFwcHJvcHJpYXRlLlxuICAgICAqL1xuICAgIGFzeW5jIHN0YXJ0RXhlY3V0aW9uKCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2c7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNdXRhdGUgaW5wdXQgYXMgbmVjY2Vzc2FyeSBiYXNlZCBvbiBtaWRkbGV3YXJlLlxuICAgICAgICAgKi9cbiAgICAgICAgYXdhaXQgdGhpcy50cmFuc2Zvcm1JbnB1dCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3RhcnQgdGhlIHRpbWVyIHRvIHRpbWUgb3V0IHRoZSBydW4gaWYgbmVlZGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdm9pZCAoKF9hID0gdGhpcy50aW1lb3V0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3RhcnQoKSk7XG4gICAgICAgIGF3YWl0ICgoX2MgPSAoX2IgPSB0aGlzLnN0YXRlLmhvb2tzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYmVmb3JlTWVtb2l6YXRpb24pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYWxsKF9iKSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB3ZSBoYWQgbm8gc3RhdGUgdG8gYmVnaW4gd2l0aCwgaW1tZWRpYXRlbHkgZW5kIHRoZSBtZW1vaXphdGlvbiBwaGFzZS5cbiAgICAgICAgICovXG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmFsbFN0YXRlVXNlZCgpKSB7XG4gICAgICAgICAgICBhd2FpdCAoKF9lID0gKF9kID0gdGhpcy5zdGF0ZS5ob29rcykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFmdGVyTWVtb2l6YXRpb24pID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5jYWxsKF9kKSk7XG4gICAgICAgICAgICBhd2FpdCAoKF9nID0gKF9mID0gdGhpcy5zdGF0ZS5ob29rcykgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmJlZm9yZUV4ZWN1dGlvbikgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLmNhbGwoX2YpKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVHJpZ2dlciB0aGUgdXNlcidzIGZ1bmN0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgKDAsIHByb21pc2VzX2pzXzEucnVuQXNQcm9taXNlKSgoKSA9PiB0aGlzLnVzZXJGblRvUnVuKHRoaXMuZm5BcmcpKVxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1taXN1c2VkLXByb21pc2VzXG4gICAgICAgICAgICAuZmluYWxseShhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICAgICAgICAgIGF3YWl0ICgoX2IgPSAoX2EgPSB0aGlzLnN0YXRlLmhvb2tzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWZ0ZXJNZW1vaXphdGlvbikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpKTtcbiAgICAgICAgICAgIGF3YWl0ICgoX2QgPSAoX2MgPSB0aGlzLnN0YXRlLmhvb2tzKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuYmVmb3JlRXhlY3V0aW9uKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuY2FsbChfYykpO1xuICAgICAgICAgICAgYXdhaXQgKChfZiA9IChfZSA9IHRoaXMuc3RhdGUuaG9va3MpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5hZnRlckV4ZWN1dGlvbikgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmNhbGwoX2UpKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50XG4gICAgICAgICAgICB0aGlzLnN0YXRlLnNldENoZWNrcG9pbnQoeyB0eXBlOiBcImZ1bmN0aW9uLXJlc29sdmVkXCIsIGRhdGEgfSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50XG4gICAgICAgICAgICB0aGlzLnN0YXRlLnNldENoZWNrcG9pbnQoeyB0eXBlOiBcImZ1bmN0aW9uLXJlamVjdGVkXCIsIGVycm9yIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNpbmcgbWlkZGxld2FyZSwgdHJhbnNmb3JtIGlucHV0IGJlZm9yZSBydW5uaW5nLlxuICAgICAqL1xuICAgIGFzeW5jIHRyYW5zZm9ybUlucHV0KCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBpbnB1dE11dGF0aW9ucyA9IGF3YWl0ICgoX2IgPSAoX2EgPSB0aGlzLnN0YXRlLmhvb2tzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudHJhbnNmb3JtSW5wdXQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCB7XG4gICAgICAgICAgICBjdHg6IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZm5BcmcpLFxuICAgICAgICAgICAgc3RlcHM6IE9iamVjdC52YWx1ZXModGhpcy5zdGF0ZS5zdGVwU3RhdGUpLFxuICAgICAgICAgICAgZm46IHRoaXMub3B0aW9ucy5mbixcbiAgICAgICAgICAgIHJlcUFyZ3M6IHRoaXMub3B0aW9ucy5yZXFBcmdzLFxuICAgICAgICB9KSk7XG4gICAgICAgIGlmIChpbnB1dE11dGF0aW9ucyA9PT0gbnVsbCB8fCBpbnB1dE11dGF0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5wdXRNdXRhdGlvbnMuY3R4KSB7XG4gICAgICAgICAgICB0aGlzLmZuQXJnID0gaW5wdXRNdXRhdGlvbnMuY3R4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnB1dE11dGF0aW9ucyA9PT0gbnVsbCB8fCBpbnB1dE11dGF0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5wdXRNdXRhdGlvbnMuc3RlcHMpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuc3RlcFN0YXRlID0gT2JqZWN0LmZyb21FbnRyaWVzKGlucHV0TXV0YXRpb25zLnN0ZXBzLm1hcCgoc3RlcCkgPT4gW3N0ZXAuaWQsIHN0ZXBdKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNpbmcgbWlkZGxld2FyZSwgdHJhbnNmb3JtIG91dHB1dCBiZWZvcmUgcmV0dXJuaW5nLlxuICAgICAqL1xuICAgIGFzeW5jIHRyYW5zZm9ybU91dHB1dChkYXRhT3JFcnJvcikge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IE9iamVjdC5hc3NpZ24oe30sIGRhdGFPckVycm9yKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHdlJ3ZlIGJlZW4gZ2l2ZW4gYW4gZXJyb3IgYW5kIGl0J3Mgb25lIHRoYXQgd2UganVzdCB0aHJldyBmcm9tIGEgc3RlcCxcbiAgICAgICAgICogd2Ugc2hvdWxkIHJldHVybiBhIGBOb25SZXRyaWFibGVFcnJvcmAgdG8gc3RvcCBleGVjdXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICBpZiAodHlwZW9mIG91dHB1dC5lcnJvciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgb3V0cHV0LmRhdGEgPSAoMCwgZXJyb3JzX2pzXzEuc2VyaWFsaXplRXJyb3IpKG91dHB1dC5lcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNTdGVwRXhlY3V0aW9uID0gQm9vbGVhbih0aGlzLnN0YXRlLmV4ZWN1dGluZ1N0ZXApO1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZE91dHB1dCA9IGF3YWl0ICgoX2IgPSAoX2EgPSB0aGlzLnN0YXRlLmhvb2tzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudHJhbnNmb3JtT3V0cHV0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwge1xuICAgICAgICAgICAgcmVzdWx0OiBPYmplY3QuYXNzaWduKHt9LCBvdXRwdXQpLFxuICAgICAgICAgICAgc3RlcDogdGhpcy5zdGF0ZS5leGVjdXRpbmdTdGVwLFxuICAgICAgICB9KSk7XG4gICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3V0cHV0KSwgdHJhbnNmb3JtZWRPdXRwdXQgPT09IG51bGwgfHwgdHJhbnNmb3JtZWRPdXRwdXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRyYW5zZm9ybWVkT3V0cHV0LnJlc3VsdCk7XG4gICAgICAgIGlmICghaXNTdGVwRXhlY3V0aW9uKSB7XG4gICAgICAgICAgICBhd2FpdCAoKF9kID0gKF9jID0gdGhpcy5zdGF0ZS5ob29rcykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmZpbmlzaGVkKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuY2FsbChfYywge1xuICAgICAgICAgICAgICAgIHJlc3VsdDogT2JqZWN0LmFzc2lnbih7fSwgKHR5cGVvZiBlcnJvciAhPT0gXCJ1bmRlZmluZWRcIiA/IHsgZXJyb3IgfSA6IHsgZGF0YSB9KSksXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBlcnJvciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBFbnN1cmUgd2UgZ2l2ZSBtaWRkbGV3YXJlIHRoZSBjaGFuY2UgdG8gZGVjaWRlIG9uIHJldHJpYWJsZSBiZWhhdmlvdXJcbiAgICAgICAgICAgICAqIGJ5IGxvb2tpbmcgYXQgdGhlIGVycm9yIHJldHVybmVkIGZyb20gb3V0cHV0IHRyYW5zZm9ybWF0aW9uLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBsZXQgcmV0cmlhYmxlID0gIShlcnJvciBpbnN0YW5jZW9mIE5vblJldHJpYWJsZUVycm9yX2pzXzEuTm9uUmV0cmlhYmxlRXJyb3IgfHwgZXJyb3IgaW5zdGFuY2VvZiBTdGVwRXJyb3JfanNfMS5TdGVwRXJyb3IpO1xuICAgICAgICAgICAgaWYgKHJldHJpYWJsZSAmJiBlcnJvciBpbnN0YW5jZW9mIFJldHJ5QWZ0ZXJFcnJvcl9qc18xLlJldHJ5QWZ0ZXJFcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHJpYWJsZSA9IGVycm9yLnJldHJ5QWZ0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzZXJpYWxpemVkRXJyb3IgPSAoMCwgZXJyb3JzX2pzXzEubWluaWZ5UHJldHR5RXJyb3IpKCgwLCBlcnJvcnNfanNfMS5zZXJpYWxpemVFcnJvcikoZXJyb3IpKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvbi1yZWplY3RlZFwiLFxuICAgICAgICAgICAgICAgIGN0eDogdGhpcy5mbkFyZyxcbiAgICAgICAgICAgICAgICBvcHM6IHRoaXMub3BzLFxuICAgICAgICAgICAgICAgIGVycm9yOiBzZXJpYWxpemVkRXJyb3IsXG4gICAgICAgICAgICAgICAgcmV0cmlhYmxlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvbi1yZXNvbHZlZFwiLFxuICAgICAgICAgICAgY3R4OiB0aGlzLmZuQXJnLFxuICAgICAgICAgICAgb3BzOiB0aGlzLm9wcyxcbiAgICAgICAgICAgIGRhdGE6ICgwLCBmdW5jdGlvbnNfanNfMS51bmRlZmluZWRUb051bGwpKGRhdGEpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjcmVhdGVFeGVjdXRpb25TdGF0ZSgpIHtcbiAgICAgICAgY29uc3QgZCA9ICgwLCBwcm9taXNlc19qc18xLmNyZWF0ZURlZmVycmVkUHJvbWlzZVdpdGhTdGFjaykoKTtcbiAgICAgICAgbGV0IGNoZWNrcG9pbnRSZXNvbHZlID0gZC5kZWZlcnJlZC5yZXNvbHZlO1xuICAgICAgICBjb25zdCBjaGVja3BvaW50UmVzdWx0cyA9IGQucmVzdWx0cztcbiAgICAgICAgY29uc3QgbG9vcCA9IChmdW5jdGlvbiAoY2xlYW5VcCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXMgPSAoeWllbGQgX19hd2FpdChjaGVja3BvaW50UmVzdWx0cy5uZXh0KCkpKS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KHJlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFuVXAgPT09IG51bGwgfHwgY2xlYW5VcCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2xlYW5VcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KSgoKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLnRpbWVvdXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbGVhcigpO1xuICAgICAgICAgICAgdm9pZCBjaGVja3BvaW50UmVzdWx0cy5yZXR1cm4oKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHN0ZXBzVG9GdWxmaWxsID0gT2JqZWN0LmtleXModGhpcy5vcHRpb25zLnN0ZXBTdGF0ZSkubGVuZ3RoO1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHtcbiAgICAgICAgICAgIHN0ZXBTdGF0ZTogdGhpcy5vcHRpb25zLnN0ZXBTdGF0ZSxcbiAgICAgICAgICAgIHN0ZXBzVG9GdWxmaWxsLFxuICAgICAgICAgICAgc3RlcHM6IG5ldyBNYXAoKSxcbiAgICAgICAgICAgIGxvb3AsXG4gICAgICAgICAgICBoYXNTdGVwczogQm9vbGVhbihzdGVwc1RvRnVsZmlsbCksXG4gICAgICAgICAgICBzdGVwQ29tcGxldGlvbk9yZGVyOiBbLi4udGhpcy5vcHRpb25zLnN0ZXBDb21wbGV0aW9uT3JkZXJdLFxuICAgICAgICAgICAgcmVtYWluaW5nU3RlcHNUb0JlU2VlbjogbmV3IFNldCh0aGlzLm9wdGlvbnMuc3RlcENvbXBsZXRpb25PcmRlciksXG4gICAgICAgICAgICBzZXRDaGVja3BvaW50OiAoY2hlY2twb2ludCkgPT4ge1xuICAgICAgICAgICAgICAgICh7IHJlc29sdmU6IGNoZWNrcG9pbnRSZXNvbHZlIH0gPSBjaGVja3BvaW50UmVzb2x2ZShjaGVja3BvaW50KSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWxsU3RhdGVVc2VkOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUucmVtYWluaW5nU3RlcHNUb0JlU2Vlbi5zaXplID09PSAwO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICBnZXQgb3BzKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKHRoaXMuc3RhdGUuc3RlcHMpO1xuICAgIH1cbiAgICBjcmVhdGVGbkFyZygpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBjb25zdCBzdGVwID0gdGhpcy5jcmVhdGVTdGVwVG9vbHMoKTtcbiAgICAgICAgbGV0IGZuQXJnID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMuZGF0YSksIHsgc3RlcCB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhhbmRsZSB1c2Ugb2YgdGhlIGBvbkZhaWx1cmVgIG9wdGlvbiBieSBkZXNlcmlhbGl6aW5nIHRoZSBlcnJvci5cbiAgICAgICAgICovXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaXNGYWlsdXJlSGFuZGxlcikge1xuICAgICAgICAgICAgY29uc3QgZXZlbnREYXRhID0gem9kXzEuelxuICAgICAgICAgICAgICAgIC5vYmplY3QoeyBlcnJvcjogdHlwZXNfanNfMS5qc29uRXJyb3JTY2hlbWEgfSlcbiAgICAgICAgICAgICAgICAucGFyc2UoKF9hID0gZm5BcmcuZXZlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kYXRhKTtcbiAgICAgICAgICAgIGZuQXJnID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBmbkFyZyksIHsgZXJyb3I6ICgwLCBlcnJvcnNfanNfMS5kZXNlcmlhbGl6ZUVycm9yKShldmVudERhdGEuZXJyb3IpIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoX2QgPSAoX2MgPSAoX2IgPSB0aGlzLm9wdGlvbnMpLnRyYW5zZm9ybUN0eCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhbGwoX2IsIGZuQXJnKSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogZm5Bcmc7XG4gICAgfVxuICAgIGNyZWF0ZVN0ZXBUb29scygpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbGlzdCBvZiBzdGVwcyB0aGF0IGhhdmUgYmVlbiBmb3VuZCBhbmQgYXJlIGJlaW5nIHJvbGxlZCB1cCBiZWZvcmUgYmVpbmdcbiAgICAgICAgICogcmVwb3J0ZWQgdG8gdGhlIGNvcmUgbG9vcC5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IGZvdW5kU3RlcHNUb1JlcG9ydCA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbWFwIG9mIHRoZSBzdWJzZXQgb2YgZm91bmQgc3RlcHMgdG8gcmVwb3J0IHRoYXQgaGF2ZSBub3QgeWV0IGJlZW5cbiAgICAgICAgICogaGFuZGxlZC4gVXNlZCBmb3IgZmFzdCBhY2Nlc3MgdG8gc3RlcHMgdGhhdCBuZWVkIHRvIGJlIGhhbmRsZWQgaW4gb3JkZXIuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCB1bmhhbmRsZWRGb3VuZFN0ZXBzVG9SZXBvcnQgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIG1hcCBvZiB0aGUgbGF0ZXN0IHNlcXVlbnRpYWwgc3RlcCBpbmRleGVzIGZvdW5kIGZvciBlYWNoIHN0ZXAgSUQuIFVzZWRcbiAgICAgICAgICogdG8gZW5zdXJlIHRoYXQgd2UgZG9uJ3QgaW5kZXggc3RlcHMgaW4gcGFyYWxsZWwuXG4gICAgICAgICAqXG4gICAgICAgICAqIE5vdGUgdGhhdCB0aGVzZSBtdXN0IGJlIHNlcXVlbnRpYWw7IGlmIHdlJ3ZlIHNlZW4gb3IgYXNzaWduZWQgYGE6MWAsXG4gICAgICAgICAqIGBhOjJgIGFuZCBgYTo0YCwgdGhlIGxhdGVzdCBzZXF1ZW50aWFsIHN0ZXAgaW5kZXggaXMgYDJgLlxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgZXhwZWN0ZWROZXh0U3RlcEluZGV4ZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHByb21pc2UgdGhhdCdzIHVzZWQgdG8gZW5zdXJlIHRoYXQgc3RlcCByZXBvcnRpbmcgY2Fubm90IGJlIHJ1biBtb3JlIHRoYW5cbiAgICAgICAgICogb25jZSBpbiBhIGdpdmVuIGFzeW5jaHJvbm91cyB0aW1lIHNwYW4uXG4gICAgICAgICAqL1xuICAgICAgICBsZXQgZm91bmRTdGVwc1JlcG9ydFByb21pc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHByb21pc2UgdGhhdCdzIHVzZWQgdG8gcmVwcmVzZW50IG1pZGRsZXdhcmUgaG9va3MgcnVubmluZyBiZWZvcmVcbiAgICAgICAgICogZXhlY3V0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IGJlZm9yZUV4ZWNIb29rc1Byb21pc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGhlbHBlciB1c2VkIHRvIHJlcG9ydCBzdGVwcyB0byB0aGUgY29yZSBsb29wLiBVc2VkIGFmdGVyIGFkZGluZyBhbiBpdGVtXG4gICAgICAgICAqIHRvIGBmb3VuZFN0ZXBzVG9SZXBvcnRgLlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgcmVwb3J0TmV4dFRpY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICAvLyBCZWluZyBleHBsaWNpdCBpbnN0ZWFkIG9mIHVzaW5nIGA/Pz1gIHRvIGFwcGVhc2UgVHlwZVNjcmlwdC5cbiAgICAgICAgICAgIGlmIChmb3VuZFN0ZXBzUmVwb3J0UHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvdW5kU3RlcHNSZXBvcnRQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldEltbWVkaWF0ZShyZXNvbHZlKSlcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBFbnN1cmUgdGhhdCB3ZSB3YWl0IGZvciB0aGlzIHByb21pc2UgdG8gcmVzb2x2ZSBiZWZvcmUgY29udGludWluZy5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIFRoZSBncm91cHMgaW4gd2hpY2ggc3RlcHMgYXJlIHJlcG9ydGVkIGNhbiBhZmZlY3QgaG93IHdlIGRldGVjdCBzb21lXG4gICAgICAgICAgICAgICAgICogbW9yZSBjb21wbGV4IGRldGVybWluaXNtIGlzc3VlcyBsaWtlIHBhcmFsbGVsIGluZGV4aW5nLiBUaGlzIHByb21pc2VcbiAgICAgICAgICAgICAgICAgKiBjYW4gcmVwcmVzZW50IG1pZGRsZXdhcmUgaG9va3MgYmVpbmcgcnVuIGVhcmx5LCBpbiB0aGUgbWlkZGxlIG9mXG4gICAgICAgICAgICAgICAgICogaW5nZXN0aW5nIHN0ZXBzIHRvIHJlcG9ydC5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEJlY2F1c2Ugb2YgdGhpcywgaXQncyBpbXBvcnRhbnQgd2Ugd2FpdCBmb3IgdGhpcyBtaWRkbGV3YXJlIHRvIHJlc29sdmVcbiAgICAgICAgICAgICAgICAgKiBiZWZvcmUgY29udGludWluZyB0byByZXBvcnQgc3RlcHMgdG8gZW5zdXJlIHRoYXQgYWxsIHN0ZXBzIGhhdmUgYVxuICAgICAgICAgICAgICAgICAqIGNoYW5jZSB0byBiZSByZXBvcnRlZCB0aHJvdWdob3V0IHRoaXMgYXN5bmNocm9ub3VzIGFjdGlvbi5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiBiZWZvcmVFeGVjSG9va3NQcm9taXNlKVxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBmb3VuZFN0ZXBzUmVwb3J0UHJvbWlzZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtoYXNoZWRJZCwgc3RlcF0gb2YgdW5oYW5kbGVkRm91bmRTdGVwc1RvUmVwb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGVwLmhhbmRsZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bmhhbmRsZWRGb3VuZFN0ZXBzVG9SZXBvcnQuZGVsZXRlKGhhc2hlZElkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGVwLmZ1bGZpbGxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kU3RlcHNUb1JlcG9ydC5kZWxldGUoc3RlcC5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kU3RlcHNUb1JlcG9ydC5zaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0ZXBzID0gWy4uLmZvdW5kU3RlcHNUb1JlcG9ydC52YWx1ZXMoKV07XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kU3RlcHNUb1JlcG9ydC5jbGVhcigpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdm9pZCB0aGlzLnN0YXRlLnNldENoZWNrcG9pbnQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdGVwcy1mb3VuZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RlcHM6IHN0ZXBzLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgaGVscGVyIHVzZWQgdG8gcHVzaCBhIHN0ZXAgdG8gdGhlIGxpc3Qgb2Ygc3RlcHMgdG8gcmVwb3J0LlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgcHVzaFN0ZXBUb1JlcG9ydCA9IChzdGVwKSA9PiB7XG4gICAgICAgICAgICBmb3VuZFN0ZXBzVG9SZXBvcnQuc2V0KHN0ZXAuaWQsIHN0ZXApO1xuICAgICAgICAgICAgdW5oYW5kbGVkRm91bmRTdGVwc1RvUmVwb3J0LnNldChzdGVwLmhhc2hlZElkLCBzdGVwKTtcbiAgICAgICAgICAgIHJlcG9ydE5leHRUaWNrKCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHN0ZXBIYW5kbGVyID0gYXN5bmMgKHsgYXJncywgbWF0Y2hPcCwgb3B0cywgfSkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICAgICAgYXdhaXQgYmVmb3JlRXhlY0hvb2tzUHJvbWlzZTtcbiAgICAgICAgICAgIGNvbnN0IHN0ZXBPcHRpb25zID0gKDAsIElubmdlc3RTdGVwVG9vbHNfanNfMS5nZXRTdGVwT3B0aW9ucykoYXJnc1swXSk7XG4gICAgICAgICAgICBjb25zdCBvcElkID0gbWF0Y2hPcChzdGVwT3B0aW9ucywgLi4uYXJncy5zbGljZSgxKSk7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5leGVjdXRpbmdTdGVwKSB7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogSWYgYSBzdGVwIGlzIGZvdW5kIGFmdGVyIGFzeW5jaHJvbm91cyBhY3Rpb25zIGR1cmluZyBhbm90aGVyIHN0ZXAnc1xuICAgICAgICAgICAgICAgICAqIGV4ZWN1dGlvbiwgZXZlcnl0aGluZyBpcyBmaW5lLiBUaGUgcHJvYmxlbSBoZXJlIGlzIGlmIHdlJ3ZlIGZvdW5kXG4gICAgICAgICAgICAgICAgICogdGhhdCBhIHN0ZXAgbmVzdGVkIGluc2lkZSBhbm90aGVyIGEgc3RlcCwgd2hpY2ggaXMgc29tZXRoaW5nIHdlIGRvbid0XG4gICAgICAgICAgICAgICAgICogc3VwcG9ydCBhdCB0aGUgdGltZSBvZiB3cml0aW5nLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogSW4gdGhpcyBjYXNlLCB3ZSBjb3VsZCB1c2Ugc29tZXRoaW5nIGxpa2UgQXN5bmMgSG9va3MgdG8gdW5kZXJzdGFuZFxuICAgICAgICAgICAgICAgICAqIGhvdyB0aGUgc3RlcCBpcyBiZWluZyB0cmlnZ2VyZWQsIHRob3VnaCB0aGlzIGlzbid0IGF2YWlsYWJsZSBpbiBhbGxcbiAgICAgICAgICAgICAgICAgKiBlbnZpcm9ubWVudHMuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBUaGVyZWZvcmUsIHdlJ2xsIG9ubHkgc2hvdyBhIHdhcm5pbmcgaGVyZSB0byBpbmRpY2F0ZSB0aGF0IHRoaXMgaXNcbiAgICAgICAgICAgICAgICAgKiBwb3RlbnRpYWxseSBhbiBpc3N1ZS5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oKDAsIGVycm9yc19qc18xLnByZXR0eUVycm9yKSh7XG4gICAgICAgICAgICAgICAgICAgIHdoYXRIYXBwZW5lZDogYFdlIGRldGVjdGVkIHRoYXQgeW91IGhhdmUgbmVzdGVkIFxcYHN0ZXAuKlxcYCB0b29saW5nIGluIFxcYCR7KF9hID0gb3BJZC5kaXNwbGF5TmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogb3BJZC5pZH1cXGBgLFxuICAgICAgICAgICAgICAgICAgICBjb25zZXF1ZW5jZXM6IFwiTmVzdGluZyBgc3RlcC4qYCB0b29saW5nIGlzIG5vdCBzdXBwb3J0ZWQuXCIsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwid2FyblwiLFxuICAgICAgICAgICAgICAgICAgICByZWFzc3VyYW5jZTogXCJJdCdzIHBvc3NpYmxlIHRvIHNlZSB0aGlzIHdhcm5pbmcgaWYgc3RlcHMgYXJlIHNlcGFyYXRlZCBieSByZWd1bGFyIGFzeW5jaHJvbm91cyBjYWxscywgd2hpY2ggaXMgZmluZS5cIixcbiAgICAgICAgICAgICAgICAgICAgc3RhY2s6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHRvRml4Tm93OiBcIk1ha2Ugc3VyZSB5b3UncmUgbm90IHVzaW5nIGBzdGVwLipgIHRvb2xpbmcgaW5zaWRlIG9mIG90aGVyIGBzdGVwLipgIHRvb2xpbmcuIElmIHlvdSBuZWVkIHRvIGNvbXBvc2Ugc3RlcHMgdG9nZXRoZXIsIHlvdSBjYW4gY3JlYXRlIGEgbmV3IGFzeW5jIGZ1bmN0aW9uIGFuZCBjYWxsIGl0IGZyb20gd2l0aGluIHlvdXIgc3RlcCBmdW5jdGlvbiwgb3IgdXNlIHByb21pc2UgY2hhaW5pbmcuXCIsXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IGVycm9yc19qc18xLkVyckNvZGUuTkVTVElOR19TVEVQUyxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5zdGVwcy5oYXMob3BJZC5pZCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbElkID0gb3BJZC5pZDtcbiAgICAgICAgICAgICAgICBjb25zdCBleHBlY3RlZE5leHRJbmRleCA9IChfYiA9IGV4cGVjdGVkTmV4dFN0ZXBJbmRleGVzLmdldChvcmlnaW5hbElkKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gZXhwZWN0ZWROZXh0SW5kZXg7OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3SWQgPSBvcmlnaW5hbElkICsgSW5uZ2VzdFN0ZXBUb29sc19qc18xLlNURVBfSU5ERVhJTkdfU1VGRklYICsgaTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnN0YXRlLnN0ZXBzLmhhcyhuZXdJZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkTmV4dFN0ZXBJbmRleGVzLnNldChvcmlnaW5hbElkLCBpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcElkLmlkID0gbmV3SWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgcHJvbWlzZSwgcmVzb2x2ZSwgcmVqZWN0IH0gPSAoMCwgcHJvbWlzZXNfanNfMS5jcmVhdGVEZWZlcnJlZFByb21pc2UpKCk7XG4gICAgICAgICAgICBjb25zdCBoYXNoZWRJZCA9IGV4cG9ydHMuX2ludGVybmFscy5oYXNoSWQob3BJZC5pZCk7XG4gICAgICAgICAgICBjb25zdCBzdGVwU3RhdGUgPSB0aGlzLnN0YXRlLnN0ZXBTdGF0ZVtoYXNoZWRJZF07XG4gICAgICAgICAgICBsZXQgaXNGdWxmaWxsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChzdGVwU3RhdGUpIHtcbiAgICAgICAgICAgICAgICBzdGVwU3RhdGUuc2VlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5yZW1haW5pbmdTdGVwc1RvQmVTZWVuLmRlbGV0ZShoYXNoZWRJZCk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzdGVwU3RhdGUuaW5wdXQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNGdWxmaWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBleHRyYU9wdHM7XG4gICAgICAgICAgICBsZXQgZm5BcmdzID0gWy4uLmFyZ3NdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAoc3RlcFN0YXRlID09PSBudWxsIHx8IHN0ZXBTdGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3RlcFN0YXRlLmlucHV0KSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkoc3RlcFN0YXRlLmlucHV0KSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAob3BJZC5vcCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBgc3RlcC5ydW4oKWAgaGFzIGl0cyBmdW5jdGlvbiBpbnB1dCBhZmZlY3RlZFxuICAgICAgICAgICAgICAgICAgICBjYXNlIHR5cGVzX2pzXzEuU3RlcE9wQ29kZS5TdGVwUGxhbm5lZDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgZm5BcmdzID0gWy4uLmFyZ3Muc2xpY2UoMCwgMiksIC4uLnN0ZXBTdGF0ZS5pbnB1dF07XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBleHRyYU9wdHMgPSB7IGlucHV0OiBbLi4uc3RlcFN0YXRlLmlucHV0XSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gYHN0ZXAuYWkuaW5mZXIoKWAgaGFzIGl0cyBib2R5IGFmZmVjdGVkXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgdHlwZXNfanNfMS5TdGVwT3BDb2RlLkFpR2F0ZXdheToge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFPcHRzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKHR5cGVvZiAoKF9jID0gb3BJZC5vcHRzKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuYm9keSkgPT09IFwib2JqZWN0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBPYmplY3QuYXNzaWduKHt9LCBvcElkLm9wdHMuYm9keSkgOiB7fSkpLCBzdGVwU3RhdGUuaW5wdXRbMF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3RlcCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3BJZCksIHsgb3B0czogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcElkLm9wdHMpLCBleHRyYU9wdHMpLCByYXdBcmdzOiBmbkFyZ3MsIC8vIFRPRE8gV2hhdCBpcyB0aGUgcmlnaHQgdmFsdWUgaGVyZT8gU2hvdWxkIHRoaXMgYmUgcmF3IGFyZ3Mgd2l0aG91dCBhZmZlY3RlZCBpbnB1dD9cbiAgICAgICAgICAgICAgICBoYXNoZWRJZCwgaW5wdXQ6IHN0ZXBTdGF0ZSA9PT0gbnVsbCB8fCBzdGVwU3RhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN0ZXBTdGF0ZS5pbnB1dCwgXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnRcbiAgICAgICAgICAgICAgICBmbjogKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5mbikgPyAoKSA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IG9wdHMuZm4pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKG9wdHMsIC4uLmZuQXJncyk7IH0gOiB1bmRlZmluZWQsIHByb21pc2UsIGZ1bGZpbGxlZDogaXNGdWxmaWxsZWQsIGhhc1N0ZXBTdGF0ZTogQm9vbGVhbihzdGVwU3RhdGUpLCBkaXNwbGF5TmFtZTogKF9kID0gb3BJZC5kaXNwbGF5TmFtZSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogb3BJZC5pZCwgaGFuZGxlZDogZmFsc2UsIGhhbmRsZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RlcC5oYW5kbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RlcC5oYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRnVsZmlsbGVkICYmIHN0ZXBTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RlcFN0YXRlLmZ1bGZpbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGb3Igc29tZSBleGVjdXRpb24gc2NlbmFyaW9zIHN1Y2ggYXMgdGVzdGluZywgYGRhdGFgLCBgZXJyb3JgLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIGBpbnB1dGAgbWF5IGJlIGBQcm9taXNlc2AuIFRoaXMgY291bGQgYWxzbyBiZSB0aGUgY2FzZSBmb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZ1dHVyZSBtaWRkbGV3YXJlIGFwcGxpY2F0aW9ucy4gRm9yIHRoaXMgcmVhc29uLCB3ZSdsbCBtYWtlIHN1cmVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSB2YWx1ZXMgYXJlIGZ1bGx5IHJlc29sdmVkIGJlZm9yZSBjb250aW51aW5nLlxuICAgICAgICAgICAgICAgICAgICAgICAgdm9pZCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RlcFN0YXRlLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RlcFN0YXRlLmVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXBTdGF0ZS5pbnB1dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RlcFN0YXRlLmRhdGEgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShzdGVwU3RhdGUuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnJlY2VudGx5UmVqZWN0ZWRTdGVwRXJyb3IgPSBuZXcgU3RlcEVycm9yX2pzXzEuU3RlcEVycm9yKG9wSWQuaWQsIHN0ZXBTdGF0ZS5lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdCh0aGlzLnN0YXRlLnJlY2VudGx5UmVqZWN0ZWRTdGVwRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0gfSk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLnN0ZXBzLnNldChvcElkLmlkLCBzdGVwKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuaGFzU3RlcHMgPSB0cnVlO1xuICAgICAgICAgICAgcHVzaFN0ZXBUb1JlcG9ydChzdGVwKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgdGhpcyBpcyB0aGUgbGFzdCBwaWVjZSBvZiBzdGF0ZSB3ZSBoYWQsIHdlJ3ZlIG5vdyBmaW5pc2hlZFxuICAgICAgICAgICAgICogbWVtb2l6aW5nLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoIWJlZm9yZUV4ZWNIb29rc1Byb21pc2UgJiYgdGhpcy5zdGF0ZS5hbGxTdGF0ZVVzZWQoKSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IChiZWZvcmVFeGVjSG9va3NQcm9taXNlID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCAoKF9iID0gKF9hID0gdGhpcy5zdGF0ZS5ob29rcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFmdGVyTWVtb2l6YXRpb24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKSk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0ICgoX2QgPSAoX2MgPSB0aGlzLnN0YXRlLmhvb2tzKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuYmVmb3JlRXhlY3V0aW9uKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuY2FsbChfYykpO1xuICAgICAgICAgICAgICAgIH0pKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiAoMCwgSW5uZ2VzdFN0ZXBUb29sc19qc18xLmNyZWF0ZVN0ZXBUb29scykodGhpcy5vcHRpb25zLmNsaWVudCwgdGhpcywgc3RlcEhhbmRsZXIpO1xuICAgIH1cbiAgICBnZXRVc2VyRm5Ub1J1bigpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuaXNGYWlsdXJlSGFuZGxlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5mbltcImZuXCJdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmZuW1wib25GYWlsdXJlRm5cIl0pIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU29tZWhvdywgd2UndmUgZW5kZWQgdXAgZGV0ZWN0aW5nIHRoYXQgdGhpcyBpcyBhIGZhaWx1cmUgaGFuZGxlciBidXRcbiAgICAgICAgICAgICAqIGRvZXNuJ3QgaGF2ZSBhbiBgb25GYWlsdXJlYCBmdW5jdGlvbi4gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBmdW5jdGlvbiBgb25GYWlsdXJlYCBoYW5kbGVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZm5bXCJvbkZhaWx1cmVGblwiXTtcbiAgICB9XG4gICAgaW5pdGlhbGl6ZVRpbWVyKHN0YXRlKSB7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLnJlcXVlc3RlZFJ1blN0ZXApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRpbWVvdXQgPSAoMCwgcHJvbWlzZXNfanNfMS5jcmVhdGVUaW1lb3V0UHJvbWlzZSkodGhpcy50aW1lb3V0RHVyYXRpb24pO1xuICAgICAgICB2b2lkIHRoaXMudGltZW91dC50aGVuKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgICAgICAgYXdhaXQgKChfYiA9IChfYSA9IHRoaXMuc3RhdGUuaG9va3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hZnRlck1lbW9pemF0aW9uKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSkpO1xuICAgICAgICAgICAgYXdhaXQgKChfZCA9IChfYyA9IHRoaXMuc3RhdGUuaG9va3MpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5iZWZvcmVFeGVjdXRpb24pID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jYWxsKF9jKSk7XG4gICAgICAgICAgICBhd2FpdCAoKF9mID0gKF9lID0gdGhpcy5zdGF0ZS5ob29rcykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmFmdGVyRXhlY3V0aW9uKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuY2FsbChfZSkpO1xuICAgICAgICAgICAgc3RhdGUuc2V0Q2hlY2twb2ludCh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJzdGVwLW5vdC1mb3VuZFwiLFxuICAgICAgICAgICAgICAgIHN0ZXA6IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHRoaXMub3B0aW9ucy5yZXF1ZXN0ZWRSdW5TdGVwLFxuICAgICAgICAgICAgICAgICAgICBvcDogdHlwZXNfanNfMS5TdGVwT3BDb2RlLlN0ZXBOb3RGb3VuZCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBpbml0aWFsaXplTWlkZGxld2FyZSgpIHtcbiAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5vcHRpb25zLmRhdGE7XG4gICAgICAgIGNvbnN0IGhvb2tzID0gYXdhaXQgKDAsIElubmdlc3RNaWRkbGV3YXJlX2pzXzEuZ2V0SG9va1N0YWNrKSh0aGlzLm9wdGlvbnMuZm5bXCJtaWRkbGV3YXJlXCJdLCBcIm9uRnVuY3Rpb25SdW5cIiwge1xuICAgICAgICAgICAgY3R4LFxuICAgICAgICAgICAgZm46IHRoaXMub3B0aW9ucy5mbixcbiAgICAgICAgICAgIHN0ZXBzOiBPYmplY3QudmFsdWVzKHRoaXMub3B0aW9ucy5zdGVwU3RhdGUpLFxuICAgICAgICAgICAgcmVxQXJnczogdGhpcy5vcHRpb25zLnJlcUFyZ3MsXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybUlucHV0OiAocHJldiwgb3V0cHV0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4OiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHByZXYuY3R4KSwgb3V0cHV0ID09PSBudWxsIHx8IG91dHB1dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3V0cHV0LmN0eCksXG4gICAgICAgICAgICAgICAgICAgIGZuOiB0aGlzLm9wdGlvbnMuZm4sXG4gICAgICAgICAgICAgICAgICAgIHN0ZXBzOiBwcmV2LnN0ZXBzLm1hcCgoc3RlcCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0ZXApLCAoX2EgPSBvdXRwdXQgPT09IG51bGwgfHwgb3V0cHV0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvdXRwdXQuc3RlcHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtpXSkpO1xuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgcmVxQXJnczogcHJldi5yZXFBcmdzLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHJhbnNmb3JtT3V0cHV0OiAocHJldiwgb3V0cHV0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHByZXYucmVzdWx0KSwgb3V0cHV0ID09PSBudWxsIHx8IG91dHB1dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3V0cHV0LnJlc3VsdCksXG4gICAgICAgICAgICAgICAgICAgIHN0ZXA6IHByZXYuc3RlcCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBob29rcztcbiAgICB9XG59XG5jb25zdCBoYXNoSWQgPSAoaWQpID0+IHtcbiAgICByZXR1cm4gKDAsIGhhc2hfanNfMS5zaGExKSgpLnVwZGF0ZShpZCkuZGlnZXN0KFwiaGV4XCIpO1xufTtcbmNvbnN0IGhhc2hPcCA9IChvcCkgPT4ge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wKSwgeyBpZDogaGFzaElkKG9wLmlkKSB9KTtcbn07XG4vKipcbiAqIEV4cG9ydGVkIGZvciB0ZXN0aW5nLlxuICovXG5leHBvcnRzLl9pbnRlcm5hbHMgPSB7IGhhc2hPcCwgaGFzaElkIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD12Mi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/execution/v2.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/experimental.js":
/*!**********************************************!*\
  !*** ./node_modules/inngest/experimental.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InngestSpanProcessor = exports.otelMiddleware = exports.getAsyncCtx = void 0;\n// AsyncLocalStorage\nvar als_js_1 = __webpack_require__(/*! ./components/execution/als.js */ \"(rsc)/./node_modules/inngest/components/execution/als.js\");\nObject.defineProperty(exports, \"getAsyncCtx\", ({ enumerable: true, get: function () { return als_js_1.getAsyncCtx; } }));\n// OpenTelemetry\nvar middleware_js_1 = __webpack_require__(/*! ./components/execution/otel/middleware.js */ \"(rsc)/./node_modules/inngest/components/execution/otel/middleware.js\");\nObject.defineProperty(exports, \"otelMiddleware\", ({ enumerable: true, get: function () { return middleware_js_1.otelMiddleware; } }));\nvar processor_js_1 = __webpack_require__(/*! ./components/execution/otel/processor.js */ \"(rsc)/./node_modules/inngest/components/execution/otel/processor.js\");\nObject.defineProperty(exports, \"InngestSpanProcessor\", ({ enumerable: true, get: function () { return processor_js_1.PublicInngestSpanProcessor; } }));\n//# sourceMappingURL=experimental.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9leHBlcmltZW50YWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNEJBQTRCLEdBQUcsc0JBQXNCLEdBQUcsbUJBQW1CO0FBQzNFO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLCtGQUErQjtBQUN0RCwrQ0FBOEMsRUFBRSxxQ0FBcUMsZ0NBQWdDLEVBQUM7QUFDdEg7QUFDQSxzQkFBc0IsbUJBQU8sQ0FBQyx1SEFBMkM7QUFDekUsa0RBQWlELEVBQUUscUNBQXFDLDBDQUEwQyxFQUFDO0FBQ25JLHFCQUFxQixtQkFBTyxDQUFDLHFIQUEwQztBQUN2RSx3REFBdUQsRUFBRSxxQ0FBcUMscURBQXFELEVBQUM7QUFDcEoiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aXZlLXZpYmUtYWktbmV4dC8uL25vZGVfbW9kdWxlcy9pbm5nZXN0L2V4cGVyaW1lbnRhbC5qcz9kMDgyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Jbm5nZXN0U3BhblByb2Nlc3NvciA9IGV4cG9ydHMub3RlbE1pZGRsZXdhcmUgPSBleHBvcnRzLmdldEFzeW5jQ3R4ID0gdm9pZCAwO1xuLy8gQXN5bmNMb2NhbFN0b3JhZ2VcbnZhciBhbHNfanNfMSA9IHJlcXVpcmUoXCIuL2NvbXBvbmVudHMvZXhlY3V0aW9uL2Fscy5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldEFzeW5jQ3R4XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhbHNfanNfMS5nZXRBc3luY0N0eDsgfSB9KTtcbi8vIE9wZW5UZWxlbWV0cnlcbnZhciBtaWRkbGV3YXJlX2pzXzEgPSByZXF1aXJlKFwiLi9jb21wb25lbnRzL2V4ZWN1dGlvbi9vdGVsL21pZGRsZXdhcmUuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJvdGVsTWlkZGxld2FyZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWlkZGxld2FyZV9qc18xLm90ZWxNaWRkbGV3YXJlOyB9IH0pO1xudmFyIHByb2Nlc3Nvcl9qc18xID0gcmVxdWlyZShcIi4vY29tcG9uZW50cy9leGVjdXRpb24vb3RlbC9wcm9jZXNzb3IuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbm5nZXN0U3BhblByb2Nlc3NvclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvY2Vzc29yX2pzXzEuUHVibGljSW5uZ2VzdFNwYW5Qcm9jZXNzb3I7IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1leHBlcmltZW50YWwuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/experimental.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/helpers/ServerTiming.js":
/*!******************************************************!*\
  !*** ./node_modules/inngest/helpers/ServerTiming.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ServerTiming = void 0;\nconst promises_js_1 = __webpack_require__(/*! ./promises.js */ \"(rsc)/./node_modules/inngest/helpers/promises.js\");\n/**\n * A class to manage timing functions and arbitrary periods of time before\n * generating a `Server-Timing` header for use in HTTP responses.\n *\n * This is a very simple implementation that does not support nested timings or\n * fractions of a millisecond.\n */\nclass ServerTiming {\n    constructor() {\n        this.timings = {};\n    }\n    /**\n     * Start a timing. Returns a function that, when called, will stop the timing\n     * and add it to the header.\n     */\n    start(name, description) {\n        if (!this.timings[name]) {\n            this.timings[name] = {\n                description: description !== null && description !== void 0 ? description : \"\",\n                timers: [],\n            };\n        }\n        const index = this.timings[name].timers.push({ start: Date.now() }) - 1;\n        return () => {\n            const target = this.timings[name];\n            if (!target) {\n                return console.warn(`Timing \"${name}\" does not exist`);\n            }\n            const timer = target.timers[index];\n            if (!timer) {\n                return console.warn(`Timer ${index} for timing \"${name}\" does not exist`);\n            }\n            timer.end = Date.now();\n        };\n    }\n    /**\n     * Add a piece of arbitrary, untimed information to the header. Common use\n     * cases would be cache misses.\n     *\n     * @example\n     * ```\n     * timer.append(\"cache\", \"miss\");\n     * ```\n     */\n    append(key, value) {\n        this.timings[key] = {\n            description: value,\n            timers: [],\n        };\n    }\n    /**\n     * Wrap a function in a timing. The timing will be stopped and added to the\n     * header when the function resolves or rejects.\n     *\n     * The return value of the function will be returned from this function.\n     */\n    async wrap(name, fn, description) {\n        const stop = this.start(name, description);\n        try {\n            return (await (0, promises_js_1.runAsPromise)(fn));\n        }\n        finally {\n            stop();\n        }\n    }\n    /**\n     * Generate the `Server-Timing` header.\n     */\n    getHeader() {\n        const entries = Object.entries(this.timings).reduce((acc, [name, { description, timers }]) => {\n            /**\n             * Ignore timers that had no end.\n             */\n            const hasTimersWithEnd = timers.some((timer) => timer.end);\n            if (!hasTimersWithEnd) {\n                return acc;\n            }\n            const dur = timers.reduce((acc, { start, end }) => {\n                if (!start || !end)\n                    return acc;\n                return acc + (end - start);\n            }, 0);\n            const entry = [\n                name,\n                description ? `desc=\"${description}\"` : \"\",\n                dur ? `dur=${dur}` : \"\",\n            ]\n                .filter(Boolean)\n                .join(\";\");\n            return [...acc, entry];\n        }, []);\n        return entries.join(\", \");\n    }\n}\nexports.ServerTiming = ServerTiming;\n//# sourceMappingURL=ServerTiming.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL1NlcnZlclRpbWluZy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0I7QUFDcEIsc0JBQXNCLG1CQUFPLENBQUMsdUVBQWU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsbUJBQW1CO0FBQzFFO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxLQUFLO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxPQUFPLGNBQWMsS0FBSztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLHFCQUFxQjtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxZQUFZO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsdUNBQXVDLFlBQVk7QUFDbkQsNkJBQTZCLElBQUk7QUFDakM7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aXZlLXZpYmUtYWktbmV4dC8uL25vZGVfbW9kdWxlcy9pbm5nZXN0L2hlbHBlcnMvU2VydmVyVGltaW5nLmpzPzUyZjkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNlcnZlclRpbWluZyA9IHZvaWQgMDtcbmNvbnN0IHByb21pc2VzX2pzXzEgPSByZXF1aXJlKFwiLi9wcm9taXNlcy5qc1wiKTtcbi8qKlxuICogQSBjbGFzcyB0byBtYW5hZ2UgdGltaW5nIGZ1bmN0aW9ucyBhbmQgYXJiaXRyYXJ5IHBlcmlvZHMgb2YgdGltZSBiZWZvcmVcbiAqIGdlbmVyYXRpbmcgYSBgU2VydmVyLVRpbWluZ2AgaGVhZGVyIGZvciB1c2UgaW4gSFRUUCByZXNwb25zZXMuXG4gKlxuICogVGhpcyBpcyBhIHZlcnkgc2ltcGxlIGltcGxlbWVudGF0aW9uIHRoYXQgZG9lcyBub3Qgc3VwcG9ydCBuZXN0ZWQgdGltaW5ncyBvclxuICogZnJhY3Rpb25zIG9mIGEgbWlsbGlzZWNvbmQuXG4gKi9cbmNsYXNzIFNlcnZlclRpbWluZyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMudGltaW5ncyA9IHt9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydCBhIHRpbWluZy4gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLCB3aWxsIHN0b3AgdGhlIHRpbWluZ1xuICAgICAqIGFuZCBhZGQgaXQgdG8gdGhlIGhlYWRlci5cbiAgICAgKi9cbiAgICBzdGFydChuYW1lLCBkZXNjcmlwdGlvbikge1xuICAgICAgICBpZiAoIXRoaXMudGltaW5nc1tuYW1lXSkge1xuICAgICAgICAgICAgdGhpcy50aW1pbmdzW25hbWVdID0ge1xuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbiAhPT0gbnVsbCAmJiBkZXNjcmlwdGlvbiAhPT0gdm9pZCAwID8gZGVzY3JpcHRpb24gOiBcIlwiLFxuICAgICAgICAgICAgICAgIHRpbWVyczogW10sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy50aW1pbmdzW25hbWVdLnRpbWVycy5wdXNoKHsgc3RhcnQ6IERhdGUubm93KCkgfSkgLSAxO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy50aW1pbmdzW25hbWVdO1xuICAgICAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKGBUaW1pbmcgXCIke25hbWV9XCIgZG9lcyBub3QgZXhpc3RgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRpbWVyID0gdGFyZ2V0LnRpbWVyc1tpbmRleF07XG4gICAgICAgICAgICBpZiAoIXRpbWVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybihgVGltZXIgJHtpbmRleH0gZm9yIHRpbWluZyBcIiR7bmFtZX1cIiBkb2VzIG5vdCBleGlzdGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGltZXIuZW5kID0gRGF0ZS5ub3coKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGEgcGllY2Ugb2YgYXJiaXRyYXJ5LCB1bnRpbWVkIGluZm9ybWF0aW9uIHRvIHRoZSBoZWFkZXIuIENvbW1vbiB1c2VcbiAgICAgKiBjYXNlcyB3b3VsZCBiZSBjYWNoZSBtaXNzZXMuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYFxuICAgICAqIHRpbWVyLmFwcGVuZChcImNhY2hlXCIsIFwibWlzc1wiKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhcHBlbmQoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnRpbWluZ3Nba2V5XSA9IHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiB2YWx1ZSxcbiAgICAgICAgICAgIHRpbWVyczogW10sXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyYXAgYSBmdW5jdGlvbiBpbiBhIHRpbWluZy4gVGhlIHRpbWluZyB3aWxsIGJlIHN0b3BwZWQgYW5kIGFkZGVkIHRvIHRoZVxuICAgICAqIGhlYWRlciB3aGVuIHRoZSBmdW5jdGlvbiByZXNvbHZlcyBvciByZWplY3RzLlxuICAgICAqXG4gICAgICogVGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZnVuY3Rpb24gd2lsbCBiZSByZXR1cm5lZCBmcm9tIHRoaXMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgYXN5bmMgd3JhcChuYW1lLCBmbiwgZGVzY3JpcHRpb24pIHtcbiAgICAgICAgY29uc3Qgc3RvcCA9IHRoaXMuc3RhcnQobmFtZSwgZGVzY3JpcHRpb24pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIChhd2FpdCAoMCwgcHJvbWlzZXNfanNfMS5ydW5Bc1Byb21pc2UpKGZuKSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBzdG9wKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgdGhlIGBTZXJ2ZXItVGltaW5nYCBoZWFkZXIuXG4gICAgICovXG4gICAgZ2V0SGVhZGVyKCkge1xuICAgICAgICBjb25zdCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXModGhpcy50aW1pbmdzKS5yZWR1Y2UoKGFjYywgW25hbWUsIHsgZGVzY3JpcHRpb24sIHRpbWVycyB9XSkgPT4ge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZ25vcmUgdGltZXJzIHRoYXQgaGFkIG5vIGVuZC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3QgaGFzVGltZXJzV2l0aEVuZCA9IHRpbWVycy5zb21lKCh0aW1lcikgPT4gdGltZXIuZW5kKTtcbiAgICAgICAgICAgIGlmICghaGFzVGltZXJzV2l0aEVuZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkdXIgPSB0aW1lcnMucmVkdWNlKChhY2MsIHsgc3RhcnQsIGVuZCB9KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFzdGFydCB8fCAhZW5kKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2MgKyAoZW5kIC0gc3RhcnQpO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICBjb25zdCBlbnRyeSA9IFtcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uID8gYGRlc2M9XCIke2Rlc2NyaXB0aW9ufVwiYCA6IFwiXCIsXG4gICAgICAgICAgICAgICAgZHVyID8gYGR1cj0ke2R1cn1gIDogXCJcIixcbiAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICAgICAgICAgICAgICAgLmpvaW4oXCI7XCIpO1xuICAgICAgICAgICAgcmV0dXJuIFsuLi5hY2MsIGVudHJ5XTtcbiAgICAgICAgfSwgW10pO1xuICAgICAgICByZXR1cm4gZW50cmllcy5qb2luKFwiLCBcIik7XG4gICAgfVxufVxuZXhwb3J0cy5TZXJ2ZXJUaW1pbmcgPSBTZXJ2ZXJUaW1pbmc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TZXJ2ZXJUaW1pbmcuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/helpers/ServerTiming.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/helpers/consts.js":
/*!************************************************!*\
  !*** ./node_modules/inngest/helpers/consts.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.syncKind = exports.serverKind = exports.dummyEventKey = exports.debugPrefix = exports.logPrefix = exports.internalEvents = exports.defaultDevServerHost = exports.defaultInngestEventBaseUrl = exports.defaultInngestApiBaseUrl = exports.headerKeys = exports.envKeys = exports.probe = exports.queryKeys = void 0;\nconst chalk_1 = __importDefault(__webpack_require__(/*! chalk */ \"(rsc)/./node_modules/chalk/source/index.js\"));\n/**\n * Keys for accessing query parameters included in requests from Inngest to run\n * functions.\n *\n * Used internally to create handlers using `InngestCommHandler`, but can be\n * imported to be used if creating a custom handler outside of the package.\n *\n * @public\n */\nvar queryKeys;\n(function (queryKeys) {\n    queryKeys[\"DeployId\"] = \"deployId\";\n    queryKeys[\"FnId\"] = \"fnId\";\n    queryKeys[\"Probe\"] = \"probe\";\n    queryKeys[\"StepId\"] = \"stepId\";\n})(queryKeys || (exports.queryKeys = queryKeys = {}));\nvar probe;\n(function (probe) {\n    probe[\"Trust\"] = \"trust\";\n})(probe || (exports.probe = probe = {}));\nvar envKeys;\n(function (envKeys) {\n    envKeys[\"InngestSigningKey\"] = \"INNGEST_SIGNING_KEY\";\n    envKeys[\"InngestSigningKeyFallback\"] = \"INNGEST_SIGNING_KEY_FALLBACK\";\n    envKeys[\"InngestEventKey\"] = \"INNGEST_EVENT_KEY\";\n    /**\n     * @deprecated Removed in v3. Use {@link InngestBaseUrl} instead.\n     */\n    envKeys[\"InngestDevServerUrl\"] = \"INNGEST_DEVSERVER_URL\";\n    envKeys[\"InngestEnvironment\"] = \"INNGEST_ENV\";\n    envKeys[\"InngestBaseUrl\"] = \"INNGEST_BASE_URL\";\n    envKeys[\"InngestEventApiBaseUrl\"] = \"INNGEST_EVENT_API_BASE_URL\";\n    envKeys[\"InngestApiBaseUrl\"] = \"INNGEST_API_BASE_URL\";\n    envKeys[\"InngestServeHost\"] = \"INNGEST_SERVE_HOST\";\n    envKeys[\"InngestServePath\"] = \"INNGEST_SERVE_PATH\";\n    envKeys[\"InngestLogLevel\"] = \"INNGEST_LOG_LEVEL\";\n    envKeys[\"InngestStreaming\"] = \"INNGEST_STREAMING\";\n    envKeys[\"InngestDevMode\"] = \"INNGEST_DEV\";\n    envKeys[\"InngestAllowInBandSync\"] = \"INNGEST_ALLOW_IN_BAND_SYNC\";\n    /**\n     * @deprecated It's unknown what this env var was used for, but we do not\n     * provide explicit support for it. Prefer using `INNGEST_ENV` instead.\n     */\n    envKeys[\"BranchName\"] = \"BRANCH_NAME\";\n    /**\n     * The git branch of the commit the deployment was triggered by. Example:\n     * `improve-about-page`.\n     *\n     * {@link https://vercel.com/docs/concepts/projects/environment-variables/system-environment-variables#system-environment-variables}\n     */\n    envKeys[\"VercelBranch\"] = \"VERCEL_GIT_COMMIT_REF\";\n    /**\n     * Expected to be `\"1\"` if defined.\n     */\n    envKeys[\"IsVercel\"] = \"VERCEL\";\n    /**\n     * The branch name of the current deployment. May only be accessible at build\n     * time, but included here just in case.\n     *\n     * {@link https://developers.cloudflare.com/pages/platform/build-configuration/#environment-variables}\n     */\n    envKeys[\"CloudflarePagesBranch\"] = \"CF_PAGES_BRANCH\";\n    /**\n     * Expected to be `\"1\"` if defined.\n     */\n    envKeys[\"IsCloudflarePages\"] = \"CF_PAGES\";\n    /**\n     * The branch name of the deployment from Git to Netlify, if available.\n     *\n     * {@link https://docs.netlify.com/configure-builds/environment-variables/#git-metadata}\n     */\n    envKeys[\"NetlifyBranch\"] = \"BRANCH\";\n    /**\n     * Expected to be `\"true\"` if defined.\n     */\n    envKeys[\"IsNetlify\"] = \"NETLIFY\";\n    /**\n     * The Git branch for a service or deploy.\n     *\n     * {@link https://render.com/docs/environment-variables#all-services}\n     */\n    envKeys[\"RenderBranch\"] = \"RENDER_GIT_BRANCH\";\n    /**\n     * Expected to be `\"true\"` if defined.\n     */\n    envKeys[\"IsRender\"] = \"RENDER\";\n    /**\n     * The branch that triggered the deployment. Example: `main`\n     *\n     * {@link https://docs.railway.app/develop/variables#railway-provided-variables}\n     */\n    envKeys[\"RailwayBranch\"] = \"RAILWAY_GIT_BRANCH\";\n    /**\n     * The railway environment for the deployment. Example: `production`\n     *\n     * {@link https://docs.railway.app/develop/variables#railway-provided-variables}\n     */\n    envKeys[\"RailwayEnvironment\"] = \"RAILWAY_ENVIRONMENT\";\n    envKeys[\"VercelEnvKey\"] = \"VERCEL_ENV\";\n    envKeys[\"OpenAiApiKey\"] = \"OPENAI_API_KEY\";\n    envKeys[\"GeminiApiKey\"] = \"GEMINI_API_KEY\";\n    envKeys[\"AnthropicApiKey\"] = \"ANTHROPIC_API_KEY\";\n})(envKeys || (exports.envKeys = envKeys = {}));\n/**\n * Keys for accessing headers included in requests from Inngest to run\n * functions.\n *\n * Used internally to create handlers using `InngestCommHandler`, but can be\n * imported to be used if creating a custom handler outside of the package.\n *\n * @public\n */\nvar headerKeys;\n(function (headerKeys) {\n    headerKeys[\"ContentLength\"] = \"content-length\";\n    headerKeys[\"Signature\"] = \"x-inngest-signature\";\n    headerKeys[\"SdkVersion\"] = \"x-inngest-sdk\";\n    headerKeys[\"Environment\"] = \"x-inngest-env\";\n    headerKeys[\"Platform\"] = \"x-inngest-platform\";\n    headerKeys[\"Framework\"] = \"x-inngest-framework\";\n    headerKeys[\"NoRetry\"] = \"x-inngest-no-retry\";\n    headerKeys[\"RequestVersion\"] = \"x-inngest-req-version\";\n    headerKeys[\"RetryAfter\"] = \"retry-after\";\n    headerKeys[\"InngestServerKind\"] = \"x-inngest-server-kind\";\n    headerKeys[\"InngestExpectedServerKind\"] = \"x-inngest-expected-server-kind\";\n    headerKeys[\"InngestSyncKind\"] = \"x-inngest-sync-kind\";\n    headerKeys[\"EventIdSeed\"] = \"x-inngest-event-id-seed\";\n    headerKeys[\"TraceParent\"] = \"traceparent\";\n    headerKeys[\"TraceState\"] = \"tracestate\";\n})(headerKeys || (exports.headerKeys = headerKeys = {}));\nexports.defaultInngestApiBaseUrl = \"https://api.inngest.com/\";\nexports.defaultInngestEventBaseUrl = \"https://inn.gs/\";\nexports.defaultDevServerHost = \"http://localhost:8288/\";\n/**\n * Events that Inngest may send internally that can be used to trigger\n * functions.\n *\n * @public\n */\nvar internalEvents;\n(function (internalEvents) {\n    /**\n     * A function has failed after exhausting all available retries. This event\n     * will contain the original event and the error that caused the failure.\n     */\n    internalEvents[\"FunctionFailed\"] = \"inngest/function.failed\";\n    internalEvents[\"FunctionInvoked\"] = \"inngest/function.invoked\";\n    internalEvents[\"FunctionFinished\"] = \"inngest/function.finished\";\n    internalEvents[\"FunctionCancelled\"] = \"inngest/function.cancelled\";\n    internalEvents[\"ScheduledTimer\"] = \"inngest/scheduled.timer\";\n})(internalEvents || (exports.internalEvents = internalEvents = {}));\nexports.logPrefix = chalk_1.default.magenta.bold(\"[Inngest]\");\nexports.debugPrefix = \"inngest\";\nexports.dummyEventKey = \"NO_EVENT_KEY_SET\";\nvar serverKind;\n(function (serverKind) {\n    serverKind[\"Dev\"] = \"dev\";\n    serverKind[\"Cloud\"] = \"cloud\";\n})(serverKind || (exports.serverKind = serverKind = {}));\nvar syncKind;\n(function (syncKind) {\n    syncKind[\"InBand\"] = \"in_band\";\n    syncKind[\"OutOfBand\"] = \"out_of_band\";\n})(syncKind || (exports.syncKind = syncKind = {}));\n//# sourceMappingURL=consts.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL2NvbnN0cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQixHQUFHLGtCQUFrQixHQUFHLHFCQUFxQixHQUFHLG1CQUFtQixHQUFHLGlCQUFpQixHQUFHLHNCQUFzQixHQUFHLDRCQUE0QixHQUFHLGtDQUFrQyxHQUFHLGdDQUFnQyxHQUFHLGtCQUFrQixHQUFHLGVBQWUsR0FBRyxhQUFhLEdBQUcsaUJBQWlCO0FBQ2xULGdDQUFnQyxtQkFBTyxDQUFDLHlEQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0JBQWdCLGlCQUFpQixpQkFBaUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxZQUFZLGFBQWEsYUFBYTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsc0JBQXNCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsY0FBYyxlQUFlLGVBQWU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsaUJBQWlCLGtCQUFrQixrQkFBa0I7QUFDdEQsZ0NBQWdDO0FBQ2hDLGtDQUFrQztBQUNsQyw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMscUJBQXFCLHNCQUFzQixzQkFBc0I7QUFDbEUsaUJBQWlCO0FBQ2pCLG1CQUFtQjtBQUNuQixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGlCQUFpQixrQkFBa0Isa0JBQWtCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxlQUFlLGdCQUFnQixnQkFBZ0I7QUFDaEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aXZlLXZpYmUtYWktbmV4dC8uL25vZGVfbW9kdWxlcy9pbm5nZXN0L2hlbHBlcnMvY29uc3RzLmpzPzk3YjUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnN5bmNLaW5kID0gZXhwb3J0cy5zZXJ2ZXJLaW5kID0gZXhwb3J0cy5kdW1teUV2ZW50S2V5ID0gZXhwb3J0cy5kZWJ1Z1ByZWZpeCA9IGV4cG9ydHMubG9nUHJlZml4ID0gZXhwb3J0cy5pbnRlcm5hbEV2ZW50cyA9IGV4cG9ydHMuZGVmYXVsdERldlNlcnZlckhvc3QgPSBleHBvcnRzLmRlZmF1bHRJbm5nZXN0RXZlbnRCYXNlVXJsID0gZXhwb3J0cy5kZWZhdWx0SW5uZ2VzdEFwaUJhc2VVcmwgPSBleHBvcnRzLmhlYWRlcktleXMgPSBleHBvcnRzLmVudktleXMgPSBleHBvcnRzLnByb2JlID0gZXhwb3J0cy5xdWVyeUtleXMgPSB2b2lkIDA7XG5jb25zdCBjaGFsa18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJjaGFsa1wiKSk7XG4vKipcbiAqIEtleXMgZm9yIGFjY2Vzc2luZyBxdWVyeSBwYXJhbWV0ZXJzIGluY2x1ZGVkIGluIHJlcXVlc3RzIGZyb20gSW5uZ2VzdCB0byBydW5cbiAqIGZ1bmN0aW9ucy5cbiAqXG4gKiBVc2VkIGludGVybmFsbHkgdG8gY3JlYXRlIGhhbmRsZXJzIHVzaW5nIGBJbm5nZXN0Q29tbUhhbmRsZXJgLCBidXQgY2FuIGJlXG4gKiBpbXBvcnRlZCB0byBiZSB1c2VkIGlmIGNyZWF0aW5nIGEgY3VzdG9tIGhhbmRsZXIgb3V0c2lkZSBvZiB0aGUgcGFja2FnZS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbnZhciBxdWVyeUtleXM7XG4oZnVuY3Rpb24gKHF1ZXJ5S2V5cykge1xuICAgIHF1ZXJ5S2V5c1tcIkRlcGxveUlkXCJdID0gXCJkZXBsb3lJZFwiO1xuICAgIHF1ZXJ5S2V5c1tcIkZuSWRcIl0gPSBcImZuSWRcIjtcbiAgICBxdWVyeUtleXNbXCJQcm9iZVwiXSA9IFwicHJvYmVcIjtcbiAgICBxdWVyeUtleXNbXCJTdGVwSWRcIl0gPSBcInN0ZXBJZFwiO1xufSkocXVlcnlLZXlzIHx8IChleHBvcnRzLnF1ZXJ5S2V5cyA9IHF1ZXJ5S2V5cyA9IHt9KSk7XG52YXIgcHJvYmU7XG4oZnVuY3Rpb24gKHByb2JlKSB7XG4gICAgcHJvYmVbXCJUcnVzdFwiXSA9IFwidHJ1c3RcIjtcbn0pKHByb2JlIHx8IChleHBvcnRzLnByb2JlID0gcHJvYmUgPSB7fSkpO1xudmFyIGVudktleXM7XG4oZnVuY3Rpb24gKGVudktleXMpIHtcbiAgICBlbnZLZXlzW1wiSW5uZ2VzdFNpZ25pbmdLZXlcIl0gPSBcIklOTkdFU1RfU0lHTklOR19LRVlcIjtcbiAgICBlbnZLZXlzW1wiSW5uZ2VzdFNpZ25pbmdLZXlGYWxsYmFja1wiXSA9IFwiSU5OR0VTVF9TSUdOSU5HX0tFWV9GQUxMQkFDS1wiO1xuICAgIGVudktleXNbXCJJbm5nZXN0RXZlbnRLZXlcIl0gPSBcIklOTkdFU1RfRVZFTlRfS0VZXCI7XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgUmVtb3ZlZCBpbiB2My4gVXNlIHtAbGluayBJbm5nZXN0QmFzZVVybH0gaW5zdGVhZC5cbiAgICAgKi9cbiAgICBlbnZLZXlzW1wiSW5uZ2VzdERldlNlcnZlclVybFwiXSA9IFwiSU5OR0VTVF9ERVZTRVJWRVJfVVJMXCI7XG4gICAgZW52S2V5c1tcIklubmdlc3RFbnZpcm9ubWVudFwiXSA9IFwiSU5OR0VTVF9FTlZcIjtcbiAgICBlbnZLZXlzW1wiSW5uZ2VzdEJhc2VVcmxcIl0gPSBcIklOTkdFU1RfQkFTRV9VUkxcIjtcbiAgICBlbnZLZXlzW1wiSW5uZ2VzdEV2ZW50QXBpQmFzZVVybFwiXSA9IFwiSU5OR0VTVF9FVkVOVF9BUElfQkFTRV9VUkxcIjtcbiAgICBlbnZLZXlzW1wiSW5uZ2VzdEFwaUJhc2VVcmxcIl0gPSBcIklOTkdFU1RfQVBJX0JBU0VfVVJMXCI7XG4gICAgZW52S2V5c1tcIklubmdlc3RTZXJ2ZUhvc3RcIl0gPSBcIklOTkdFU1RfU0VSVkVfSE9TVFwiO1xuICAgIGVudktleXNbXCJJbm5nZXN0U2VydmVQYXRoXCJdID0gXCJJTk5HRVNUX1NFUlZFX1BBVEhcIjtcbiAgICBlbnZLZXlzW1wiSW5uZ2VzdExvZ0xldmVsXCJdID0gXCJJTk5HRVNUX0xPR19MRVZFTFwiO1xuICAgIGVudktleXNbXCJJbm5nZXN0U3RyZWFtaW5nXCJdID0gXCJJTk5HRVNUX1NUUkVBTUlOR1wiO1xuICAgIGVudktleXNbXCJJbm5nZXN0RGV2TW9kZVwiXSA9IFwiSU5OR0VTVF9ERVZcIjtcbiAgICBlbnZLZXlzW1wiSW5uZ2VzdEFsbG93SW5CYW5kU3luY1wiXSA9IFwiSU5OR0VTVF9BTExPV19JTl9CQU5EX1NZTkNcIjtcbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBJdCdzIHVua25vd24gd2hhdCB0aGlzIGVudiB2YXIgd2FzIHVzZWQgZm9yLCBidXQgd2UgZG8gbm90XG4gICAgICogcHJvdmlkZSBleHBsaWNpdCBzdXBwb3J0IGZvciBpdC4gUHJlZmVyIHVzaW5nIGBJTk5HRVNUX0VOVmAgaW5zdGVhZC5cbiAgICAgKi9cbiAgICBlbnZLZXlzW1wiQnJhbmNoTmFtZVwiXSA9IFwiQlJBTkNIX05BTUVcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgZ2l0IGJyYW5jaCBvZiB0aGUgY29tbWl0IHRoZSBkZXBsb3ltZW50IHdhcyB0cmlnZ2VyZWQgYnkuIEV4YW1wbGU6XG4gICAgICogYGltcHJvdmUtYWJvdXQtcGFnZWAuXG4gICAgICpcbiAgICAgKiB7QGxpbmsgaHR0cHM6Ly92ZXJjZWwuY29tL2RvY3MvY29uY2VwdHMvcHJvamVjdHMvZW52aXJvbm1lbnQtdmFyaWFibGVzL3N5c3RlbS1lbnZpcm9ubWVudC12YXJpYWJsZXMjc3lzdGVtLWVudmlyb25tZW50LXZhcmlhYmxlc31cbiAgICAgKi9cbiAgICBlbnZLZXlzW1wiVmVyY2VsQnJhbmNoXCJdID0gXCJWRVJDRUxfR0lUX0NPTU1JVF9SRUZcIjtcbiAgICAvKipcbiAgICAgKiBFeHBlY3RlZCB0byBiZSBgXCIxXCJgIGlmIGRlZmluZWQuXG4gICAgICovXG4gICAgZW52S2V5c1tcIklzVmVyY2VsXCJdID0gXCJWRVJDRUxcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgYnJhbmNoIG5hbWUgb2YgdGhlIGN1cnJlbnQgZGVwbG95bWVudC4gTWF5IG9ubHkgYmUgYWNjZXNzaWJsZSBhdCBidWlsZFxuICAgICAqIHRpbWUsIGJ1dCBpbmNsdWRlZCBoZXJlIGp1c3QgaW4gY2FzZS5cbiAgICAgKlxuICAgICAqIHtAbGluayBodHRwczovL2RldmVsb3BlcnMuY2xvdWRmbGFyZS5jb20vcGFnZXMvcGxhdGZvcm0vYnVpbGQtY29uZmlndXJhdGlvbi8jZW52aXJvbm1lbnQtdmFyaWFibGVzfVxuICAgICAqL1xuICAgIGVudktleXNbXCJDbG91ZGZsYXJlUGFnZXNCcmFuY2hcIl0gPSBcIkNGX1BBR0VTX0JSQU5DSFwiO1xuICAgIC8qKlxuICAgICAqIEV4cGVjdGVkIHRvIGJlIGBcIjFcImAgaWYgZGVmaW5lZC5cbiAgICAgKi9cbiAgICBlbnZLZXlzW1wiSXNDbG91ZGZsYXJlUGFnZXNcIl0gPSBcIkNGX1BBR0VTXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGJyYW5jaCBuYW1lIG9mIHRoZSBkZXBsb3ltZW50IGZyb20gR2l0IHRvIE5ldGxpZnksIGlmIGF2YWlsYWJsZS5cbiAgICAgKlxuICAgICAqIHtAbGluayBodHRwczovL2RvY3MubmV0bGlmeS5jb20vY29uZmlndXJlLWJ1aWxkcy9lbnZpcm9ubWVudC12YXJpYWJsZXMvI2dpdC1tZXRhZGF0YX1cbiAgICAgKi9cbiAgICBlbnZLZXlzW1wiTmV0bGlmeUJyYW5jaFwiXSA9IFwiQlJBTkNIXCI7XG4gICAgLyoqXG4gICAgICogRXhwZWN0ZWQgdG8gYmUgYFwidHJ1ZVwiYCBpZiBkZWZpbmVkLlxuICAgICAqL1xuICAgIGVudktleXNbXCJJc05ldGxpZnlcIl0gPSBcIk5FVExJRllcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgR2l0IGJyYW5jaCBmb3IgYSBzZXJ2aWNlIG9yIGRlcGxveS5cbiAgICAgKlxuICAgICAqIHtAbGluayBodHRwczovL3JlbmRlci5jb20vZG9jcy9lbnZpcm9ubWVudC12YXJpYWJsZXMjYWxsLXNlcnZpY2VzfVxuICAgICAqL1xuICAgIGVudktleXNbXCJSZW5kZXJCcmFuY2hcIl0gPSBcIlJFTkRFUl9HSVRfQlJBTkNIXCI7XG4gICAgLyoqXG4gICAgICogRXhwZWN0ZWQgdG8gYmUgYFwidHJ1ZVwiYCBpZiBkZWZpbmVkLlxuICAgICAqL1xuICAgIGVudktleXNbXCJJc1JlbmRlclwiXSA9IFwiUkVOREVSXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGJyYW5jaCB0aGF0IHRyaWdnZXJlZCB0aGUgZGVwbG95bWVudC4gRXhhbXBsZTogYG1haW5gXG4gICAgICpcbiAgICAgKiB7QGxpbmsgaHR0cHM6Ly9kb2NzLnJhaWx3YXkuYXBwL2RldmVsb3AvdmFyaWFibGVzI3JhaWx3YXktcHJvdmlkZWQtdmFyaWFibGVzfVxuICAgICAqL1xuICAgIGVudktleXNbXCJSYWlsd2F5QnJhbmNoXCJdID0gXCJSQUlMV0FZX0dJVF9CUkFOQ0hcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgcmFpbHdheSBlbnZpcm9ubWVudCBmb3IgdGhlIGRlcGxveW1lbnQuIEV4YW1wbGU6IGBwcm9kdWN0aW9uYFxuICAgICAqXG4gICAgICoge0BsaW5rIGh0dHBzOi8vZG9jcy5yYWlsd2F5LmFwcC9kZXZlbG9wL3ZhcmlhYmxlcyNyYWlsd2F5LXByb3ZpZGVkLXZhcmlhYmxlc31cbiAgICAgKi9cbiAgICBlbnZLZXlzW1wiUmFpbHdheUVudmlyb25tZW50XCJdID0gXCJSQUlMV0FZX0VOVklST05NRU5UXCI7XG4gICAgZW52S2V5c1tcIlZlcmNlbEVudktleVwiXSA9IFwiVkVSQ0VMX0VOVlwiO1xuICAgIGVudktleXNbXCJPcGVuQWlBcGlLZXlcIl0gPSBcIk9QRU5BSV9BUElfS0VZXCI7XG4gICAgZW52S2V5c1tcIkdlbWluaUFwaUtleVwiXSA9IFwiR0VNSU5JX0FQSV9LRVlcIjtcbiAgICBlbnZLZXlzW1wiQW50aHJvcGljQXBpS2V5XCJdID0gXCJBTlRIUk9QSUNfQVBJX0tFWVwiO1xufSkoZW52S2V5cyB8fCAoZXhwb3J0cy5lbnZLZXlzID0gZW52S2V5cyA9IHt9KSk7XG4vKipcbiAqIEtleXMgZm9yIGFjY2Vzc2luZyBoZWFkZXJzIGluY2x1ZGVkIGluIHJlcXVlc3RzIGZyb20gSW5uZ2VzdCB0byBydW5cbiAqIGZ1bmN0aW9ucy5cbiAqXG4gKiBVc2VkIGludGVybmFsbHkgdG8gY3JlYXRlIGhhbmRsZXJzIHVzaW5nIGBJbm5nZXN0Q29tbUhhbmRsZXJgLCBidXQgY2FuIGJlXG4gKiBpbXBvcnRlZCB0byBiZSB1c2VkIGlmIGNyZWF0aW5nIGEgY3VzdG9tIGhhbmRsZXIgb3V0c2lkZSBvZiB0aGUgcGFja2FnZS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbnZhciBoZWFkZXJLZXlzO1xuKGZ1bmN0aW9uIChoZWFkZXJLZXlzKSB7XG4gICAgaGVhZGVyS2V5c1tcIkNvbnRlbnRMZW5ndGhcIl0gPSBcImNvbnRlbnQtbGVuZ3RoXCI7XG4gICAgaGVhZGVyS2V5c1tcIlNpZ25hdHVyZVwiXSA9IFwieC1pbm5nZXN0LXNpZ25hdHVyZVwiO1xuICAgIGhlYWRlcktleXNbXCJTZGtWZXJzaW9uXCJdID0gXCJ4LWlubmdlc3Qtc2RrXCI7XG4gICAgaGVhZGVyS2V5c1tcIkVudmlyb25tZW50XCJdID0gXCJ4LWlubmdlc3QtZW52XCI7XG4gICAgaGVhZGVyS2V5c1tcIlBsYXRmb3JtXCJdID0gXCJ4LWlubmdlc3QtcGxhdGZvcm1cIjtcbiAgICBoZWFkZXJLZXlzW1wiRnJhbWV3b3JrXCJdID0gXCJ4LWlubmdlc3QtZnJhbWV3b3JrXCI7XG4gICAgaGVhZGVyS2V5c1tcIk5vUmV0cnlcIl0gPSBcIngtaW5uZ2VzdC1uby1yZXRyeVwiO1xuICAgIGhlYWRlcktleXNbXCJSZXF1ZXN0VmVyc2lvblwiXSA9IFwieC1pbm5nZXN0LXJlcS12ZXJzaW9uXCI7XG4gICAgaGVhZGVyS2V5c1tcIlJldHJ5QWZ0ZXJcIl0gPSBcInJldHJ5LWFmdGVyXCI7XG4gICAgaGVhZGVyS2V5c1tcIklubmdlc3RTZXJ2ZXJLaW5kXCJdID0gXCJ4LWlubmdlc3Qtc2VydmVyLWtpbmRcIjtcbiAgICBoZWFkZXJLZXlzW1wiSW5uZ2VzdEV4cGVjdGVkU2VydmVyS2luZFwiXSA9IFwieC1pbm5nZXN0LWV4cGVjdGVkLXNlcnZlci1raW5kXCI7XG4gICAgaGVhZGVyS2V5c1tcIklubmdlc3RTeW5jS2luZFwiXSA9IFwieC1pbm5nZXN0LXN5bmMta2luZFwiO1xuICAgIGhlYWRlcktleXNbXCJFdmVudElkU2VlZFwiXSA9IFwieC1pbm5nZXN0LWV2ZW50LWlkLXNlZWRcIjtcbiAgICBoZWFkZXJLZXlzW1wiVHJhY2VQYXJlbnRcIl0gPSBcInRyYWNlcGFyZW50XCI7XG4gICAgaGVhZGVyS2V5c1tcIlRyYWNlU3RhdGVcIl0gPSBcInRyYWNlc3RhdGVcIjtcbn0pKGhlYWRlcktleXMgfHwgKGV4cG9ydHMuaGVhZGVyS2V5cyA9IGhlYWRlcktleXMgPSB7fSkpO1xuZXhwb3J0cy5kZWZhdWx0SW5uZ2VzdEFwaUJhc2VVcmwgPSBcImh0dHBzOi8vYXBpLmlubmdlc3QuY29tL1wiO1xuZXhwb3J0cy5kZWZhdWx0SW5uZ2VzdEV2ZW50QmFzZVVybCA9IFwiaHR0cHM6Ly9pbm4uZ3MvXCI7XG5leHBvcnRzLmRlZmF1bHREZXZTZXJ2ZXJIb3N0ID0gXCJodHRwOi8vbG9jYWxob3N0OjgyODgvXCI7XG4vKipcbiAqIEV2ZW50cyB0aGF0IElubmdlc3QgbWF5IHNlbmQgaW50ZXJuYWxseSB0aGF0IGNhbiBiZSB1c2VkIHRvIHRyaWdnZXJcbiAqIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcHVibGljXG4gKi9cbnZhciBpbnRlcm5hbEV2ZW50cztcbihmdW5jdGlvbiAoaW50ZXJuYWxFdmVudHMpIHtcbiAgICAvKipcbiAgICAgKiBBIGZ1bmN0aW9uIGhhcyBmYWlsZWQgYWZ0ZXIgZXhoYXVzdGluZyBhbGwgYXZhaWxhYmxlIHJldHJpZXMuIFRoaXMgZXZlbnRcbiAgICAgKiB3aWxsIGNvbnRhaW4gdGhlIG9yaWdpbmFsIGV2ZW50IGFuZCB0aGUgZXJyb3IgdGhhdCBjYXVzZWQgdGhlIGZhaWx1cmUuXG4gICAgICovXG4gICAgaW50ZXJuYWxFdmVudHNbXCJGdW5jdGlvbkZhaWxlZFwiXSA9IFwiaW5uZ2VzdC9mdW5jdGlvbi5mYWlsZWRcIjtcbiAgICBpbnRlcm5hbEV2ZW50c1tcIkZ1bmN0aW9uSW52b2tlZFwiXSA9IFwiaW5uZ2VzdC9mdW5jdGlvbi5pbnZva2VkXCI7XG4gICAgaW50ZXJuYWxFdmVudHNbXCJGdW5jdGlvbkZpbmlzaGVkXCJdID0gXCJpbm5nZXN0L2Z1bmN0aW9uLmZpbmlzaGVkXCI7XG4gICAgaW50ZXJuYWxFdmVudHNbXCJGdW5jdGlvbkNhbmNlbGxlZFwiXSA9IFwiaW5uZ2VzdC9mdW5jdGlvbi5jYW5jZWxsZWRcIjtcbiAgICBpbnRlcm5hbEV2ZW50c1tcIlNjaGVkdWxlZFRpbWVyXCJdID0gXCJpbm5nZXN0L3NjaGVkdWxlZC50aW1lclwiO1xufSkoaW50ZXJuYWxFdmVudHMgfHwgKGV4cG9ydHMuaW50ZXJuYWxFdmVudHMgPSBpbnRlcm5hbEV2ZW50cyA9IHt9KSk7XG5leHBvcnRzLmxvZ1ByZWZpeCA9IGNoYWxrXzEuZGVmYXVsdC5tYWdlbnRhLmJvbGQoXCJbSW5uZ2VzdF1cIik7XG5leHBvcnRzLmRlYnVnUHJlZml4ID0gXCJpbm5nZXN0XCI7XG5leHBvcnRzLmR1bW15RXZlbnRLZXkgPSBcIk5PX0VWRU5UX0tFWV9TRVRcIjtcbnZhciBzZXJ2ZXJLaW5kO1xuKGZ1bmN0aW9uIChzZXJ2ZXJLaW5kKSB7XG4gICAgc2VydmVyS2luZFtcIkRldlwiXSA9IFwiZGV2XCI7XG4gICAgc2VydmVyS2luZFtcIkNsb3VkXCJdID0gXCJjbG91ZFwiO1xufSkoc2VydmVyS2luZCB8fCAoZXhwb3J0cy5zZXJ2ZXJLaW5kID0gc2VydmVyS2luZCA9IHt9KSk7XG52YXIgc3luY0tpbmQ7XG4oZnVuY3Rpb24gKHN5bmNLaW5kKSB7XG4gICAgc3luY0tpbmRbXCJJbkJhbmRcIl0gPSBcImluX2JhbmRcIjtcbiAgICBzeW5jS2luZFtcIk91dE9mQmFuZFwiXSA9IFwib3V0X29mX2JhbmRcIjtcbn0pKHN5bmNLaW5kIHx8IChleHBvcnRzLnN5bmNLaW5kID0gc3luY0tpbmQgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/helpers/consts.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/helpers/crypto.js":
/*!************************************************!*\
  !*** ./node_modules/inngest/helpers/crypto.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createEntropy = createEntropy;\n/**\n * Create a cryptographically secure random value.\n *\n * @throws {Error} If the crypto module is not available.\n */\nfunction createEntropy(byteLength) {\n    const bytes = new Uint8Array(byteLength);\n    // https://developer.mozilla.org/en-US/docs/Web/API/Crypto#browser_compatibility\n    const { crypto } = globalThis;\n    if (!crypto) {\n        // This should only happen in Node <19.\n        throw new Error(\"missing crypto module\");\n    }\n    if (!crypto.getRandomValues) {\n        throw new Error(\"missing crypto.getRandomValues\");\n    }\n    crypto.getRandomValues(bytes);\n    return bytes;\n}\n//# sourceMappingURL=crypto.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL2NyeXB0by5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aXZlLXZpYmUtYWktbmV4dC8uL25vZGVfbW9kdWxlcy9pbm5nZXN0L2hlbHBlcnMvY3J5cHRvLmpzP2YzNTkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZUVudHJvcHkgPSBjcmVhdGVFbnRyb3B5O1xuLyoqXG4gKiBDcmVhdGUgYSBjcnlwdG9ncmFwaGljYWxseSBzZWN1cmUgcmFuZG9tIHZhbHVlLlxuICpcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgY3J5cHRvIG1vZHVsZSBpcyBub3QgYXZhaWxhYmxlLlxuICovXG5mdW5jdGlvbiBjcmVhdGVFbnRyb3B5KGJ5dGVMZW5ndGgpIHtcbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJ5dGVMZW5ndGgpO1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DcnlwdG8jYnJvd3Nlcl9jb21wYXRpYmlsaXR5XG4gICAgY29uc3QgeyBjcnlwdG8gfSA9IGdsb2JhbFRoaXM7XG4gICAgaWYgKCFjcnlwdG8pIHtcbiAgICAgICAgLy8gVGhpcyBzaG91bGQgb25seSBoYXBwZW4gaW4gTm9kZSA8MTkuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgY3J5cHRvIG1vZHVsZVwiKTtcbiAgICB9XG4gICAgaWYgKCFjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgY3J5cHRvLmdldFJhbmRvbVZhbHVlc1wiKTtcbiAgICB9XG4gICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhieXRlcyk7XG4gICAgcmV0dXJuIGJ5dGVzO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3J5cHRvLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/helpers/crypto.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/helpers/devserver.js":
/*!***************************************************!*\
  !*** ./node_modules/inngest/helpers/devserver.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.devServerHost = exports.devServerUrl = exports.devServerAvailable = void 0;\nconst consts_js_1 = __webpack_require__(/*! ./consts.js */ \"(rsc)/./node_modules/inngest/helpers/consts.js\");\nconst env_js_1 = __webpack_require__(/*! ./env.js */ \"(rsc)/./node_modules/inngest/helpers/env.js\");\n/**\n * Attempts to contact the dev server, returning a boolean indicating whether or\n * not it was successful.\n *\n * @example devServerUrl(process.env[envKeys.DevServerUrl], \"/your-path\")\n */\nconst devServerAvailable = async (\n/**\n * The host of the dev server. You should pass in an environment variable as\n * this parameter.\n */\nhost = consts_js_1.defaultDevServerHost, \n/**\n * The fetch implementation to use to communicate with the dev server.\n */\nfetch) => {\n    try {\n        const url = (0, exports.devServerUrl)(host, \"/dev\");\n        const result = await fetch(url.toString());\n        await result.json();\n        return true;\n    }\n    catch (e) {\n        return false;\n    }\n};\nexports.devServerAvailable = devServerAvailable;\n/**\n * devServerUrl returns a full URL for the given path name.\n *\n * Because Cloudflare/V8 platforms don't allow process.env, you are expected\n * to pass in the host from the dev server env key:\n *\n * @example devServerUrl(processEnv(envKeys.DevServerUrl), \"/your-path\")\n * @example devServerUrl(\"http://localhost:8288/\", \"/your-path\")\n */\nconst devServerUrl = (host = (0, exports.devServerHost)(), pathname = \"\") => {\n    return new URL(pathname, host.includes(\"://\") ? host : `http://${host}`);\n};\nexports.devServerUrl = devServerUrl;\n/**\n * devServerHost exports the development server's domain by inspecting env\n * variables, or returns the default development server URL.\n *\n * This guarantees a specific URL as a string, as opposed to the env export\n * which only returns a value of the env var is set.\n */\nconst devServerHost = () => (0, env_js_1.devServerHost)() || consts_js_1.defaultDevServerHost;\nexports.devServerHost = devServerHost;\n//# sourceMappingURL=devserver.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL2RldnNlcnZlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUIsR0FBRyxvQkFBb0IsR0FBRywwQkFBMEI7QUFDekUsb0JBQW9CLG1CQUFPLENBQUMsbUVBQWE7QUFDekMsaUJBQWlCLG1CQUFPLENBQUMsNkRBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxLQUFLO0FBQzFFO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aXZlLXZpYmUtYWktbmV4dC8uL25vZGVfbW9kdWxlcy9pbm5nZXN0L2hlbHBlcnMvZGV2c2VydmVyLmpzPzdjOWIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRldlNlcnZlckhvc3QgPSBleHBvcnRzLmRldlNlcnZlclVybCA9IGV4cG9ydHMuZGV2U2VydmVyQXZhaWxhYmxlID0gdm9pZCAwO1xuY29uc3QgY29uc3RzX2pzXzEgPSByZXF1aXJlKFwiLi9jb25zdHMuanNcIik7XG5jb25zdCBlbnZfanNfMSA9IHJlcXVpcmUoXCIuL2Vudi5qc1wiKTtcbi8qKlxuICogQXR0ZW1wdHMgdG8gY29udGFjdCB0aGUgZGV2IHNlcnZlciwgcmV0dXJuaW5nIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgb3JcbiAqIG5vdCBpdCB3YXMgc3VjY2Vzc2Z1bC5cbiAqXG4gKiBAZXhhbXBsZSBkZXZTZXJ2ZXJVcmwocHJvY2Vzcy5lbnZbZW52S2V5cy5EZXZTZXJ2ZXJVcmxdLCBcIi95b3VyLXBhdGhcIilcbiAqL1xuY29uc3QgZGV2U2VydmVyQXZhaWxhYmxlID0gYXN5bmMgKFxuLyoqXG4gKiBUaGUgaG9zdCBvZiB0aGUgZGV2IHNlcnZlci4gWW91IHNob3VsZCBwYXNzIGluIGFuIGVudmlyb25tZW50IHZhcmlhYmxlIGFzXG4gKiB0aGlzIHBhcmFtZXRlci5cbiAqL1xuaG9zdCA9IGNvbnN0c19qc18xLmRlZmF1bHREZXZTZXJ2ZXJIb3N0LCBcbi8qKlxuICogVGhlIGZldGNoIGltcGxlbWVudGF0aW9uIHRvIHVzZSB0byBjb21tdW5pY2F0ZSB3aXRoIHRoZSBkZXYgc2VydmVyLlxuICovXG5mZXRjaCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHVybCA9ICgwLCBleHBvcnRzLmRldlNlcnZlclVybCkoaG9zdCwgXCIvZGV2XCIpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBmZXRjaCh1cmwudG9TdHJpbmcoKSk7XG4gICAgICAgIGF3YWl0IHJlc3VsdC5qc29uKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcbmV4cG9ydHMuZGV2U2VydmVyQXZhaWxhYmxlID0gZGV2U2VydmVyQXZhaWxhYmxlO1xuLyoqXG4gKiBkZXZTZXJ2ZXJVcmwgcmV0dXJucyBhIGZ1bGwgVVJMIGZvciB0aGUgZ2l2ZW4gcGF0aCBuYW1lLlxuICpcbiAqIEJlY2F1c2UgQ2xvdWRmbGFyZS9WOCBwbGF0Zm9ybXMgZG9uJ3QgYWxsb3cgcHJvY2Vzcy5lbnYsIHlvdSBhcmUgZXhwZWN0ZWRcbiAqIHRvIHBhc3MgaW4gdGhlIGhvc3QgZnJvbSB0aGUgZGV2IHNlcnZlciBlbnYga2V5OlxuICpcbiAqIEBleGFtcGxlIGRldlNlcnZlclVybChwcm9jZXNzRW52KGVudktleXMuRGV2U2VydmVyVXJsKSwgXCIveW91ci1wYXRoXCIpXG4gKiBAZXhhbXBsZSBkZXZTZXJ2ZXJVcmwoXCJodHRwOi8vbG9jYWxob3N0OjgyODgvXCIsIFwiL3lvdXItcGF0aFwiKVxuICovXG5jb25zdCBkZXZTZXJ2ZXJVcmwgPSAoaG9zdCA9ICgwLCBleHBvcnRzLmRldlNlcnZlckhvc3QpKCksIHBhdGhuYW1lID0gXCJcIikgPT4ge1xuICAgIHJldHVybiBuZXcgVVJMKHBhdGhuYW1lLCBob3N0LmluY2x1ZGVzKFwiOi8vXCIpID8gaG9zdCA6IGBodHRwOi8vJHtob3N0fWApO1xufTtcbmV4cG9ydHMuZGV2U2VydmVyVXJsID0gZGV2U2VydmVyVXJsO1xuLyoqXG4gKiBkZXZTZXJ2ZXJIb3N0IGV4cG9ydHMgdGhlIGRldmVsb3BtZW50IHNlcnZlcidzIGRvbWFpbiBieSBpbnNwZWN0aW5nIGVudlxuICogdmFyaWFibGVzLCBvciByZXR1cm5zIHRoZSBkZWZhdWx0IGRldmVsb3BtZW50IHNlcnZlciBVUkwuXG4gKlxuICogVGhpcyBndWFyYW50ZWVzIGEgc3BlY2lmaWMgVVJMIGFzIGEgc3RyaW5nLCBhcyBvcHBvc2VkIHRvIHRoZSBlbnYgZXhwb3J0XG4gKiB3aGljaCBvbmx5IHJldHVybnMgYSB2YWx1ZSBvZiB0aGUgZW52IHZhciBpcyBzZXQuXG4gKi9cbmNvbnN0IGRldlNlcnZlckhvc3QgPSAoKSA9PiAoMCwgZW52X2pzXzEuZGV2U2VydmVySG9zdCkoKSB8fCBjb25zdHNfanNfMS5kZWZhdWx0RGV2U2VydmVySG9zdDtcbmV4cG9ydHMuZGV2U2VydmVySG9zdCA9IGRldlNlcnZlckhvc3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZXZzZXJ2ZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/helpers/devserver.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/helpers/enum.js":
/*!**********************************************!*\
  !*** ./node_modules/inngest/helpers/enum.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.enumFromValue = void 0;\n/**\n * Returns the value of an enum from a string value.\n *\n * If the value given is not a value from the enum, `undefined` is returned.\n */\nconst enumFromValue = (enumType, value) => {\n    if (Object.values(enumType).includes(value)) {\n        return value;\n    }\n};\nexports.enumFromValue = enumFromValue;\n//# sourceMappingURL=enum.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL2VudW0uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdml2ZS12aWJlLWFpLW5leHQvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL2VudW0uanM/NzczNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZW51bUZyb21WYWx1ZSA9IHZvaWQgMDtcbi8qKlxuICogUmV0dXJucyB0aGUgdmFsdWUgb2YgYW4gZW51bSBmcm9tIGEgc3RyaW5nIHZhbHVlLlxuICpcbiAqIElmIHRoZSB2YWx1ZSBnaXZlbiBpcyBub3QgYSB2YWx1ZSBmcm9tIHRoZSBlbnVtLCBgdW5kZWZpbmVkYCBpcyByZXR1cm5lZC5cbiAqL1xuY29uc3QgZW51bUZyb21WYWx1ZSA9IChlbnVtVHlwZSwgdmFsdWUpID0+IHtcbiAgICBpZiAoT2JqZWN0LnZhbHVlcyhlbnVtVHlwZSkuaW5jbHVkZXModmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59O1xuZXhwb3J0cy5lbnVtRnJvbVZhbHVlID0gZW51bUZyb21WYWx1ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVudW0uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/helpers/enum.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/helpers/env.js":
/*!*********************************************!*\
  !*** ./node_modules/inngest/helpers/env.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// This file exists to help normalize process.env amongst the backend\n// and frontend.  Many frontends (eg. Next, CRA) utilize webpack's DefinePlugin\n// along with prefixes, meaning we have to explicitly use the full `process.env.FOO`\n// string in order to read variables.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parseAsBoolean = exports.getResponse = exports.getFetch = exports.platformSupportsStreaming = exports.getPlatformName = exports.inngestHeaders = exports.allProcessEnv = exports.processEnv = exports.getEnvironmentName = exports.getMode = exports.Mode = exports.devServerHost = void 0;\nconst version_js_1 = __webpack_require__(/*! ../version.js */ \"(rsc)/./node_modules/inngest/version.js\");\nconst consts_js_1 = __webpack_require__(/*! ./consts.js */ \"(rsc)/./node_modules/inngest/helpers/consts.js\");\nconst strings_js_1 = __webpack_require__(/*! ./strings.js */ \"(rsc)/./node_modules/inngest/helpers/strings.js\");\n/**\n * devServerHost returns the dev server host by searching for the INNGEST_DEVSERVER_URL\n * environment variable (plus project prefixces for eg. react, such as REACT_APP_INNGEST_DEVSERVER_URL).\n *\n * If not found this returns undefined, indicating that the env var has not been set.\n *\n * @example devServerHost()\n */\nconst devServerHost = (env = (0, exports.allProcessEnv)()) => {\n    // devServerKeys are the env keys we search for to discover the dev server\n    // URL.  This includes the standard key first, then includes prefixed keys\n    // for use within common frameworks (eg. CRA, next).\n    //\n    // We have to fully write these using process.env as they're typically\n    // processed using webpack's DefinePlugin, which is dumb and does a straight\n    // text replacement instead of actually understanding the AST, despite webpack\n    // being fully capable of understanding the AST.\n    const prefixes = [\"REACT_APP_\", \"NEXT_PUBLIC_\"];\n    const keys = [consts_js_1.envKeys.InngestBaseUrl, consts_js_1.envKeys.InngestDevMode];\n    const values = keys.flatMap((key) => {\n        return prefixes.map((prefix) => {\n            return env[prefix + key];\n        });\n    });\n    return values.find((v) => {\n        if (!v) {\n            return;\n        }\n        try {\n            return Boolean(new URL(v));\n        }\n        catch (_a) {\n            // no-op\n        }\n    });\n};\nexports.devServerHost = devServerHost;\nconst checkFns = ((checks) => checks)({\n    equals: (actual, expected) => actual === expected,\n    \"starts with\": (actual, expected) => { var _a; return expected ? (_a = actual === null || actual === void 0 ? void 0 : actual.startsWith(expected)) !== null && _a !== void 0 ? _a : false : false; },\n    \"is truthy\": (actual) => Boolean(actual),\n    \"is truthy but not\": (actual, expected) => Boolean(actual) && actual !== expected,\n});\nconst prodChecks = [\n    [\"CF_PAGES\", \"equals\", \"1\"],\n    [\"CONTEXT\", \"starts with\", \"prod\"],\n    [\"ENVIRONMENT\", \"starts with\", \"prod\"],\n    [\"NODE_ENV\", \"starts with\", \"prod\"],\n    [\"VERCEL_ENV\", \"starts with\", \"prod\"],\n    [\"DENO_DEPLOYMENT_ID\", \"is truthy\"],\n    [consts_js_1.envKeys.VercelEnvKey, \"is truthy but not\", \"development\"],\n    [consts_js_1.envKeys.IsNetlify, \"is truthy\"],\n    [consts_js_1.envKeys.IsRender, \"is truthy\"],\n    [consts_js_1.envKeys.RailwayBranch, \"is truthy\"],\n    [consts_js_1.envKeys.IsCloudflarePages, \"is truthy\"],\n];\nclass Mode {\n    constructor({ type, isExplicit, explicitDevUrl, env = (0, exports.allProcessEnv)(), }) {\n        this.env = env;\n        this.type = type;\n        this.isExplicit = isExplicit || Boolean(explicitDevUrl);\n        this.explicitDevUrl = explicitDevUrl;\n    }\n    get isDev() {\n        return this.type === \"dev\";\n    }\n    get isCloud() {\n        return this.type === \"cloud\";\n    }\n    get isInferred() {\n        return !this.isExplicit;\n    }\n    /**\n     * If we are explicitly in a particular mode, retrieve the URL that we are\n     * sure we should be using, not considering any environment variables or other\n     * influences.\n     */\n    getExplicitUrl(defaultCloudUrl) {\n        if (!this.isExplicit) {\n            return undefined;\n        }\n        if (this.explicitDevUrl) {\n            return this.explicitDevUrl.href;\n        }\n        if (this.isCloud) {\n            return defaultCloudUrl;\n        }\n        if (this.isDev) {\n            return consts_js_1.defaultDevServerHost;\n        }\n        return undefined;\n    }\n}\nexports.Mode = Mode;\n/**\n * Returns the mode of the current environment, based off of either passed\n * environment variables or `process.env`, or explicit settings.\n */\nconst getMode = ({ env = (0, exports.allProcessEnv)(), client, explicitMode, } = {}) => {\n    if (explicitMode) {\n        return new Mode({ type: explicitMode, isExplicit: true, env });\n    }\n    if (client === null || client === void 0 ? void 0 : client[\"mode\"].isExplicit) {\n        return client[\"mode\"];\n    }\n    if (consts_js_1.envKeys.InngestDevMode in env) {\n        if (typeof env[consts_js_1.envKeys.InngestDevMode] === \"string\") {\n            try {\n                const explicitDevUrl = new URL(env[consts_js_1.envKeys.InngestDevMode]);\n                return new Mode({ type: \"dev\", isExplicit: true, explicitDevUrl, env });\n            }\n            catch (_a) {\n                // no-op\n            }\n        }\n        const envIsDev = (0, exports.parseAsBoolean)(env[consts_js_1.envKeys.InngestDevMode]);\n        if (typeof envIsDev === \"boolean\") {\n            return new Mode({\n                type: envIsDev ? \"dev\" : \"cloud\",\n                isExplicit: true,\n                env,\n            });\n        }\n    }\n    const isProd = prodChecks.some(([key, checkKey, expected]) => {\n        return checkFns[checkKey]((0, strings_js_1.stringifyUnknown)(env[key]), expected);\n    });\n    return new Mode({ type: isProd ? \"cloud\" : \"dev\", isExplicit: false, env });\n};\nexports.getMode = getMode;\n/**\n * getEnvironmentName returns the suspected branch name for this environment by\n * searching through a set of common environment variables.\n *\n * This could be used to determine if we're on a branch deploy or not, though it\n * should be noted that we don't know if this is the default branch or not.\n */\nconst getEnvironmentName = (env = (0, exports.allProcessEnv)()) => {\n    /**\n     * Order is important; more than one of these env vars may be set, so ensure\n     * that we check the most specific, most reliable env vars first.\n     */\n    return (env[consts_js_1.envKeys.InngestEnvironment] ||\n        env[consts_js_1.envKeys.BranchName] ||\n        env[consts_js_1.envKeys.VercelBranch] ||\n        env[consts_js_1.envKeys.NetlifyBranch] ||\n        env[consts_js_1.envKeys.CloudflarePagesBranch] ||\n        env[consts_js_1.envKeys.RenderBranch] ||\n        env[consts_js_1.envKeys.RailwayBranch]);\n};\nexports.getEnvironmentName = getEnvironmentName;\nconst processEnv = (key) => {\n    return (0, exports.allProcessEnv)()[key];\n};\nexports.processEnv = processEnv;\n/**\n * allProcessEnv returns the current process environment variables, or an empty\n * object if they cannot be read, making sure we support environments other than\n * Node such as Deno, too.\n *\n * Using this ensures we don't dangerously access `process.env` in environments\n * where it may not be defined, such as Deno or the browser.\n */\nconst allProcessEnv = () => {\n    // Node, or Node-like environments\n    try {\n        // eslint-disable-next-line @inngest/internal/process-warn\n        if (process.env) {\n            // eslint-disable-next-line @inngest/internal/process-warn\n            return process.env;\n        }\n    }\n    catch (_err) {\n        // noop\n    }\n    // Deno\n    try {\n        const env = Deno.env.toObject();\n        if (env) {\n            return env;\n        }\n    }\n    catch (_err) {\n        // noop\n    }\n    // Netlify\n    try {\n        const env = Netlify.env.toObject();\n        if (env) {\n            return env;\n        }\n    }\n    catch (_err) {\n        // noop\n    }\n    return {};\n};\nexports.allProcessEnv = allProcessEnv;\n/**\n * Generate a standardised set of headers based on input and environment\n * variables.\n *\n *\n */\nconst inngestHeaders = (opts) => {\n    var _a;\n    const sdkVersion = `inngest-js:v${version_js_1.version}`;\n    const headers = {\n        \"Content-Type\": \"application/json\",\n        \"User-Agent\": sdkVersion,\n        [consts_js_1.headerKeys.SdkVersion]: sdkVersion,\n    };\n    if (opts === null || opts === void 0 ? void 0 : opts.framework) {\n        headers[consts_js_1.headerKeys.Framework] = opts.framework;\n    }\n    if (opts === null || opts === void 0 ? void 0 : opts.expectedServerKind) {\n        headers[consts_js_1.headerKeys.InngestExpectedServerKind] = opts.expectedServerKind;\n    }\n    const env = Object.assign(Object.assign({}, (0, exports.allProcessEnv)()), opts === null || opts === void 0 ? void 0 : opts.env);\n    const inngestEnv = (opts === null || opts === void 0 ? void 0 : opts.inngestEnv) || (0, exports.getEnvironmentName)(env);\n    if (inngestEnv) {\n        headers[consts_js_1.headerKeys.Environment] = inngestEnv;\n    }\n    const platform = (0, exports.getPlatformName)(env);\n    if (platform) {\n        headers[consts_js_1.headerKeys.Platform] = platform;\n    }\n    return Object.assign(Object.assign(Object.assign({}, headers), (_a = opts === null || opts === void 0 ? void 0 : opts.client) === null || _a === void 0 ? void 0 : _a[\"headers\"]), opts === null || opts === void 0 ? void 0 : opts.extras);\n};\nexports.inngestHeaders = inngestHeaders;\n/**\n * A set of checks that, given an environment, will return `true` if the current\n * environment is running on the platform with the given name.\n */\nconst platformChecks = {\n    /**\n     * Vercel Edge Functions don't have access to environment variables unless\n     * they are explicitly referenced in the top level code, but they do have a\n     * global `EdgeRuntime` variable set that we can use to detect this.\n     */\n    vercel: (env) => env[consts_js_1.envKeys.IsVercel] === \"1\" || typeof EdgeRuntime === \"string\",\n    netlify: (env) => env[consts_js_1.envKeys.IsNetlify] === \"true\",\n    \"cloudflare-pages\": (env) => env[consts_js_1.envKeys.IsCloudflarePages] === \"1\",\n    render: (env) => env[consts_js_1.envKeys.IsRender] === \"true\",\n    railway: (env) => Boolean(env[consts_js_1.envKeys.RailwayEnvironment]),\n};\n/**\n * A set of checks that, given an environment, will return `true` if the current\n * environment and platform supports streaming responses back to Inngest.\n *\n * Streaming capability is both framework and platform-based. Frameworks are\n * supported in serve handlers, and platforms are checked here.\n *\n * As such, this record declares which platforms we explicitly support for\n * streaming and is used by {@link platformSupportsStreaming}.\n */\nconst streamingChecks = {\n    /**\n     * \"Vercel supports streaming for Serverless Functions, Edge Functions, and\n     * React Server Components in Next.js projects.\"\n     *\n     * In practice, however, there are many reports of streaming not working as\n     * expected on Serverless Functions, so we resort to only allowing streaming\n     * for Edge Functions here.\n     *\n     * See {@link https://vercel.com/docs/frameworks/nextjs#streaming}\n     */\n    vercel: (_framework, _env) => typeof EdgeRuntime === \"string\",\n    \"cloudflare-pages\": () => true,\n};\nconst getPlatformName = (env) => {\n    return Object.keys(platformChecks).find((key) => {\n        return platformChecks[key](env);\n    });\n};\nexports.getPlatformName = getPlatformName;\n/**\n * Returns `true` if we believe the current environment supports streaming\n * responses back to Inngest.\n *\n * We run a check directly related to the platform we believe we're running on,\n * usually based on environment variables.\n */\nconst platformSupportsStreaming = (framework, env = (0, exports.allProcessEnv)()) => {\n    var _a, _b;\n    return ((_b = (_a = streamingChecks[(0, exports.getPlatformName)(env)]) === null || _a === void 0 ? void 0 : _a.call(streamingChecks, framework, env)) !== null && _b !== void 0 ? _b : false);\n};\nexports.platformSupportsStreaming = platformSupportsStreaming;\n/**\n * A unique symbol used to mark a custom fetch implementation. We wrap the\n * implementations to provide some extra control when handling errors.\n */\nconst CUSTOM_FETCH_MARKER = Symbol(\"Custom fetch implementation\");\n/**\n * Given a potential fetch function, return the fetch function to use based on\n * this and the environment.\n */\nconst getFetch = (givenFetch) => {\n    /**\n     * If we've explicitly been given a fetch function, use that.\n     */\n    if (givenFetch) {\n        if (CUSTOM_FETCH_MARKER in givenFetch) {\n            return givenFetch;\n        }\n        /**\n         * We wrap the given fetch function to provide some extra control when\n         * handling errors.\n         */\n        const customFetch = async (...args) => {\n            var _a;\n            try {\n                return await givenFetch(...args);\n            }\n            catch (err) {\n                /**\n                 * Capture warnings that are not simple fetch failures and highlight\n                 * them for the user.\n                 *\n                 * We also use this opportunity to log the causing error, as code higher\n                 * up the stack will likely abstract this.\n                 */\n                if (!(err instanceof Error) ||\n                    !((_a = err.message) === null || _a === void 0 ? void 0 : _a.startsWith(\"fetch failed\"))) {\n                    console.warn(\"A request failed when using a custom fetch implementation; this may be a misconfiguration. Make sure that your fetch client is correctly bound to the global scope.\");\n                    console.error(err);\n                }\n                throw err;\n            }\n        };\n        /**\n         * Mark the custom fetch implementation so that we can identify it later, in\n         * addition to adding some runtime properties to it to make it seem as much\n         * like the original fetch as possible.\n         */\n        Object.defineProperties(customFetch, {\n            [CUSTOM_FETCH_MARKER]: {},\n            name: { value: givenFetch.name },\n            length: { value: givenFetch.length },\n        });\n        return customFetch;\n    }\n    /**\n     * Browser or Node 18+\n     */\n    try {\n        if (typeof globalThis !== \"undefined\" && \"fetch\" in globalThis) {\n            return fetch.bind(globalThis);\n        }\n    }\n    catch (err) {\n        // no-op\n    }\n    /**\n     * Existing polyfilled fetch\n     */\n    if (typeof fetch !== \"undefined\") {\n        return fetch;\n    }\n    /**\n     * Environments where fetch cannot be found and must be polyfilled\n     */\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\n    return __webpack_require__(/*! cross-fetch */ \"(rsc)/./node_modules/cross-fetch/dist/node-ponyfill.js\");\n};\nexports.getFetch = getFetch;\n/**\n * If `Response` isn't included in this environment, it's probably an earlier\n * Node env that isn't already polyfilling. This function returns either the\n * native `Response` or a polyfilled one.\n */\nconst getResponse = () => {\n    if (typeof Response !== \"undefined\") {\n        return Response;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-var-requires\n    return (__webpack_require__(/*! cross-fetch */ \"(rsc)/./node_modules/cross-fetch/dist/node-ponyfill.js\").Response);\n};\nexports.getResponse = getResponse;\n/**\n * Given an unknown value, try to parse it as a `boolean`. Useful for parsing\n * environment variables that could be a selection of different values such as\n * `\"true\"`, `\"1\"`.\n *\n * If the value could not be confidently parsed as a `boolean` or was seen to be\n * `undefined`, this function returns `undefined`.\n */\nconst parseAsBoolean = (value) => {\n    if (typeof value === \"boolean\") {\n        return value;\n    }\n    if (typeof value === \"number\") {\n        return Boolean(value);\n    }\n    if (typeof value === \"string\") {\n        const trimmed = value.trim().toLowerCase();\n        if (trimmed === \"undefined\") {\n            return undefined;\n        }\n        if ([\"true\", \"1\"].includes(trimmed)) {\n            return true;\n        }\n        return false;\n    }\n    return undefined;\n};\nexports.parseAsBoolean = parseAsBoolean;\n//# sourceMappingURL=env.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL2Vudi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQixHQUFHLG1CQUFtQixHQUFHLGdCQUFnQixHQUFHLGlDQUFpQyxHQUFHLHVCQUF1QixHQUFHLHNCQUFzQixHQUFHLHFCQUFxQixHQUFHLGtCQUFrQixHQUFHLDBCQUEwQixHQUFHLGVBQWUsR0FBRyxZQUFZLEdBQUcscUJBQXFCO0FBQ3pSLHFCQUFxQixtQkFBTyxDQUFDLDhEQUFlO0FBQzVDLG9CQUFvQixtQkFBTyxDQUFDLG1FQUFhO0FBQ3pDLHFCQUFxQixtQkFBTyxDQUFDLHFFQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsMkNBQTJDLFFBQVEsc0pBQXNKO0FBQ3pNO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix1RUFBdUU7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdml2ZS12aWJlLWFpLW5leHQvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL2Vudi5qcz9jZDY4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gVGhpcyBmaWxlIGV4aXN0cyB0byBoZWxwIG5vcm1hbGl6ZSBwcm9jZXNzLmVudiBhbW9uZ3N0IHRoZSBiYWNrZW5kXG4vLyBhbmQgZnJvbnRlbmQuICBNYW55IGZyb250ZW5kcyAoZWcuIE5leHQsIENSQSkgdXRpbGl6ZSB3ZWJwYWNrJ3MgRGVmaW5lUGx1Z2luXG4vLyBhbG9uZyB3aXRoIHByZWZpeGVzLCBtZWFuaW5nIHdlIGhhdmUgdG8gZXhwbGljaXRseSB1c2UgdGhlIGZ1bGwgYHByb2Nlc3MuZW52LkZPT2Bcbi8vIHN0cmluZyBpbiBvcmRlciB0byByZWFkIHZhcmlhYmxlcy5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucGFyc2VBc0Jvb2xlYW4gPSBleHBvcnRzLmdldFJlc3BvbnNlID0gZXhwb3J0cy5nZXRGZXRjaCA9IGV4cG9ydHMucGxhdGZvcm1TdXBwb3J0c1N0cmVhbWluZyA9IGV4cG9ydHMuZ2V0UGxhdGZvcm1OYW1lID0gZXhwb3J0cy5pbm5nZXN0SGVhZGVycyA9IGV4cG9ydHMuYWxsUHJvY2Vzc0VudiA9IGV4cG9ydHMucHJvY2Vzc0VudiA9IGV4cG9ydHMuZ2V0RW52aXJvbm1lbnROYW1lID0gZXhwb3J0cy5nZXRNb2RlID0gZXhwb3J0cy5Nb2RlID0gZXhwb3J0cy5kZXZTZXJ2ZXJIb3N0ID0gdm9pZCAwO1xuY29uc3QgdmVyc2lvbl9qc18xID0gcmVxdWlyZShcIi4uL3ZlcnNpb24uanNcIik7XG5jb25zdCBjb25zdHNfanNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0cy5qc1wiKTtcbmNvbnN0IHN0cmluZ3NfanNfMSA9IHJlcXVpcmUoXCIuL3N0cmluZ3MuanNcIik7XG4vKipcbiAqIGRldlNlcnZlckhvc3QgcmV0dXJucyB0aGUgZGV2IHNlcnZlciBob3N0IGJ5IHNlYXJjaGluZyBmb3IgdGhlIElOTkdFU1RfREVWU0VSVkVSX1VSTFxuICogZW52aXJvbm1lbnQgdmFyaWFibGUgKHBsdXMgcHJvamVjdCBwcmVmaXhjZXMgZm9yIGVnLiByZWFjdCwgc3VjaCBhcyBSRUFDVF9BUFBfSU5OR0VTVF9ERVZTRVJWRVJfVVJMKS5cbiAqXG4gKiBJZiBub3QgZm91bmQgdGhpcyByZXR1cm5zIHVuZGVmaW5lZCwgaW5kaWNhdGluZyB0aGF0IHRoZSBlbnYgdmFyIGhhcyBub3QgYmVlbiBzZXQuXG4gKlxuICogQGV4YW1wbGUgZGV2U2VydmVySG9zdCgpXG4gKi9cbmNvbnN0IGRldlNlcnZlckhvc3QgPSAoZW52ID0gKDAsIGV4cG9ydHMuYWxsUHJvY2Vzc0VudikoKSkgPT4ge1xuICAgIC8vIGRldlNlcnZlcktleXMgYXJlIHRoZSBlbnYga2V5cyB3ZSBzZWFyY2ggZm9yIHRvIGRpc2NvdmVyIHRoZSBkZXYgc2VydmVyXG4gICAgLy8gVVJMLiAgVGhpcyBpbmNsdWRlcyB0aGUgc3RhbmRhcmQga2V5IGZpcnN0LCB0aGVuIGluY2x1ZGVzIHByZWZpeGVkIGtleXNcbiAgICAvLyBmb3IgdXNlIHdpdGhpbiBjb21tb24gZnJhbWV3b3JrcyAoZWcuIENSQSwgbmV4dCkuXG4gICAgLy9cbiAgICAvLyBXZSBoYXZlIHRvIGZ1bGx5IHdyaXRlIHRoZXNlIHVzaW5nIHByb2Nlc3MuZW52IGFzIHRoZXkncmUgdHlwaWNhbGx5XG4gICAgLy8gcHJvY2Vzc2VkIHVzaW5nIHdlYnBhY2sncyBEZWZpbmVQbHVnaW4sIHdoaWNoIGlzIGR1bWIgYW5kIGRvZXMgYSBzdHJhaWdodFxuICAgIC8vIHRleHQgcmVwbGFjZW1lbnQgaW5zdGVhZCBvZiBhY3R1YWxseSB1bmRlcnN0YW5kaW5nIHRoZSBBU1QsIGRlc3BpdGUgd2VicGFja1xuICAgIC8vIGJlaW5nIGZ1bGx5IGNhcGFibGUgb2YgdW5kZXJzdGFuZGluZyB0aGUgQVNULlxuICAgIGNvbnN0IHByZWZpeGVzID0gW1wiUkVBQ1RfQVBQX1wiLCBcIk5FWFRfUFVCTElDX1wiXTtcbiAgICBjb25zdCBrZXlzID0gW2NvbnN0c19qc18xLmVudktleXMuSW5uZ2VzdEJhc2VVcmwsIGNvbnN0c19qc18xLmVudktleXMuSW5uZ2VzdERldk1vZGVdO1xuICAgIGNvbnN0IHZhbHVlcyA9IGtleXMuZmxhdE1hcCgoa2V5KSA9PiB7XG4gICAgICAgIHJldHVybiBwcmVmaXhlcy5tYXAoKHByZWZpeCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGVudltwcmVmaXggKyBrZXldO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gdmFsdWVzLmZpbmQoKHYpID0+IHtcbiAgICAgICAgaWYgKCF2KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBCb29sZWFuKG5ldyBVUkwodikpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgLy8gbm8tb3BcbiAgICAgICAgfVxuICAgIH0pO1xufTtcbmV4cG9ydHMuZGV2U2VydmVySG9zdCA9IGRldlNlcnZlckhvc3Q7XG5jb25zdCBjaGVja0ZucyA9ICgoY2hlY2tzKSA9PiBjaGVja3MpKHtcbiAgICBlcXVhbHM6IChhY3R1YWwsIGV4cGVjdGVkKSA9PiBhY3R1YWwgPT09IGV4cGVjdGVkLFxuICAgIFwic3RhcnRzIHdpdGhcIjogKGFjdHVhbCwgZXhwZWN0ZWQpID0+IHsgdmFyIF9hOyByZXR1cm4gZXhwZWN0ZWQgPyAoX2EgPSBhY3R1YWwgPT09IG51bGwgfHwgYWN0dWFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhY3R1YWwuc3RhcnRzV2l0aChleHBlY3RlZCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlIDogZmFsc2U7IH0sXG4gICAgXCJpcyB0cnV0aHlcIjogKGFjdHVhbCkgPT4gQm9vbGVhbihhY3R1YWwpLFxuICAgIFwiaXMgdHJ1dGh5IGJ1dCBub3RcIjogKGFjdHVhbCwgZXhwZWN0ZWQpID0+IEJvb2xlYW4oYWN0dWFsKSAmJiBhY3R1YWwgIT09IGV4cGVjdGVkLFxufSk7XG5jb25zdCBwcm9kQ2hlY2tzID0gW1xuICAgIFtcIkNGX1BBR0VTXCIsIFwiZXF1YWxzXCIsIFwiMVwiXSxcbiAgICBbXCJDT05URVhUXCIsIFwic3RhcnRzIHdpdGhcIiwgXCJwcm9kXCJdLFxuICAgIFtcIkVOVklST05NRU5UXCIsIFwic3RhcnRzIHdpdGhcIiwgXCJwcm9kXCJdLFxuICAgIFtcIk5PREVfRU5WXCIsIFwic3RhcnRzIHdpdGhcIiwgXCJwcm9kXCJdLFxuICAgIFtcIlZFUkNFTF9FTlZcIiwgXCJzdGFydHMgd2l0aFwiLCBcInByb2RcIl0sXG4gICAgW1wiREVOT19ERVBMT1lNRU5UX0lEXCIsIFwiaXMgdHJ1dGh5XCJdLFxuICAgIFtjb25zdHNfanNfMS5lbnZLZXlzLlZlcmNlbEVudktleSwgXCJpcyB0cnV0aHkgYnV0IG5vdFwiLCBcImRldmVsb3BtZW50XCJdLFxuICAgIFtjb25zdHNfanNfMS5lbnZLZXlzLklzTmV0bGlmeSwgXCJpcyB0cnV0aHlcIl0sXG4gICAgW2NvbnN0c19qc18xLmVudktleXMuSXNSZW5kZXIsIFwiaXMgdHJ1dGh5XCJdLFxuICAgIFtjb25zdHNfanNfMS5lbnZLZXlzLlJhaWx3YXlCcmFuY2gsIFwiaXMgdHJ1dGh5XCJdLFxuICAgIFtjb25zdHNfanNfMS5lbnZLZXlzLklzQ2xvdWRmbGFyZVBhZ2VzLCBcImlzIHRydXRoeVwiXSxcbl07XG5jbGFzcyBNb2RlIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHR5cGUsIGlzRXhwbGljaXQsIGV4cGxpY2l0RGV2VXJsLCBlbnYgPSAoMCwgZXhwb3J0cy5hbGxQcm9jZXNzRW52KSgpLCB9KSB7XG4gICAgICAgIHRoaXMuZW52ID0gZW52O1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmlzRXhwbGljaXQgPSBpc0V4cGxpY2l0IHx8IEJvb2xlYW4oZXhwbGljaXREZXZVcmwpO1xuICAgICAgICB0aGlzLmV4cGxpY2l0RGV2VXJsID0gZXhwbGljaXREZXZVcmw7XG4gICAgfVxuICAgIGdldCBpc0RldigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gXCJkZXZcIjtcbiAgICB9XG4gICAgZ2V0IGlzQ2xvdWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09IFwiY2xvdWRcIjtcbiAgICB9XG4gICAgZ2V0IGlzSW5mZXJyZWQoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5pc0V4cGxpY2l0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiB3ZSBhcmUgZXhwbGljaXRseSBpbiBhIHBhcnRpY3VsYXIgbW9kZSwgcmV0cmlldmUgdGhlIFVSTCB0aGF0IHdlIGFyZVxuICAgICAqIHN1cmUgd2Ugc2hvdWxkIGJlIHVzaW5nLCBub3QgY29uc2lkZXJpbmcgYW55IGVudmlyb25tZW50IHZhcmlhYmxlcyBvciBvdGhlclxuICAgICAqIGluZmx1ZW5jZXMuXG4gICAgICovXG4gICAgZ2V0RXhwbGljaXRVcmwoZGVmYXVsdENsb3VkVXJsKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0V4cGxpY2l0KSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmV4cGxpY2l0RGV2VXJsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5leHBsaWNpdERldlVybC5ocmVmO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzQ2xvdWQpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0Q2xvdWRVcmw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNEZXYpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25zdHNfanNfMS5kZWZhdWx0RGV2U2VydmVySG9zdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmV4cG9ydHMuTW9kZSA9IE1vZGU7XG4vKipcbiAqIFJldHVybnMgdGhlIG1vZGUgb2YgdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQsIGJhc2VkIG9mZiBvZiBlaXRoZXIgcGFzc2VkXG4gKiBlbnZpcm9ubWVudCB2YXJpYWJsZXMgb3IgYHByb2Nlc3MuZW52YCwgb3IgZXhwbGljaXQgc2V0dGluZ3MuXG4gKi9cbmNvbnN0IGdldE1vZGUgPSAoeyBlbnYgPSAoMCwgZXhwb3J0cy5hbGxQcm9jZXNzRW52KSgpLCBjbGllbnQsIGV4cGxpY2l0TW9kZSwgfSA9IHt9KSA9PiB7XG4gICAgaWYgKGV4cGxpY2l0TW9kZSkge1xuICAgICAgICByZXR1cm4gbmV3IE1vZGUoeyB0eXBlOiBleHBsaWNpdE1vZGUsIGlzRXhwbGljaXQ6IHRydWUsIGVudiB9KTtcbiAgICB9XG4gICAgaWYgKGNsaWVudCA9PT0gbnVsbCB8fCBjbGllbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNsaWVudFtcIm1vZGVcIl0uaXNFeHBsaWNpdCkge1xuICAgICAgICByZXR1cm4gY2xpZW50W1wibW9kZVwiXTtcbiAgICB9XG4gICAgaWYgKGNvbnN0c19qc18xLmVudktleXMuSW5uZ2VzdERldk1vZGUgaW4gZW52KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZW52W2NvbnN0c19qc18xLmVudktleXMuSW5uZ2VzdERldk1vZGVdID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4cGxpY2l0RGV2VXJsID0gbmV3IFVSTChlbnZbY29uc3RzX2pzXzEuZW52S2V5cy5Jbm5nZXN0RGV2TW9kZV0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTW9kZSh7IHR5cGU6IFwiZGV2XCIsIGlzRXhwbGljaXQ6IHRydWUsIGV4cGxpY2l0RGV2VXJsLCBlbnYgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgICAgICAvLyBuby1vcFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVudklzRGV2ID0gKDAsIGV4cG9ydHMucGFyc2VBc0Jvb2xlYW4pKGVudltjb25zdHNfanNfMS5lbnZLZXlzLklubmdlc3REZXZNb2RlXSk7XG4gICAgICAgIGlmICh0eXBlb2YgZW52SXNEZXYgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1vZGUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IGVudklzRGV2ID8gXCJkZXZcIiA6IFwiY2xvdWRcIixcbiAgICAgICAgICAgICAgICBpc0V4cGxpY2l0OiB0cnVlLFxuICAgICAgICAgICAgICAgIGVudixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGlzUHJvZCA9IHByb2RDaGVja3Muc29tZSgoW2tleSwgY2hlY2tLZXksIGV4cGVjdGVkXSkgPT4ge1xuICAgICAgICByZXR1cm4gY2hlY2tGbnNbY2hlY2tLZXldKCgwLCBzdHJpbmdzX2pzXzEuc3RyaW5naWZ5VW5rbm93bikoZW52W2tleV0pLCBleHBlY3RlZCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBNb2RlKHsgdHlwZTogaXNQcm9kID8gXCJjbG91ZFwiIDogXCJkZXZcIiwgaXNFeHBsaWNpdDogZmFsc2UsIGVudiB9KTtcbn07XG5leHBvcnRzLmdldE1vZGUgPSBnZXRNb2RlO1xuLyoqXG4gKiBnZXRFbnZpcm9ubWVudE5hbWUgcmV0dXJucyB0aGUgc3VzcGVjdGVkIGJyYW5jaCBuYW1lIGZvciB0aGlzIGVudmlyb25tZW50IGJ5XG4gKiBzZWFyY2hpbmcgdGhyb3VnaCBhIHNldCBvZiBjb21tb24gZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuICpcbiAqIFRoaXMgY291bGQgYmUgdXNlZCB0byBkZXRlcm1pbmUgaWYgd2UncmUgb24gYSBicmFuY2ggZGVwbG95IG9yIG5vdCwgdGhvdWdoIGl0XG4gKiBzaG91bGQgYmUgbm90ZWQgdGhhdCB3ZSBkb24ndCBrbm93IGlmIHRoaXMgaXMgdGhlIGRlZmF1bHQgYnJhbmNoIG9yIG5vdC5cbiAqL1xuY29uc3QgZ2V0RW52aXJvbm1lbnROYW1lID0gKGVudiA9ICgwLCBleHBvcnRzLmFsbFByb2Nlc3NFbnYpKCkpID0+IHtcbiAgICAvKipcbiAgICAgKiBPcmRlciBpcyBpbXBvcnRhbnQ7IG1vcmUgdGhhbiBvbmUgb2YgdGhlc2UgZW52IHZhcnMgbWF5IGJlIHNldCwgc28gZW5zdXJlXG4gICAgICogdGhhdCB3ZSBjaGVjayB0aGUgbW9zdCBzcGVjaWZpYywgbW9zdCByZWxpYWJsZSBlbnYgdmFycyBmaXJzdC5cbiAgICAgKi9cbiAgICByZXR1cm4gKGVudltjb25zdHNfanNfMS5lbnZLZXlzLklubmdlc3RFbnZpcm9ubWVudF0gfHxcbiAgICAgICAgZW52W2NvbnN0c19qc18xLmVudktleXMuQnJhbmNoTmFtZV0gfHxcbiAgICAgICAgZW52W2NvbnN0c19qc18xLmVudktleXMuVmVyY2VsQnJhbmNoXSB8fFxuICAgICAgICBlbnZbY29uc3RzX2pzXzEuZW52S2V5cy5OZXRsaWZ5QnJhbmNoXSB8fFxuICAgICAgICBlbnZbY29uc3RzX2pzXzEuZW52S2V5cy5DbG91ZGZsYXJlUGFnZXNCcmFuY2hdIHx8XG4gICAgICAgIGVudltjb25zdHNfanNfMS5lbnZLZXlzLlJlbmRlckJyYW5jaF0gfHxcbiAgICAgICAgZW52W2NvbnN0c19qc18xLmVudktleXMuUmFpbHdheUJyYW5jaF0pO1xufTtcbmV4cG9ydHMuZ2V0RW52aXJvbm1lbnROYW1lID0gZ2V0RW52aXJvbm1lbnROYW1lO1xuY29uc3QgcHJvY2Vzc0VudiA9IChrZXkpID0+IHtcbiAgICByZXR1cm4gKDAsIGV4cG9ydHMuYWxsUHJvY2Vzc0VudikoKVtrZXldO1xufTtcbmV4cG9ydHMucHJvY2Vzc0VudiA9IHByb2Nlc3NFbnY7XG4vKipcbiAqIGFsbFByb2Nlc3NFbnYgcmV0dXJucyB0aGUgY3VycmVudCBwcm9jZXNzIGVudmlyb25tZW50IHZhcmlhYmxlcywgb3IgYW4gZW1wdHlcbiAqIG9iamVjdCBpZiB0aGV5IGNhbm5vdCBiZSByZWFkLCBtYWtpbmcgc3VyZSB3ZSBzdXBwb3J0IGVudmlyb25tZW50cyBvdGhlciB0aGFuXG4gKiBOb2RlIHN1Y2ggYXMgRGVubywgdG9vLlxuICpcbiAqIFVzaW5nIHRoaXMgZW5zdXJlcyB3ZSBkb24ndCBkYW5nZXJvdXNseSBhY2Nlc3MgYHByb2Nlc3MuZW52YCBpbiBlbnZpcm9ubWVudHNcbiAqIHdoZXJlIGl0IG1heSBub3QgYmUgZGVmaW5lZCwgc3VjaCBhcyBEZW5vIG9yIHRoZSBicm93c2VyLlxuICovXG5jb25zdCBhbGxQcm9jZXNzRW52ID0gKCkgPT4ge1xuICAgIC8vIE5vZGUsIG9yIE5vZGUtbGlrZSBlbnZpcm9ubWVudHNcbiAgICB0cnkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQGlubmdlc3QvaW50ZXJuYWwvcHJvY2Vzcy13YXJuXG4gICAgICAgIGlmIChwcm9jZXNzLmVudikge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEBpbm5nZXN0L2ludGVybmFsL3Byb2Nlc3Mtd2FyblxuICAgICAgICAgICAgcmV0dXJuIHByb2Nlc3MuZW52O1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChfZXJyKSB7XG4gICAgICAgIC8vIG5vb3BcbiAgICB9XG4gICAgLy8gRGVub1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGVudiA9IERlbm8uZW52LnRvT2JqZWN0KCk7XG4gICAgICAgIGlmIChlbnYpIHtcbiAgICAgICAgICAgIHJldHVybiBlbnY7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKF9lcnIpIHtcbiAgICAgICAgLy8gbm9vcFxuICAgIH1cbiAgICAvLyBOZXRsaWZ5XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZW52ID0gTmV0bGlmeS5lbnYudG9PYmplY3QoKTtcbiAgICAgICAgaWYgKGVudikge1xuICAgICAgICAgICAgcmV0dXJuIGVudjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoX2Vycikge1xuICAgICAgICAvLyBub29wXG4gICAgfVxuICAgIHJldHVybiB7fTtcbn07XG5leHBvcnRzLmFsbFByb2Nlc3NFbnYgPSBhbGxQcm9jZXNzRW52O1xuLyoqXG4gKiBHZW5lcmF0ZSBhIHN0YW5kYXJkaXNlZCBzZXQgb2YgaGVhZGVycyBiYXNlZCBvbiBpbnB1dCBhbmQgZW52aXJvbm1lbnRcbiAqIHZhcmlhYmxlcy5cbiAqXG4gKlxuICovXG5jb25zdCBpbm5nZXN0SGVhZGVycyA9IChvcHRzKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHNka1ZlcnNpb24gPSBgaW5uZ2VzdC1qczp2JHt2ZXJzaW9uX2pzXzEudmVyc2lvbn1gO1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICBcIlVzZXItQWdlbnRcIjogc2RrVmVyc2lvbixcbiAgICAgICAgW2NvbnN0c19qc18xLmhlYWRlcktleXMuU2RrVmVyc2lvbl06IHNka1ZlcnNpb24sXG4gICAgfTtcbiAgICBpZiAob3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLmZyYW1ld29yaykge1xuICAgICAgICBoZWFkZXJzW2NvbnN0c19qc18xLmhlYWRlcktleXMuRnJhbWV3b3JrXSA9IG9wdHMuZnJhbWV3b3JrO1xuICAgIH1cbiAgICBpZiAob3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLmV4cGVjdGVkU2VydmVyS2luZCkge1xuICAgICAgICBoZWFkZXJzW2NvbnN0c19qc18xLmhlYWRlcktleXMuSW5uZ2VzdEV4cGVjdGVkU2VydmVyS2luZF0gPSBvcHRzLmV4cGVjdGVkU2VydmVyS2luZDtcbiAgICB9XG4gICAgY29uc3QgZW52ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAoMCwgZXhwb3J0cy5hbGxQcm9jZXNzRW52KSgpKSwgb3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLmVudik7XG4gICAgY29uc3QgaW5uZ2VzdEVudiA9IChvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMuaW5uZ2VzdEVudikgfHwgKDAsIGV4cG9ydHMuZ2V0RW52aXJvbm1lbnROYW1lKShlbnYpO1xuICAgIGlmIChpbm5nZXN0RW52KSB7XG4gICAgICAgIGhlYWRlcnNbY29uc3RzX2pzXzEuaGVhZGVyS2V5cy5FbnZpcm9ubWVudF0gPSBpbm5nZXN0RW52O1xuICAgIH1cbiAgICBjb25zdCBwbGF0Zm9ybSA9ICgwLCBleHBvcnRzLmdldFBsYXRmb3JtTmFtZSkoZW52KTtcbiAgICBpZiAocGxhdGZvcm0pIHtcbiAgICAgICAgaGVhZGVyc1tjb25zdHNfanNfMS5oZWFkZXJLZXlzLlBsYXRmb3JtXSA9IHBsYXRmb3JtO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGhlYWRlcnMpLCAoX2EgPSBvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMuY2xpZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbXCJoZWFkZXJzXCJdKSwgb3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLmV4dHJhcyk7XG59O1xuZXhwb3J0cy5pbm5nZXN0SGVhZGVycyA9IGlubmdlc3RIZWFkZXJzO1xuLyoqXG4gKiBBIHNldCBvZiBjaGVja3MgdGhhdCwgZ2l2ZW4gYW4gZW52aXJvbm1lbnQsIHdpbGwgcmV0dXJuIGB0cnVlYCBpZiB0aGUgY3VycmVudFxuICogZW52aXJvbm1lbnQgaXMgcnVubmluZyBvbiB0aGUgcGxhdGZvcm0gd2l0aCB0aGUgZ2l2ZW4gbmFtZS5cbiAqL1xuY29uc3QgcGxhdGZvcm1DaGVja3MgPSB7XG4gICAgLyoqXG4gICAgICogVmVyY2VsIEVkZ2UgRnVuY3Rpb25zIGRvbid0IGhhdmUgYWNjZXNzIHRvIGVudmlyb25tZW50IHZhcmlhYmxlcyB1bmxlc3NcbiAgICAgKiB0aGV5IGFyZSBleHBsaWNpdGx5IHJlZmVyZW5jZWQgaW4gdGhlIHRvcCBsZXZlbCBjb2RlLCBidXQgdGhleSBkbyBoYXZlIGFcbiAgICAgKiBnbG9iYWwgYEVkZ2VSdW50aW1lYCB2YXJpYWJsZSBzZXQgdGhhdCB3ZSBjYW4gdXNlIHRvIGRldGVjdCB0aGlzLlxuICAgICAqL1xuICAgIHZlcmNlbDogKGVudikgPT4gZW52W2NvbnN0c19qc18xLmVudktleXMuSXNWZXJjZWxdID09PSBcIjFcIiB8fCB0eXBlb2YgRWRnZVJ1bnRpbWUgPT09IFwic3RyaW5nXCIsXG4gICAgbmV0bGlmeTogKGVudikgPT4gZW52W2NvbnN0c19qc18xLmVudktleXMuSXNOZXRsaWZ5XSA9PT0gXCJ0cnVlXCIsXG4gICAgXCJjbG91ZGZsYXJlLXBhZ2VzXCI6IChlbnYpID0+IGVudltjb25zdHNfanNfMS5lbnZLZXlzLklzQ2xvdWRmbGFyZVBhZ2VzXSA9PT0gXCIxXCIsXG4gICAgcmVuZGVyOiAoZW52KSA9PiBlbnZbY29uc3RzX2pzXzEuZW52S2V5cy5Jc1JlbmRlcl0gPT09IFwidHJ1ZVwiLFxuICAgIHJhaWx3YXk6IChlbnYpID0+IEJvb2xlYW4oZW52W2NvbnN0c19qc18xLmVudktleXMuUmFpbHdheUVudmlyb25tZW50XSksXG59O1xuLyoqXG4gKiBBIHNldCBvZiBjaGVja3MgdGhhdCwgZ2l2ZW4gYW4gZW52aXJvbm1lbnQsIHdpbGwgcmV0dXJuIGB0cnVlYCBpZiB0aGUgY3VycmVudFxuICogZW52aXJvbm1lbnQgYW5kIHBsYXRmb3JtIHN1cHBvcnRzIHN0cmVhbWluZyByZXNwb25zZXMgYmFjayB0byBJbm5nZXN0LlxuICpcbiAqIFN0cmVhbWluZyBjYXBhYmlsaXR5IGlzIGJvdGggZnJhbWV3b3JrIGFuZCBwbGF0Zm9ybS1iYXNlZC4gRnJhbWV3b3JrcyBhcmVcbiAqIHN1cHBvcnRlZCBpbiBzZXJ2ZSBoYW5kbGVycywgYW5kIHBsYXRmb3JtcyBhcmUgY2hlY2tlZCBoZXJlLlxuICpcbiAqIEFzIHN1Y2gsIHRoaXMgcmVjb3JkIGRlY2xhcmVzIHdoaWNoIHBsYXRmb3JtcyB3ZSBleHBsaWNpdGx5IHN1cHBvcnQgZm9yXG4gKiBzdHJlYW1pbmcgYW5kIGlzIHVzZWQgYnkge0BsaW5rIHBsYXRmb3JtU3VwcG9ydHNTdHJlYW1pbmd9LlxuICovXG5jb25zdCBzdHJlYW1pbmdDaGVja3MgPSB7XG4gICAgLyoqXG4gICAgICogXCJWZXJjZWwgc3VwcG9ydHMgc3RyZWFtaW5nIGZvciBTZXJ2ZXJsZXNzIEZ1bmN0aW9ucywgRWRnZSBGdW5jdGlvbnMsIGFuZFxuICAgICAqIFJlYWN0IFNlcnZlciBDb21wb25lbnRzIGluIE5leHQuanMgcHJvamVjdHMuXCJcbiAgICAgKlxuICAgICAqIEluIHByYWN0aWNlLCBob3dldmVyLCB0aGVyZSBhcmUgbWFueSByZXBvcnRzIG9mIHN0cmVhbWluZyBub3Qgd29ya2luZyBhc1xuICAgICAqIGV4cGVjdGVkIG9uIFNlcnZlcmxlc3MgRnVuY3Rpb25zLCBzbyB3ZSByZXNvcnQgdG8gb25seSBhbGxvd2luZyBzdHJlYW1pbmdcbiAgICAgKiBmb3IgRWRnZSBGdW5jdGlvbnMgaGVyZS5cbiAgICAgKlxuICAgICAqIFNlZSB7QGxpbmsgaHR0cHM6Ly92ZXJjZWwuY29tL2RvY3MvZnJhbWV3b3Jrcy9uZXh0anMjc3RyZWFtaW5nfVxuICAgICAqL1xuICAgIHZlcmNlbDogKF9mcmFtZXdvcmssIF9lbnYpID0+IHR5cGVvZiBFZGdlUnVudGltZSA9PT0gXCJzdHJpbmdcIixcbiAgICBcImNsb3VkZmxhcmUtcGFnZXNcIjogKCkgPT4gdHJ1ZSxcbn07XG5jb25zdCBnZXRQbGF0Zm9ybU5hbWUgPSAoZW52KSA9PiB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHBsYXRmb3JtQ2hlY2tzKS5maW5kKChrZXkpID0+IHtcbiAgICAgICAgcmV0dXJuIHBsYXRmb3JtQ2hlY2tzW2tleV0oZW52KTtcbiAgICB9KTtcbn07XG5leHBvcnRzLmdldFBsYXRmb3JtTmFtZSA9IGdldFBsYXRmb3JtTmFtZTtcbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgd2UgYmVsaWV2ZSB0aGUgY3VycmVudCBlbnZpcm9ubWVudCBzdXBwb3J0cyBzdHJlYW1pbmdcbiAqIHJlc3BvbnNlcyBiYWNrIHRvIElubmdlc3QuXG4gKlxuICogV2UgcnVuIGEgY2hlY2sgZGlyZWN0bHkgcmVsYXRlZCB0byB0aGUgcGxhdGZvcm0gd2UgYmVsaWV2ZSB3ZSdyZSBydW5uaW5nIG9uLFxuICogdXN1YWxseSBiYXNlZCBvbiBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG4gKi9cbmNvbnN0IHBsYXRmb3JtU3VwcG9ydHNTdHJlYW1pbmcgPSAoZnJhbWV3b3JrLCBlbnYgPSAoMCwgZXhwb3J0cy5hbGxQcm9jZXNzRW52KSgpKSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gKChfYiA9IChfYSA9IHN0cmVhbWluZ0NoZWNrc1soMCwgZXhwb3J0cy5nZXRQbGF0Zm9ybU5hbWUpKGVudildKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChzdHJlYW1pbmdDaGVja3MsIGZyYW1ld29yaywgZW52KSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZmFsc2UpO1xufTtcbmV4cG9ydHMucGxhdGZvcm1TdXBwb3J0c1N0cmVhbWluZyA9IHBsYXRmb3JtU3VwcG9ydHNTdHJlYW1pbmc7XG4vKipcbiAqIEEgdW5pcXVlIHN5bWJvbCB1c2VkIHRvIG1hcmsgYSBjdXN0b20gZmV0Y2ggaW1wbGVtZW50YXRpb24uIFdlIHdyYXAgdGhlXG4gKiBpbXBsZW1lbnRhdGlvbnMgdG8gcHJvdmlkZSBzb21lIGV4dHJhIGNvbnRyb2wgd2hlbiBoYW5kbGluZyBlcnJvcnMuXG4gKi9cbmNvbnN0IENVU1RPTV9GRVRDSF9NQVJLRVIgPSBTeW1ib2woXCJDdXN0b20gZmV0Y2ggaW1wbGVtZW50YXRpb25cIik7XG4vKipcbiAqIEdpdmVuIGEgcG90ZW50aWFsIGZldGNoIGZ1bmN0aW9uLCByZXR1cm4gdGhlIGZldGNoIGZ1bmN0aW9uIHRvIHVzZSBiYXNlZCBvblxuICogdGhpcyBhbmQgdGhlIGVudmlyb25tZW50LlxuICovXG5jb25zdCBnZXRGZXRjaCA9IChnaXZlbkZldGNoKSA9PiB7XG4gICAgLyoqXG4gICAgICogSWYgd2UndmUgZXhwbGljaXRseSBiZWVuIGdpdmVuIGEgZmV0Y2ggZnVuY3Rpb24sIHVzZSB0aGF0LlxuICAgICAqL1xuICAgIGlmIChnaXZlbkZldGNoKSB7XG4gICAgICAgIGlmIChDVVNUT01fRkVUQ0hfTUFSS0VSIGluIGdpdmVuRmV0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiBnaXZlbkZldGNoO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXZSB3cmFwIHRoZSBnaXZlbiBmZXRjaCBmdW5jdGlvbiB0byBwcm92aWRlIHNvbWUgZXh0cmEgY29udHJvbCB3aGVuXG4gICAgICAgICAqIGhhbmRsaW5nIGVycm9ycy5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IGN1c3RvbUZldGNoID0gYXN5bmMgKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGdpdmVuRmV0Y2goLi4uYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQ2FwdHVyZSB3YXJuaW5ncyB0aGF0IGFyZSBub3Qgc2ltcGxlIGZldGNoIGZhaWx1cmVzIGFuZCBoaWdobGlnaHRcbiAgICAgICAgICAgICAgICAgKiB0aGVtIGZvciB0aGUgdXNlci5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIFdlIGFsc28gdXNlIHRoaXMgb3Bwb3J0dW5pdHkgdG8gbG9nIHRoZSBjYXVzaW5nIGVycm9yLCBhcyBjb2RlIGhpZ2hlclxuICAgICAgICAgICAgICAgICAqIHVwIHRoZSBzdGFjayB3aWxsIGxpa2VseSBhYnN0cmFjdCB0aGlzLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmICghKGVyciBpbnN0YW5jZW9mIEVycm9yKSB8fFxuICAgICAgICAgICAgICAgICAgICAhKChfYSA9IGVyci5tZXNzYWdlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3RhcnRzV2l0aChcImZldGNoIGZhaWxlZFwiKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQSByZXF1ZXN0IGZhaWxlZCB3aGVuIHVzaW5nIGEgY3VzdG9tIGZldGNoIGltcGxlbWVudGF0aW9uOyB0aGlzIG1heSBiZSBhIG1pc2NvbmZpZ3VyYXRpb24uIE1ha2Ugc3VyZSB0aGF0IHlvdXIgZmV0Y2ggY2xpZW50IGlzIGNvcnJlY3RseSBib3VuZCB0byB0aGUgZ2xvYmFsIHNjb3BlLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXJrIHRoZSBjdXN0b20gZmV0Y2ggaW1wbGVtZW50YXRpb24gc28gdGhhdCB3ZSBjYW4gaWRlbnRpZnkgaXQgbGF0ZXIsIGluXG4gICAgICAgICAqIGFkZGl0aW9uIHRvIGFkZGluZyBzb21lIHJ1bnRpbWUgcHJvcGVydGllcyB0byBpdCB0byBtYWtlIGl0IHNlZW0gYXMgbXVjaFxuICAgICAgICAgKiBsaWtlIHRoZSBvcmlnaW5hbCBmZXRjaCBhcyBwb3NzaWJsZS5cbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGN1c3RvbUZldGNoLCB7XG4gICAgICAgICAgICBbQ1VTVE9NX0ZFVENIX01BUktFUl06IHt9LFxuICAgICAgICAgICAgbmFtZTogeyB2YWx1ZTogZ2l2ZW5GZXRjaC5uYW1lIH0sXG4gICAgICAgICAgICBsZW5ndGg6IHsgdmFsdWU6IGdpdmVuRmV0Y2gubGVuZ3RoIH0sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY3VzdG9tRmV0Y2g7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJyb3dzZXIgb3IgTm9kZSAxOCtcbiAgICAgKi9cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIgJiYgXCJmZXRjaFwiIGluIGdsb2JhbFRoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmZXRjaC5iaW5kKGdsb2JhbFRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy8gbm8tb3BcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhpc3RpbmcgcG9seWZpbGxlZCBmZXRjaFxuICAgICAqL1xuICAgIGlmICh0eXBlb2YgZmV0Y2ggIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIGZldGNoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbnZpcm9ubWVudHMgd2hlcmUgZmV0Y2ggY2Fubm90IGJlIGZvdW5kIGFuZCBtdXN0IGJlIHBvbHlmaWxsZWRcbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXZhci1yZXF1aXJlc1xuICAgIHJldHVybiByZXF1aXJlKFwiY3Jvc3MtZmV0Y2hcIik7XG59O1xuZXhwb3J0cy5nZXRGZXRjaCA9IGdldEZldGNoO1xuLyoqXG4gKiBJZiBgUmVzcG9uc2VgIGlzbid0IGluY2x1ZGVkIGluIHRoaXMgZW52aXJvbm1lbnQsIGl0J3MgcHJvYmFibHkgYW4gZWFybGllclxuICogTm9kZSBlbnYgdGhhdCBpc24ndCBhbHJlYWR5IHBvbHlmaWxsaW5nLiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgZWl0aGVyIHRoZVxuICogbmF0aXZlIGBSZXNwb25zZWAgb3IgYSBwb2x5ZmlsbGVkIG9uZS5cbiAqL1xuY29uc3QgZ2V0UmVzcG9uc2UgPSAoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBSZXNwb25zZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICByZXR1cm4gUmVzcG9uc2U7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVybiwgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdmFyLXJlcXVpcmVzXG4gICAgcmV0dXJuIHJlcXVpcmUoXCJjcm9zcy1mZXRjaFwiKS5SZXNwb25zZTtcbn07XG5leHBvcnRzLmdldFJlc3BvbnNlID0gZ2V0UmVzcG9uc2U7XG4vKipcbiAqIEdpdmVuIGFuIHVua25vd24gdmFsdWUsIHRyeSB0byBwYXJzZSBpdCBhcyBhIGBib29sZWFuYC4gVXNlZnVsIGZvciBwYXJzaW5nXG4gKiBlbnZpcm9ubWVudCB2YXJpYWJsZXMgdGhhdCBjb3VsZCBiZSBhIHNlbGVjdGlvbiBvZiBkaWZmZXJlbnQgdmFsdWVzIHN1Y2ggYXNcbiAqIGBcInRydWVcImAsIGBcIjFcImAuXG4gKlxuICogSWYgdGhlIHZhbHVlIGNvdWxkIG5vdCBiZSBjb25maWRlbnRseSBwYXJzZWQgYXMgYSBgYm9vbGVhbmAgb3Igd2FzIHNlZW4gdG8gYmVcbiAqIGB1bmRlZmluZWRgLCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYHVuZGVmaW5lZGAuXG4gKi9cbmNvbnN0IHBhcnNlQXNCb29sZWFuID0gKHZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCB0cmltbWVkID0gdmFsdWUudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICh0cmltbWVkID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChbXCJ0cnVlXCIsIFwiMVwiXS5pbmNsdWRlcyh0cmltbWVkKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufTtcbmV4cG9ydHMucGFyc2VBc0Jvb2xlYW4gPSBwYXJzZUFzQm9vbGVhbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVudi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/helpers/env.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/helpers/errors.js":
/*!************************************************!*\
  !*** ./node_modules/inngest/helpers/errors.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.functionStoppedRunningErr = exports.rethrowError = exports.OutgoingResultError = exports.fixEventKeyMissingSteps = exports.prettyError = exports.getErrorMessage = exports.minifyPrettyError = exports.prettyErrorSplitter = exports.ErrCode = exports.deserializeError = exports.isSerializedError = exports.serializeError = void 0;\nconst chalk_1 = __importDefault(__webpack_require__(/*! chalk */ \"(rsc)/./node_modules/chalk/source/index.js\"));\nconst json_stringify_safe_1 = __importDefault(__webpack_require__(/*! json-stringify-safe */ \"(rsc)/./node_modules/json-stringify-safe/stringify.js\"));\nconst serialize_error_cjs_1 = __webpack_require__(/*! serialize-error-cjs */ \"(rsc)/./node_modules/serialize-error-cjs/dist/index.js\");\nconst strip_ansi_1 = __importDefault(__webpack_require__(/*! strip-ansi */ \"(rsc)/./node_modules/inngest/node_modules/strip-ansi/index.js\"));\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/inngest/node_modules/zod/lib/index.js\");\nconst NonRetriableError_js_1 = __webpack_require__(/*! ../components/NonRetriableError.js */ \"(rsc)/./node_modules/inngest/components/NonRetriableError.js\");\nconst SERIALIZED_KEY = \"__serialized\";\nconst SERIALIZED_VALUE = true;\n/**\n * Add first-class support for certain errors that we control, in addition to\n * built-in errors such as `TypeError`.\n *\n * Adding these allows these non-standard errors to be correctly serialized,\n * sent to Inngest, then deserialized back into the correct error type for users\n * to react to correctly.\n *\n * Note that these errors only support `message?: string | undefined` as the\n * input; more custom errors are not supported with this current strategy.\n */\nserialize_error_cjs_1.errorConstructors.set(\"NonRetriableError\", NonRetriableError_js_1.NonRetriableError);\n/**\n * Serialise an error to a serialized JSON string.\n *\n * Errors do not serialise nicely to JSON, so we use this function to convert\n * them to a serialized JSON string. Doing this is also non-trivial for some\n * errors, so we use the `serialize-error` package to do it for us.\n *\n * See {@link https://www.npmjs.com/package/serialize-error}\n *\n * This function is a small wrapper around that package to also add a `type`\n * property to the serialised error, so that we can distinguish between\n * serialised errors and other objects.\n *\n * Will not reserialise existing serialised errors.\n */\nconst serializeError = (\n/**\n * The suspected error to serialize.\n */\nsubject, \n/**\n * If `true` and the error is not serializable, will return the original value\n * as `unknown` instead of coercing it to a serialized error.\n */\nallowUnknown = false) => {\n    try {\n        // Try to understand if this is already done.\n        // Will handle stringified errors.\n        const existingSerializedError = (0, exports.isSerializedError)(subject);\n        if (existingSerializedError) {\n            return existingSerializedError;\n        }\n        if (typeof subject === \"object\" && subject !== null) {\n            // Is an object, so let's try and serialize it.\n            const serializedErr = (0, serialize_error_cjs_1.serializeError)(subject);\n            // Not a proper error was caught, so give us a chance to return `unknown`.\n            if (!serializedErr.name && allowUnknown) {\n                return subject;\n            }\n            // Serialization can succeed but assign no name or message, so we'll\n            // map over the result here to ensure we have everything.\n            // We'll just stringify the entire subject for the message, as this at\n            // least provides some context for the user.\n            const ret = Object.assign(Object.assign({}, serializedErr), { name: serializedErr.name || \"Error\", message: serializedErr.message ||\n                    (0, json_stringify_safe_1.default)(subject) ||\n                    \"Unknown error; error serialization could not find a message.\", stack: serializedErr.stack || \"\", [SERIALIZED_KEY]: SERIALIZED_VALUE });\n            // If we have a cause, make sure we recursively serialize them too. We are\n            // lighter with causes though; attempt to recursively serialize them, but\n            // stop if we find something that doesn't work and just return `unknown`.\n            let target = ret;\n            const maxDepth = 5;\n            for (let i = 0; i < maxDepth; i++) {\n                if (typeof target === \"object\" &&\n                    target !== null &&\n                    \"cause\" in target &&\n                    target.cause) {\n                    target = target.cause = (0, exports.serializeError)(target.cause, true);\n                    continue;\n                }\n                break;\n            }\n            return ret;\n        }\n        // If it's not an object, it's hard to parse this as an Error. In this case,\n        // we'll throw an error to start attempting backup strategies.\n        throw new Error(\"Error is not an object; strange throw value.\");\n    }\n    catch (err) {\n        if (allowUnknown) {\n            // If we are allowed to return unknown, we'll just return the original\n            // value.\n            return subject;\n        }\n        try {\n            // If serialization fails, fall back to a regular Error and use the\n            // original object as the message for an Error. We don't know what this\n            // object looks like, so we can't do anything else with it.\n            return Object.assign(Object.assign({}, (0, exports.serializeError)(new Error(typeof subject === \"string\" ? subject : (0, json_stringify_safe_1.default)(subject)), false)), { \n                // Remove the stack; it's not relevant here\n                stack: \"\", [SERIALIZED_KEY]: SERIALIZED_VALUE });\n        }\n        catch (err) {\n            // If this failed, then stringifying the object also failed, so we'll just\n            // return a completely generic error.\n            // Failing to stringify the object is very unlikely.\n            return {\n                name: \"Could not serialize source error\",\n                message: \"Serializing the source error failed.\",\n                stack: \"\",\n                [SERIALIZED_KEY]: SERIALIZED_VALUE,\n            };\n        }\n    }\n};\nexports.serializeError = serializeError;\n/**\n * Check if an object or a string is a serialised error created by\n * {@link serializeError}.\n */\nconst isSerializedError = (value) => {\n    try {\n        if (typeof value === \"string\") {\n            const parsed = zod_1.z\n                .object({\n                [SERIALIZED_KEY]: zod_1.z.literal(SERIALIZED_VALUE),\n                name: zod_1.z.enum([...Array.from(serialize_error_cjs_1.errorConstructors.keys())]),\n                message: zod_1.z.string(),\n                stack: zod_1.z.string(),\n            })\n                .passthrough()\n                .safeParse(JSON.parse(value));\n            if (parsed.success) {\n                return parsed.data;\n            }\n        }\n        if (typeof value === \"object\" && value !== null) {\n            const objIsSerializedErr = Object.prototype.hasOwnProperty.call(value, SERIALIZED_KEY) &&\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n                value[SERIALIZED_KEY] ===\n                    SERIALIZED_VALUE;\n            if (objIsSerializedErr) {\n                return value;\n            }\n        }\n    }\n    catch (_a) {\n        // no-op; we'll return undefined if parsing failed, as it isn't a serialized\n        // error\n    }\n};\nexports.isSerializedError = isSerializedError;\n/**\n * Deserialise an error created by {@link serializeError}.\n *\n * Ensures we only deserialise errors that meet a minimum level of\n * applicability, inclusive of error handling to ensure that badly serialized\n * errors are still handled.\n */\nconst deserializeError = (subject, allowUnknown = false) => {\n    const requiredFields = [\"name\", \"message\"];\n    try {\n        const hasRequiredFields = requiredFields.every((field) => {\n            return Object.prototype.hasOwnProperty.call(subject, field);\n        });\n        if (!hasRequiredFields) {\n            throw new Error();\n        }\n        const deserializedErr = (0, serialize_error_cjs_1.deserializeError)(subject);\n        if (\"cause\" in deserializedErr) {\n            deserializedErr.cause = (0, exports.deserializeError)(deserializedErr.cause, true);\n        }\n        return deserializedErr;\n    }\n    catch (_a) {\n        if (allowUnknown) {\n            // If we are allowed to return unknown, we'll just return the original\n            // value.\n            return subject;\n        }\n        const err = new Error(\"Unknown error; could not reserialize\");\n        /**\n         * Remove the stack so that it's not misleadingly shown as the Inngest\n         * internals.\n         */\n        err.stack = undefined;\n        return err;\n    }\n};\nexports.deserializeError = deserializeError;\nvar ErrCode;\n(function (ErrCode) {\n    ErrCode[\"NESTING_STEPS\"] = \"NESTING_STEPS\";\n    /**\n     * Legacy v0 execution error code for when a function has changed and no\n     * longer matches its in-progress state.\n     *\n     * @deprecated Not for use in latest execution method.\n     */\n    ErrCode[\"NON_DETERMINISTIC_FUNCTION\"] = \"NON_DETERMINISTIC_FUNCTION\";\n    /**\n     * Legacy v0 execution error code for when a function is found to be using\n     * async actions after memoziation has occurred, which v0 doesn't support.\n     *\n     * @deprecated Not for use in latest execution method.\n     */\n    ErrCode[\"ASYNC_DETECTED_AFTER_MEMOIZATION\"] = \"ASYNC_DETECTED_AFTER_MEMOIZATION\";\n    /**\n     * Legacy v0 execution error code for when a function is found to be using\n     * steps after a non-step async action has occurred.\n     *\n     * @deprecated Not for use in latest execution method.\n     */\n    ErrCode[\"STEP_USED_AFTER_ASYNC\"] = \"STEP_USED_AFTER_ASYNC\";\n    ErrCode[\"AUTOMATIC_PARALLEL_INDEXING\"] = \"AUTOMATIC_PARALLEL_INDEXING\";\n})(ErrCode || (exports.ErrCode = ErrCode = {}));\nexports.prettyErrorSplitter = \"=================================================\";\n/**\n * Given an unknown `err`, mutate it to minify any pretty errors that it\n * contains.\n */\nconst minifyPrettyError = (err) => {\n    var _a, _b, _c, _d;\n    try {\n        if (!isError(err)) {\n            return err;\n        }\n        const isPrettyError = err.message.includes(exports.prettyErrorSplitter);\n        if (!isPrettyError) {\n            return err;\n        }\n        const sanitizedMessage = (0, strip_ansi_1.default)(err.message);\n        const message = ((_b = (_a = sanitizedMessage.split(\"  \")[1]) === null || _a === void 0 ? void 0 : _a.split(\"\\n\")[0]) === null || _b === void 0 ? void 0 : _b.trim()) || err.message;\n        const code = ((_d = (_c = sanitizedMessage.split(\"\\n\\nCode: \")[1]) === null || _c === void 0 ? void 0 : _c.split(\"\\n\\n\")[0]) === null || _d === void 0 ? void 0 : _d.trim()) ||\n            undefined;\n        err.message = [code, message].filter(Boolean).join(\" - \");\n        if (err.stack) {\n            const sanitizedStack = (0, strip_ansi_1.default)(err.stack);\n            const stackRest = sanitizedStack\n                .split(`${exports.prettyErrorSplitter}\\n`)\n                .slice(2)\n                .join(\"\\n\");\n            err.stack = `${err.name}: ${err.message}\\n${stackRest}`;\n        }\n        return err;\n    }\n    catch (noopErr) {\n        return err;\n    }\n};\nexports.minifyPrettyError = minifyPrettyError;\n/**\n * Given an `err`, return a boolean representing whether it is in the shape of\n * an `Error` or not.\n */\nconst isError = (err) => {\n    try {\n        if (err instanceof Error) {\n            return true;\n        }\n        const hasName = Object.prototype.hasOwnProperty.call(err, \"name\");\n        const hasMessage = Object.prototype.hasOwnProperty.call(err, \"message\");\n        return hasName && hasMessage;\n    }\n    catch (noopErr) {\n        return false;\n    }\n};\n/**\n * Given an `unknown` object, retrieve the `message` property from it, or fall\n * back to the `fallback` string if it doesn't exist or is empty.\n */\nconst getErrorMessage = (err, fallback) => {\n    const { message } = zod_1.z\n        .object({ message: zod_1.z.string().min(1) })\n        .catch({ message: fallback })\n        .parse(err);\n    return message;\n};\nexports.getErrorMessage = getErrorMessage;\n/**\n * Given a {@link PrettyError}, return a nicely-formatted string ready to log\n * or throw.\n *\n * Useful for ensuring that errors are logged in a consistent, helpful format\n * across the SDK by prompting for key pieces of information.\n */\nconst prettyError = ({ type = \"error\", whatHappened, otherwise, reassurance, toFixNow, why, consequences, stack, code, }) => {\n    var _a, _b;\n    const { icon, colorFn } = {\n        error: { icon: \"\", colorFn: chalk_1.default.red },\n        warn: { icon: \"\", colorFn: chalk_1.default.yellow },\n    }[type];\n    let header = `${icon}  ${chalk_1.default.bold.underline(whatHappened.trim())}`;\n    if (stack) {\n        header +=\n            \"\\n\" +\n                [...(((_a = new Error().stack) === null || _a === void 0 ? void 0 : _a.split(\"\\n\").slice(1).filter(Boolean)) || [])].join(\"\\n\");\n    }\n    let toFixNowStr = (_b = (Array.isArray(toFixNow)\n        ? toFixNow\n            .map((s) => s.trim())\n            .filter(Boolean)\n            .map((s, i) => `\\t${i + 1}. ${s}`)\n            .join(\"\\n\")\n        : toFixNow === null || toFixNow === void 0 ? void 0 : toFixNow.trim())) !== null && _b !== void 0 ? _b : \"\";\n    if (Array.isArray(toFixNow) && toFixNowStr) {\n        toFixNowStr = `To fix this, you can take one of the following courses of action:\\n\\n${toFixNowStr}`;\n    }\n    let body = [reassurance === null || reassurance === void 0 ? void 0 : reassurance.trim(), why === null || why === void 0 ? void 0 : why.trim(), consequences === null || consequences === void 0 ? void 0 : consequences.trim()]\n        .filter(Boolean)\n        .join(\" \");\n    body += body ? `\\n\\n${toFixNowStr}` : toFixNowStr;\n    const trailer = [otherwise === null || otherwise === void 0 ? void 0 : otherwise.trim()].filter(Boolean).join(\" \");\n    const message = [\n        exports.prettyErrorSplitter,\n        header,\n        body,\n        trailer,\n        code ? `Code: ${code}` : \"\",\n        exports.prettyErrorSplitter,\n    ]\n        .filter(Boolean)\n        .join(\"\\n\\n\");\n    return colorFn(message);\n};\nexports.prettyError = prettyError;\nexports.fixEventKeyMissingSteps = [\n    \"Set the `INNGEST_EVENT_KEY` environment variable\",\n    `Pass a key to the \\`new Inngest()\\` constructor using the \\`${\"eventKey\"}\\` option`,\n    `Use \\`inngest.${\"setEventKey\"}()\\` at runtime`,\n];\n/**\n * An error that, when thrown, indicates internally that an outgoing operation\n * contains an error.\n *\n * We use this because serialized `data` sent back to Inngest may differ from\n * the error instance itself due to middleware.\n *\n * @internal\n */\nclass OutgoingResultError extends Error {\n    constructor(result) {\n        super(\"OutgoingOpError\");\n        this.result = result;\n    }\n}\nexports.OutgoingResultError = OutgoingResultError;\n/**\n * Create a function that will rethrow an error with a prefix added to the\n * message.\n *\n * Useful for adding context to errors that are rethrown.\n *\n * @example\n * ```ts\n * await doSomeAction().catch(rethrowError(\"Failed to do some action\"));\n * ```\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst rethrowError = (prefix) => {\n    return (err) => {\n        try {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/restrict-template-expressions\n            err.message && (err.message = `${prefix}; ${err.message}`);\n        }\n        catch (noopErr) {\n            // no-op\n        }\n        finally {\n            // eslint-disable-next-line no-unsafe-finally\n            throw err;\n        }\n    };\n};\nexports.rethrowError = rethrowError;\n/**\n * Legacy v0 execution error for functions that don't support mixing steps and\n * regular async actions.\n */\nconst functionStoppedRunningErr = (code) => {\n    return (0, exports.prettyError)({\n        whatHappened: \"Your function was stopped from running\",\n        why: \"We detected a mix of asynchronous logic, some using step tooling and some not.\",\n        consequences: \"This can cause unexpected behaviour when a function is paused and resumed and is therefore strongly discouraged; we stopped your function to ensure nothing unexpected happened!\",\n        stack: true,\n        toFixNow: \"Ensure that your function is either entirely step-based or entirely non-step-based, by either wrapping all asynchronous logic in `step.run()` calls or by removing all `step.*()` calls.\",\n        otherwise: \"For more information on why step functions work in this manner, see https://www.inngest.com/docs/functions/multi-step#gotchas\",\n        code,\n    });\n};\nexports.functionStoppedRunningErr = functionStoppedRunningErr;\n//# sourceMappingURL=errors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL2Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlDQUFpQyxHQUFHLG9CQUFvQixHQUFHLDJCQUEyQixHQUFHLCtCQUErQixHQUFHLG1CQUFtQixHQUFHLHVCQUF1QixHQUFHLHlCQUF5QixHQUFHLDJCQUEyQixHQUFHLGVBQWUsR0FBRyx3QkFBd0IsR0FBRyx5QkFBeUIsR0FBRyxzQkFBc0I7QUFDcFUsZ0NBQWdDLG1CQUFPLENBQUMseURBQU87QUFDL0MsOENBQThDLG1CQUFPLENBQUMsa0ZBQXFCO0FBQzNFLDhCQUE4QixtQkFBTyxDQUFDLG1GQUFxQjtBQUMzRCxxQ0FBcUMsbUJBQU8sQ0FBQyxpRkFBWTtBQUN6RCxjQUFjLG1CQUFPLENBQUMsdUVBQUs7QUFDM0IsK0JBQStCLG1CQUFPLENBQUMsd0dBQW9DO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Qsb0JBQW9CO0FBQzFFO0FBQ0Esb0NBQW9DLHNIQUFzSDtBQUMxSjtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsY0FBYztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFNBQVMsRUFBRSxZQUFZO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3SUFBd0k7QUFDeEk7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxpQ0FBaUM7QUFDakMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aXZlLXZpYmUtYWktbmV4dC8uL25vZGVfbW9kdWxlcy9pbm5nZXN0L2hlbHBlcnMvZXJyb3JzLmpzPzVmYzYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZ1bmN0aW9uU3RvcHBlZFJ1bm5pbmdFcnIgPSBleHBvcnRzLnJldGhyb3dFcnJvciA9IGV4cG9ydHMuT3V0Z29pbmdSZXN1bHRFcnJvciA9IGV4cG9ydHMuZml4RXZlbnRLZXlNaXNzaW5nU3RlcHMgPSBleHBvcnRzLnByZXR0eUVycm9yID0gZXhwb3J0cy5nZXRFcnJvck1lc3NhZ2UgPSBleHBvcnRzLm1pbmlmeVByZXR0eUVycm9yID0gZXhwb3J0cy5wcmV0dHlFcnJvclNwbGl0dGVyID0gZXhwb3J0cy5FcnJDb2RlID0gZXhwb3J0cy5kZXNlcmlhbGl6ZUVycm9yID0gZXhwb3J0cy5pc1NlcmlhbGl6ZWRFcnJvciA9IGV4cG9ydHMuc2VyaWFsaXplRXJyb3IgPSB2b2lkIDA7XG5jb25zdCBjaGFsa18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJjaGFsa1wiKSk7XG5jb25zdCBqc29uX3N0cmluZ2lmeV9zYWZlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImpzb24tc3RyaW5naWZ5LXNhZmVcIikpO1xuY29uc3Qgc2VyaWFsaXplX2Vycm9yX2Nqc18xID0gcmVxdWlyZShcInNlcmlhbGl6ZS1lcnJvci1janNcIik7XG5jb25zdCBzdHJpcF9hbnNpXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInN0cmlwLWFuc2lcIikpO1xuY29uc3Qgem9kXzEgPSByZXF1aXJlKFwiem9kXCIpO1xuY29uc3QgTm9uUmV0cmlhYmxlRXJyb3JfanNfMSA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnRzL05vblJldHJpYWJsZUVycm9yLmpzXCIpO1xuY29uc3QgU0VSSUFMSVpFRF9LRVkgPSBcIl9fc2VyaWFsaXplZFwiO1xuY29uc3QgU0VSSUFMSVpFRF9WQUxVRSA9IHRydWU7XG4vKipcbiAqIEFkZCBmaXJzdC1jbGFzcyBzdXBwb3J0IGZvciBjZXJ0YWluIGVycm9ycyB0aGF0IHdlIGNvbnRyb2wsIGluIGFkZGl0aW9uIHRvXG4gKiBidWlsdC1pbiBlcnJvcnMgc3VjaCBhcyBgVHlwZUVycm9yYC5cbiAqXG4gKiBBZGRpbmcgdGhlc2UgYWxsb3dzIHRoZXNlIG5vbi1zdGFuZGFyZCBlcnJvcnMgdG8gYmUgY29ycmVjdGx5IHNlcmlhbGl6ZWQsXG4gKiBzZW50IHRvIElubmdlc3QsIHRoZW4gZGVzZXJpYWxpemVkIGJhY2sgaW50byB0aGUgY29ycmVjdCBlcnJvciB0eXBlIGZvciB1c2Vyc1xuICogdG8gcmVhY3QgdG8gY29ycmVjdGx5LlxuICpcbiAqIE5vdGUgdGhhdCB0aGVzZSBlcnJvcnMgb25seSBzdXBwb3J0IGBtZXNzYWdlPzogc3RyaW5nIHwgdW5kZWZpbmVkYCBhcyB0aGVcbiAqIGlucHV0OyBtb3JlIGN1c3RvbSBlcnJvcnMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCB0aGlzIGN1cnJlbnQgc3RyYXRlZ3kuXG4gKi9cbnNlcmlhbGl6ZV9lcnJvcl9janNfMS5lcnJvckNvbnN0cnVjdG9ycy5zZXQoXCJOb25SZXRyaWFibGVFcnJvclwiLCBOb25SZXRyaWFibGVFcnJvcl9qc18xLk5vblJldHJpYWJsZUVycm9yKTtcbi8qKlxuICogU2VyaWFsaXNlIGFuIGVycm9yIHRvIGEgc2VyaWFsaXplZCBKU09OIHN0cmluZy5cbiAqXG4gKiBFcnJvcnMgZG8gbm90IHNlcmlhbGlzZSBuaWNlbHkgdG8gSlNPTiwgc28gd2UgdXNlIHRoaXMgZnVuY3Rpb24gdG8gY29udmVydFxuICogdGhlbSB0byBhIHNlcmlhbGl6ZWQgSlNPTiBzdHJpbmcuIERvaW5nIHRoaXMgaXMgYWxzbyBub24tdHJpdmlhbCBmb3Igc29tZVxuICogZXJyb3JzLCBzbyB3ZSB1c2UgdGhlIGBzZXJpYWxpemUtZXJyb3JgIHBhY2thZ2UgdG8gZG8gaXQgZm9yIHVzLlxuICpcbiAqIFNlZSB7QGxpbmsgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvc2VyaWFsaXplLWVycm9yfVxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgYSBzbWFsbCB3cmFwcGVyIGFyb3VuZCB0aGF0IHBhY2thZ2UgdG8gYWxzbyBhZGQgYSBgdHlwZWBcbiAqIHByb3BlcnR5IHRvIHRoZSBzZXJpYWxpc2VkIGVycm9yLCBzbyB0aGF0IHdlIGNhbiBkaXN0aW5ndWlzaCBiZXR3ZWVuXG4gKiBzZXJpYWxpc2VkIGVycm9ycyBhbmQgb3RoZXIgb2JqZWN0cy5cbiAqXG4gKiBXaWxsIG5vdCByZXNlcmlhbGlzZSBleGlzdGluZyBzZXJpYWxpc2VkIGVycm9ycy5cbiAqL1xuY29uc3Qgc2VyaWFsaXplRXJyb3IgPSAoXG4vKipcbiAqIFRoZSBzdXNwZWN0ZWQgZXJyb3IgdG8gc2VyaWFsaXplLlxuICovXG5zdWJqZWN0LCBcbi8qKlxuICogSWYgYHRydWVgIGFuZCB0aGUgZXJyb3IgaXMgbm90IHNlcmlhbGl6YWJsZSwgd2lsbCByZXR1cm4gdGhlIG9yaWdpbmFsIHZhbHVlXG4gKiBhcyBgdW5rbm93bmAgaW5zdGVhZCBvZiBjb2VyY2luZyBpdCB0byBhIHNlcmlhbGl6ZWQgZXJyb3IuXG4gKi9cbmFsbG93VW5rbm93biA9IGZhbHNlKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gVHJ5IHRvIHVuZGVyc3RhbmQgaWYgdGhpcyBpcyBhbHJlYWR5IGRvbmUuXG4gICAgICAgIC8vIFdpbGwgaGFuZGxlIHN0cmluZ2lmaWVkIGVycm9ycy5cbiAgICAgICAgY29uc3QgZXhpc3RpbmdTZXJpYWxpemVkRXJyb3IgPSAoMCwgZXhwb3J0cy5pc1NlcmlhbGl6ZWRFcnJvcikoc3ViamVjdCk7XG4gICAgICAgIGlmIChleGlzdGluZ1NlcmlhbGl6ZWRFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nU2VyaWFsaXplZEVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygc3ViamVjdCA9PT0gXCJvYmplY3RcIiAmJiBzdWJqZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBJcyBhbiBvYmplY3QsIHNvIGxldCdzIHRyeSBhbmQgc2VyaWFsaXplIGl0LlxuICAgICAgICAgICAgY29uc3Qgc2VyaWFsaXplZEVyciA9ICgwLCBzZXJpYWxpemVfZXJyb3JfY2pzXzEuc2VyaWFsaXplRXJyb3IpKHN1YmplY3QpO1xuICAgICAgICAgICAgLy8gTm90IGEgcHJvcGVyIGVycm9yIHdhcyBjYXVnaHQsIHNvIGdpdmUgdXMgYSBjaGFuY2UgdG8gcmV0dXJuIGB1bmtub3duYC5cbiAgICAgICAgICAgIGlmICghc2VyaWFsaXplZEVyci5uYW1lICYmIGFsbG93VW5rbm93bikge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdWJqZWN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2VyaWFsaXphdGlvbiBjYW4gc3VjY2VlZCBidXQgYXNzaWduIG5vIG5hbWUgb3IgbWVzc2FnZSwgc28gd2UnbGxcbiAgICAgICAgICAgIC8vIG1hcCBvdmVyIHRoZSByZXN1bHQgaGVyZSB0byBlbnN1cmUgd2UgaGF2ZSBldmVyeXRoaW5nLlxuICAgICAgICAgICAgLy8gV2UnbGwganVzdCBzdHJpbmdpZnkgdGhlIGVudGlyZSBzdWJqZWN0IGZvciB0aGUgbWVzc2FnZSwgYXMgdGhpcyBhdFxuICAgICAgICAgICAgLy8gbGVhc3QgcHJvdmlkZXMgc29tZSBjb250ZXh0IGZvciB0aGUgdXNlci5cbiAgICAgICAgICAgIGNvbnN0IHJldCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc2VyaWFsaXplZEVyciksIHsgbmFtZTogc2VyaWFsaXplZEVyci5uYW1lIHx8IFwiRXJyb3JcIiwgbWVzc2FnZTogc2VyaWFsaXplZEVyci5tZXNzYWdlIHx8XG4gICAgICAgICAgICAgICAgICAgICgwLCBqc29uX3N0cmluZ2lmeV9zYWZlXzEuZGVmYXVsdCkoc3ViamVjdCkgfHxcbiAgICAgICAgICAgICAgICAgICAgXCJVbmtub3duIGVycm9yOyBlcnJvciBzZXJpYWxpemF0aW9uIGNvdWxkIG5vdCBmaW5kIGEgbWVzc2FnZS5cIiwgc3RhY2s6IHNlcmlhbGl6ZWRFcnIuc3RhY2sgfHwgXCJcIiwgW1NFUklBTElaRURfS0VZXTogU0VSSUFMSVpFRF9WQUxVRSB9KTtcbiAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYSBjYXVzZSwgbWFrZSBzdXJlIHdlIHJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSB0aGVtIHRvby4gV2UgYXJlXG4gICAgICAgICAgICAvLyBsaWdodGVyIHdpdGggY2F1c2VzIHRob3VnaDsgYXR0ZW1wdCB0byByZWN1cnNpdmVseSBzZXJpYWxpemUgdGhlbSwgYnV0XG4gICAgICAgICAgICAvLyBzdG9wIGlmIHdlIGZpbmQgc29tZXRoaW5nIHRoYXQgZG9lc24ndCB3b3JrIGFuZCBqdXN0IHJldHVybiBgdW5rbm93bmAuXG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gcmV0O1xuICAgICAgICAgICAgY29uc3QgbWF4RGVwdGggPSA1O1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhEZXB0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgIFwiY2F1c2VcIiBpbiB0YXJnZXQgJiZcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmNhdXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldC5jYXVzZSA9ICgwLCBleHBvcnRzLnNlcmlhbGl6ZUVycm9yKSh0YXJnZXQuY2F1c2UsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIGl0J3Mgbm90IGFuIG9iamVjdCwgaXQncyBoYXJkIHRvIHBhcnNlIHRoaXMgYXMgYW4gRXJyb3IuIEluIHRoaXMgY2FzZSxcbiAgICAgICAgLy8gd2UnbGwgdGhyb3cgYW4gZXJyb3IgdG8gc3RhcnQgYXR0ZW1wdGluZyBiYWNrdXAgc3RyYXRlZ2llcy5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgaXMgbm90IGFuIG9iamVjdDsgc3RyYW5nZSB0aHJvdyB2YWx1ZS5cIik7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKGFsbG93VW5rbm93bikge1xuICAgICAgICAgICAgLy8gSWYgd2UgYXJlIGFsbG93ZWQgdG8gcmV0dXJuIHVua25vd24sIHdlJ2xsIGp1c3QgcmV0dXJuIHRoZSBvcmlnaW5hbFxuICAgICAgICAgICAgLy8gdmFsdWUuXG4gICAgICAgICAgICByZXR1cm4gc3ViamVjdDtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gSWYgc2VyaWFsaXphdGlvbiBmYWlscywgZmFsbCBiYWNrIHRvIGEgcmVndWxhciBFcnJvciBhbmQgdXNlIHRoZVxuICAgICAgICAgICAgLy8gb3JpZ2luYWwgb2JqZWN0IGFzIHRoZSBtZXNzYWdlIGZvciBhbiBFcnJvci4gV2UgZG9uJ3Qga25vdyB3aGF0IHRoaXNcbiAgICAgICAgICAgIC8vIG9iamVjdCBsb29rcyBsaWtlLCBzbyB3ZSBjYW4ndCBkbyBhbnl0aGluZyBlbHNlIHdpdGggaXQuXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAoMCwgZXhwb3J0cy5zZXJpYWxpemVFcnJvcikobmV3IEVycm9yKHR5cGVvZiBzdWJqZWN0ID09PSBcInN0cmluZ1wiID8gc3ViamVjdCA6ICgwLCBqc29uX3N0cmluZ2lmeV9zYWZlXzEuZGVmYXVsdCkoc3ViamVjdCkpLCBmYWxzZSkpLCB7IFxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgc3RhY2s7IGl0J3Mgbm90IHJlbGV2YW50IGhlcmVcbiAgICAgICAgICAgICAgICBzdGFjazogXCJcIiwgW1NFUklBTElaRURfS0VZXTogU0VSSUFMSVpFRF9WQUxVRSB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIGZhaWxlZCwgdGhlbiBzdHJpbmdpZnlpbmcgdGhlIG9iamVjdCBhbHNvIGZhaWxlZCwgc28gd2UnbGwganVzdFxuICAgICAgICAgICAgLy8gcmV0dXJuIGEgY29tcGxldGVseSBnZW5lcmljIGVycm9yLlxuICAgICAgICAgICAgLy8gRmFpbGluZyB0byBzdHJpbmdpZnkgdGhlIG9iamVjdCBpcyB2ZXJ5IHVubGlrZWx5LlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcIkNvdWxkIG5vdCBzZXJpYWxpemUgc291cmNlIGVycm9yXCIsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogXCJTZXJpYWxpemluZyB0aGUgc291cmNlIGVycm9yIGZhaWxlZC5cIixcbiAgICAgICAgICAgICAgICBzdGFjazogXCJcIixcbiAgICAgICAgICAgICAgICBbU0VSSUFMSVpFRF9LRVldOiBTRVJJQUxJWkVEX1ZBTFVFLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5leHBvcnRzLnNlcmlhbGl6ZUVycm9yID0gc2VyaWFsaXplRXJyb3I7XG4vKipcbiAqIENoZWNrIGlmIGFuIG9iamVjdCBvciBhIHN0cmluZyBpcyBhIHNlcmlhbGlzZWQgZXJyb3IgY3JlYXRlZCBieVxuICoge0BsaW5rIHNlcmlhbGl6ZUVycm9yfS5cbiAqL1xuY29uc3QgaXNTZXJpYWxpemVkRXJyb3IgPSAodmFsdWUpID0+IHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWQgPSB6b2RfMS56XG4gICAgICAgICAgICAgICAgLm9iamVjdCh7XG4gICAgICAgICAgICAgICAgW1NFUklBTElaRURfS0VZXTogem9kXzEuei5saXRlcmFsKFNFUklBTElaRURfVkFMVUUpLFxuICAgICAgICAgICAgICAgIG5hbWU6IHpvZF8xLnouZW51bShbLi4uQXJyYXkuZnJvbShzZXJpYWxpemVfZXJyb3JfY2pzXzEuZXJyb3JDb25zdHJ1Y3RvcnMua2V5cygpKV0pLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHpvZF8xLnouc3RyaW5nKCksXG4gICAgICAgICAgICAgICAgc3RhY2s6IHpvZF8xLnouc3RyaW5nKCksXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5wYXNzdGhyb3VnaCgpXG4gICAgICAgICAgICAgICAgLnNhZmVQYXJzZShKU09OLnBhcnNlKHZhbHVlKSk7XG4gICAgICAgICAgICBpZiAocGFyc2VkLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VkLmRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3Qgb2JqSXNTZXJpYWxpemVkRXJyID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBTRVJJQUxJWkVEX0tFWSkgJiZcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXG4gICAgICAgICAgICAgICAgdmFsdWVbU0VSSUFMSVpFRF9LRVldID09PVxuICAgICAgICAgICAgICAgICAgICBTRVJJQUxJWkVEX1ZBTFVFO1xuICAgICAgICAgICAgaWYgKG9iaklzU2VyaWFsaXplZEVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgLy8gbm8tb3A7IHdlJ2xsIHJldHVybiB1bmRlZmluZWQgaWYgcGFyc2luZyBmYWlsZWQsIGFzIGl0IGlzbid0IGEgc2VyaWFsaXplZFxuICAgICAgICAvLyBlcnJvclxuICAgIH1cbn07XG5leHBvcnRzLmlzU2VyaWFsaXplZEVycm9yID0gaXNTZXJpYWxpemVkRXJyb3I7XG4vKipcbiAqIERlc2VyaWFsaXNlIGFuIGVycm9yIGNyZWF0ZWQgYnkge0BsaW5rIHNlcmlhbGl6ZUVycm9yfS5cbiAqXG4gKiBFbnN1cmVzIHdlIG9ubHkgZGVzZXJpYWxpc2UgZXJyb3JzIHRoYXQgbWVldCBhIG1pbmltdW0gbGV2ZWwgb2ZcbiAqIGFwcGxpY2FiaWxpdHksIGluY2x1c2l2ZSBvZiBlcnJvciBoYW5kbGluZyB0byBlbnN1cmUgdGhhdCBiYWRseSBzZXJpYWxpemVkXG4gKiBlcnJvcnMgYXJlIHN0aWxsIGhhbmRsZWQuXG4gKi9cbmNvbnN0IGRlc2VyaWFsaXplRXJyb3IgPSAoc3ViamVjdCwgYWxsb3dVbmtub3duID0gZmFsc2UpID0+IHtcbiAgICBjb25zdCByZXF1aXJlZEZpZWxkcyA9IFtcIm5hbWVcIiwgXCJtZXNzYWdlXCJdO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGhhc1JlcXVpcmVkRmllbGRzID0gcmVxdWlyZWRGaWVsZHMuZXZlcnkoKGZpZWxkKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHN1YmplY3QsIGZpZWxkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghaGFzUmVxdWlyZWRGaWVsZHMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlc2VyaWFsaXplZEVyciA9ICgwLCBzZXJpYWxpemVfZXJyb3JfY2pzXzEuZGVzZXJpYWxpemVFcnJvcikoc3ViamVjdCk7XG4gICAgICAgIGlmIChcImNhdXNlXCIgaW4gZGVzZXJpYWxpemVkRXJyKSB7XG4gICAgICAgICAgICBkZXNlcmlhbGl6ZWRFcnIuY2F1c2UgPSAoMCwgZXhwb3J0cy5kZXNlcmlhbGl6ZUVycm9yKShkZXNlcmlhbGl6ZWRFcnIuY2F1c2UsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXNlcmlhbGl6ZWRFcnI7XG4gICAgfVxuICAgIGNhdGNoIChfYSkge1xuICAgICAgICBpZiAoYWxsb3dVbmtub3duKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBhcmUgYWxsb3dlZCB0byByZXR1cm4gdW5rbm93biwgd2UnbGwganVzdCByZXR1cm4gdGhlIG9yaWdpbmFsXG4gICAgICAgICAgICAvLyB2YWx1ZS5cbiAgICAgICAgICAgIHJldHVybiBzdWJqZWN0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihcIlVua25vd24gZXJyb3I7IGNvdWxkIG5vdCByZXNlcmlhbGl6ZVwiKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZSB0aGUgc3RhY2sgc28gdGhhdCBpdCdzIG5vdCBtaXNsZWFkaW5nbHkgc2hvd24gYXMgdGhlIElubmdlc3RcbiAgICAgICAgICogaW50ZXJuYWxzLlxuICAgICAgICAgKi9cbiAgICAgICAgZXJyLnN0YWNrID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gZXJyO1xuICAgIH1cbn07XG5leHBvcnRzLmRlc2VyaWFsaXplRXJyb3IgPSBkZXNlcmlhbGl6ZUVycm9yO1xudmFyIEVyckNvZGU7XG4oZnVuY3Rpb24gKEVyckNvZGUpIHtcbiAgICBFcnJDb2RlW1wiTkVTVElOR19TVEVQU1wiXSA9IFwiTkVTVElOR19TVEVQU1wiO1xuICAgIC8qKlxuICAgICAqIExlZ2FjeSB2MCBleGVjdXRpb24gZXJyb3IgY29kZSBmb3Igd2hlbiBhIGZ1bmN0aW9uIGhhcyBjaGFuZ2VkIGFuZCBub1xuICAgICAqIGxvbmdlciBtYXRjaGVzIGl0cyBpbi1wcm9ncmVzcyBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkIE5vdCBmb3IgdXNlIGluIGxhdGVzdCBleGVjdXRpb24gbWV0aG9kLlxuICAgICAqL1xuICAgIEVyckNvZGVbXCJOT05fREVURVJNSU5JU1RJQ19GVU5DVElPTlwiXSA9IFwiTk9OX0RFVEVSTUlOSVNUSUNfRlVOQ1RJT05cIjtcbiAgICAvKipcbiAgICAgKiBMZWdhY3kgdjAgZXhlY3V0aW9uIGVycm9yIGNvZGUgZm9yIHdoZW4gYSBmdW5jdGlvbiBpcyBmb3VuZCB0byBiZSB1c2luZ1xuICAgICAqIGFzeW5jIGFjdGlvbnMgYWZ0ZXIgbWVtb3ppYXRpb24gaGFzIG9jY3VycmVkLCB3aGljaCB2MCBkb2Vzbid0IHN1cHBvcnQuXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCBOb3QgZm9yIHVzZSBpbiBsYXRlc3QgZXhlY3V0aW9uIG1ldGhvZC5cbiAgICAgKi9cbiAgICBFcnJDb2RlW1wiQVNZTkNfREVURUNURURfQUZURVJfTUVNT0laQVRJT05cIl0gPSBcIkFTWU5DX0RFVEVDVEVEX0FGVEVSX01FTU9JWkFUSU9OXCI7XG4gICAgLyoqXG4gICAgICogTGVnYWN5IHYwIGV4ZWN1dGlvbiBlcnJvciBjb2RlIGZvciB3aGVuIGEgZnVuY3Rpb24gaXMgZm91bmQgdG8gYmUgdXNpbmdcbiAgICAgKiBzdGVwcyBhZnRlciBhIG5vbi1zdGVwIGFzeW5jIGFjdGlvbiBoYXMgb2NjdXJyZWQuXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCBOb3QgZm9yIHVzZSBpbiBsYXRlc3QgZXhlY3V0aW9uIG1ldGhvZC5cbiAgICAgKi9cbiAgICBFcnJDb2RlW1wiU1RFUF9VU0VEX0FGVEVSX0FTWU5DXCJdID0gXCJTVEVQX1VTRURfQUZURVJfQVNZTkNcIjtcbiAgICBFcnJDb2RlW1wiQVVUT01BVElDX1BBUkFMTEVMX0lOREVYSU5HXCJdID0gXCJBVVRPTUFUSUNfUEFSQUxMRUxfSU5ERVhJTkdcIjtcbn0pKEVyckNvZGUgfHwgKGV4cG9ydHMuRXJyQ29kZSA9IEVyckNvZGUgPSB7fSkpO1xuZXhwb3J0cy5wcmV0dHlFcnJvclNwbGl0dGVyID0gXCI9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XCI7XG4vKipcbiAqIEdpdmVuIGFuIHVua25vd24gYGVycmAsIG11dGF0ZSBpdCB0byBtaW5pZnkgYW55IHByZXR0eSBlcnJvcnMgdGhhdCBpdFxuICogY29udGFpbnMuXG4gKi9cbmNvbnN0IG1pbmlmeVByZXR0eUVycm9yID0gKGVycikgPT4ge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICB0cnkge1xuICAgICAgICBpZiAoIWlzRXJyb3IoZXJyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc1ByZXR0eUVycm9yID0gZXJyLm1lc3NhZ2UuaW5jbHVkZXMoZXhwb3J0cy5wcmV0dHlFcnJvclNwbGl0dGVyKTtcbiAgICAgICAgaWYgKCFpc1ByZXR0eUVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNhbml0aXplZE1lc3NhZ2UgPSAoMCwgc3RyaXBfYW5zaV8xLmRlZmF1bHQpKGVyci5tZXNzYWdlKTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9ICgoX2IgPSAoX2EgPSBzYW5pdGl6ZWRNZXNzYWdlLnNwbGl0KFwiICBcIilbMV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zcGxpdChcIlxcblwiKVswXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnRyaW0oKSkgfHwgZXJyLm1lc3NhZ2U7XG4gICAgICAgIGNvbnN0IGNvZGUgPSAoKF9kID0gKF9jID0gc2FuaXRpemVkTWVzc2FnZS5zcGxpdChcIlxcblxcbkNvZGU6IFwiKVsxXSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnNwbGl0KFwiXFxuXFxuXCIpWzBdKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QudHJpbSgpKSB8fFxuICAgICAgICAgICAgdW5kZWZpbmVkO1xuICAgICAgICBlcnIubWVzc2FnZSA9IFtjb2RlLCBtZXNzYWdlXS5maWx0ZXIoQm9vbGVhbikuam9pbihcIiAtIFwiKTtcbiAgICAgICAgaWYgKGVyci5zdGFjaykge1xuICAgICAgICAgICAgY29uc3Qgc2FuaXRpemVkU3RhY2sgPSAoMCwgc3RyaXBfYW5zaV8xLmRlZmF1bHQpKGVyci5zdGFjayk7XG4gICAgICAgICAgICBjb25zdCBzdGFja1Jlc3QgPSBzYW5pdGl6ZWRTdGFja1xuICAgICAgICAgICAgICAgIC5zcGxpdChgJHtleHBvcnRzLnByZXR0eUVycm9yU3BsaXR0ZXJ9XFxuYClcbiAgICAgICAgICAgICAgICAuc2xpY2UoMilcbiAgICAgICAgICAgICAgICAuam9pbihcIlxcblwiKTtcbiAgICAgICAgICAgIGVyci5zdGFjayA9IGAke2Vyci5uYW1lfTogJHtlcnIubWVzc2FnZX1cXG4ke3N0YWNrUmVzdH1gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcnI7XG4gICAgfVxuICAgIGNhdGNoIChub29wRXJyKSB7XG4gICAgICAgIHJldHVybiBlcnI7XG4gICAgfVxufTtcbmV4cG9ydHMubWluaWZ5UHJldHR5RXJyb3IgPSBtaW5pZnlQcmV0dHlFcnJvcjtcbi8qKlxuICogR2l2ZW4gYW4gYGVycmAsIHJldHVybiBhIGJvb2xlYW4gcmVwcmVzZW50aW5nIHdoZXRoZXIgaXQgaXMgaW4gdGhlIHNoYXBlIG9mXG4gKiBhbiBgRXJyb3JgIG9yIG5vdC5cbiAqL1xuY29uc3QgaXNFcnJvciA9IChlcnIpID0+IHtcbiAgICB0cnkge1xuICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhhc05hbWUgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXJyLCBcIm5hbWVcIik7XG4gICAgICAgIGNvbnN0IGhhc01lc3NhZ2UgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXJyLCBcIm1lc3NhZ2VcIik7XG4gICAgICAgIHJldHVybiBoYXNOYW1lICYmIGhhc01lc3NhZ2U7XG4gICAgfVxuICAgIGNhdGNoIChub29wRXJyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuLyoqXG4gKiBHaXZlbiBhbiBgdW5rbm93bmAgb2JqZWN0LCByZXRyaWV2ZSB0aGUgYG1lc3NhZ2VgIHByb3BlcnR5IGZyb20gaXQsIG9yIGZhbGxcbiAqIGJhY2sgdG8gdGhlIGBmYWxsYmFja2Agc3RyaW5nIGlmIGl0IGRvZXNuJ3QgZXhpc3Qgb3IgaXMgZW1wdHkuXG4gKi9cbmNvbnN0IGdldEVycm9yTWVzc2FnZSA9IChlcnIsIGZhbGxiYWNrKSA9PiB7XG4gICAgY29uc3QgeyBtZXNzYWdlIH0gPSB6b2RfMS56XG4gICAgICAgIC5vYmplY3QoeyBtZXNzYWdlOiB6b2RfMS56LnN0cmluZygpLm1pbigxKSB9KVxuICAgICAgICAuY2F0Y2goeyBtZXNzYWdlOiBmYWxsYmFjayB9KVxuICAgICAgICAucGFyc2UoZXJyKTtcbiAgICByZXR1cm4gbWVzc2FnZTtcbn07XG5leHBvcnRzLmdldEVycm9yTWVzc2FnZSA9IGdldEVycm9yTWVzc2FnZTtcbi8qKlxuICogR2l2ZW4gYSB7QGxpbmsgUHJldHR5RXJyb3J9LCByZXR1cm4gYSBuaWNlbHktZm9ybWF0dGVkIHN0cmluZyByZWFkeSB0byBsb2dcbiAqIG9yIHRocm93LlxuICpcbiAqIFVzZWZ1bCBmb3IgZW5zdXJpbmcgdGhhdCBlcnJvcnMgYXJlIGxvZ2dlZCBpbiBhIGNvbnNpc3RlbnQsIGhlbHBmdWwgZm9ybWF0XG4gKiBhY3Jvc3MgdGhlIFNESyBieSBwcm9tcHRpbmcgZm9yIGtleSBwaWVjZXMgb2YgaW5mb3JtYXRpb24uXG4gKi9cbmNvbnN0IHByZXR0eUVycm9yID0gKHsgdHlwZSA9IFwiZXJyb3JcIiwgd2hhdEhhcHBlbmVkLCBvdGhlcndpc2UsIHJlYXNzdXJhbmNlLCB0b0ZpeE5vdywgd2h5LCBjb25zZXF1ZW5jZXMsIHN0YWNrLCBjb2RlLCB9KSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCB7IGljb24sIGNvbG9yRm4gfSA9IHtcbiAgICAgICAgZXJyb3I6IHsgaWNvbjogXCLinYxcIiwgY29sb3JGbjogY2hhbGtfMS5kZWZhdWx0LnJlZCB9LFxuICAgICAgICB3YXJuOiB7IGljb246IFwi4pqg77iPXCIsIGNvbG9yRm46IGNoYWxrXzEuZGVmYXVsdC55ZWxsb3cgfSxcbiAgICB9W3R5cGVdO1xuICAgIGxldCBoZWFkZXIgPSBgJHtpY29ufSAgJHtjaGFsa18xLmRlZmF1bHQuYm9sZC51bmRlcmxpbmUod2hhdEhhcHBlbmVkLnRyaW0oKSl9YDtcbiAgICBpZiAoc3RhY2spIHtcbiAgICAgICAgaGVhZGVyICs9XG4gICAgICAgICAgICBcIlxcblwiICtcbiAgICAgICAgICAgICAgICBbLi4uKCgoX2EgPSBuZXcgRXJyb3IoKS5zdGFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNwbGl0KFwiXFxuXCIpLnNsaWNlKDEpLmZpbHRlcihCb29sZWFuKSkgfHwgW10pXS5qb2luKFwiXFxuXCIpO1xuICAgIH1cbiAgICBsZXQgdG9GaXhOb3dTdHIgPSAoX2IgPSAoQXJyYXkuaXNBcnJheSh0b0ZpeE5vdylcbiAgICAgICAgPyB0b0ZpeE5vd1xuICAgICAgICAgICAgLm1hcCgocykgPT4gcy50cmltKCkpXG4gICAgICAgICAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICAgICAgICAgICAubWFwKChzLCBpKSA9PiBgXFx0JHtpICsgMX0uICR7c31gKVxuICAgICAgICAgICAgLmpvaW4oXCJcXG5cIilcbiAgICAgICAgOiB0b0ZpeE5vdyA9PT0gbnVsbCB8fCB0b0ZpeE5vdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdG9GaXhOb3cudHJpbSgpKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogXCJcIjtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0b0ZpeE5vdykgJiYgdG9GaXhOb3dTdHIpIHtcbiAgICAgICAgdG9GaXhOb3dTdHIgPSBgVG8gZml4IHRoaXMsIHlvdSBjYW4gdGFrZSBvbmUgb2YgdGhlIGZvbGxvd2luZyBjb3Vyc2VzIG9mIGFjdGlvbjpcXG5cXG4ke3RvRml4Tm93U3RyfWA7XG4gICAgfVxuICAgIGxldCBib2R5ID0gW3JlYXNzdXJhbmNlID09PSBudWxsIHx8IHJlYXNzdXJhbmNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWFzc3VyYW5jZS50cmltKCksIHdoeSA9PT0gbnVsbCB8fCB3aHkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdoeS50cmltKCksIGNvbnNlcXVlbmNlcyA9PT0gbnVsbCB8fCBjb25zZXF1ZW5jZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbnNlcXVlbmNlcy50cmltKCldXG4gICAgICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAgICAgLmpvaW4oXCIgXCIpO1xuICAgIGJvZHkgKz0gYm9keSA/IGBcXG5cXG4ke3RvRml4Tm93U3RyfWAgOiB0b0ZpeE5vd1N0cjtcbiAgICBjb25zdCB0cmFpbGVyID0gW290aGVyd2lzZSA9PT0gbnVsbCB8fCBvdGhlcndpc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG90aGVyd2lzZS50cmltKCldLmZpbHRlcihCb29sZWFuKS5qb2luKFwiIFwiKTtcbiAgICBjb25zdCBtZXNzYWdlID0gW1xuICAgICAgICBleHBvcnRzLnByZXR0eUVycm9yU3BsaXR0ZXIsXG4gICAgICAgIGhlYWRlcixcbiAgICAgICAgYm9keSxcbiAgICAgICAgdHJhaWxlcixcbiAgICAgICAgY29kZSA/IGBDb2RlOiAke2NvZGV9YCA6IFwiXCIsXG4gICAgICAgIGV4cG9ydHMucHJldHR5RXJyb3JTcGxpdHRlcixcbiAgICBdXG4gICAgICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAgICAgLmpvaW4oXCJcXG5cXG5cIik7XG4gICAgcmV0dXJuIGNvbG9yRm4obWVzc2FnZSk7XG59O1xuZXhwb3J0cy5wcmV0dHlFcnJvciA9IHByZXR0eUVycm9yO1xuZXhwb3J0cy5maXhFdmVudEtleU1pc3NpbmdTdGVwcyA9IFtcbiAgICBcIlNldCB0aGUgYElOTkdFU1RfRVZFTlRfS0VZYCBlbnZpcm9ubWVudCB2YXJpYWJsZVwiLFxuICAgIGBQYXNzIGEga2V5IHRvIHRoZSBcXGBuZXcgSW5uZ2VzdCgpXFxgIGNvbnN0cnVjdG9yIHVzaW5nIHRoZSBcXGAke1wiZXZlbnRLZXlcIn1cXGAgb3B0aW9uYCxcbiAgICBgVXNlIFxcYGlubmdlc3QuJHtcInNldEV2ZW50S2V5XCJ9KClcXGAgYXQgcnVudGltZWAsXG5dO1xuLyoqXG4gKiBBbiBlcnJvciB0aGF0LCB3aGVuIHRocm93biwgaW5kaWNhdGVzIGludGVybmFsbHkgdGhhdCBhbiBvdXRnb2luZyBvcGVyYXRpb25cbiAqIGNvbnRhaW5zIGFuIGVycm9yLlxuICpcbiAqIFdlIHVzZSB0aGlzIGJlY2F1c2Ugc2VyaWFsaXplZCBgZGF0YWAgc2VudCBiYWNrIHRvIElubmdlc3QgbWF5IGRpZmZlciBmcm9tXG4gKiB0aGUgZXJyb3IgaW5zdGFuY2UgaXRzZWxmIGR1ZSB0byBtaWRkbGV3YXJlLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5jbGFzcyBPdXRnb2luZ1Jlc3VsdEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHJlc3VsdCkge1xuICAgICAgICBzdXBlcihcIk91dGdvaW5nT3BFcnJvclwiKTtcbiAgICAgICAgdGhpcy5yZXN1bHQgPSByZXN1bHQ7XG4gICAgfVxufVxuZXhwb3J0cy5PdXRnb2luZ1Jlc3VsdEVycm9yID0gT3V0Z29pbmdSZXN1bHRFcnJvcjtcbi8qKlxuICogQ3JlYXRlIGEgZnVuY3Rpb24gdGhhdCB3aWxsIHJldGhyb3cgYW4gZXJyb3Igd2l0aCBhIHByZWZpeCBhZGRlZCB0byB0aGVcbiAqIG1lc3NhZ2UuXG4gKlxuICogVXNlZnVsIGZvciBhZGRpbmcgY29udGV4dCB0byBlcnJvcnMgdGhhdCBhcmUgcmV0aHJvd24uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBhd2FpdCBkb1NvbWVBY3Rpb24oKS5jYXRjaChyZXRocm93RXJyb3IoXCJGYWlsZWQgdG8gZG8gc29tZSBhY3Rpb25cIikpO1xuICogYGBgXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5jb25zdCByZXRocm93RXJyb3IgPSAocHJlZml4KSA9PiB7XG4gICAgcmV0dXJuIChlcnIpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3MsIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC10ZW1wbGF0ZS1leHByZXNzaW9uc1xuICAgICAgICAgICAgZXJyLm1lc3NhZ2UgJiYgKGVyci5tZXNzYWdlID0gYCR7cHJlZml4fTsgJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAobm9vcEVycikge1xuICAgICAgICAgICAgLy8gbm8tb3BcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnNhZmUtZmluYWxseVxuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5leHBvcnRzLnJldGhyb3dFcnJvciA9IHJldGhyb3dFcnJvcjtcbi8qKlxuICogTGVnYWN5IHYwIGV4ZWN1dGlvbiBlcnJvciBmb3IgZnVuY3Rpb25zIHRoYXQgZG9uJ3Qgc3VwcG9ydCBtaXhpbmcgc3RlcHMgYW5kXG4gKiByZWd1bGFyIGFzeW5jIGFjdGlvbnMuXG4gKi9cbmNvbnN0IGZ1bmN0aW9uU3RvcHBlZFJ1bm5pbmdFcnIgPSAoY29kZSkgPT4ge1xuICAgIHJldHVybiAoMCwgZXhwb3J0cy5wcmV0dHlFcnJvcikoe1xuICAgICAgICB3aGF0SGFwcGVuZWQ6IFwiWW91ciBmdW5jdGlvbiB3YXMgc3RvcHBlZCBmcm9tIHJ1bm5pbmdcIixcbiAgICAgICAgd2h5OiBcIldlIGRldGVjdGVkIGEgbWl4IG9mIGFzeW5jaHJvbm91cyBsb2dpYywgc29tZSB1c2luZyBzdGVwIHRvb2xpbmcgYW5kIHNvbWUgbm90LlwiLFxuICAgICAgICBjb25zZXF1ZW5jZXM6IFwiVGhpcyBjYW4gY2F1c2UgdW5leHBlY3RlZCBiZWhhdmlvdXIgd2hlbiBhIGZ1bmN0aW9uIGlzIHBhdXNlZCBhbmQgcmVzdW1lZCBhbmQgaXMgdGhlcmVmb3JlIHN0cm9uZ2x5IGRpc2NvdXJhZ2VkOyB3ZSBzdG9wcGVkIHlvdXIgZnVuY3Rpb24gdG8gZW5zdXJlIG5vdGhpbmcgdW5leHBlY3RlZCBoYXBwZW5lZCFcIixcbiAgICAgICAgc3RhY2s6IHRydWUsXG4gICAgICAgIHRvRml4Tm93OiBcIkVuc3VyZSB0aGF0IHlvdXIgZnVuY3Rpb24gaXMgZWl0aGVyIGVudGlyZWx5IHN0ZXAtYmFzZWQgb3IgZW50aXJlbHkgbm9uLXN0ZXAtYmFzZWQsIGJ5IGVpdGhlciB3cmFwcGluZyBhbGwgYXN5bmNocm9ub3VzIGxvZ2ljIGluIGBzdGVwLnJ1bigpYCBjYWxscyBvciBieSByZW1vdmluZyBhbGwgYHN0ZXAuKigpYCBjYWxscy5cIixcbiAgICAgICAgb3RoZXJ3aXNlOiBcIkZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHdoeSBzdGVwIGZ1bmN0aW9ucyB3b3JrIGluIHRoaXMgbWFubmVyLCBzZWUgaHR0cHM6Ly93d3cuaW5uZ2VzdC5jb20vZG9jcy9mdW5jdGlvbnMvbXVsdGktc3RlcCNnb3RjaGFzXCIsXG4gICAgICAgIGNvZGUsXG4gICAgfSk7XG59O1xuZXhwb3J0cy5mdW5jdGlvblN0b3BwZWRSdW5uaW5nRXJyID0gZnVuY3Rpb25TdG9wcGVkUnVubmluZ0Vycjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9ycy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/helpers/errors.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/helpers/functions.js":
/*!***************************************************!*\
  !*** ./node_modules/inngest/helpers/functions.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.fetchAllFnData = exports.parseFnData = exports.undefinedToNull = exports.waterfall = exports.cacheFn = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/inngest/node_modules/zod/lib/index.js\");\nconst schema_js_1 = __webpack_require__(/*! ../api/schema.js */ \"(rsc)/./node_modules/inngest/api/schema.js\");\nconst InngestExecution_js_1 = __webpack_require__(/*! ../components/execution/InngestExecution.js */ \"(rsc)/./node_modules/inngest/components/execution/InngestExecution.js\");\nconst types_js_1 = __webpack_require__(/*! ../types.js */ \"(rsc)/./node_modules/inngest/types.js\");\nconst errors_js_1 = __webpack_require__(/*! ./errors.js */ \"(rsc)/./node_modules/inngest/helpers/errors.js\");\n/**\n * Wraps a function with a cache. When the returned function is run, it will\n * cache the result and return it on subsequent calls.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst cacheFn = (fn) => {\n    const key = \"value\";\n    const cache = new Map();\n    return ((...args) => {\n        if (!cache.has(key)) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n            cache.set(key, fn(...args));\n        }\n        return cache.get(key);\n    });\n};\nexports.cacheFn = cacheFn;\n/**\n * Given an array of functions, return a new function that will run each\n * function in series and return the result of the final function. Regardless of\n * if the functions are synchronous or asynchronous, they'll be made into an\n * async promise chain.\n *\n * If an error is thrown, the waterfall will stop and return the error.\n *\n * Because this needs to support both sync and async functions, it only allows\n * functions that accept a single argument.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst waterfall = (fns, \n/**\n * A function that transforms the result of each function in the waterfall,\n * ready for the next function.\n *\n * Will not be called on the final function.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntransform) => {\n    return (...args) => {\n        const chain = fns.reduce(async (acc, fn) => {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            const prev = await acc;\n            const output = (await fn(prev));\n            if (transform) {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                return await transform(prev, output);\n            }\n            if (typeof output === \"undefined\") {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                return prev;\n            }\n            return output;\n        }, Promise.resolve(args[0]));\n        return chain;\n    };\n};\nexports.waterfall = waterfall;\n/**\n * Given a value `v`, return `v` if it's not undefined, otherwise return `null`.\n */\nconst undefinedToNull = (v) => {\n    const isUndefined = typeof v === \"undefined\";\n    return isUndefined ? null : v;\n};\nexports.undefinedToNull = undefinedToNull;\nconst fnDataVersionSchema = zod_1.z.object({\n    version: zod_1.z\n        .literal(-1)\n        .or(zod_1.z.literal(0))\n        .or(zod_1.z.literal(1))\n        .or(zod_1.z.literal(2))\n        .optional()\n        .transform((v) => {\n        if (typeof v === \"undefined\") {\n            console.debug(`No request version specified by executor; defaulting to v${InngestExecution_js_1.PREFERRED_EXECUTION_VERSION}`);\n            return InngestExecution_js_1.PREFERRED_EXECUTION_VERSION;\n        }\n        return v === -1 ? InngestExecution_js_1.PREFERRED_EXECUTION_VERSION : v;\n    }),\n});\nconst parseFnData = (data) => {\n    let version;\n    try {\n        ({ version } = fnDataVersionSchema.parse(data));\n        const versionHandlers = {\n            [InngestExecution_js_1.ExecutionVersion.V0]: () => (Object.assign({ version: InngestExecution_js_1.ExecutionVersion.V0 }, zod_1.z\n                .object({\n                event: zod_1.z.record(zod_1.z.any()),\n                events: zod_1.z.array(zod_1.z.record(zod_1.z.any())).default([]),\n                steps: schema_js_1.stepsSchemas[InngestExecution_js_1.ExecutionVersion.V0],\n                ctx: zod_1.z\n                    .object({\n                    run_id: zod_1.z.string(),\n                    attempt: zod_1.z.number().default(0),\n                    stack: zod_1.z\n                        .object({\n                        stack: zod_1.z\n                            .array(zod_1.z.string())\n                            .nullable()\n                            .transform((v) => (Array.isArray(v) ? v : [])),\n                        current: zod_1.z.number(),\n                    })\n                        .passthrough()\n                        .optional()\n                        .nullable(),\n                })\n                    .optional()\n                    .nullable(),\n                use_api: zod_1.z.boolean().default(false),\n            })\n                .parse(data))),\n            [InngestExecution_js_1.ExecutionVersion.V1]: () => (Object.assign({ version: InngestExecution_js_1.ExecutionVersion.V1 }, zod_1.z\n                .object({\n                event: zod_1.z.record(zod_1.z.any()),\n                events: zod_1.z.array(zod_1.z.record(zod_1.z.any())).default([]),\n                steps: schema_js_1.stepsSchemas[InngestExecution_js_1.ExecutionVersion.V1],\n                ctx: zod_1.z\n                    .object({\n                    run_id: zod_1.z.string(),\n                    attempt: zod_1.z.number().default(0),\n                    disable_immediate_execution: zod_1.z.boolean().default(false),\n                    use_api: zod_1.z.boolean().default(false),\n                    stack: zod_1.z\n                        .object({\n                        stack: zod_1.z\n                            .array(zod_1.z.string())\n                            .nullable()\n                            .transform((v) => (Array.isArray(v) ? v : [])),\n                        current: zod_1.z.number(),\n                    })\n                        .passthrough()\n                        .optional()\n                        .nullable(),\n                })\n                    .optional()\n                    .nullable(),\n            })\n                .parse(data))),\n            [InngestExecution_js_1.ExecutionVersion.V2]: () => (Object.assign({ version: InngestExecution_js_1.ExecutionVersion.V2 }, zod_1.z\n                .object({\n                event: zod_1.z.record(zod_1.z.any()),\n                events: zod_1.z.array(zod_1.z.record(zod_1.z.any())).default([]),\n                steps: schema_js_1.stepsSchemas[InngestExecution_js_1.ExecutionVersion.V2],\n                ctx: zod_1.z\n                    .object({\n                    run_id: zod_1.z.string(),\n                    attempt: zod_1.z.number().default(0),\n                    disable_immediate_execution: zod_1.z.boolean().default(false),\n                    use_api: zod_1.z.boolean().default(false),\n                    stack: zod_1.z\n                        .object({\n                        stack: zod_1.z\n                            .array(zod_1.z.string())\n                            .nullable()\n                            .transform((v) => (Array.isArray(v) ? v : [])),\n                        current: zod_1.z.number(),\n                    })\n                        .passthrough()\n                        .optional()\n                        .nullable(),\n                })\n                    .optional()\n                    .nullable(),\n            })\n                .parse(data))),\n        };\n        return versionHandlers[version]();\n    }\n    catch (err) {\n        throw new Error(parseFailureErr(err));\n    }\n};\nexports.parseFnData = parseFnData;\nconst fetchAllFnData = async ({ data, api, version, }) => {\n    var _a, _b, _c, _d;\n    const result = Object.assign({}, data);\n    try {\n        if ((result.version === InngestExecution_js_1.ExecutionVersion.V0 && result.use_api) ||\n            (result.version === InngestExecution_js_1.ExecutionVersion.V1 && ((_a = result.ctx) === null || _a === void 0 ? void 0 : _a.use_api))) {\n            if (!((_b = result.ctx) === null || _b === void 0 ? void 0 : _b.run_id)) {\n                return (0, types_js_1.err)((0, errors_js_1.prettyError)({\n                    whatHappened: \"failed to attempt retrieving data from API\",\n                    consequences: \"function execution can't continue\",\n                    why: \"run_id is missing from context\",\n                    stack: true,\n                }));\n            }\n            const [evtResp, stepResp] = await Promise.all([\n                api.getRunBatch(result.ctx.run_id),\n                api.getRunSteps(result.ctx.run_id, version),\n            ]);\n            if (evtResp.ok) {\n                result.events = evtResp.value;\n            }\n            else {\n                return (0, types_js_1.err)((0, errors_js_1.prettyError)({\n                    whatHappened: \"failed to retrieve list of events\",\n                    consequences: \"function execution can't continue\",\n                    why: (_c = evtResp.error) === null || _c === void 0 ? void 0 : _c.error,\n                    stack: true,\n                }));\n            }\n            if (stepResp.ok) {\n                result.steps = stepResp.value;\n            }\n            else {\n                return (0, types_js_1.err)((0, errors_js_1.prettyError)({\n                    whatHappened: \"failed to retrieve steps for function run\",\n                    consequences: \"function execution can't continue\",\n                    why: (_d = stepResp.error) === null || _d === void 0 ? void 0 : _d.error,\n                    stack: true,\n                }));\n            }\n        }\n        return (0, types_js_1.ok)(result);\n    }\n    catch (error) {\n        // print it out for now.\n        // move to something like protobuf so we don't have to deal with this\n        console.error(error);\n        return (0, types_js_1.err)(parseFailureErr(error));\n    }\n};\nexports.fetchAllFnData = fetchAllFnData;\nconst parseFailureErr = (err) => {\n    let why;\n    if (err instanceof zod_1.ZodError) {\n        why = err.toString();\n    }\n    return (0, errors_js_1.prettyError)({\n        whatHappened: \"Failed to parse data from executor.\",\n        consequences: \"Function execution can't continue.\",\n        toFixNow: \"Make sure that your API is set up to parse incoming request bodies as JSON, like body-parser for Express (https://expressjs.com/en/resources/middleware/body-parser.html).\",\n        stack: true,\n        why,\n    });\n};\n//# sourceMappingURL=functions.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL2Z1bmN0aW9ucy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0IsR0FBRyxtQkFBbUIsR0FBRyx1QkFBdUIsR0FBRyxpQkFBaUIsR0FBRyxlQUFlO0FBQzVHLGNBQWMsbUJBQU8sQ0FBQyx1RUFBSztBQUMzQixvQkFBb0IsbUJBQU8sQ0FBQyxvRUFBa0I7QUFDOUMsOEJBQThCLG1CQUFPLENBQUMsMEhBQTZDO0FBQ25GLG1CQUFtQixtQkFBTyxDQUFDLDBEQUFhO0FBQ3hDLG9CQUFvQixtQkFBTyxDQUFDLG1FQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLGlCQUFpQixrREFBa0Q7QUFDeEk7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQSxnRkFBZ0Ysb0RBQW9EO0FBQ3BJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsZ0ZBQWdGLG9EQUFvRDtBQUNwSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsZ0ZBQWdGLG9EQUFvRDtBQUNwSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsZ0NBQWdDLHFCQUFxQjtBQUNyRDtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpdmUtdmliZS1haS1uZXh0Ly4vbm9kZV9tb2R1bGVzL2lubmdlc3QvaGVscGVycy9mdW5jdGlvbnMuanM/MTEzNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZmV0Y2hBbGxGbkRhdGEgPSBleHBvcnRzLnBhcnNlRm5EYXRhID0gZXhwb3J0cy51bmRlZmluZWRUb051bGwgPSBleHBvcnRzLndhdGVyZmFsbCA9IGV4cG9ydHMuY2FjaGVGbiA9IHZvaWQgMDtcbmNvbnN0IHpvZF8xID0gcmVxdWlyZShcInpvZFwiKTtcbmNvbnN0IHNjaGVtYV9qc18xID0gcmVxdWlyZShcIi4uL2FwaS9zY2hlbWEuanNcIik7XG5jb25zdCBJbm5nZXN0RXhlY3V0aW9uX2pzXzEgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50cy9leGVjdXRpb24vSW5uZ2VzdEV4ZWN1dGlvbi5qc1wiKTtcbmNvbnN0IHR5cGVzX2pzXzEgPSByZXF1aXJlKFwiLi4vdHlwZXMuanNcIik7XG5jb25zdCBlcnJvcnNfanNfMSA9IHJlcXVpcmUoXCIuL2Vycm9ycy5qc1wiKTtcbi8qKlxuICogV3JhcHMgYSBmdW5jdGlvbiB3aXRoIGEgY2FjaGUuIFdoZW4gdGhlIHJldHVybmVkIGZ1bmN0aW9uIGlzIHJ1biwgaXQgd2lsbFxuICogY2FjaGUgdGhlIHJlc3VsdCBhbmQgcmV0dXJuIGl0IG9uIHN1YnNlcXVlbnQgY2FsbHMuXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5jb25zdCBjYWNoZUZuID0gKGZuKSA9PiB7XG4gICAgY29uc3Qga2V5ID0gXCJ2YWx1ZVwiO1xuICAgIGNvbnN0IGNhY2hlID0gbmV3IE1hcCgpO1xuICAgIHJldHVybiAoKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgaWYgKCFjYWNoZS5oYXMoa2V5KSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnRcbiAgICAgICAgICAgIGNhY2hlLnNldChrZXksIGZuKC4uLmFyZ3MpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgfSk7XG59O1xuZXhwb3J0cy5jYWNoZUZuID0gY2FjaGVGbjtcbi8qKlxuICogR2l2ZW4gYW4gYXJyYXkgb2YgZnVuY3Rpb25zLCByZXR1cm4gYSBuZXcgZnVuY3Rpb24gdGhhdCB3aWxsIHJ1biBlYWNoXG4gKiBmdW5jdGlvbiBpbiBzZXJpZXMgYW5kIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5hbCBmdW5jdGlvbi4gUmVnYXJkbGVzcyBvZlxuICogaWYgdGhlIGZ1bmN0aW9ucyBhcmUgc3luY2hyb25vdXMgb3IgYXN5bmNocm9ub3VzLCB0aGV5J2xsIGJlIG1hZGUgaW50byBhblxuICogYXN5bmMgcHJvbWlzZSBjaGFpbi5cbiAqXG4gKiBJZiBhbiBlcnJvciBpcyB0aHJvd24sIHRoZSB3YXRlcmZhbGwgd2lsbCBzdG9wIGFuZCByZXR1cm4gdGhlIGVycm9yLlxuICpcbiAqIEJlY2F1c2UgdGhpcyBuZWVkcyB0byBzdXBwb3J0IGJvdGggc3luYyBhbmQgYXN5bmMgZnVuY3Rpb25zLCBpdCBvbmx5IGFsbG93c1xuICogZnVuY3Rpb25zIHRoYXQgYWNjZXB0IGEgc2luZ2xlIGFyZ3VtZW50LlxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuY29uc3Qgd2F0ZXJmYWxsID0gKGZucywgXG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCB0cmFuc2Zvcm1zIHRoZSByZXN1bHQgb2YgZWFjaCBmdW5jdGlvbiBpbiB0aGUgd2F0ZXJmYWxsLFxuICogcmVhZHkgZm9yIHRoZSBuZXh0IGZ1bmN0aW9uLlxuICpcbiAqIFdpbGwgbm90IGJlIGNhbGxlZCBvbiB0aGUgZmluYWwgZnVuY3Rpb24uXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG50cmFuc2Zvcm0pID0+IHtcbiAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgY29uc3QgY2hhaW4gPSBmbnMucmVkdWNlKGFzeW5jIChhY2MsIGZuKSA9PiB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50XG4gICAgICAgICAgICBjb25zdCBwcmV2ID0gYXdhaXQgYWNjO1xuICAgICAgICAgICAgY29uc3Qgb3V0cHV0ID0gKGF3YWl0IGZuKHByZXYpKTtcbiAgICAgICAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm5cbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdHJhbnNmb3JtKHByZXYsIG91dHB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIG91dHB1dCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVyblxuICAgICAgICAgICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfSwgUHJvbWlzZS5yZXNvbHZlKGFyZ3NbMF0pKTtcbiAgICAgICAgcmV0dXJuIGNoYWluO1xuICAgIH07XG59O1xuZXhwb3J0cy53YXRlcmZhbGwgPSB3YXRlcmZhbGw7XG4vKipcbiAqIEdpdmVuIGEgdmFsdWUgYHZgLCByZXR1cm4gYHZgIGlmIGl0J3Mgbm90IHVuZGVmaW5lZCwgb3RoZXJ3aXNlIHJldHVybiBgbnVsbGAuXG4gKi9cbmNvbnN0IHVuZGVmaW5lZFRvTnVsbCA9ICh2KSA9PiB7XG4gICAgY29uc3QgaXNVbmRlZmluZWQgPSB0eXBlb2YgdiA9PT0gXCJ1bmRlZmluZWRcIjtcbiAgICByZXR1cm4gaXNVbmRlZmluZWQgPyBudWxsIDogdjtcbn07XG5leHBvcnRzLnVuZGVmaW5lZFRvTnVsbCA9IHVuZGVmaW5lZFRvTnVsbDtcbmNvbnN0IGZuRGF0YVZlcnNpb25TY2hlbWEgPSB6b2RfMS56Lm9iamVjdCh7XG4gICAgdmVyc2lvbjogem9kXzEuelxuICAgICAgICAubGl0ZXJhbCgtMSlcbiAgICAgICAgLm9yKHpvZF8xLnoubGl0ZXJhbCgwKSlcbiAgICAgICAgLm9yKHpvZF8xLnoubGl0ZXJhbCgxKSlcbiAgICAgICAgLm9yKHpvZF8xLnoubGl0ZXJhbCgyKSlcbiAgICAgICAgLm9wdGlvbmFsKClcbiAgICAgICAgLnRyYW5zZm9ybSgodikgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHYgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoYE5vIHJlcXVlc3QgdmVyc2lvbiBzcGVjaWZpZWQgYnkgZXhlY3V0b3I7IGRlZmF1bHRpbmcgdG8gdiR7SW5uZ2VzdEV4ZWN1dGlvbl9qc18xLlBSRUZFUlJFRF9FWEVDVVRJT05fVkVSU0lPTn1gKTtcbiAgICAgICAgICAgIHJldHVybiBJbm5nZXN0RXhlY3V0aW9uX2pzXzEuUFJFRkVSUkVEX0VYRUNVVElPTl9WRVJTSU9OO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2ID09PSAtMSA/IElubmdlc3RFeGVjdXRpb25fanNfMS5QUkVGRVJSRURfRVhFQ1VUSU9OX1ZFUlNJT04gOiB2O1xuICAgIH0pLFxufSk7XG5jb25zdCBwYXJzZUZuRGF0YSA9IChkYXRhKSA9PiB7XG4gICAgbGV0IHZlcnNpb247XG4gICAgdHJ5IHtcbiAgICAgICAgKHsgdmVyc2lvbiB9ID0gZm5EYXRhVmVyc2lvblNjaGVtYS5wYXJzZShkYXRhKSk7XG4gICAgICAgIGNvbnN0IHZlcnNpb25IYW5kbGVycyA9IHtcbiAgICAgICAgICAgIFtJbm5nZXN0RXhlY3V0aW9uX2pzXzEuRXhlY3V0aW9uVmVyc2lvbi5WMF06ICgpID0+IChPYmplY3QuYXNzaWduKHsgdmVyc2lvbjogSW5uZ2VzdEV4ZWN1dGlvbl9qc18xLkV4ZWN1dGlvblZlcnNpb24uVjAgfSwgem9kXzEuelxuICAgICAgICAgICAgICAgIC5vYmplY3Qoe1xuICAgICAgICAgICAgICAgIGV2ZW50OiB6b2RfMS56LnJlY29yZCh6b2RfMS56LmFueSgpKSxcbiAgICAgICAgICAgICAgICBldmVudHM6IHpvZF8xLnouYXJyYXkoem9kXzEuei5yZWNvcmQoem9kXzEuei5hbnkoKSkpLmRlZmF1bHQoW10pLFxuICAgICAgICAgICAgICAgIHN0ZXBzOiBzY2hlbWFfanNfMS5zdGVwc1NjaGVtYXNbSW5uZ2VzdEV4ZWN1dGlvbl9qc18xLkV4ZWN1dGlvblZlcnNpb24uVjBdLFxuICAgICAgICAgICAgICAgIGN0eDogem9kXzEuelxuICAgICAgICAgICAgICAgICAgICAub2JqZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgcnVuX2lkOiB6b2RfMS56LnN0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICBhdHRlbXB0OiB6b2RfMS56Lm51bWJlcigpLmRlZmF1bHQoMCksXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrOiB6b2RfMS56XG4gICAgICAgICAgICAgICAgICAgICAgICAub2JqZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrOiB6b2RfMS56XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFycmF5KHpvZF8xLnouc3RyaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm51bGxhYmxlKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudHJhbnNmb3JtKCh2KSA9PiAoQXJyYXkuaXNBcnJheSh2KSA/IHYgOiBbXSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudDogem9kXzEuei5udW1iZXIoKSxcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5wYXNzdGhyb3VnaCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAub3B0aW9uYWwoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm51bGxhYmxlKCksXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLm9wdGlvbmFsKClcbiAgICAgICAgICAgICAgICAgICAgLm51bGxhYmxlKCksXG4gICAgICAgICAgICAgICAgdXNlX2FwaTogem9kXzEuei5ib29sZWFuKCkuZGVmYXVsdChmYWxzZSksXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5wYXJzZShkYXRhKSkpLFxuICAgICAgICAgICAgW0lubmdlc3RFeGVjdXRpb25fanNfMS5FeGVjdXRpb25WZXJzaW9uLlYxXTogKCkgPT4gKE9iamVjdC5hc3NpZ24oeyB2ZXJzaW9uOiBJbm5nZXN0RXhlY3V0aW9uX2pzXzEuRXhlY3V0aW9uVmVyc2lvbi5WMSB9LCB6b2RfMS56XG4gICAgICAgICAgICAgICAgLm9iamVjdCh7XG4gICAgICAgICAgICAgICAgZXZlbnQ6IHpvZF8xLnoucmVjb3JkKHpvZF8xLnouYW55KCkpLFxuICAgICAgICAgICAgICAgIGV2ZW50czogem9kXzEuei5hcnJheSh6b2RfMS56LnJlY29yZCh6b2RfMS56LmFueSgpKSkuZGVmYXVsdChbXSksXG4gICAgICAgICAgICAgICAgc3RlcHM6IHNjaGVtYV9qc18xLnN0ZXBzU2NoZW1hc1tJbm5nZXN0RXhlY3V0aW9uX2pzXzEuRXhlY3V0aW9uVmVyc2lvbi5WMV0sXG4gICAgICAgICAgICAgICAgY3R4OiB6b2RfMS56XG4gICAgICAgICAgICAgICAgICAgIC5vYmplY3Qoe1xuICAgICAgICAgICAgICAgICAgICBydW5faWQ6IHpvZF8xLnouc3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgIGF0dGVtcHQ6IHpvZF8xLnoubnVtYmVyKCkuZGVmYXVsdCgwKSxcbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZV9pbW1lZGlhdGVfZXhlY3V0aW9uOiB6b2RfMS56LmJvb2xlYW4oKS5kZWZhdWx0KGZhbHNlKSxcbiAgICAgICAgICAgICAgICAgICAgdXNlX2FwaTogem9kXzEuei5ib29sZWFuKCkuZGVmYXVsdChmYWxzZSksXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrOiB6b2RfMS56XG4gICAgICAgICAgICAgICAgICAgICAgICAub2JqZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrOiB6b2RfMS56XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFycmF5KHpvZF8xLnouc3RyaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm51bGxhYmxlKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudHJhbnNmb3JtKCh2KSA9PiAoQXJyYXkuaXNBcnJheSh2KSA/IHYgOiBbXSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudDogem9kXzEuei5udW1iZXIoKSxcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5wYXNzdGhyb3VnaCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAub3B0aW9uYWwoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm51bGxhYmxlKCksXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLm9wdGlvbmFsKClcbiAgICAgICAgICAgICAgICAgICAgLm51bGxhYmxlKCksXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5wYXJzZShkYXRhKSkpLFxuICAgICAgICAgICAgW0lubmdlc3RFeGVjdXRpb25fanNfMS5FeGVjdXRpb25WZXJzaW9uLlYyXTogKCkgPT4gKE9iamVjdC5hc3NpZ24oeyB2ZXJzaW9uOiBJbm5nZXN0RXhlY3V0aW9uX2pzXzEuRXhlY3V0aW9uVmVyc2lvbi5WMiB9LCB6b2RfMS56XG4gICAgICAgICAgICAgICAgLm9iamVjdCh7XG4gICAgICAgICAgICAgICAgZXZlbnQ6IHpvZF8xLnoucmVjb3JkKHpvZF8xLnouYW55KCkpLFxuICAgICAgICAgICAgICAgIGV2ZW50czogem9kXzEuei5hcnJheSh6b2RfMS56LnJlY29yZCh6b2RfMS56LmFueSgpKSkuZGVmYXVsdChbXSksXG4gICAgICAgICAgICAgICAgc3RlcHM6IHNjaGVtYV9qc18xLnN0ZXBzU2NoZW1hc1tJbm5nZXN0RXhlY3V0aW9uX2pzXzEuRXhlY3V0aW9uVmVyc2lvbi5WMl0sXG4gICAgICAgICAgICAgICAgY3R4OiB6b2RfMS56XG4gICAgICAgICAgICAgICAgICAgIC5vYmplY3Qoe1xuICAgICAgICAgICAgICAgICAgICBydW5faWQ6IHpvZF8xLnouc3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgIGF0dGVtcHQ6IHpvZF8xLnoubnVtYmVyKCkuZGVmYXVsdCgwKSxcbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZV9pbW1lZGlhdGVfZXhlY3V0aW9uOiB6b2RfMS56LmJvb2xlYW4oKS5kZWZhdWx0KGZhbHNlKSxcbiAgICAgICAgICAgICAgICAgICAgdXNlX2FwaTogem9kXzEuei5ib29sZWFuKCkuZGVmYXVsdChmYWxzZSksXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrOiB6b2RfMS56XG4gICAgICAgICAgICAgICAgICAgICAgICAub2JqZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrOiB6b2RfMS56XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFycmF5KHpvZF8xLnouc3RyaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm51bGxhYmxlKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudHJhbnNmb3JtKCh2KSA9PiAoQXJyYXkuaXNBcnJheSh2KSA/IHYgOiBbXSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudDogem9kXzEuei5udW1iZXIoKSxcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5wYXNzdGhyb3VnaCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAub3B0aW9uYWwoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm51bGxhYmxlKCksXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLm9wdGlvbmFsKClcbiAgICAgICAgICAgICAgICAgICAgLm51bGxhYmxlKCksXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5wYXJzZShkYXRhKSkpLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdmVyc2lvbkhhbmRsZXJzW3ZlcnNpb25dKCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHBhcnNlRmFpbHVyZUVycihlcnIpKTtcbiAgICB9XG59O1xuZXhwb3J0cy5wYXJzZUZuRGF0YSA9IHBhcnNlRm5EYXRhO1xuY29uc3QgZmV0Y2hBbGxGbkRhdGEgPSBhc3luYyAoeyBkYXRhLCBhcGksIHZlcnNpb24sIH0pID0+IHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgY29uc3QgcmVzdWx0ID0gT2JqZWN0LmFzc2lnbih7fSwgZGF0YSk7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKChyZXN1bHQudmVyc2lvbiA9PT0gSW5uZ2VzdEV4ZWN1dGlvbl9qc18xLkV4ZWN1dGlvblZlcnNpb24uVjAgJiYgcmVzdWx0LnVzZV9hcGkpIHx8XG4gICAgICAgICAgICAocmVzdWx0LnZlcnNpb24gPT09IElubmdlc3RFeGVjdXRpb25fanNfMS5FeGVjdXRpb25WZXJzaW9uLlYxICYmICgoX2EgPSByZXN1bHQuY3R4KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudXNlX2FwaSkpKSB7XG4gICAgICAgICAgICBpZiAoISgoX2IgPSByZXN1bHQuY3R4KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucnVuX2lkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgdHlwZXNfanNfMS5lcnIpKCgwLCBlcnJvcnNfanNfMS5wcmV0dHlFcnJvcikoe1xuICAgICAgICAgICAgICAgICAgICB3aGF0SGFwcGVuZWQ6IFwiZmFpbGVkIHRvIGF0dGVtcHQgcmV0cmlldmluZyBkYXRhIGZyb20gQVBJXCIsXG4gICAgICAgICAgICAgICAgICAgIGNvbnNlcXVlbmNlczogXCJmdW5jdGlvbiBleGVjdXRpb24gY2FuJ3QgY29udGludWVcIixcbiAgICAgICAgICAgICAgICAgICAgd2h5OiBcInJ1bl9pZCBpcyBtaXNzaW5nIGZyb20gY29udGV4dFwiLFxuICAgICAgICAgICAgICAgICAgICBzdGFjazogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBbZXZ0UmVzcCwgc3RlcFJlc3BdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIGFwaS5nZXRSdW5CYXRjaChyZXN1bHQuY3R4LnJ1bl9pZCksXG4gICAgICAgICAgICAgICAgYXBpLmdldFJ1blN0ZXBzKHJlc3VsdC5jdHgucnVuX2lkLCB2ZXJzaW9uKSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgaWYgKGV2dFJlc3Aub2spIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuZXZlbnRzID0gZXZ0UmVzcC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgdHlwZXNfanNfMS5lcnIpKCgwLCBlcnJvcnNfanNfMS5wcmV0dHlFcnJvcikoe1xuICAgICAgICAgICAgICAgICAgICB3aGF0SGFwcGVuZWQ6IFwiZmFpbGVkIHRvIHJldHJpZXZlIGxpc3Qgb2YgZXZlbnRzXCIsXG4gICAgICAgICAgICAgICAgICAgIGNvbnNlcXVlbmNlczogXCJmdW5jdGlvbiBleGVjdXRpb24gY2FuJ3QgY29udGludWVcIixcbiAgICAgICAgICAgICAgICAgICAgd2h5OiAoX2MgPSBldnRSZXNwLmVycm9yKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGVwUmVzcC5vaykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zdGVwcyA9IHN0ZXBSZXNwLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCB0eXBlc19qc18xLmVycikoKDAsIGVycm9yc19qc18xLnByZXR0eUVycm9yKSh7XG4gICAgICAgICAgICAgICAgICAgIHdoYXRIYXBwZW5lZDogXCJmYWlsZWQgdG8gcmV0cmlldmUgc3RlcHMgZm9yIGZ1bmN0aW9uIHJ1blwiLFxuICAgICAgICAgICAgICAgICAgICBjb25zZXF1ZW5jZXM6IFwiZnVuY3Rpb24gZXhlY3V0aW9uIGNhbid0IGNvbnRpbnVlXCIsXG4gICAgICAgICAgICAgICAgICAgIHdoeTogKF9kID0gc3RlcFJlc3AuZXJyb3IpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5lcnJvcixcbiAgICAgICAgICAgICAgICAgICAgc3RhY2s6IHRydWUsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoMCwgdHlwZXNfanNfMS5vaykocmVzdWx0KTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIHByaW50IGl0IG91dCBmb3Igbm93LlxuICAgICAgICAvLyBtb3ZlIHRvIHNvbWV0aGluZyBsaWtlIHByb3RvYnVmIHNvIHdlIGRvbid0IGhhdmUgdG8gZGVhbCB3aXRoIHRoaXNcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgIHJldHVybiAoMCwgdHlwZXNfanNfMS5lcnIpKHBhcnNlRmFpbHVyZUVycihlcnJvcikpO1xuICAgIH1cbn07XG5leHBvcnRzLmZldGNoQWxsRm5EYXRhID0gZmV0Y2hBbGxGbkRhdGE7XG5jb25zdCBwYXJzZUZhaWx1cmVFcnIgPSAoZXJyKSA9PiB7XG4gICAgbGV0IHdoeTtcbiAgICBpZiAoZXJyIGluc3RhbmNlb2Ygem9kXzEuWm9kRXJyb3IpIHtcbiAgICAgICAgd2h5ID0gZXJyLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHJldHVybiAoMCwgZXJyb3JzX2pzXzEucHJldHR5RXJyb3IpKHtcbiAgICAgICAgd2hhdEhhcHBlbmVkOiBcIkZhaWxlZCB0byBwYXJzZSBkYXRhIGZyb20gZXhlY3V0b3IuXCIsXG4gICAgICAgIGNvbnNlcXVlbmNlczogXCJGdW5jdGlvbiBleGVjdXRpb24gY2FuJ3QgY29udGludWUuXCIsXG4gICAgICAgIHRvRml4Tm93OiBcIk1ha2Ugc3VyZSB0aGF0IHlvdXIgQVBJIGlzIHNldCB1cCB0byBwYXJzZSBpbmNvbWluZyByZXF1ZXN0IGJvZGllcyBhcyBKU09OLCBsaWtlIGJvZHktcGFyc2VyIGZvciBFeHByZXNzIChodHRwczovL2V4cHJlc3Nqcy5jb20vZW4vcmVzb3VyY2VzL21pZGRsZXdhcmUvYm9keS1wYXJzZXIuaHRtbCkuXCIsXG4gICAgICAgIHN0YWNrOiB0cnVlLFxuICAgICAgICB3aHksXG4gICAgfSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnVuY3Rpb25zLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/helpers/functions.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/helpers/net.js":
/*!*********************************************!*\
  !*** ./node_modules/inngest/helpers/net.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.fetchWithAuthFallback = fetchWithAuthFallback;\nexports.signDataWithKey = signDataWithKey;\nconst canonicalize_1 = __importDefault(__webpack_require__(/*! canonicalize */ \"(rsc)/./node_modules/canonicalize/lib/canonicalize.js\"));\nconst hash_js_1 = __webpack_require__(/*! hash.js */ \"(rsc)/./node_modules/hash.js/lib/hash.js\");\n/**\n * Send an HTTP request with the given signing key. If the response is a 401 or\n * 403, then try again with the fallback signing key\n */\nasync function fetchWithAuthFallback({ authToken, authTokenFallback, fetch, options, url, }) {\n    let res = await fetch(url, Object.assign(Object.assign({}, options), { headers: Object.assign(Object.assign({}, options === null || options === void 0 ? void 0 : options.headers), { Authorization: `Bearer ${authToken}` }) }));\n    if ([401, 403].includes(res.status) && authTokenFallback) {\n        res = await fetch(url, Object.assign(Object.assign({}, options), { headers: Object.assign(Object.assign({}, options === null || options === void 0 ? void 0 : options.headers), { Authorization: `Bearer ${authTokenFallback}` }) }));\n    }\n    return res;\n}\nfunction signDataWithKey(data, signingKey, ts) {\n    // Calculate the HMAC of the request body ourselves.\n    // We make the assumption here that a stringified body is the same as the\n    // raw bytes; it may be pertinent in the future to always parse, then\n    // canonicalize the body to ensure it's consistent.\n    const encoded = typeof data === \"string\" ? data : (0, canonicalize_1.default)(data);\n    // Remove the `/signkey-[test|prod]-/` prefix from our signing key to calculate the HMAC.\n    const key = signingKey.replace(/signkey-\\w+-/, \"\");\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-explicit-any\n    const mac = (0, hash_js_1.hmac)(hash_js_1.sha256, key)\n        .update(encoded)\n        .update(ts)\n        .digest(\"hex\");\n    return mac;\n}\n//# sourceMappingURL=net.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL25ldC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDZCQUE2QjtBQUM3Qix1QkFBdUI7QUFDdkIsdUNBQXVDLG1CQUFPLENBQUMsMkVBQWM7QUFDN0Qsa0JBQWtCLG1CQUFPLENBQUMseURBQVM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsb0RBQW9EO0FBQzNGLDZEQUE2RCxjQUFjLHVDQUF1Qyx3RUFBd0UseUJBQXlCLFVBQVUsR0FBRyxHQUFHO0FBQ25PO0FBQ0EsNkRBQTZELGNBQWMsdUNBQXVDLHdFQUF3RSx5QkFBeUIsa0JBQWtCLEdBQUcsR0FBRztBQUMzTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdml2ZS12aWJlLWFpLW5leHQvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL25ldC5qcz9hOTdhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5mZXRjaFdpdGhBdXRoRmFsbGJhY2sgPSBmZXRjaFdpdGhBdXRoRmFsbGJhY2s7XG5leHBvcnRzLnNpZ25EYXRhV2l0aEtleSA9IHNpZ25EYXRhV2l0aEtleTtcbmNvbnN0IGNhbm9uaWNhbGl6ZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJjYW5vbmljYWxpemVcIikpO1xuY29uc3QgaGFzaF9qc18xID0gcmVxdWlyZShcImhhc2guanNcIik7XG4vKipcbiAqIFNlbmQgYW4gSFRUUCByZXF1ZXN0IHdpdGggdGhlIGdpdmVuIHNpZ25pbmcga2V5LiBJZiB0aGUgcmVzcG9uc2UgaXMgYSA0MDEgb3JcbiAqIDQwMywgdGhlbiB0cnkgYWdhaW4gd2l0aCB0aGUgZmFsbGJhY2sgc2lnbmluZyBrZXlcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZmV0Y2hXaXRoQXV0aEZhbGxiYWNrKHsgYXV0aFRva2VuLCBhdXRoVG9rZW5GYWxsYmFjaywgZmV0Y2gsIG9wdGlvbnMsIHVybCwgfSkge1xuICAgIGxldCByZXMgPSBhd2FpdCBmZXRjaCh1cmwsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHsgaGVhZGVyczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaGVhZGVycyksIHsgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke2F1dGhUb2tlbn1gIH0pIH0pKTtcbiAgICBpZiAoWzQwMSwgNDAzXS5pbmNsdWRlcyhyZXMuc3RhdHVzKSAmJiBhdXRoVG9rZW5GYWxsYmFjaykge1xuICAgICAgICByZXMgPSBhd2FpdCBmZXRjaCh1cmwsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHsgaGVhZGVyczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaGVhZGVycyksIHsgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke2F1dGhUb2tlbkZhbGxiYWNrfWAgfSkgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gc2lnbkRhdGFXaXRoS2V5KGRhdGEsIHNpZ25pbmdLZXksIHRzKSB7XG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBITUFDIG9mIHRoZSByZXF1ZXN0IGJvZHkgb3Vyc2VsdmVzLlxuICAgIC8vIFdlIG1ha2UgdGhlIGFzc3VtcHRpb24gaGVyZSB0aGF0IGEgc3RyaW5naWZpZWQgYm9keSBpcyB0aGUgc2FtZSBhcyB0aGVcbiAgICAvLyByYXcgYnl0ZXM7IGl0IG1heSBiZSBwZXJ0aW5lbnQgaW4gdGhlIGZ1dHVyZSB0byBhbHdheXMgcGFyc2UsIHRoZW5cbiAgICAvLyBjYW5vbmljYWxpemUgdGhlIGJvZHkgdG8gZW5zdXJlIGl0J3MgY29uc2lzdGVudC5cbiAgICBjb25zdCBlbmNvZGVkID0gdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgPyBkYXRhIDogKDAsIGNhbm9uaWNhbGl6ZV8xLmRlZmF1bHQpKGRhdGEpO1xuICAgIC8vIFJlbW92ZSB0aGUgYC9zaWdua2V5LVt0ZXN0fHByb2RdLS9gIHByZWZpeCBmcm9tIG91ciBzaWduaW5nIGtleSB0byBjYWxjdWxhdGUgdGhlIEhNQUMuXG4gICAgY29uc3Qga2V5ID0gc2lnbmluZ0tleS5yZXBsYWNlKC9zaWdua2V5LVxcdystLywgXCJcIik7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnQsIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBjb25zdCBtYWMgPSAoMCwgaGFzaF9qc18xLmhtYWMpKGhhc2hfanNfMS5zaGEyNTYsIGtleSlcbiAgICAgICAgLnVwZGF0ZShlbmNvZGVkKVxuICAgICAgICAudXBkYXRlKHRzKVxuICAgICAgICAuZGlnZXN0KFwiaGV4XCIpO1xuICAgIHJldHVybiBtYWM7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1uZXQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/helpers/net.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/helpers/promises.js":
/*!**************************************************!*\
  !*** ./node_modules/inngest/helpers/promises.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.retryWithBackoff = exports.resolveNextTick = exports.runAsPromise = exports.createTimeoutPromise = exports.createDeferredPromiseWithStack = exports.createDeferredPromise = exports.resolveAfterPending = exports.createFrozenPromise = void 0;\n/**\n * Some environments don't allow access to the global queueMicrotask(). While we\n * had assumed this was only true for those powered by earlier versions of Node\n * (<14) that we don't officially support, Vercel's Edge Functions also obscure\n * the function in dev, even though the platform it's based on (Cloudflare\n * Workers) appropriately exposes it. Even worse, production Vercel Edge\n * Functions can see the function, but it immediately blows up the function when\n * used.\n *\n * Therefore, we can fall back to a reasonable alternative of\n * `Promise.resolve().then(fn)` instead. This _may_ be slightly slower in modern\n * environments, but at least we can still work in these environments.\n */\nconst shimQueueMicrotask = (callback) => {\n    void Promise.resolve().then(callback);\n};\n/**\n * A helper function to create a `Promise` that will never settle.\n *\n * It purposefully creates no references to `resolve` or `reject` so that the\n * returned `Promise` will remain unsettled until it falls out of scope and is\n * garbage collected.\n *\n * This should be used within transient closures to fake asynchronous action, so\n * long as it's guaranteed that they will fall out of scope.\n */\nconst createFrozenPromise = () => {\n    return new Promise(() => undefined);\n};\nexports.createFrozenPromise = createFrozenPromise;\n/**\n * Returns a Promise that resolves after the current event loop's microtasks\n * have finished, but before the next event loop tick.\n */\nconst resolveAfterPending = (count = 100) => {\n    /**\n     * This uses a brute force implementation that will continue to enqueue\n     * microtasks 10 times before resolving. This is to ensure that the microtask\n     * queue is drained, even if the microtask queue is being manipulated by other\n     * code.\n     *\n     * While this still doesn't guarantee that the microtask queue is drained,\n     * it's our best bet for giving other non-controlled promises a chance to\n     * resolve before we continue without resorting to falling in to the next\n     * tick.\n     */\n    return new Promise((resolve) => {\n        let i = 0;\n        const iterate = () => {\n            shimQueueMicrotask(() => {\n                if (i++ > count) {\n                    return resolve();\n                }\n                iterate();\n            });\n        };\n        iterate();\n    });\n};\nexports.resolveAfterPending = resolveAfterPending;\n/**\n * Creates and returns Promise that can be resolved or rejected with the\n * returned `resolve` and `reject` functions.\n *\n * Resolving or rejecting the function will return a new set of Promise control\n * functions. These can be ignored if the original Promise is all that's needed.\n */\nconst createDeferredPromise = () => {\n    let resolve;\n    let reject;\n    const promise = new Promise((_resolve, _reject) => {\n        resolve = (value) => {\n            _resolve(value);\n            return (0, exports.createDeferredPromise)();\n        };\n        reject = (reason) => {\n            _reject(reason);\n            return (0, exports.createDeferredPromise)();\n        };\n    });\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return { promise, resolve: resolve, reject: reject };\n};\nexports.createDeferredPromise = createDeferredPromise;\n/**\n * Creates and returns a deferred Promise that can be resolved or rejected with\n * the returned `resolve` and `reject` functions.\n *\n * For each Promise resolved or rejected this way, this will also keep a stack\n * of all unhandled Promises, resolved or rejected.\n *\n * Once a Promise is read, it is removed from the stack.\n */\nconst createDeferredPromiseWithStack = () => {\n    const settledPromises = [];\n    let rotateQueue = () => { };\n    const results = (function () {\n        return __asyncGenerator(this, arguments, function* () {\n            while (true) {\n                const next = settledPromises.shift();\n                if (next) {\n                    yield yield __await(next);\n                }\n                else {\n                    yield __await(new Promise((resolve) => {\n                        rotateQueue = resolve;\n                    }));\n                }\n            }\n        });\n    })();\n    const shimDeferredPromise = (deferred) => {\n        const originalResolve = deferred.resolve;\n        const originalReject = deferred.reject;\n        deferred.resolve = (value) => {\n            settledPromises.push(deferred.promise);\n            rotateQueue();\n            return shimDeferredPromise(originalResolve(value));\n        };\n        deferred.reject = (reason) => {\n            settledPromises.push(deferred.promise);\n            rotateQueue();\n            return shimDeferredPromise(originalReject(reason));\n        };\n        return deferred;\n    };\n    const deferred = shimDeferredPromise((0, exports.createDeferredPromise)());\n    return { deferred, results };\n};\nexports.createDeferredPromiseWithStack = createDeferredPromiseWithStack;\n/**\n * Creates a Promise that will resolve after the given duration, along with\n * methods to start, clear, and reset the timeout.\n */\nconst createTimeoutPromise = (duration) => {\n    const { promise, resolve } = (0, exports.createDeferredPromise)();\n    let timeout;\n    // eslint-disable-next-line prefer-const\n    let ret;\n    const start = () => {\n        if (timeout)\n            return ret;\n        timeout = setTimeout(() => {\n            resolve();\n        }, duration);\n        return ret;\n    };\n    const clear = () => {\n        clearTimeout(timeout);\n        timeout = undefined;\n    };\n    const reset = () => {\n        clear();\n        return start();\n    };\n    ret = Object.assign(promise, { start, clear, reset });\n    return ret;\n};\nexports.createTimeoutPromise = createTimeoutPromise;\n/**\n * Take any function and safely promisify such that both synchronous and\n * asynchronous errors are caught and returned as a rejected Promise.\n *\n * The passed `fn` can be undefined to support functions that may conditionally\n * be defined.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst runAsPromise = (fn\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n) => {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return Promise.resolve().then(fn);\n};\nexports.runAsPromise = runAsPromise;\n/**\n * Returns a Promise that resolve after the current event loop tick.\n */\nconst resolveNextTick = () => {\n    return new Promise((resolve) => setTimeout(resolve));\n};\nexports.resolveNextTick = resolveNextTick;\nconst retryWithBackoff = async (fn, opts) => {\n    var _a;\n    const maxAttempts = (opts === null || opts === void 0 ? void 0 : opts.maxAttempts) || 5;\n    const baseDelay = (_a = opts === null || opts === void 0 ? void 0 : opts.baseDelay) !== null && _a !== void 0 ? _a : 100;\n    for (let attempt = 1; attempt <= maxAttempts; attempt++) {\n        try {\n            return await fn();\n        }\n        catch (err) {\n            if (attempt >= maxAttempts) {\n                throw err;\n            }\n            const jitter = Math.random() * baseDelay;\n            const delay = baseDelay * Math.pow(2, attempt - 1) + jitter;\n            await new Promise((resolve) => setTimeout(resolve, delay));\n        }\n    }\n    throw new Error(\"Max retries reached; this should be unreachable.\");\n};\nexports.retryWithBackoff = retryWithBackoff;\n//# sourceMappingURL=promises.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL3Byb21pc2VzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLDBNQUEwTSxjQUFjO0FBQ3hOLDhCQUE4QixzQkFBc0I7QUFDcEQsMEJBQTBCLFlBQVksc0JBQXNCLHFDQUFxQywyQ0FBMkMsTUFBTTtBQUNsSiw0QkFBNEIsTUFBTSxpQkFBaUIsWUFBWTtBQUMvRCx1QkFBdUI7QUFDdkIsOEJBQThCO0FBQzlCLDZCQUE2QjtBQUM3Qiw0QkFBNEI7QUFDNUI7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0JBQXdCLEdBQUcsdUJBQXVCLEdBQUcsb0JBQW9CLEdBQUcsNEJBQTRCLEdBQUcsc0NBQXNDLEdBQUcsNkJBQTZCLEdBQUcsMkJBQTJCLEdBQUcsMkJBQTJCO0FBQzdPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxhQUFhO0FBQ2I7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMscUJBQXFCO0FBQ3hEO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsd0JBQXdCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBLHdCQUF3QjtBQUN4QiIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpdmUtdmliZS1haS1uZXh0Ly4vbm9kZV9tb2R1bGVzL2lubmdlc3QvaGVscGVycy9wcm9taXNlcy5qcz81NWFkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXQgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXQpIHx8IGZ1bmN0aW9uICh2KSB7IHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpOyB9XG52YXIgX19hc3luY0dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19hc3luY0dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcbiAgICByZXR1cm4gaSA9IE9iamVjdC5jcmVhdGUoKHR5cGVvZiBBc3luY0l0ZXJhdG9yID09PSBcImZ1bmN0aW9uXCIgPyBBc3luY0l0ZXJhdG9yIDogT2JqZWN0KS5wcm90b3R5cGUpLCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIsIGF3YWl0UmV0dXJuKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xuICAgIGZ1bmN0aW9uIGF3YWl0UmV0dXJuKGYpIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBQcm9taXNlLnJlc29sdmUodikudGhlbihmLCByZWplY3QpOyB9OyB9XG4gICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlmIChnW25dKSB7IGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IGlmIChmKSBpW25dID0gZihpW25dKTsgfSB9XG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxuICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgfVxuICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XG4gICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmV0cnlXaXRoQmFja29mZiA9IGV4cG9ydHMucmVzb2x2ZU5leHRUaWNrID0gZXhwb3J0cy5ydW5Bc1Byb21pc2UgPSBleHBvcnRzLmNyZWF0ZVRpbWVvdXRQcm9taXNlID0gZXhwb3J0cy5jcmVhdGVEZWZlcnJlZFByb21pc2VXaXRoU3RhY2sgPSBleHBvcnRzLmNyZWF0ZURlZmVycmVkUHJvbWlzZSA9IGV4cG9ydHMucmVzb2x2ZUFmdGVyUGVuZGluZyA9IGV4cG9ydHMuY3JlYXRlRnJvemVuUHJvbWlzZSA9IHZvaWQgMDtcbi8qKlxuICogU29tZSBlbnZpcm9ubWVudHMgZG9uJ3QgYWxsb3cgYWNjZXNzIHRvIHRoZSBnbG9iYWwgcXVldWVNaWNyb3Rhc2soKS4gV2hpbGUgd2VcbiAqIGhhZCBhc3N1bWVkIHRoaXMgd2FzIG9ubHkgdHJ1ZSBmb3IgdGhvc2UgcG93ZXJlZCBieSBlYXJsaWVyIHZlcnNpb25zIG9mIE5vZGVcbiAqICg8MTQpIHRoYXQgd2UgZG9uJ3Qgb2ZmaWNpYWxseSBzdXBwb3J0LCBWZXJjZWwncyBFZGdlIEZ1bmN0aW9ucyBhbHNvIG9ic2N1cmVcbiAqIHRoZSBmdW5jdGlvbiBpbiBkZXYsIGV2ZW4gdGhvdWdoIHRoZSBwbGF0Zm9ybSBpdCdzIGJhc2VkIG9uIChDbG91ZGZsYXJlXG4gKiBXb3JrZXJzKSBhcHByb3ByaWF0ZWx5IGV4cG9zZXMgaXQuIEV2ZW4gd29yc2UsIHByb2R1Y3Rpb24gVmVyY2VsIEVkZ2VcbiAqIEZ1bmN0aW9ucyBjYW4gc2VlIHRoZSBmdW5jdGlvbiwgYnV0IGl0IGltbWVkaWF0ZWx5IGJsb3dzIHVwIHRoZSBmdW5jdGlvbiB3aGVuXG4gKiB1c2VkLlxuICpcbiAqIFRoZXJlZm9yZSwgd2UgY2FuIGZhbGwgYmFjayB0byBhIHJlYXNvbmFibGUgYWx0ZXJuYXRpdmUgb2ZcbiAqIGBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZuKWAgaW5zdGVhZC4gVGhpcyBfbWF5XyBiZSBzbGlnaHRseSBzbG93ZXIgaW4gbW9kZXJuXG4gKiBlbnZpcm9ubWVudHMsIGJ1dCBhdCBsZWFzdCB3ZSBjYW4gc3RpbGwgd29yayBpbiB0aGVzZSBlbnZpcm9ubWVudHMuXG4gKi9cbmNvbnN0IHNoaW1RdWV1ZU1pY3JvdGFzayA9IChjYWxsYmFjaykgPT4ge1xuICAgIHZvaWQgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihjYWxsYmFjayk7XG59O1xuLyoqXG4gKiBBIGhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgYSBgUHJvbWlzZWAgdGhhdCB3aWxsIG5ldmVyIHNldHRsZS5cbiAqXG4gKiBJdCBwdXJwb3NlZnVsbHkgY3JlYXRlcyBubyByZWZlcmVuY2VzIHRvIGByZXNvbHZlYCBvciBgcmVqZWN0YCBzbyB0aGF0IHRoZVxuICogcmV0dXJuZWQgYFByb21pc2VgIHdpbGwgcmVtYWluIHVuc2V0dGxlZCB1bnRpbCBpdCBmYWxscyBvdXQgb2Ygc2NvcGUgYW5kIGlzXG4gKiBnYXJiYWdlIGNvbGxlY3RlZC5cbiAqXG4gKiBUaGlzIHNob3VsZCBiZSB1c2VkIHdpdGhpbiB0cmFuc2llbnQgY2xvc3VyZXMgdG8gZmFrZSBhc3luY2hyb25vdXMgYWN0aW9uLCBzb1xuICogbG9uZyBhcyBpdCdzIGd1YXJhbnRlZWQgdGhhdCB0aGV5IHdpbGwgZmFsbCBvdXQgb2Ygc2NvcGUuXG4gKi9cbmNvbnN0IGNyZWF0ZUZyb3plblByb21pc2UgPSAoKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpID0+IHVuZGVmaW5lZCk7XG59O1xuZXhwb3J0cy5jcmVhdGVGcm96ZW5Qcm9taXNlID0gY3JlYXRlRnJvemVuUHJvbWlzZTtcbi8qKlxuICogUmV0dXJucyBhIFByb21pc2UgdGhhdCByZXNvbHZlcyBhZnRlciB0aGUgY3VycmVudCBldmVudCBsb29wJ3MgbWljcm90YXNrc1xuICogaGF2ZSBmaW5pc2hlZCwgYnV0IGJlZm9yZSB0aGUgbmV4dCBldmVudCBsb29wIHRpY2suXG4gKi9cbmNvbnN0IHJlc29sdmVBZnRlclBlbmRpbmcgPSAoY291bnQgPSAxMDApID0+IHtcbiAgICAvKipcbiAgICAgKiBUaGlzIHVzZXMgYSBicnV0ZSBmb3JjZSBpbXBsZW1lbnRhdGlvbiB0aGF0IHdpbGwgY29udGludWUgdG8gZW5xdWV1ZVxuICAgICAqIG1pY3JvdGFza3MgMTAgdGltZXMgYmVmb3JlIHJlc29sdmluZy4gVGhpcyBpcyB0byBlbnN1cmUgdGhhdCB0aGUgbWljcm90YXNrXG4gICAgICogcXVldWUgaXMgZHJhaW5lZCwgZXZlbiBpZiB0aGUgbWljcm90YXNrIHF1ZXVlIGlzIGJlaW5nIG1hbmlwdWxhdGVkIGJ5IG90aGVyXG4gICAgICogY29kZS5cbiAgICAgKlxuICAgICAqIFdoaWxlIHRoaXMgc3RpbGwgZG9lc24ndCBndWFyYW50ZWUgdGhhdCB0aGUgbWljcm90YXNrIHF1ZXVlIGlzIGRyYWluZWQsXG4gICAgICogaXQncyBvdXIgYmVzdCBiZXQgZm9yIGdpdmluZyBvdGhlciBub24tY29udHJvbGxlZCBwcm9taXNlcyBhIGNoYW5jZSB0b1xuICAgICAqIHJlc29sdmUgYmVmb3JlIHdlIGNvbnRpbnVlIHdpdGhvdXQgcmVzb3J0aW5nIHRvIGZhbGxpbmcgaW4gdG8gdGhlIG5leHRcbiAgICAgKiB0aWNrLlxuICAgICAqL1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGNvbnN0IGl0ZXJhdGUgPSAoKSA9PiB7XG4gICAgICAgICAgICBzaGltUXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpKysgPiBjb3VudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpdGVyYXRlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgaXRlcmF0ZSgpO1xuICAgIH0pO1xufTtcbmV4cG9ydHMucmVzb2x2ZUFmdGVyUGVuZGluZyA9IHJlc29sdmVBZnRlclBlbmRpbmc7XG4vKipcbiAqIENyZWF0ZXMgYW5kIHJldHVybnMgUHJvbWlzZSB0aGF0IGNhbiBiZSByZXNvbHZlZCBvciByZWplY3RlZCB3aXRoIHRoZVxuICogcmV0dXJuZWQgYHJlc29sdmVgIGFuZCBgcmVqZWN0YCBmdW5jdGlvbnMuXG4gKlxuICogUmVzb2x2aW5nIG9yIHJlamVjdGluZyB0aGUgZnVuY3Rpb24gd2lsbCByZXR1cm4gYSBuZXcgc2V0IG9mIFByb21pc2UgY29udHJvbFxuICogZnVuY3Rpb25zLiBUaGVzZSBjYW4gYmUgaWdub3JlZCBpZiB0aGUgb3JpZ2luYWwgUHJvbWlzZSBpcyBhbGwgdGhhdCdzIG5lZWRlZC5cbiAqL1xuY29uc3QgY3JlYXRlRGVmZXJyZWRQcm9taXNlID0gKCkgPT4ge1xuICAgIGxldCByZXNvbHZlO1xuICAgIGxldCByZWplY3Q7XG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChfcmVzb2x2ZSwgX3JlamVjdCkgPT4ge1xuICAgICAgICByZXNvbHZlID0gKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBfcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuY3JlYXRlRGVmZXJyZWRQcm9taXNlKSgpO1xuICAgICAgICB9O1xuICAgICAgICByZWplY3QgPSAocmVhc29uKSA9PiB7XG4gICAgICAgICAgICBfcmVqZWN0KHJlYXNvbik7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuY3JlYXRlRGVmZXJyZWRQcm9taXNlKSgpO1xuICAgICAgICB9O1xuICAgIH0pO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgcmV0dXJuIHsgcHJvbWlzZSwgcmVzb2x2ZTogcmVzb2x2ZSwgcmVqZWN0OiByZWplY3QgfTtcbn07XG5leHBvcnRzLmNyZWF0ZURlZmVycmVkUHJvbWlzZSA9IGNyZWF0ZURlZmVycmVkUHJvbWlzZTtcbi8qKlxuICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIGRlZmVycmVkIFByb21pc2UgdGhhdCBjYW4gYmUgcmVzb2x2ZWQgb3IgcmVqZWN0ZWQgd2l0aFxuICogdGhlIHJldHVybmVkIGByZXNvbHZlYCBhbmQgYHJlamVjdGAgZnVuY3Rpb25zLlxuICpcbiAqIEZvciBlYWNoIFByb21pc2UgcmVzb2x2ZWQgb3IgcmVqZWN0ZWQgdGhpcyB3YXksIHRoaXMgd2lsbCBhbHNvIGtlZXAgYSBzdGFja1xuICogb2YgYWxsIHVuaGFuZGxlZCBQcm9taXNlcywgcmVzb2x2ZWQgb3IgcmVqZWN0ZWQuXG4gKlxuICogT25jZSBhIFByb21pc2UgaXMgcmVhZCwgaXQgaXMgcmVtb3ZlZCBmcm9tIHRoZSBzdGFjay5cbiAqL1xuY29uc3QgY3JlYXRlRGVmZXJyZWRQcm9taXNlV2l0aFN0YWNrID0gKCkgPT4ge1xuICAgIGNvbnN0IHNldHRsZWRQcm9taXNlcyA9IFtdO1xuICAgIGxldCByb3RhdGVRdWV1ZSA9ICgpID0+IHsgfTtcbiAgICBjb25zdCByZXN1bHRzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gc2V0dGxlZFByb21pc2VzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdChuZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIF9fYXdhaXQobmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdGF0ZVF1ZXVlID0gcmVzb2x2ZTtcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSkoKTtcbiAgICBjb25zdCBzaGltRGVmZXJyZWRQcm9taXNlID0gKGRlZmVycmVkKSA9PiB7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsUmVzb2x2ZSA9IGRlZmVycmVkLnJlc29sdmU7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsUmVqZWN0ID0gZGVmZXJyZWQucmVqZWN0O1xuICAgICAgICBkZWZlcnJlZC5yZXNvbHZlID0gKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBzZXR0bGVkUHJvbWlzZXMucHVzaChkZWZlcnJlZC5wcm9taXNlKTtcbiAgICAgICAgICAgIHJvdGF0ZVF1ZXVlKCk7XG4gICAgICAgICAgICByZXR1cm4gc2hpbURlZmVycmVkUHJvbWlzZShvcmlnaW5hbFJlc29sdmUodmFsdWUpKTtcbiAgICAgICAgfTtcbiAgICAgICAgZGVmZXJyZWQucmVqZWN0ID0gKHJlYXNvbikgPT4ge1xuICAgICAgICAgICAgc2V0dGxlZFByb21pc2VzLnB1c2goZGVmZXJyZWQucHJvbWlzZSk7XG4gICAgICAgICAgICByb3RhdGVRdWV1ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHNoaW1EZWZlcnJlZFByb21pc2Uob3JpZ2luYWxSZWplY3QocmVhc29uKSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBkZWZlcnJlZDtcbiAgICB9O1xuICAgIGNvbnN0IGRlZmVycmVkID0gc2hpbURlZmVycmVkUHJvbWlzZSgoMCwgZXhwb3J0cy5jcmVhdGVEZWZlcnJlZFByb21pc2UpKCkpO1xuICAgIHJldHVybiB7IGRlZmVycmVkLCByZXN1bHRzIH07XG59O1xuZXhwb3J0cy5jcmVhdGVEZWZlcnJlZFByb21pc2VXaXRoU3RhY2sgPSBjcmVhdGVEZWZlcnJlZFByb21pc2VXaXRoU3RhY2s7XG4vKipcbiAqIENyZWF0ZXMgYSBQcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIGFmdGVyIHRoZSBnaXZlbiBkdXJhdGlvbiwgYWxvbmcgd2l0aFxuICogbWV0aG9kcyB0byBzdGFydCwgY2xlYXIsIGFuZCByZXNldCB0aGUgdGltZW91dC5cbiAqL1xuY29uc3QgY3JlYXRlVGltZW91dFByb21pc2UgPSAoZHVyYXRpb24pID0+IHtcbiAgICBjb25zdCB7IHByb21pc2UsIHJlc29sdmUgfSA9ICgwLCBleHBvcnRzLmNyZWF0ZURlZmVycmVkUHJvbWlzZSkoKTtcbiAgICBsZXQgdGltZW91dDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWNvbnN0XG4gICAgbGV0IHJldDtcbiAgICBjb25zdCBzdGFydCA9ICgpID0+IHtcbiAgICAgICAgaWYgKHRpbWVvdXQpXG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0sIGR1cmF0aW9uKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGNvbnN0IGNsZWFyID0gKCkgPT4ge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIHRpbWVvdXQgPSB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICBjb25zdCByZXNldCA9ICgpID0+IHtcbiAgICAgICAgY2xlYXIoKTtcbiAgICAgICAgcmV0dXJuIHN0YXJ0KCk7XG4gICAgfTtcbiAgICByZXQgPSBPYmplY3QuYXNzaWduKHByb21pc2UsIHsgc3RhcnQsIGNsZWFyLCByZXNldCB9KTtcbiAgICByZXR1cm4gcmV0O1xufTtcbmV4cG9ydHMuY3JlYXRlVGltZW91dFByb21pc2UgPSBjcmVhdGVUaW1lb3V0UHJvbWlzZTtcbi8qKlxuICogVGFrZSBhbnkgZnVuY3Rpb24gYW5kIHNhZmVseSBwcm9taXNpZnkgc3VjaCB0aGF0IGJvdGggc3luY2hyb25vdXMgYW5kXG4gKiBhc3luY2hyb25vdXMgZXJyb3JzIGFyZSBjYXVnaHQgYW5kIHJldHVybmVkIGFzIGEgcmVqZWN0ZWQgUHJvbWlzZS5cbiAqXG4gKiBUaGUgcGFzc2VkIGBmbmAgY2FuIGJlIHVuZGVmaW5lZCB0byBzdXBwb3J0IGZ1bmN0aW9ucyB0aGF0IG1heSBjb25kaXRpb25hbGx5XG4gKiBiZSBkZWZpbmVkLlxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuY29uc3QgcnVuQXNQcm9taXNlID0gKGZuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuKSA9PiB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtcmV0dXJuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZm4pO1xufTtcbmV4cG9ydHMucnVuQXNQcm9taXNlID0gcnVuQXNQcm9taXNlO1xuLyoqXG4gKiBSZXR1cm5zIGEgUHJvbWlzZSB0aGF0IHJlc29sdmUgYWZ0ZXIgdGhlIGN1cnJlbnQgZXZlbnQgbG9vcCB0aWNrLlxuICovXG5jb25zdCByZXNvbHZlTmV4dFRpY2sgPSAoKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUpKTtcbn07XG5leHBvcnRzLnJlc29sdmVOZXh0VGljayA9IHJlc29sdmVOZXh0VGljaztcbmNvbnN0IHJldHJ5V2l0aEJhY2tvZmYgPSBhc3luYyAoZm4sIG9wdHMpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgbWF4QXR0ZW1wdHMgPSAob3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLm1heEF0dGVtcHRzKSB8fCA1O1xuICAgIGNvbnN0IGJhc2VEZWxheSA9IChfYSA9IG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5iYXNlRGVsYXkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDEwMDtcbiAgICBmb3IgKGxldCBhdHRlbXB0ID0gMTsgYXR0ZW1wdCA8PSBtYXhBdHRlbXB0czsgYXR0ZW1wdCsrKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgZm4oKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoYXR0ZW1wdCA+PSBtYXhBdHRlbXB0cykge1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGppdHRlciA9IE1hdGgucmFuZG9tKCkgKiBiYXNlRGVsYXk7XG4gICAgICAgICAgICBjb25zdCBkZWxheSA9IGJhc2VEZWxheSAqIE1hdGgucG93KDIsIGF0dGVtcHQgLSAxKSArIGppdHRlcjtcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGRlbGF5KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWF4IHJldHJpZXMgcmVhY2hlZDsgdGhpcyBzaG91bGQgYmUgdW5yZWFjaGFibGUuXCIpO1xufTtcbmV4cG9ydHMucmV0cnlXaXRoQmFja29mZiA9IHJldHJ5V2l0aEJhY2tvZmY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9taXNlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/helpers/promises.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/helpers/stream.js":
/*!************************************************!*\
  !*** ./node_modules/inngest/helpers/stream.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createStream = void 0;\nconst strings_js_1 = __webpack_require__(/*! ./strings.js */ \"(rsc)/./node_modules/inngest/helpers/strings.js\");\n/**\n * Creates a {@link ReadableStream} that sends a `value` every `interval`\n * milliseconds as a heartbeat, intended to keep a stream open.\n *\n * Returns the `stream` itself and a `finalize` function that can be used to\n * close the stream and send a final value.\n */\nconst createStream = (opts) => {\n    var _a, _b;\n    /**\n     * We need to resolve this promise with both the stream and the `finalize`\n     * function, but having them both instantiated synchronously is difficult, as\n     * we need access to the stream's internals too.\n     *\n     * We create this cheeky deferred promise to grab the internal `finalize`\n     * value. Be warned that simpler solutions may appear to compile, but fail at\n     * runtime due to variables not being assigned; make sure to test your code!\n     */\n    let passFinalize;\n    const finalizeP = new Promise((resolve) => {\n        passFinalize = resolve;\n    });\n    const interval = (_a = opts === null || opts === void 0 ? void 0 : opts.interval) !== null && _a !== void 0 ? _a : 3000;\n    const value = (_b = opts === null || opts === void 0 ? void 0 : opts.value) !== null && _b !== void 0 ? _b : \" \";\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises, no-async-promise-executor\n    return new Promise(async (resolve, reject) => {\n        try {\n            const stream = new ReadableStream({\n                start(controller) {\n                    const encoder = new TextEncoder();\n                    const heartbeat = setInterval(() => {\n                        controller.enqueue(encoder.encode(value));\n                    }, interval);\n                    const finalize = (data) => {\n                        clearInterval(heartbeat);\n                        // `data` may be a `Promise`. If it is, we need to wait for it to\n                        // resolve before sending it. To support this elegantly we'll always\n                        // assume it's a promise and handle that case.\n                        void Promise.resolve(data).then((resolvedData) => {\n                            controller.enqueue(encoder.encode((0, strings_js_1.stringify)(resolvedData)));\n                            controller.close();\n                        });\n                    };\n                    passFinalize(finalize);\n                },\n            });\n            resolve({ stream, finalize: await finalizeP });\n        }\n        catch (err) {\n            reject(err);\n        }\n    });\n};\nexports.createStream = createStream;\n//# sourceMappingURL=stream.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL3N0cmVhbS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0I7QUFDcEIscUJBQXFCLG1CQUFPLENBQUMscUVBQWM7QUFDM0M7QUFDQSxjQUFjLHNCQUFzQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2Isc0JBQXNCLG1DQUFtQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLG9CQUFvQjtBQUNwQiIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpdmUtdmliZS1haS1uZXh0Ly4vbm9kZV9tb2R1bGVzL2lubmdlc3QvaGVscGVycy9zdHJlYW0uanM/ZTBkOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlU3RyZWFtID0gdm9pZCAwO1xuY29uc3Qgc3RyaW5nc19qc18xID0gcmVxdWlyZShcIi4vc3RyaW5ncy5qc1wiKTtcbi8qKlxuICogQ3JlYXRlcyBhIHtAbGluayBSZWFkYWJsZVN0cmVhbX0gdGhhdCBzZW5kcyBhIGB2YWx1ZWAgZXZlcnkgYGludGVydmFsYFxuICogbWlsbGlzZWNvbmRzIGFzIGEgaGVhcnRiZWF0LCBpbnRlbmRlZCB0byBrZWVwIGEgc3RyZWFtIG9wZW4uXG4gKlxuICogUmV0dXJucyB0aGUgYHN0cmVhbWAgaXRzZWxmIGFuZCBhIGBmaW5hbGl6ZWAgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0b1xuICogY2xvc2UgdGhlIHN0cmVhbSBhbmQgc2VuZCBhIGZpbmFsIHZhbHVlLlxuICovXG5jb25zdCBjcmVhdGVTdHJlYW0gPSAob3B0cykgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgLyoqXG4gICAgICogV2UgbmVlZCB0byByZXNvbHZlIHRoaXMgcHJvbWlzZSB3aXRoIGJvdGggdGhlIHN0cmVhbSBhbmQgdGhlIGBmaW5hbGl6ZWBcbiAgICAgKiBmdW5jdGlvbiwgYnV0IGhhdmluZyB0aGVtIGJvdGggaW5zdGFudGlhdGVkIHN5bmNocm9ub3VzbHkgaXMgZGlmZmljdWx0LCBhc1xuICAgICAqIHdlIG5lZWQgYWNjZXNzIHRvIHRoZSBzdHJlYW0ncyBpbnRlcm5hbHMgdG9vLlxuICAgICAqXG4gICAgICogV2UgY3JlYXRlIHRoaXMgY2hlZWt5IGRlZmVycmVkIHByb21pc2UgdG8gZ3JhYiB0aGUgaW50ZXJuYWwgYGZpbmFsaXplYFxuICAgICAqIHZhbHVlLiBCZSB3YXJuZWQgdGhhdCBzaW1wbGVyIHNvbHV0aW9ucyBtYXkgYXBwZWFyIHRvIGNvbXBpbGUsIGJ1dCBmYWlsIGF0XG4gICAgICogcnVudGltZSBkdWUgdG8gdmFyaWFibGVzIG5vdCBiZWluZyBhc3NpZ25lZDsgbWFrZSBzdXJlIHRvIHRlc3QgeW91ciBjb2RlIVxuICAgICAqL1xuICAgIGxldCBwYXNzRmluYWxpemU7XG4gICAgY29uc3QgZmluYWxpemVQID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgcGFzc0ZpbmFsaXplID0gcmVzb2x2ZTtcbiAgICB9KTtcbiAgICBjb25zdCBpbnRlcnZhbCA9IChfYSA9IG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5pbnRlcnZhbCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMzAwMDtcbiAgICBjb25zdCB2YWx1ZSA9IChfYiA9IG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy52YWx1ZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogXCIgXCI7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1taXN1c2VkLXByb21pc2VzLCBuby1hc3luYy1wcm9taXNlLWV4ZWN1dG9yXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgICAgICAgICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhlYXJ0YmVhdCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShlbmNvZGVyLmVuY29kZSh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICB9LCBpbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbmFsaXplID0gKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaGVhcnRiZWF0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGBkYXRhYCBtYXkgYmUgYSBgUHJvbWlzZWAuIElmIGl0IGlzLCB3ZSBuZWVkIHRvIHdhaXQgZm9yIGl0IHRvXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZXNvbHZlIGJlZm9yZSBzZW5kaW5nIGl0LiBUbyBzdXBwb3J0IHRoaXMgZWxlZ2FudGx5IHdlJ2xsIGFsd2F5c1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXNzdW1lIGl0J3MgYSBwcm9taXNlIGFuZCBoYW5kbGUgdGhhdCBjYXNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgdm9pZCBQcm9taXNlLnJlc29sdmUoZGF0YSkudGhlbigocmVzb2x2ZWREYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGVuY29kZXIuZW5jb2RlKCgwLCBzdHJpbmdzX2pzXzEuc3RyaW5naWZ5KShyZXNvbHZlZERhdGEpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHBhc3NGaW5hbGl6ZShmaW5hbGl6ZSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVzb2x2ZSh7IHN0cmVhbSwgZmluYWxpemU6IGF3YWl0IGZpbmFsaXplUCB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcbmV4cG9ydHMuY3JlYXRlU3RyZWFtID0gY3JlYXRlU3RyZWFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RyZWFtLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/helpers/stream.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/helpers/strings.js":
/*!*************************************************!*\
  !*** ./node_modules/inngest/helpers/strings.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.hashSigningKey = exports.hashEventKey = exports.stringifyUnknown = exports.timeStr = exports.slugify = exports.stringify = void 0;\nconst hash_js_1 = __webpack_require__(/*! hash.js */ \"(rsc)/./node_modules/hash.js/lib/hash.js\");\nconst json_stringify_safe_1 = __importDefault(__webpack_require__(/*! json-stringify-safe */ \"(rsc)/./node_modules/json-stringify-safe/stringify.js\"));\nconst ms_1 = __importDefault(__webpack_require__(/*! ms */ \"(rsc)/./node_modules/ms/index.js\"));\n/**\n * Safely `JSON.stringify()` an `input`, handling circular refernences and\n * removing `BigInt` values.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst stringify = (input) => {\n    return (0, json_stringify_safe_1.default)(input, (key, value) => {\n        if (typeof value !== \"bigint\") {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n            return value;\n        }\n    });\n};\nexports.stringify = stringify;\n/**\n * Returns a slugified string used to generate consistent IDs.\n *\n * This can be used to generate a consistent ID for a function when migrating\n * from v2 to v3 of the SDK.\n *\n * @public\n */\nconst slugify = (str) => {\n    const join = \"-\";\n    return str\n        .toLowerCase()\n        .replace(/[^a-z0-9-]+/g, join)\n        .replace(/-+/g, join)\n        .split(join)\n        .filter(Boolean)\n        .join(join);\n};\nexports.slugify = slugify;\nconst millisecond = 1;\nconst second = millisecond * 1000;\nconst minute = second * 60;\nconst hour = minute * 60;\nconst day = hour * 24;\nconst week = day * 7;\n/**\n * A collection of periods in milliseconds and their suffixes used when creating\n * time strings.\n */\nconst periods = [\n    [\"w\", week],\n    [\"d\", day],\n    [\"h\", hour],\n    [\"m\", minute],\n    [\"s\", second],\n];\n/**\n * Convert a given `Date`, `number`, or `ms`-compatible `string` to a\n * Inngest sleep-compatible time string (e.g. `\"1d\"` or `\"2h3010s\"`).\n *\n * Can optionally provide a `now` date to use as the base for the calculation,\n * otherwise a new date will be created on invocation.\n */\nconst timeStr = (\n/**\n * The future date to use to convert to a time string.\n */\ninput) => {\n    if (input instanceof Date) {\n        return input.toISOString();\n    }\n    const milliseconds = typeof input === \"string\" ? (0, ms_1.default)(input) : input;\n    const [, timeStr] = periods.reduce(([num, str], [suffix, period]) => {\n        const numPeriods = Math.floor(num / period);\n        if (numPeriods > 0) {\n            return [num % period, `${str}${numPeriods}${suffix}`];\n        }\n        return [num, str];\n    }, [milliseconds, \"\"]);\n    return timeStr;\n};\nexports.timeStr = timeStr;\n/**\n * Given an unknown input, stringify it if it's a boolean, a number, or a\n * string, else return `undefined`.\n */\nconst stringifyUnknown = (input) => {\n    if (typeof input === \"boolean\" ||\n        typeof input === \"number\" ||\n        typeof input === \"string\") {\n        return input.toString();\n    }\n};\nexports.stringifyUnknown = stringifyUnknown;\nconst hashEventKey = (eventKey) => {\n    return (0, hash_js_1.sha256)().update(eventKey).digest(\"hex\");\n};\nexports.hashEventKey = hashEventKey;\nconst hashSigningKey = (signingKey) => {\n    var _a;\n    if (!signingKey) {\n        return \"\";\n    }\n    const prefix = ((_a = signingKey.match(/^signkey-[\\w]+-/)) === null || _a === void 0 ? void 0 : _a.shift()) || \"\";\n    const key = signingKey.replace(/^signkey-[\\w]+-/, \"\");\n    // Decode the key from its hex representation into a bytestream\n    return `${prefix}${(0, hash_js_1.sha256)().update(key, \"hex\").digest(\"hex\")}`;\n};\nexports.hashSigningKey = hashSigningKey;\n//# sourceMappingURL=strings.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL3N0cmluZ3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0IsR0FBRyxvQkFBb0IsR0FBRyx3QkFBd0IsR0FBRyxlQUFlLEdBQUcsZUFBZSxHQUFHLGlCQUFpQjtBQUNoSSxrQkFBa0IsbUJBQU8sQ0FBQyx5REFBUztBQUNuQyw4Q0FBOEMsbUJBQU8sQ0FBQyxrRkFBcUI7QUFDM0UsNkJBQTZCLG1CQUFPLENBQUMsNENBQUk7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLElBQUksRUFBRSxXQUFXLEVBQUUsT0FBTztBQUMvRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTyxFQUFFLHlEQUF5RDtBQUNoRjtBQUNBLHNCQUFzQjtBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpdmUtdmliZS1haS1uZXh0Ly4vbm9kZV9tb2R1bGVzL2lubmdlc3QvaGVscGVycy9zdHJpbmdzLmpzPzc2YzMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmhhc2hTaWduaW5nS2V5ID0gZXhwb3J0cy5oYXNoRXZlbnRLZXkgPSBleHBvcnRzLnN0cmluZ2lmeVVua25vd24gPSBleHBvcnRzLnRpbWVTdHIgPSBleHBvcnRzLnNsdWdpZnkgPSBleHBvcnRzLnN0cmluZ2lmeSA9IHZvaWQgMDtcbmNvbnN0IGhhc2hfanNfMSA9IHJlcXVpcmUoXCJoYXNoLmpzXCIpO1xuY29uc3QganNvbl9zdHJpbmdpZnlfc2FmZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJqc29uLXN0cmluZ2lmeS1zYWZlXCIpKTtcbmNvbnN0IG1zXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIm1zXCIpKTtcbi8qKlxuICogU2FmZWx5IGBKU09OLnN0cmluZ2lmeSgpYCBhbiBgaW5wdXRgLCBoYW5kbGluZyBjaXJjdWxhciByZWZlcm5lbmNlcyBhbmRcbiAqIHJlbW92aW5nIGBCaWdJbnRgIHZhbHVlcy5cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmNvbnN0IHN0cmluZ2lmeSA9IChpbnB1dCkgPT4ge1xuICAgIHJldHVybiAoMCwganNvbl9zdHJpbmdpZnlfc2FmZV8xLmRlZmF1bHQpKGlucHV0LCAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcImJpZ2ludFwiKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm5cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcbmV4cG9ydHMuc3RyaW5naWZ5ID0gc3RyaW5naWZ5O1xuLyoqXG4gKiBSZXR1cm5zIGEgc2x1Z2lmaWVkIHN0cmluZyB1c2VkIHRvIGdlbmVyYXRlIGNvbnNpc3RlbnQgSURzLlxuICpcbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gZ2VuZXJhdGUgYSBjb25zaXN0ZW50IElEIGZvciBhIGZ1bmN0aW9uIHdoZW4gbWlncmF0aW5nXG4gKiBmcm9tIHYyIHRvIHYzIG9mIHRoZSBTREsuXG4gKlxuICogQHB1YmxpY1xuICovXG5jb25zdCBzbHVnaWZ5ID0gKHN0cikgPT4ge1xuICAgIGNvbnN0IGpvaW4gPSBcIi1cIjtcbiAgICByZXR1cm4gc3RyXG4gICAgICAgIC50b0xvd2VyQ2FzZSgpXG4gICAgICAgIC5yZXBsYWNlKC9bXmEtejAtOS1dKy9nLCBqb2luKVxuICAgICAgICAucmVwbGFjZSgvLSsvZywgam9pbilcbiAgICAgICAgLnNwbGl0KGpvaW4pXG4gICAgICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAgICAgLmpvaW4oam9pbik7XG59O1xuZXhwb3J0cy5zbHVnaWZ5ID0gc2x1Z2lmeTtcbmNvbnN0IG1pbGxpc2Vjb25kID0gMTtcbmNvbnN0IHNlY29uZCA9IG1pbGxpc2Vjb25kICogMTAwMDtcbmNvbnN0IG1pbnV0ZSA9IHNlY29uZCAqIDYwO1xuY29uc3QgaG91ciA9IG1pbnV0ZSAqIDYwO1xuY29uc3QgZGF5ID0gaG91ciAqIDI0O1xuY29uc3Qgd2VlayA9IGRheSAqIDc7XG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiBwZXJpb2RzIGluIG1pbGxpc2Vjb25kcyBhbmQgdGhlaXIgc3VmZml4ZXMgdXNlZCB3aGVuIGNyZWF0aW5nXG4gKiB0aW1lIHN0cmluZ3MuXG4gKi9cbmNvbnN0IHBlcmlvZHMgPSBbXG4gICAgW1wid1wiLCB3ZWVrXSxcbiAgICBbXCJkXCIsIGRheV0sXG4gICAgW1wiaFwiLCBob3VyXSxcbiAgICBbXCJtXCIsIG1pbnV0ZV0sXG4gICAgW1wic1wiLCBzZWNvbmRdLFxuXTtcbi8qKlxuICogQ29udmVydCBhIGdpdmVuIGBEYXRlYCwgYG51bWJlcmAsIG9yIGBtc2AtY29tcGF0aWJsZSBgc3RyaW5nYCB0byBhXG4gKiBJbm5nZXN0IHNsZWVwLWNvbXBhdGlibGUgdGltZSBzdHJpbmcgKGUuZy4gYFwiMWRcImAgb3IgYFwiMmgzMDEwc1wiYCkuXG4gKlxuICogQ2FuIG9wdGlvbmFsbHkgcHJvdmlkZSBhIGBub3dgIGRhdGUgdG8gdXNlIGFzIHRoZSBiYXNlIGZvciB0aGUgY2FsY3VsYXRpb24sXG4gKiBvdGhlcndpc2UgYSBuZXcgZGF0ZSB3aWxsIGJlIGNyZWF0ZWQgb24gaW52b2NhdGlvbi5cbiAqL1xuY29uc3QgdGltZVN0ciA9IChcbi8qKlxuICogVGhlIGZ1dHVyZSBkYXRlIHRvIHVzZSB0byBjb252ZXJ0IHRvIGEgdGltZSBzdHJpbmcuXG4gKi9cbmlucHV0KSA9PiB7XG4gICAgaWYgKGlucHV0IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gaW5wdXQudG9JU09TdHJpbmcoKTtcbiAgICB9XG4gICAgY29uc3QgbWlsbGlzZWNvbmRzID0gdHlwZW9mIGlucHV0ID09PSBcInN0cmluZ1wiID8gKDAsIG1zXzEuZGVmYXVsdCkoaW5wdXQpIDogaW5wdXQ7XG4gICAgY29uc3QgWywgdGltZVN0cl0gPSBwZXJpb2RzLnJlZHVjZSgoW251bSwgc3RyXSwgW3N1ZmZpeCwgcGVyaW9kXSkgPT4ge1xuICAgICAgICBjb25zdCBudW1QZXJpb2RzID0gTWF0aC5mbG9vcihudW0gLyBwZXJpb2QpO1xuICAgICAgICBpZiAobnVtUGVyaW9kcyA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbbnVtICUgcGVyaW9kLCBgJHtzdHJ9JHtudW1QZXJpb2RzfSR7c3VmZml4fWBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbbnVtLCBzdHJdO1xuICAgIH0sIFttaWxsaXNlY29uZHMsIFwiXCJdKTtcbiAgICByZXR1cm4gdGltZVN0cjtcbn07XG5leHBvcnRzLnRpbWVTdHIgPSB0aW1lU3RyO1xuLyoqXG4gKiBHaXZlbiBhbiB1bmtub3duIGlucHV0LCBzdHJpbmdpZnkgaXQgaWYgaXQncyBhIGJvb2xlYW4sIGEgbnVtYmVyLCBvciBhXG4gKiBzdHJpbmcsIGVsc2UgcmV0dXJuIGB1bmRlZmluZWRgLlxuICovXG5jb25zdCBzdHJpbmdpZnlVbmtub3duID0gKGlucHV0KSA9PiB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJib29sZWFuXCIgfHxcbiAgICAgICAgdHlwZW9mIGlucHV0ID09PSBcIm51bWJlclwiIHx8XG4gICAgICAgIHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gaW5wdXQudG9TdHJpbmcoKTtcbiAgICB9XG59O1xuZXhwb3J0cy5zdHJpbmdpZnlVbmtub3duID0gc3RyaW5naWZ5VW5rbm93bjtcbmNvbnN0IGhhc2hFdmVudEtleSA9IChldmVudEtleSkgPT4ge1xuICAgIHJldHVybiAoMCwgaGFzaF9qc18xLnNoYTI1NikoKS51cGRhdGUoZXZlbnRLZXkpLmRpZ2VzdChcImhleFwiKTtcbn07XG5leHBvcnRzLmhhc2hFdmVudEtleSA9IGhhc2hFdmVudEtleTtcbmNvbnN0IGhhc2hTaWduaW5nS2V5ID0gKHNpZ25pbmdLZXkpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCFzaWduaW5nS2V5KSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICBjb25zdCBwcmVmaXggPSAoKF9hID0gc2lnbmluZ0tleS5tYXRjaCgvXnNpZ25rZXktW1xcd10rLS8pKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2hpZnQoKSkgfHwgXCJcIjtcbiAgICBjb25zdCBrZXkgPSBzaWduaW5nS2V5LnJlcGxhY2UoL15zaWdua2V5LVtcXHddKy0vLCBcIlwiKTtcbiAgICAvLyBEZWNvZGUgdGhlIGtleSBmcm9tIGl0cyBoZXggcmVwcmVzZW50YXRpb24gaW50byBhIGJ5dGVzdHJlYW1cbiAgICByZXR1cm4gYCR7cHJlZml4fSR7KDAsIGhhc2hfanNfMS5zaGEyNTYpKCkudXBkYXRlKGtleSwgXCJoZXhcIikuZGlnZXN0KFwiaGV4XCIpfWA7XG59O1xuZXhwb3J0cy5oYXNoU2lnbmluZ0tleSA9IGhhc2hTaWduaW5nS2V5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RyaW5ncy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/helpers/strings.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/helpers/temporal.js":
/*!**************************************************!*\
  !*** ./node_modules/inngest/helpers/temporal.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getISOString = exports.isTemporalZonedDateTime = exports.isTemporalInstant = exports.isTemporalDuration = void 0;\n/**\n * Asserts that the given `input` is a `Temporal.Duration` object.\n */\nconst isTemporalDuration = (\n/**\n * The input to check.\n */\ninput) => {\n    try {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access\n        return input[Symbol.toStringTag] === \"Temporal.Duration\";\n    }\n    catch (_a) {\n        return false;\n    }\n};\nexports.isTemporalDuration = isTemporalDuration;\n/**\n * Asserts that the given `input` is a `Temporal.TimeZone` object.\n */\nconst isTemporalInstant = (\n/**\n * The input to check.\n */\ninput) => {\n    try {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access\n        return input[Symbol.toStringTag] === \"Temporal.Instant\";\n    }\n    catch (_a) {\n        return false;\n    }\n};\nexports.isTemporalInstant = isTemporalInstant;\n/**\n * Asserts that the given `input` is a `Temporal.ZonedDateTime` object.\n */\nconst isTemporalZonedDateTime = (\n/**\n * The input to check.\n */\ninput) => {\n    try {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access\n        return input[Symbol.toStringTag] === \"Temporal.ZonedDateTime\";\n    }\n    catch (_a) {\n        return false;\n    }\n};\nexports.isTemporalZonedDateTime = isTemporalZonedDateTime;\n/**\n * Converts a given `Date`, `string`, `Temporal.Instant`, or\n * `Temporal.ZonedDateTime` to an ISO 8601 string.\n */\nconst getISOString = (time) => {\n    if (typeof time === \"string\") {\n        return new Date(time).toISOString();\n    }\n    if (time instanceof Date) {\n        return time.toISOString();\n    }\n    if ((0, exports.isTemporalZonedDateTime)(time)) {\n        return time.toInstant().toString();\n    }\n    if ((0, exports.isTemporalInstant)(time)) {\n        return time.toString();\n    }\n    throw new TypeError(\"Invalid date input\");\n};\nexports.getISOString = getISOString;\n//# sourceMappingURL=temporal.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL3RlbXBvcmFsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQixHQUFHLCtCQUErQixHQUFHLHlCQUF5QixHQUFHLDBCQUEwQjtBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQiIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpdmUtdmliZS1haS1uZXh0Ly4vbm9kZV9tb2R1bGVzL2lubmdlc3QvaGVscGVycy90ZW1wb3JhbC5qcz8yMWQ1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRJU09TdHJpbmcgPSBleHBvcnRzLmlzVGVtcG9yYWxab25lZERhdGVUaW1lID0gZXhwb3J0cy5pc1RlbXBvcmFsSW5zdGFudCA9IGV4cG9ydHMuaXNUZW1wb3JhbER1cmF0aW9uID0gdm9pZCAwO1xuLyoqXG4gKiBBc3NlcnRzIHRoYXQgdGhlIGdpdmVuIGBpbnB1dGAgaXMgYSBgVGVtcG9yYWwuRHVyYXRpb25gIG9iamVjdC5cbiAqL1xuY29uc3QgaXNUZW1wb3JhbER1cmF0aW9uID0gKFxuLyoqXG4gKiBUaGUgaW5wdXQgdG8gY2hlY2suXG4gKi9cbmlucHV0KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnksIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgICAgICByZXR1cm4gaW5wdXRbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gXCJUZW1wb3JhbC5EdXJhdGlvblwiO1xuICAgIH1cbiAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn07XG5leHBvcnRzLmlzVGVtcG9yYWxEdXJhdGlvbiA9IGlzVGVtcG9yYWxEdXJhdGlvbjtcbi8qKlxuICogQXNzZXJ0cyB0aGF0IHRoZSBnaXZlbiBgaW5wdXRgIGlzIGEgYFRlbXBvcmFsLlRpbWVab25lYCBvYmplY3QuXG4gKi9cbmNvbnN0IGlzVGVtcG9yYWxJbnN0YW50ID0gKFxuLyoqXG4gKiBUaGUgaW5wdXQgdG8gY2hlY2suXG4gKi9cbmlucHV0KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnksIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgICAgICByZXR1cm4gaW5wdXRbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gXCJUZW1wb3JhbC5JbnN0YW50XCI7XG4gICAgfVxuICAgIGNhdGNoIChfYSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcbmV4cG9ydHMuaXNUZW1wb3JhbEluc3RhbnQgPSBpc1RlbXBvcmFsSW5zdGFudDtcbi8qKlxuICogQXNzZXJ0cyB0aGF0IHRoZSBnaXZlbiBgaW5wdXRgIGlzIGEgYFRlbXBvcmFsLlpvbmVkRGF0ZVRpbWVgIG9iamVjdC5cbiAqL1xuY29uc3QgaXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUgPSAoXG4vKipcbiAqIFRoZSBpbnB1dCB0byBjaGVjay5cbiAqL1xuaW5wdXQpID0+IHtcbiAgICB0cnkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSwgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXG4gICAgICAgIHJldHVybiBpbnB1dFtTeW1ib2wudG9TdHJpbmdUYWddID09PSBcIlRlbXBvcmFsLlpvbmVkRGF0ZVRpbWVcIjtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuZXhwb3J0cy5pc1RlbXBvcmFsWm9uZWREYXRlVGltZSA9IGlzVGVtcG9yYWxab25lZERhdGVUaW1lO1xuLyoqXG4gKiBDb252ZXJ0cyBhIGdpdmVuIGBEYXRlYCwgYHN0cmluZ2AsIGBUZW1wb3JhbC5JbnN0YW50YCwgb3JcbiAqIGBUZW1wb3JhbC5ab25lZERhdGVUaW1lYCB0byBhbiBJU08gODYwMSBzdHJpbmcuXG4gKi9cbmNvbnN0IGdldElTT1N0cmluZyA9ICh0aW1lKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB0aW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aW1lKS50b0lTT1N0cmluZygpO1xuICAgIH1cbiAgICBpZiAodGltZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRpbWUudG9JU09TdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKCgwLCBleHBvcnRzLmlzVGVtcG9yYWxab25lZERhdGVUaW1lKSh0aW1lKSkge1xuICAgICAgICByZXR1cm4gdGltZS50b0luc3RhbnQoKS50b1N0cmluZygpO1xuICAgIH1cbiAgICBpZiAoKDAsIGV4cG9ydHMuaXNUZW1wb3JhbEluc3RhbnQpKHRpbWUpKSB7XG4gICAgICAgIHJldHVybiB0aW1lLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGRhdGUgaW5wdXRcIik7XG59O1xuZXhwb3J0cy5nZXRJU09TdHJpbmcgPSBnZXRJU09TdHJpbmc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZW1wb3JhbC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/helpers/temporal.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/index.js":
/*!***************************************!*\
  !*** ./node_modules/inngest/index.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/**\n * The primary entrypoint for the Inngest SDK. This provides all the necessary\n * exports to create, run, and trigger Inngest functions.\n *\n * Typical usage involves creating a new Inngest client with `Inngest`, and then\n * using the client to create functions, middleware, and other tools.\n *\n * See {@link https://www.inngest.com/docs} for more information.\n *\n * @example Create an Inngest client\n * ```ts\n * const inngest = new Inngest({\n *   id: \"my-app-id\",\n * });\n * ```\n *\n * @example Create an Inngest function\n * ```ts\n * const myFn = inngest.createFunction({\n *  id: \"my-function\",\n * }, {\n *   event: \"user/created\",\n * }, async ({ event, step }) => {\n *   console.log(\"User created:\", event.data);\n * });\n * ```\n *\n * @example Send an event\n * ```ts\n * await inngest.send({\n *   name: \"user/created\",\n *   data: {\n *     id: \"123\",\n *   },\n * });\n * ```\n *\n * @module\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.version = exports.ProxyLogger = exports.dependencyInjectionMiddleware = exports.slugify = exports.queryKeys = exports.internalEvents = exports.headerKeys = exports.StepError = exports.RetryAfterError = exports.NonRetriableError = exports.InngestMiddleware = exports.referenceFunction = exports.InngestCommHandler = exports.Inngest = exports.EventSchemas = void 0;\n__exportStar(__webpack_require__(/*! @inngest/ai */ \"(rsc)/./node_modules/@inngest/ai/dist/index.js\"), exports);\nvar EventSchemas_js_1 = __webpack_require__(/*! ./components/EventSchemas.js */ \"(rsc)/./node_modules/inngest/components/EventSchemas.js\");\nObject.defineProperty(exports, \"EventSchemas\", ({ enumerable: true, get: function () { return EventSchemas_js_1.EventSchemas; } }));\nvar Fetch_js_1 = __webpack_require__(/*! ./components/Fetch.js */ \"(rsc)/./node_modules/inngest/components/Fetch.js\");\nObject.defineProperty(exports, \"fetch\", ({ enumerable: true, get: function () { return Fetch_js_1.fetch; } }));\nvar Inngest_js_1 = __webpack_require__(/*! ./components/Inngest.js */ \"(rsc)/./node_modules/inngest/components/Inngest.js\");\nObject.defineProperty(exports, \"Inngest\", ({ enumerable: true, get: function () { return Inngest_js_1.Inngest; } }));\nvar InngestCommHandler_js_1 = __webpack_require__(/*! ./components/InngestCommHandler.js */ \"(rsc)/./node_modules/inngest/components/InngestCommHandler.js\");\nObject.defineProperty(exports, \"InngestCommHandler\", ({ enumerable: true, get: function () { return InngestCommHandler_js_1.InngestCommHandler; } }));\nvar InngestFunctionReference_js_1 = __webpack_require__(/*! ./components/InngestFunctionReference.js */ \"(rsc)/./node_modules/inngest/components/InngestFunctionReference.js\");\nObject.defineProperty(exports, \"referenceFunction\", ({ enumerable: true, get: function () { return InngestFunctionReference_js_1.referenceFunction; } }));\nvar InngestMiddleware_js_1 = __webpack_require__(/*! ./components/InngestMiddleware.js */ \"(rsc)/./node_modules/inngest/components/InngestMiddleware.js\");\nObject.defineProperty(exports, \"InngestMiddleware\", ({ enumerable: true, get: function () { return InngestMiddleware_js_1.InngestMiddleware; } }));\nvar NonRetriableError_js_1 = __webpack_require__(/*! ./components/NonRetriableError.js */ \"(rsc)/./node_modules/inngest/components/NonRetriableError.js\");\nObject.defineProperty(exports, \"NonRetriableError\", ({ enumerable: true, get: function () { return NonRetriableError_js_1.NonRetriableError; } }));\nvar RetryAfterError_js_1 = __webpack_require__(/*! ./components/RetryAfterError.js */ \"(rsc)/./node_modules/inngest/components/RetryAfterError.js\");\nObject.defineProperty(exports, \"RetryAfterError\", ({ enumerable: true, get: function () { return RetryAfterError_js_1.RetryAfterError; } }));\nvar StepError_js_1 = __webpack_require__(/*! ./components/StepError.js */ \"(rsc)/./node_modules/inngest/components/StepError.js\");\nObject.defineProperty(exports, \"StepError\", ({ enumerable: true, get: function () { return StepError_js_1.StepError; } }));\nvar consts_js_1 = __webpack_require__(/*! ./helpers/consts.js */ \"(rsc)/./node_modules/inngest/helpers/consts.js\");\nObject.defineProperty(exports, \"headerKeys\", ({ enumerable: true, get: function () { return consts_js_1.headerKeys; } }));\nObject.defineProperty(exports, \"internalEvents\", ({ enumerable: true, get: function () { return consts_js_1.internalEvents; } }));\nObject.defineProperty(exports, \"queryKeys\", ({ enumerable: true, get: function () { return consts_js_1.queryKeys; } }));\nvar strings_js_1 = __webpack_require__(/*! ./helpers/strings.js */ \"(rsc)/./node_modules/inngest/helpers/strings.js\");\nObject.defineProperty(exports, \"slugify\", ({ enumerable: true, get: function () { return strings_js_1.slugify; } }));\nvar dependencyInjection_js_1 = __webpack_require__(/*! ./middleware/dependencyInjection.js */ \"(rsc)/./node_modules/inngest/middleware/dependencyInjection.js\");\nObject.defineProperty(exports, \"dependencyInjectionMiddleware\", ({ enumerable: true, get: function () { return dependencyInjection_js_1.dependencyInjectionMiddleware; } }));\nvar logger_js_1 = __webpack_require__(/*! ./middleware/logger.js */ \"(rsc)/./node_modules/inngest/middleware/logger.js\");\nObject.defineProperty(exports, \"ProxyLogger\", ({ enumerable: true, get: function () { return logger_js_1.ProxyLogger; } }));\nvar version_js_1 = __webpack_require__(/*! ./version.js */ \"(rsc)/./node_modules/inngest/version.js\");\nObject.defineProperty(exports, \"version\", ({ enumerable: true, get: function () { return version_js_1.version; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvQ0FBb0M7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJLFdBQVcsYUFBYTtBQUM1QjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlLEdBQUcsbUJBQW1CLEdBQUcscUNBQXFDLEdBQUcsZUFBZSxHQUFHLGlCQUFpQixHQUFHLHNCQUFzQixHQUFHLGtCQUFrQixHQUFHLGlCQUFpQixHQUFHLHVCQUF1QixHQUFHLHlCQUF5QixHQUFHLHlCQUF5QixHQUFHLHlCQUF5QixHQUFHLDBCQUEwQixHQUFHLGVBQWUsR0FBRyxvQkFBb0I7QUFDelcsYUFBYSxtQkFBTyxDQUFDLG1FQUFhO0FBQ2xDLHdCQUF3QixtQkFBTyxDQUFDLDZGQUE4QjtBQUM5RCxnREFBK0MsRUFBRSxxQ0FBcUMsMENBQTBDLEVBQUM7QUFDakksaUJBQWlCLG1CQUFPLENBQUMsK0VBQXVCO0FBQ2hELHlDQUF3QyxFQUFFLHFDQUFxQyw0QkFBNEIsRUFBQztBQUM1RyxtQkFBbUIsbUJBQU8sQ0FBQyxtRkFBeUI7QUFDcEQsMkNBQTBDLEVBQUUscUNBQXFDLGdDQUFnQyxFQUFDO0FBQ2xILDhCQUE4QixtQkFBTyxDQUFDLHlHQUFvQztBQUMxRSxzREFBcUQsRUFBRSxxQ0FBcUMsc0RBQXNELEVBQUM7QUFDbkosb0NBQW9DLG1CQUFPLENBQUMscUhBQTBDO0FBQ3RGLHFEQUFvRCxFQUFFLHFDQUFxQywyREFBMkQsRUFBQztBQUN2Siw2QkFBNkIsbUJBQU8sQ0FBQyx1R0FBbUM7QUFDeEUscURBQW9ELEVBQUUscUNBQXFDLG9EQUFvRCxFQUFDO0FBQ2hKLDZCQUE2QixtQkFBTyxDQUFDLHVHQUFtQztBQUN4RSxxREFBb0QsRUFBRSxxQ0FBcUMsb0RBQW9ELEVBQUM7QUFDaEosMkJBQTJCLG1CQUFPLENBQUMsbUdBQWlDO0FBQ3BFLG1EQUFrRCxFQUFFLHFDQUFxQyxnREFBZ0QsRUFBQztBQUMxSSxxQkFBcUIsbUJBQU8sQ0FBQyx1RkFBMkI7QUFDeEQsNkNBQTRDLEVBQUUscUNBQXFDLG9DQUFvQyxFQUFDO0FBQ3hILGtCQUFrQixtQkFBTyxDQUFDLDJFQUFxQjtBQUMvQyw4Q0FBNkMsRUFBRSxxQ0FBcUMsa0NBQWtDLEVBQUM7QUFDdkgsa0RBQWlELEVBQUUscUNBQXFDLHNDQUFzQyxFQUFDO0FBQy9ILDZDQUE0QyxFQUFFLHFDQUFxQyxpQ0FBaUMsRUFBQztBQUNySCxtQkFBbUIsbUJBQU8sQ0FBQyw2RUFBc0I7QUFDakQsMkNBQTBDLEVBQUUscUNBQXFDLGdDQUFnQyxFQUFDO0FBQ2xILCtCQUErQixtQkFBTyxDQUFDLDJHQUFxQztBQUM1RSxpRUFBZ0UsRUFBRSxxQ0FBcUMsa0VBQWtFLEVBQUM7QUFDMUssa0JBQWtCLG1CQUFPLENBQUMsaUZBQXdCO0FBQ2xELCtDQUE4QyxFQUFFLHFDQUFxQyxtQ0FBbUMsRUFBQztBQUN6SCxtQkFBbUIsbUJBQU8sQ0FBQyw2REFBYztBQUN6QywyQ0FBMEMsRUFBRSxxQ0FBcUMsZ0NBQWdDLEVBQUM7QUFDbEgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aXZlLXZpYmUtYWktbmV4dC8uL25vZGVfbW9kdWxlcy9pbm5nZXN0L2luZGV4LmpzP2JlYzIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIFRoZSBwcmltYXJ5IGVudHJ5cG9pbnQgZm9yIHRoZSBJbm5nZXN0IFNESy4gVGhpcyBwcm92aWRlcyBhbGwgdGhlIG5lY2Vzc2FyeVxuICogZXhwb3J0cyB0byBjcmVhdGUsIHJ1biwgYW5kIHRyaWdnZXIgSW5uZ2VzdCBmdW5jdGlvbnMuXG4gKlxuICogVHlwaWNhbCB1c2FnZSBpbnZvbHZlcyBjcmVhdGluZyBhIG5ldyBJbm5nZXN0IGNsaWVudCB3aXRoIGBJbm5nZXN0YCwgYW5kIHRoZW5cbiAqIHVzaW5nIHRoZSBjbGllbnQgdG8gY3JlYXRlIGZ1bmN0aW9ucywgbWlkZGxld2FyZSwgYW5kIG90aGVyIHRvb2xzLlxuICpcbiAqIFNlZSB7QGxpbmsgaHR0cHM6Ly93d3cuaW5uZ2VzdC5jb20vZG9jc30gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQGV4YW1wbGUgQ3JlYXRlIGFuIElubmdlc3QgY2xpZW50XG4gKiBgYGB0c1xuICogY29uc3QgaW5uZ2VzdCA9IG5ldyBJbm5nZXN0KHtcbiAqICAgaWQ6IFwibXktYXBwLWlkXCIsXG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlIENyZWF0ZSBhbiBJbm5nZXN0IGZ1bmN0aW9uXG4gKiBgYGB0c1xuICogY29uc3QgbXlGbiA9IGlubmdlc3QuY3JlYXRlRnVuY3Rpb24oe1xuICogIGlkOiBcIm15LWZ1bmN0aW9uXCIsXG4gKiB9LCB7XG4gKiAgIGV2ZW50OiBcInVzZXIvY3JlYXRlZFwiLFxuICogfSwgYXN5bmMgKHsgZXZlbnQsIHN0ZXAgfSkgPT4ge1xuICogICBjb25zb2xlLmxvZyhcIlVzZXIgY3JlYXRlZDpcIiwgZXZlbnQuZGF0YSk7XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlIFNlbmQgYW4gZXZlbnRcbiAqIGBgYHRzXG4gKiBhd2FpdCBpbm5nZXN0LnNlbmQoe1xuICogICBuYW1lOiBcInVzZXIvY3JlYXRlZFwiLFxuICogICBkYXRhOiB7XG4gKiAgICAgaWQ6IFwiMTIzXCIsXG4gKiAgIH0sXG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEBtb2R1bGVcbiAqL1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZlcnNpb24gPSBleHBvcnRzLlByb3h5TG9nZ2VyID0gZXhwb3J0cy5kZXBlbmRlbmN5SW5qZWN0aW9uTWlkZGxld2FyZSA9IGV4cG9ydHMuc2x1Z2lmeSA9IGV4cG9ydHMucXVlcnlLZXlzID0gZXhwb3J0cy5pbnRlcm5hbEV2ZW50cyA9IGV4cG9ydHMuaGVhZGVyS2V5cyA9IGV4cG9ydHMuU3RlcEVycm9yID0gZXhwb3J0cy5SZXRyeUFmdGVyRXJyb3IgPSBleHBvcnRzLk5vblJldHJpYWJsZUVycm9yID0gZXhwb3J0cy5Jbm5nZXN0TWlkZGxld2FyZSA9IGV4cG9ydHMucmVmZXJlbmNlRnVuY3Rpb24gPSBleHBvcnRzLklubmdlc3RDb21tSGFuZGxlciA9IGV4cG9ydHMuSW5uZ2VzdCA9IGV4cG9ydHMuRXZlbnRTY2hlbWFzID0gdm9pZCAwO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCJAaW5uZ2VzdC9haVwiKSwgZXhwb3J0cyk7XG52YXIgRXZlbnRTY2hlbWFzX2pzXzEgPSByZXF1aXJlKFwiLi9jb21wb25lbnRzL0V2ZW50U2NoZW1hcy5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkV2ZW50U2NoZW1hc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gRXZlbnRTY2hlbWFzX2pzXzEuRXZlbnRTY2hlbWFzOyB9IH0pO1xudmFyIEZldGNoX2pzXzEgPSByZXF1aXJlKFwiLi9jb21wb25lbnRzL0ZldGNoLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZmV0Y2hcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEZldGNoX2pzXzEuZmV0Y2g7IH0gfSk7XG52YXIgSW5uZ2VzdF9qc18xID0gcmVxdWlyZShcIi4vY29tcG9uZW50cy9Jbm5nZXN0LmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW5uZ2VzdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gSW5uZ2VzdF9qc18xLklubmdlc3Q7IH0gfSk7XG52YXIgSW5uZ2VzdENvbW1IYW5kbGVyX2pzXzEgPSByZXF1aXJlKFwiLi9jb21wb25lbnRzL0lubmdlc3RDb21tSGFuZGxlci5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIklubmdlc3RDb21tSGFuZGxlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gSW5uZ2VzdENvbW1IYW5kbGVyX2pzXzEuSW5uZ2VzdENvbW1IYW5kbGVyOyB9IH0pO1xudmFyIElubmdlc3RGdW5jdGlvblJlZmVyZW5jZV9qc18xID0gcmVxdWlyZShcIi4vY29tcG9uZW50cy9Jbm5nZXN0RnVuY3Rpb25SZWZlcmVuY2UuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyZWZlcmVuY2VGdW5jdGlvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gSW5uZ2VzdEZ1bmN0aW9uUmVmZXJlbmNlX2pzXzEucmVmZXJlbmNlRnVuY3Rpb247IH0gfSk7XG52YXIgSW5uZ2VzdE1pZGRsZXdhcmVfanNfMSA9IHJlcXVpcmUoXCIuL2NvbXBvbmVudHMvSW5uZ2VzdE1pZGRsZXdhcmUuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbm5nZXN0TWlkZGxld2FyZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gSW5uZ2VzdE1pZGRsZXdhcmVfanNfMS5Jbm5nZXN0TWlkZGxld2FyZTsgfSB9KTtcbnZhciBOb25SZXRyaWFibGVFcnJvcl9qc18xID0gcmVxdWlyZShcIi4vY29tcG9uZW50cy9Ob25SZXRyaWFibGVFcnJvci5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vblJldHJpYWJsZUVycm9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBOb25SZXRyaWFibGVFcnJvcl9qc18xLk5vblJldHJpYWJsZUVycm9yOyB9IH0pO1xudmFyIFJldHJ5QWZ0ZXJFcnJvcl9qc18xID0gcmVxdWlyZShcIi4vY29tcG9uZW50cy9SZXRyeUFmdGVyRXJyb3IuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSZXRyeUFmdGVyRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFJldHJ5QWZ0ZXJFcnJvcl9qc18xLlJldHJ5QWZ0ZXJFcnJvcjsgfSB9KTtcbnZhciBTdGVwRXJyb3JfanNfMSA9IHJlcXVpcmUoXCIuL2NvbXBvbmVudHMvU3RlcEVycm9yLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU3RlcEVycm9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBTdGVwRXJyb3JfanNfMS5TdGVwRXJyb3I7IH0gfSk7XG52YXIgY29uc3RzX2pzXzEgPSByZXF1aXJlKFwiLi9oZWxwZXJzL2NvbnN0cy5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImhlYWRlcktleXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnN0c19qc18xLmhlYWRlcktleXM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpbnRlcm5hbEV2ZW50c1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uc3RzX2pzXzEuaW50ZXJuYWxFdmVudHM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJxdWVyeUtleXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnN0c19qc18xLnF1ZXJ5S2V5czsgfSB9KTtcbnZhciBzdHJpbmdzX2pzXzEgPSByZXF1aXJlKFwiLi9oZWxwZXJzL3N0cmluZ3MuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzbHVnaWZ5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdHJpbmdzX2pzXzEuc2x1Z2lmeTsgfSB9KTtcbnZhciBkZXBlbmRlbmN5SW5qZWN0aW9uX2pzXzEgPSByZXF1aXJlKFwiLi9taWRkbGV3YXJlL2RlcGVuZGVuY3lJbmplY3Rpb24uanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZXBlbmRlbmN5SW5qZWN0aW9uTWlkZGxld2FyZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVwZW5kZW5jeUluamVjdGlvbl9qc18xLmRlcGVuZGVuY3lJbmplY3Rpb25NaWRkbGV3YXJlOyB9IH0pO1xudmFyIGxvZ2dlcl9qc18xID0gcmVxdWlyZShcIi4vbWlkZGxld2FyZS9sb2dnZXIuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQcm94eUxvZ2dlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbG9nZ2VyX2pzXzEuUHJveHlMb2dnZXI7IH0gfSk7XG52YXIgdmVyc2lvbl9qc18xID0gcmVxdWlyZShcIi4vdmVyc2lvbi5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInZlcnNpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZlcnNpb25fanNfMS52ZXJzaW9uOyB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/middleware/dependencyInjection.js":
/*!****************************************************************!*\
  !*** ./node_modules/inngest/middleware/dependencyInjection.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.dependencyInjectionMiddleware = void 0;\nconst InngestMiddleware_js_1 = __webpack_require__(/*! ../components/InngestMiddleware.js */ \"(rsc)/./node_modules/inngest/components/InngestMiddleware.js\");\n/**\n * Adds properties to the function input for every function created using this\n * app.\n */\n// We can use `const` here yet due to TS constraints.\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst dependencyInjectionMiddleware = (\n/**\n * The context to inject into the function input.\n */\nctx) => {\n    return new InngestMiddleware_js_1.InngestMiddleware({\n        name: \"Inngest: Dependency Injection\",\n        init() {\n            return {\n                onFunctionRun() {\n                    return {\n                        transformInput() {\n                            return {\n                                ctx,\n                            };\n                        },\n                    };\n                },\n            };\n        },\n    });\n};\nexports.dependencyInjectionMiddleware = dependencyInjectionMiddleware;\n//# sourceMappingURL=dependencyInjection.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9taWRkbGV3YXJlL2RlcGVuZGVuY3lJbmplY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUNBQXFDO0FBQ3JDLCtCQUErQixtQkFBTyxDQUFDLHdHQUFvQztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0EscUNBQXFDO0FBQ3JDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdml2ZS12aWJlLWFpLW5leHQvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9taWRkbGV3YXJlL2RlcGVuZGVuY3lJbmplY3Rpb24uanM/YjdjZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVwZW5kZW5jeUluamVjdGlvbk1pZGRsZXdhcmUgPSB2b2lkIDA7XG5jb25zdCBJbm5nZXN0TWlkZGxld2FyZV9qc18xID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudHMvSW5uZ2VzdE1pZGRsZXdhcmUuanNcIik7XG4vKipcbiAqIEFkZHMgcHJvcGVydGllcyB0byB0aGUgZnVuY3Rpb24gaW5wdXQgZm9yIGV2ZXJ5IGZ1bmN0aW9uIGNyZWF0ZWQgdXNpbmcgdGhpc1xuICogYXBwLlxuICovXG4vLyBXZSBjYW4gdXNlIGBjb25zdGAgaGVyZSB5ZXQgZHVlIHRvIFRTIGNvbnN0cmFpbnRzLlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmNvbnN0IGRlcGVuZGVuY3lJbmplY3Rpb25NaWRkbGV3YXJlID0gKFxuLyoqXG4gKiBUaGUgY29udGV4dCB0byBpbmplY3QgaW50byB0aGUgZnVuY3Rpb24gaW5wdXQuXG4gKi9cbmN0eCkgPT4ge1xuICAgIHJldHVybiBuZXcgSW5uZ2VzdE1pZGRsZXdhcmVfanNfMS5Jbm5nZXN0TWlkZGxld2FyZSh7XG4gICAgICAgIG5hbWU6IFwiSW5uZ2VzdDogRGVwZW5kZW5jeSBJbmplY3Rpb25cIixcbiAgICAgICAgaW5pdCgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgb25GdW5jdGlvblJ1bigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybUlucHV0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn07XG5leHBvcnRzLmRlcGVuZGVuY3lJbmplY3Rpb25NaWRkbGV3YXJlID0gZGVwZW5kZW5jeUluamVjdGlvbk1pZGRsZXdhcmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZXBlbmRlbmN5SW5qZWN0aW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/middleware/dependencyInjection.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/middleware/logger.js":
/*!***************************************************!*\
  !*** ./node_modules/inngest/middleware/logger.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ProxyLogger = exports.DefaultLogger = void 0;\nclass DefaultLogger {\n    info(...args) {\n        console.info(...args);\n    }\n    warn(...args) {\n        console.warn(...args);\n    }\n    error(...args) {\n        console.error(...args);\n    }\n    debug(...args) {\n        console.debug(...args);\n    }\n}\nexports.DefaultLogger = DefaultLogger;\n/**\n * ProxyLogger aims to provide a thin wrapper on user's provided logger.\n * It's expected to be turned on and off based on the function execution\n * context, so it doesn't result in duplicated logging.\n *\n * And also attempt to allow enough time for the logger to flush all logs.\n *\n * @public\n */\nclass ProxyLogger {\n    constructor(logger) {\n        this.enabled = false;\n        this.logger = logger;\n        // Return a Proxy to forward arbitrary property access to the underlying\n        // logger. For example, if the user provides a logger that has a `foo`\n        // method, they can call `foo` on the ProxyLogger and it will call the\n        // underlying logger's `foo` method.\n        return new Proxy(this, {\n            get(target, prop, receiver) {\n                // Handle ProxyLogger's own methods/properties.\n                if (prop in target) {\n                    return Reflect.get(target, prop, receiver);\n                }\n                // Forward property access to the underlying logger.\n                return Reflect.get(target.logger, prop, receiver);\n            },\n        });\n    }\n    info(...args) {\n        if (!this.enabled)\n            return;\n        this.logger.info(...args);\n    }\n    warn(...args) {\n        if (!this.enabled)\n            return;\n        this.logger.warn(...args);\n    }\n    error(...args) {\n        if (!this.enabled)\n            return;\n        this.logger.error(...args);\n    }\n    debug(...args) {\n        // there are loggers that don't implement \"debug\" by default\n        if (!this.enabled || !(typeof this.logger.debug === \"function\"))\n            return;\n        this.logger.debug(...args);\n    }\n    enable() {\n        this.enabled = true;\n    }\n    disable() {\n        this.enabled = false;\n    }\n    async flush() {\n        // Allow 1s for the provided logger to handle flushing since the ones that do\n        // flushing usually has some kind of timeout of up to 1s.\n        //\n        // TODO:\n        // This should only happen when using a serverless environment because it's very\n        // costly from the compute perspective.\n        // server runtimes should just let the logger do their thing since most of them\n        // should have already figured what to do in those environments, be it threading or\n        // something else.\n        if (this.logger.constructor.name !== DefaultLogger.name) {\n            await new Promise((resolve) => {\n                setTimeout(() => resolve(null), 1000);\n            });\n        }\n    }\n}\nexports.ProxyLogger = ProxyLogger;\n//# sourceMappingURL=logger.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9taWRkbGV3YXJlL2xvZ2dlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUIsR0FBRyxxQkFBcUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aXZlLXZpYmUtYWktbmV4dC8uL25vZGVfbW9kdWxlcy9pbm5nZXN0L21pZGRsZXdhcmUvbG9nZ2VyLmpzPzIwYWYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlByb3h5TG9nZ2VyID0gZXhwb3J0cy5EZWZhdWx0TG9nZ2VyID0gdm9pZCAwO1xuY2xhc3MgRGVmYXVsdExvZ2dlciB7XG4gICAgaW5mbyguLi5hcmdzKSB7XG4gICAgICAgIGNvbnNvbGUuaW5mbyguLi5hcmdzKTtcbiAgICB9XG4gICAgd2FybiguLi5hcmdzKSB7XG4gICAgICAgIGNvbnNvbGUud2FybiguLi5hcmdzKTtcbiAgICB9XG4gICAgZXJyb3IoLi4uYXJncykge1xuICAgICAgICBjb25zb2xlLmVycm9yKC4uLmFyZ3MpO1xuICAgIH1cbiAgICBkZWJ1ZyguLi5hcmdzKSB7XG4gICAgICAgIGNvbnNvbGUuZGVidWcoLi4uYXJncyk7XG4gICAgfVxufVxuZXhwb3J0cy5EZWZhdWx0TG9nZ2VyID0gRGVmYXVsdExvZ2dlcjtcbi8qKlxuICogUHJveHlMb2dnZXIgYWltcyB0byBwcm92aWRlIGEgdGhpbiB3cmFwcGVyIG9uIHVzZXIncyBwcm92aWRlZCBsb2dnZXIuXG4gKiBJdCdzIGV4cGVjdGVkIHRvIGJlIHR1cm5lZCBvbiBhbmQgb2ZmIGJhc2VkIG9uIHRoZSBmdW5jdGlvbiBleGVjdXRpb25cbiAqIGNvbnRleHQsIHNvIGl0IGRvZXNuJ3QgcmVzdWx0IGluIGR1cGxpY2F0ZWQgbG9nZ2luZy5cbiAqXG4gKiBBbmQgYWxzbyBhdHRlbXB0IHRvIGFsbG93IGVub3VnaCB0aW1lIGZvciB0aGUgbG9nZ2VyIHRvIGZsdXNoIGFsbCBsb2dzLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgUHJveHlMb2dnZXIge1xuICAgIGNvbnN0cnVjdG9yKGxvZ2dlcikge1xuICAgICAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gICAgICAgIC8vIFJldHVybiBhIFByb3h5IHRvIGZvcndhcmQgYXJiaXRyYXJ5IHByb3BlcnR5IGFjY2VzcyB0byB0aGUgdW5kZXJseWluZ1xuICAgICAgICAvLyBsb2dnZXIuIEZvciBleGFtcGxlLCBpZiB0aGUgdXNlciBwcm92aWRlcyBhIGxvZ2dlciB0aGF0IGhhcyBhIGBmb29gXG4gICAgICAgIC8vIG1ldGhvZCwgdGhleSBjYW4gY2FsbCBgZm9vYCBvbiB0aGUgUHJveHlMb2dnZXIgYW5kIGl0IHdpbGwgY2FsbCB0aGVcbiAgICAgICAgLy8gdW5kZXJseWluZyBsb2dnZXIncyBgZm9vYCBtZXRob2QuXG4gICAgICAgIHJldHVybiBuZXcgUHJveHkodGhpcywge1xuICAgICAgICAgICAgZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgUHJveHlMb2dnZXIncyBvd24gbWV0aG9kcy9wcm9wZXJ0aWVzLlxuICAgICAgICAgICAgICAgIGlmIChwcm9wIGluIHRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEZvcndhcmQgcHJvcGVydHkgYWNjZXNzIHRvIHRoZSB1bmRlcmx5aW5nIGxvZ2dlci5cbiAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LmxvZ2dlciwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGluZm8oLi4uYXJncykge1xuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyguLi5hcmdzKTtcbiAgICB9XG4gICAgd2FybiguLi5hcmdzKSB7XG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKC4uLmFyZ3MpO1xuICAgIH1cbiAgICBlcnJvciguLi5hcmdzKSB7XG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmxvZ2dlci5lcnJvciguLi5hcmdzKTtcbiAgICB9XG4gICAgZGVidWcoLi4uYXJncykge1xuICAgICAgICAvLyB0aGVyZSBhcmUgbG9nZ2VycyB0aGF0IGRvbid0IGltcGxlbWVudCBcImRlYnVnXCIgYnkgZGVmYXVsdFxuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZCB8fCAhKHR5cGVvZiB0aGlzLmxvZ2dlci5kZWJ1ZyA9PT0gXCJmdW5jdGlvblwiKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoLi4uYXJncyk7XG4gICAgfVxuICAgIGVuYWJsZSgpIHtcbiAgICAgICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgZGlzYWJsZSgpIHtcbiAgICAgICAgdGhpcy5lbmFibGVkID0gZmFsc2U7XG4gICAgfVxuICAgIGFzeW5jIGZsdXNoKCkge1xuICAgICAgICAvLyBBbGxvdyAxcyBmb3IgdGhlIHByb3ZpZGVkIGxvZ2dlciB0byBoYW5kbGUgZmx1c2hpbmcgc2luY2UgdGhlIG9uZXMgdGhhdCBkb1xuICAgICAgICAvLyBmbHVzaGluZyB1c3VhbGx5IGhhcyBzb21lIGtpbmQgb2YgdGltZW91dCBvZiB1cCB0byAxcy5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVE9ETzpcbiAgICAgICAgLy8gVGhpcyBzaG91bGQgb25seSBoYXBwZW4gd2hlbiB1c2luZyBhIHNlcnZlcmxlc3MgZW52aXJvbm1lbnQgYmVjYXVzZSBpdCdzIHZlcnlcbiAgICAgICAgLy8gY29zdGx5IGZyb20gdGhlIGNvbXB1dGUgcGVyc3BlY3RpdmUuXG4gICAgICAgIC8vIHNlcnZlciBydW50aW1lcyBzaG91bGQganVzdCBsZXQgdGhlIGxvZ2dlciBkbyB0aGVpciB0aGluZyBzaW5jZSBtb3N0IG9mIHRoZW1cbiAgICAgICAgLy8gc2hvdWxkIGhhdmUgYWxyZWFkeSBmaWd1cmVkIHdoYXQgdG8gZG8gaW4gdGhvc2UgZW52aXJvbm1lbnRzLCBiZSBpdCB0aHJlYWRpbmcgb3JcbiAgICAgICAgLy8gc29tZXRoaW5nIGVsc2UuXG4gICAgICAgIGlmICh0aGlzLmxvZ2dlci5jb25zdHJ1Y3Rvci5uYW1lICE9PSBEZWZhdWx0TG9nZ2VyLm5hbWUpIHtcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiByZXNvbHZlKG51bGwpLCAxMDAwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5Qcm94eUxvZ2dlciA9IFByb3h5TG9nZ2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9nZ2VyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/middleware/logger.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/next.js":
/*!**************************************!*\
  !*** ./node_modules/inngest/next.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * An adapter for Next.js to serve and register any declared functions with\n * Inngest, making them available to be triggered by events.\n *\n * Supports Next.js 12+, both serverless and edge.\n *\n * @example Next.js <=12 or the pages router can export the handler directly\n * ```ts\n * export default serve({ client: inngest, functions: [fn1, fn2] });\n * ```\n *\n * @example Next.js >=13 with the `app` dir must export individual methods\n * ```ts\n * export const { GET, POST, PUT } = serve({\n *            client: inngest,\n *            functions: [fn1, fn2],\n * });\n * ```\n *\n * @module\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.serve = exports.frameworkName = void 0;\nconst InngestCommHandler_js_1 = __webpack_require__(/*! ./components/InngestCommHandler.js */ \"(rsc)/./node_modules/inngest/components/InngestCommHandler.js\");\nconst env_js_1 = __webpack_require__(/*! ./helpers/env.js */ \"(rsc)/./node_modules/inngest/helpers/env.js\");\n/**\n * The name of the framework, used to identify the framework in Inngest\n * dashboards and during testing.\n */\nexports.frameworkName = \"nextjs\";\nconst isRecord = (val) => {\n    return typeof val === \"object\" && val !== null;\n};\nconst isFunction = (val) => {\n    return typeof val === \"function\";\n};\nconst isNext12ApiResponse = (val) => {\n    return (isRecord(val) &&\n        isFunction(val.setHeader) &&\n        isFunction(val.status) &&\n        isFunction(val.send));\n};\n/**\n * In Next.js, serve and register any declared functions with Inngest, making\n * them available to be triggered by events.\n *\n * Supports Next.js 12+, both serverless and edge.\n *\n * @example Next.js <=12 or the pages router can export the handler directly\n * ```ts\n * export default serve({ client: inngest, functions: [fn1, fn2] });\n * ```\n *\n * @example Next.js >=13 with the `app` dir must export individual methods\n * ```ts\n * export const { GET, POST, PUT } = serve({\n *            client: inngest,\n *            functions: [fn1, fn2],\n * });\n * ```\n *\n * @public\n */\n// Has explicit return type to avoid JSR-defined \"slow types\"\nconst serve = (options) => {\n    const handler = new InngestCommHandler_js_1.InngestCommHandler(Object.assign(Object.assign({ frameworkName: exports.frameworkName }, options), { handler: (reqMethod, ...args) => {\n            const [expectedReq, res] = args;\n            const req = expectedReq;\n            const getHeader = (key) => {\n                const header = typeof req.headers.get === \"function\"\n                    ? req.headers.get(key)\n                    : req.headers[key];\n                return Array.isArray(header) ? header[0] : header;\n            };\n            return {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                body: () => (typeof req.json === \"function\" ? req.json() : req.body),\n                headers: getHeader,\n                method: () => {\n                    /**\n                     * `req.method`, though types say otherwise, is not available in Next.js\n                     * 13 {@link https://beta.nextjs.org/docs/routing/route-handlers Route Handlers}.\n                     *\n                     * Therefore, we must try to set the method ourselves where we know it.\n                     */\n                    const method = reqMethod || req.method || \"\";\n                    return method;\n                },\n                isProduction: () => {\n                    /**\n                     * Vercel Edge Functions do not allow dynamic access to environment\n                     * variables, so we'll manage production checks directly here.\n                     *\n                     * We try/catch to avoid situations where Next.js is being used in\n                     * environments where `process.env` is not accessible or polyfilled.\n                     */\n                    try {\n                        // eslint-disable-next-line @inngest/internal/process-warn\n                        const isProd = \"development\" === \"production\";\n                        return isProd;\n                    }\n                    catch (err) {\n                        // no-op\n                    }\n                },\n                queryString: (key, url) => {\n                    var _a;\n                    const qs = ((_a = req.query) === null || _a === void 0 ? void 0 : _a[key]) || url.searchParams.get(key);\n                    return Array.isArray(qs) ? qs[0] : qs;\n                },\n                url: () => {\n                    let absoluteUrl;\n                    try {\n                        absoluteUrl = new URL(req.url);\n                    }\n                    catch (_a) {\n                        // no-op\n                    }\n                    if (absoluteUrl) {\n                        /**\n                         * `req.url` here should may be the full URL, including query string.\n                         * There are some caveats, however, where Next.js will obfuscate\n                         * the host. For example, in the case of `host.docker.internal`,\n                         * Next.js will instead set the host here to `localhost`.\n                         *\n                         * To avoid this, we'll try to parse the URL from `req.url`, but\n                         * also use the `host` header if it's available.\n                         */\n                        const host = options.serveHost || getHeader(\"host\");\n                        if (host) {\n                            const hostWithProtocol = new URL(host.includes(\"://\") ? host : `${absoluteUrl.protocol}//${host}`);\n                            absoluteUrl.protocol = hostWithProtocol.protocol;\n                            absoluteUrl.host = hostWithProtocol.host;\n                            absoluteUrl.port = hostWithProtocol.port;\n                            absoluteUrl.username = hostWithProtocol.username;\n                            absoluteUrl.password = hostWithProtocol.password;\n                        }\n                        return absoluteUrl;\n                    }\n                    let scheme = \"https\";\n                    const host = options.serveHost || getHeader(\"host\") || \"\";\n                    try {\n                        // eslint-disable-next-line @inngest/internal/process-warn\n                        if (true) {\n                            scheme = \"http\";\n                        }\n                    }\n                    catch (err) {\n                        // no-op\n                    }\n                    const url = new URL(req.url, `${scheme}://${host}`);\n                    return url;\n                },\n                transformResponse: ({ body, headers, status }) => {\n                    /**\n                     * Carefully attempt to set headers and data on the response object\n                     * for Next.js 12 support.\n                     *\n                     * This also assumes that we're not using Next.js 15, where the `res`\n                     * object is repopulated as a `RouteContext` object. We expect these\n                     * methods to NOT be defined in Next.js 15.\n                     *\n                     * We could likely use `instanceof ServerResponse` to better check the\n                     * type of this, though Next.js 12 had issues with this due to not\n                     * instantiating the response correctly.\n                     */\n                    if (isNext12ApiResponse(res)) {\n                        for (const [key, value] of Object.entries(headers)) {\n                            res.setHeader(key, value);\n                        }\n                        res.status(status);\n                        res.send(body);\n                        /**\n                         * If we're here, we're in a serverless endpoint (not edge), so\n                         * we've correctly sent the response and can return `undefined`.\n                         *\n                         * Next.js 13 edge requires that the return value is typed as\n                         * `Response`, so we still enforce that as we cannot dynamically\n                         * adjust typing based on the environment.\n                         */\n                        return undefined;\n                    }\n                    /**\n                     * If we're here, we're in an edge environment and need to return a\n                     * `Response` object.\n                     *\n                     * We also don't know if the current environment has a native\n                     * `Response` object, so we'll grab that first.\n                     */\n                    const Res = (0, env_js_1.getResponse)();\n                    return new Res(body, { status, headers });\n                },\n                transformStreamingResponse: ({ body, headers, status }) => {\n                    return new Response(body, { status, headers });\n                },\n            };\n        } }));\n    /**\n     * Next.js 13 uses\n     * {@link https://beta.nextjs.org/docs/routing/route-handlers Route Handlers}\n     * to declare API routes instead of a generic catch-all method that was\n     * available using the `pages/api` directory.\n     *\n     * This means that users must now export a function for each method supported\n     * by the endpoint. For us, this means requiring a user explicitly exports\n     * `GET`, `POST`, and `PUT` functions.\n     *\n     * Because of this, we'll add circular references to those property names of\n     * the returned handler, meaning we can write some succinct code to export\n     * them. Thanks, @goodoldneon.\n     *\n     * @example\n     * ```ts\n     * export const { GET, POST, PUT } = serve(...);\n     * ```\n     *\n     * See {@link https://beta.nextjs.org/docs/routing/route-handlers}\n     */\n    const baseFn = handler.createHandler();\n    const fn = baseFn.bind(null, undefined);\n    /**\n     * Ensure we have a non-variadic length to avoid issues with forced type\n     * checking.\n     */\n    Object.defineProperty(fn, \"length\", { value: 1 });\n    const handlerFn = Object.defineProperties(fn, {\n        GET: { value: baseFn.bind(null, \"GET\") },\n        POST: { value: baseFn.bind(null, \"POST\") },\n        PUT: { value: baseFn.bind(null, \"PUT\") },\n    });\n    return handlerFn;\n};\nexports.serve = serve;\n//# sourceMappingURL=next.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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cz9lNDdjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBBbiBhZGFwdGVyIGZvciBOZXh0LmpzIHRvIHNlcnZlIGFuZCByZWdpc3RlciBhbnkgZGVjbGFyZWQgZnVuY3Rpb25zIHdpdGhcbiAqIElubmdlc3QsIG1ha2luZyB0aGVtIGF2YWlsYWJsZSB0byBiZSB0cmlnZ2VyZWQgYnkgZXZlbnRzLlxuICpcbiAqIFN1cHBvcnRzIE5leHQuanMgMTIrLCBib3RoIHNlcnZlcmxlc3MgYW5kIGVkZ2UuXG4gKlxuICogQGV4YW1wbGUgTmV4dC5qcyA8PTEyIG9yIHRoZSBwYWdlcyByb3V0ZXIgY2FuIGV4cG9ydCB0aGUgaGFuZGxlciBkaXJlY3RseVxuICogYGBgdHNcbiAqIGV4cG9ydCBkZWZhdWx0IHNlcnZlKHsgY2xpZW50OiBpbm5nZXN0LCBmdW5jdGlvbnM6IFtmbjEsIGZuMl0gfSk7XG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZSBOZXh0LmpzID49MTMgd2l0aCB0aGUgYGFwcGAgZGlyIG11c3QgZXhwb3J0IGluZGl2aWR1YWwgbWV0aG9kc1xuICogYGBgdHNcbiAqIGV4cG9ydCBjb25zdCB7IEdFVCwgUE9TVCwgUFVUIH0gPSBzZXJ2ZSh7XG4gKiAgICAgICAgICAgIGNsaWVudDogaW5uZ2VzdCxcbiAqICAgICAgICAgICAgZnVuY3Rpb25zOiBbZm4xLCBmbjJdLFxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAbW9kdWxlXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2VydmUgPSBleHBvcnRzLmZyYW1ld29ya05hbWUgPSB2b2lkIDA7XG5jb25zdCBJbm5nZXN0Q29tbUhhbmRsZXJfanNfMSA9IHJlcXVpcmUoXCIuL2NvbXBvbmVudHMvSW5uZ2VzdENvbW1IYW5kbGVyLmpzXCIpO1xuY29uc3QgZW52X2pzXzEgPSByZXF1aXJlKFwiLi9oZWxwZXJzL2Vudi5qc1wiKTtcbi8qKlxuICogVGhlIG5hbWUgb2YgdGhlIGZyYW1ld29yaywgdXNlZCB0byBpZGVudGlmeSB0aGUgZnJhbWV3b3JrIGluIElubmdlc3RcbiAqIGRhc2hib2FyZHMgYW5kIGR1cmluZyB0ZXN0aW5nLlxuICovXG5leHBvcnRzLmZyYW1ld29ya05hbWUgPSBcIm5leHRqc1wiO1xuY29uc3QgaXNSZWNvcmQgPSAodmFsKSA9PiB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWwgPT09IFwib2JqZWN0XCIgJiYgdmFsICE9PSBudWxsO1xufTtcbmNvbnN0IGlzRnVuY3Rpb24gPSAodmFsKSA9PiB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWwgPT09IFwiZnVuY3Rpb25cIjtcbn07XG5jb25zdCBpc05leHQxMkFwaVJlc3BvbnNlID0gKHZhbCkgPT4ge1xuICAgIHJldHVybiAoaXNSZWNvcmQodmFsKSAmJlxuICAgICAgICBpc0Z1bmN0aW9uKHZhbC5zZXRIZWFkZXIpICYmXG4gICAgICAgIGlzRnVuY3Rpb24odmFsLnN0YXR1cykgJiZcbiAgICAgICAgaXNGdW5jdGlvbih2YWwuc2VuZCkpO1xufTtcbi8qKlxuICogSW4gTmV4dC5qcywgc2VydmUgYW5kIHJlZ2lzdGVyIGFueSBkZWNsYXJlZCBmdW5jdGlvbnMgd2l0aCBJbm5nZXN0LCBtYWtpbmdcbiAqIHRoZW0gYXZhaWxhYmxlIHRvIGJlIHRyaWdnZXJlZCBieSBldmVudHMuXG4gKlxuICogU3VwcG9ydHMgTmV4dC5qcyAxMissIGJvdGggc2VydmVybGVzcyBhbmQgZWRnZS5cbiAqXG4gKiBAZXhhbXBsZSBOZXh0LmpzIDw9MTIgb3IgdGhlIHBhZ2VzIHJvdXRlciBjYW4gZXhwb3J0IHRoZSBoYW5kbGVyIGRpcmVjdGx5XG4gKiBgYGB0c1xuICogZXhwb3J0IGRlZmF1bHQgc2VydmUoeyBjbGllbnQ6IGlubmdlc3QsIGZ1bmN0aW9uczogW2ZuMSwgZm4yXSB9KTtcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlIE5leHQuanMgPj0xMyB3aXRoIHRoZSBgYXBwYCBkaXIgbXVzdCBleHBvcnQgaW5kaXZpZHVhbCBtZXRob2RzXG4gKiBgYGB0c1xuICogZXhwb3J0IGNvbnN0IHsgR0VULCBQT1NULCBQVVQgfSA9IHNlcnZlKHtcbiAqICAgICAgICAgICAgY2xpZW50OiBpbm5nZXN0LFxuICogICAgICAgICAgICBmdW5jdGlvbnM6IFtmbjEsIGZuMl0sXG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEBwdWJsaWNcbiAqL1xuLy8gSGFzIGV4cGxpY2l0IHJldHVybiB0eXBlIHRvIGF2b2lkIEpTUi1kZWZpbmVkIFwic2xvdyB0eXBlc1wiXG5jb25zdCBzZXJ2ZSA9IChvcHRpb25zKSA9PiB7XG4gICAgY29uc3QgaGFuZGxlciA9IG5ldyBJbm5nZXN0Q29tbUhhbmRsZXJfanNfMS5Jbm5nZXN0Q29tbUhhbmRsZXIoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgZnJhbWV3b3JrTmFtZTogZXhwb3J0cy5mcmFtZXdvcmtOYW1lIH0sIG9wdGlvbnMpLCB7IGhhbmRsZXI6IChyZXFNZXRob2QsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IFtleHBlY3RlZFJlcSwgcmVzXSA9IGFyZ3M7XG4gICAgICAgICAgICBjb25zdCByZXEgPSBleHBlY3RlZFJlcTtcbiAgICAgICAgICAgIGNvbnN0IGdldEhlYWRlciA9IChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBoZWFkZXIgPSB0eXBlb2YgcmVxLmhlYWRlcnMuZ2V0ID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgICAgICAgICAgPyByZXEuaGVhZGVycy5nZXQoa2V5KVxuICAgICAgICAgICAgICAgICAgICA6IHJlcS5oZWFkZXJzW2tleV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoaGVhZGVyKSA/IGhlYWRlclswXSA6IGhlYWRlcjtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVyblxuICAgICAgICAgICAgICAgIGJvZHk6ICgpID0+ICh0eXBlb2YgcmVxLmpzb24gPT09IFwiZnVuY3Rpb25cIiA/IHJlcS5qc29uKCkgOiByZXEuYm9keSksXG4gICAgICAgICAgICAgICAgaGVhZGVyczogZ2V0SGVhZGVyLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogYHJlcS5tZXRob2RgLCB0aG91Z2ggdHlwZXMgc2F5IG90aGVyd2lzZSwgaXMgbm90IGF2YWlsYWJsZSBpbiBOZXh0LmpzXG4gICAgICAgICAgICAgICAgICAgICAqIDEzIHtAbGluayBodHRwczovL2JldGEubmV4dGpzLm9yZy9kb2NzL3JvdXRpbmcvcm91dGUtaGFuZGxlcnMgUm91dGUgSGFuZGxlcnN9LlxuICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgKiBUaGVyZWZvcmUsIHdlIG11c3QgdHJ5IHRvIHNldCB0aGUgbWV0aG9kIG91cnNlbHZlcyB3aGVyZSB3ZSBrbm93IGl0LlxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWV0aG9kID0gcmVxTWV0aG9kIHx8IHJlcS5tZXRob2QgfHwgXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ldGhvZDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlzUHJvZHVjdGlvbjogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogVmVyY2VsIEVkZ2UgRnVuY3Rpb25zIGRvIG5vdCBhbGxvdyBkeW5hbWljIGFjY2VzcyB0byBlbnZpcm9ubWVudFxuICAgICAgICAgICAgICAgICAgICAgKiB2YXJpYWJsZXMsIHNvIHdlJ2xsIG1hbmFnZSBwcm9kdWN0aW9uIGNoZWNrcyBkaXJlY3RseSBoZXJlLlxuICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgKiBXZSB0cnkvY2F0Y2ggdG8gYXZvaWQgc2l0dWF0aW9ucyB3aGVyZSBOZXh0LmpzIGlzIGJlaW5nIHVzZWQgaW5cbiAgICAgICAgICAgICAgICAgICAgICogZW52aXJvbm1lbnRzIHdoZXJlIGBwcm9jZXNzLmVudmAgaXMgbm90IGFjY2Vzc2libGUgb3IgcG9seWZpbGxlZC5cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQGlubmdlc3QvaW50ZXJuYWwvcHJvY2Vzcy13YXJuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc1Byb2QgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNQcm9kO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vLW9wXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHF1ZXJ5U3RyaW5nOiAoa2V5LCB1cmwpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBxcyA9ICgoX2EgPSByZXEucXVlcnkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtrZXldKSB8fCB1cmwuc2VhcmNoUGFyYW1zLmdldChrZXkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShxcykgPyBxc1swXSA6IHFzO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdXJsOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBhYnNvbHV0ZVVybDtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFic29sdXRlVXJsID0gbmV3IFVSTChyZXEudXJsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vLW9wXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFic29sdXRlVXJsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIGByZXEudXJsYCBoZXJlIHNob3VsZCBtYXkgYmUgdGhlIGZ1bGwgVVJMLCBpbmNsdWRpbmcgcXVlcnkgc3RyaW5nLlxuICAgICAgICAgICAgICAgICAgICAgICAgICogVGhlcmUgYXJlIHNvbWUgY2F2ZWF0cywgaG93ZXZlciwgd2hlcmUgTmV4dC5qcyB3aWxsIG9iZnVzY2F0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICogdGhlIGhvc3QuIEZvciBleGFtcGxlLCBpbiB0aGUgY2FzZSBvZiBgaG9zdC5kb2NrZXIuaW50ZXJuYWxgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICogTmV4dC5qcyB3aWxsIGluc3RlYWQgc2V0IHRoZSBob3N0IGhlcmUgdG8gYGxvY2FsaG9zdGAuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogVG8gYXZvaWQgdGhpcywgd2UnbGwgdHJ5IHRvIHBhcnNlIHRoZSBVUkwgZnJvbSBgcmVxLnVybGAsIGJ1dFxuICAgICAgICAgICAgICAgICAgICAgICAgICogYWxzbyB1c2UgdGhlIGBob3N0YCBoZWFkZXIgaWYgaXQncyBhdmFpbGFibGUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGhvc3QgPSBvcHRpb25zLnNlcnZlSG9zdCB8fCBnZXRIZWFkZXIoXCJob3N0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhvc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBob3N0V2l0aFByb3RvY29sID0gbmV3IFVSTChob3N0LmluY2x1ZGVzKFwiOi8vXCIpID8gaG9zdCA6IGAke2Fic29sdXRlVXJsLnByb3RvY29sfS8vJHtob3N0fWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFic29sdXRlVXJsLnByb3RvY29sID0gaG9zdFdpdGhQcm90b2NvbC5wcm90b2NvbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYnNvbHV0ZVVybC5ob3N0ID0gaG9zdFdpdGhQcm90b2NvbC5ob3N0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFic29sdXRlVXJsLnBvcnQgPSBob3N0V2l0aFByb3RvY29sLnBvcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJzb2x1dGVVcmwudXNlcm5hbWUgPSBob3N0V2l0aFByb3RvY29sLnVzZXJuYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFic29sdXRlVXJsLnBhc3N3b3JkID0gaG9zdFdpdGhQcm90b2NvbC5wYXNzd29yZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhYnNvbHV0ZVVybDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgc2NoZW1lID0gXCJodHRwc1wiO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBob3N0ID0gb3B0aW9ucy5zZXJ2ZUhvc3QgfHwgZ2V0SGVhZGVyKFwiaG9zdFwiKSB8fCBcIlwiO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEBpbm5nZXN0L2ludGVybmFsL3Byb2Nlc3Mtd2FyblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2hlbWUgPSBcImh0dHBcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBuby1vcFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwocmVxLnVybCwgYCR7c2NoZW1lfTovLyR7aG9zdH1gKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVybDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybVJlc3BvbnNlOiAoeyBib2R5LCBoZWFkZXJzLCBzdGF0dXMgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogQ2FyZWZ1bGx5IGF0dGVtcHQgdG8gc2V0IGhlYWRlcnMgYW5kIGRhdGEgb24gdGhlIHJlc3BvbnNlIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICAgKiBmb3IgTmV4dC5qcyAxMiBzdXBwb3J0LlxuICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgKiBUaGlzIGFsc28gYXNzdW1lcyB0aGF0IHdlJ3JlIG5vdCB1c2luZyBOZXh0LmpzIDE1LCB3aGVyZSB0aGUgYHJlc2BcbiAgICAgICAgICAgICAgICAgICAgICogb2JqZWN0IGlzIHJlcG9wdWxhdGVkIGFzIGEgYFJvdXRlQ29udGV4dGAgb2JqZWN0LiBXZSBleHBlY3QgdGhlc2VcbiAgICAgICAgICAgICAgICAgICAgICogbWV0aG9kcyB0byBOT1QgYmUgZGVmaW5lZCBpbiBOZXh0LmpzIDE1LlxuICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgKiBXZSBjb3VsZCBsaWtlbHkgdXNlIGBpbnN0YW5jZW9mIFNlcnZlclJlc3BvbnNlYCB0byBiZXR0ZXIgY2hlY2sgdGhlXG4gICAgICAgICAgICAgICAgICAgICAqIHR5cGUgb2YgdGhpcywgdGhvdWdoIE5leHQuanMgMTIgaGFkIGlzc3VlcyB3aXRoIHRoaXMgZHVlIHRvIG5vdFxuICAgICAgICAgICAgICAgICAgICAgKiBpbnN0YW50aWF0aW5nIHRoZSByZXNwb25zZSBjb3JyZWN0bHkuXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOZXh0MTJBcGlSZXNwb25zZShyZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhoZWFkZXJzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5zZXRIZWFkZXIoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMuc3RhdHVzKHN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMuc2VuZChib2R5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogSWYgd2UncmUgaGVyZSwgd2UncmUgaW4gYSBzZXJ2ZXJsZXNzIGVuZHBvaW50IChub3QgZWRnZSksIHNvXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiB3ZSd2ZSBjb3JyZWN0bHkgc2VudCB0aGUgcmVzcG9uc2UgYW5kIGNhbiByZXR1cm4gYHVuZGVmaW5lZGAuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogTmV4dC5qcyAxMyBlZGdlIHJlcXVpcmVzIHRoYXQgdGhlIHJldHVybiB2YWx1ZSBpcyB0eXBlZCBhc1xuICAgICAgICAgICAgICAgICAgICAgICAgICogYFJlc3BvbnNlYCwgc28gd2Ugc3RpbGwgZW5mb3JjZSB0aGF0IGFzIHdlIGNhbm5vdCBkeW5hbWljYWxseVxuICAgICAgICAgICAgICAgICAgICAgICAgICogYWRqdXN0IHR5cGluZyBiYXNlZCBvbiB0aGUgZW52aXJvbm1lbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIElmIHdlJ3JlIGhlcmUsIHdlJ3JlIGluIGFuIGVkZ2UgZW52aXJvbm1lbnQgYW5kIG5lZWQgdG8gcmV0dXJuIGFcbiAgICAgICAgICAgICAgICAgICAgICogYFJlc3BvbnNlYCBvYmplY3QuXG4gICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAqIFdlIGFsc28gZG9uJ3Qga25vdyBpZiB0aGUgY3VycmVudCBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmVcbiAgICAgICAgICAgICAgICAgICAgICogYFJlc3BvbnNlYCBvYmplY3QsIHNvIHdlJ2xsIGdyYWIgdGhhdCBmaXJzdC5cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFJlcyA9ICgwLCBlbnZfanNfMS5nZXRSZXNwb25zZSkoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXMoYm9keSwgeyBzdGF0dXMsIGhlYWRlcnMgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1TdHJlYW1pbmdSZXNwb25zZTogKHsgYm9keSwgaGVhZGVycywgc3RhdHVzIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShib2R5LCB7IHN0YXR1cywgaGVhZGVycyB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSB9KSk7XG4gICAgLyoqXG4gICAgICogTmV4dC5qcyAxMyB1c2VzXG4gICAgICoge0BsaW5rIGh0dHBzOi8vYmV0YS5uZXh0anMub3JnL2RvY3Mvcm91dGluZy9yb3V0ZS1oYW5kbGVycyBSb3V0ZSBIYW5kbGVyc31cbiAgICAgKiB0byBkZWNsYXJlIEFQSSByb3V0ZXMgaW5zdGVhZCBvZiBhIGdlbmVyaWMgY2F0Y2gtYWxsIG1ldGhvZCB0aGF0IHdhc1xuICAgICAqIGF2YWlsYWJsZSB1c2luZyB0aGUgYHBhZ2VzL2FwaWAgZGlyZWN0b3J5LlxuICAgICAqXG4gICAgICogVGhpcyBtZWFucyB0aGF0IHVzZXJzIG11c3Qgbm93IGV4cG9ydCBhIGZ1bmN0aW9uIGZvciBlYWNoIG1ldGhvZCBzdXBwb3J0ZWRcbiAgICAgKiBieSB0aGUgZW5kcG9pbnQuIEZvciB1cywgdGhpcyBtZWFucyByZXF1aXJpbmcgYSB1c2VyIGV4cGxpY2l0bHkgZXhwb3J0c1xuICAgICAqIGBHRVRgLCBgUE9TVGAsIGFuZCBgUFVUYCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBCZWNhdXNlIG9mIHRoaXMsIHdlJ2xsIGFkZCBjaXJjdWxhciByZWZlcmVuY2VzIHRvIHRob3NlIHByb3BlcnR5IG5hbWVzIG9mXG4gICAgICogdGhlIHJldHVybmVkIGhhbmRsZXIsIG1lYW5pbmcgd2UgY2FuIHdyaXRlIHNvbWUgc3VjY2luY3QgY29kZSB0byBleHBvcnRcbiAgICAgKiB0aGVtLiBUaGFua3MsIEBnb29kb2xkbmVvbi5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBleHBvcnQgY29uc3QgeyBHRVQsIFBPU1QsIFBVVCB9ID0gc2VydmUoLi4uKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFNlZSB7QGxpbmsgaHR0cHM6Ly9iZXRhLm5leHRqcy5vcmcvZG9jcy9yb3V0aW5nL3JvdXRlLWhhbmRsZXJzfVxuICAgICAqL1xuICAgIGNvbnN0IGJhc2VGbiA9IGhhbmRsZXIuY3JlYXRlSGFuZGxlcigpO1xuICAgIGNvbnN0IGZuID0gYmFzZUZuLmJpbmQobnVsbCwgdW5kZWZpbmVkKTtcbiAgICAvKipcbiAgICAgKiBFbnN1cmUgd2UgaGF2ZSBhIG5vbi12YXJpYWRpYyBsZW5ndGggdG8gYXZvaWQgaXNzdWVzIHdpdGggZm9yY2VkIHR5cGVcbiAgICAgKiBjaGVja2luZy5cbiAgICAgKi9cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sIFwibGVuZ3RoXCIsIHsgdmFsdWU6IDEgfSk7XG4gICAgY29uc3QgaGFuZGxlckZuID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZm4sIHtcbiAgICAgICAgR0VUOiB7IHZhbHVlOiBiYXNlRm4uYmluZChudWxsLCBcIkdFVFwiKSB9LFxuICAgICAgICBQT1NUOiB7IHZhbHVlOiBiYXNlRm4uYmluZChudWxsLCBcIlBPU1RcIikgfSxcbiAgICAgICAgUFVUOiB7IHZhbHVlOiBiYXNlRm4uYmluZChudWxsLCBcIlBVVFwiKSB9LFxuICAgIH0pO1xuICAgIHJldHVybiBoYW5kbGVyRm47XG59O1xuZXhwb3J0cy5zZXJ2ZSA9IHNlcnZlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmV4dC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/next.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/node_modules/ansi-regex/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/inngest/node_modules/ansi-regex/index.js ***!
  \***************************************************************/
/***/ ((module) => {

eval("\nmodule.exports = (options)=>{\n    options = Object.assign({\n        onlyFirst: false\n    }, options);\n    const pattern = [\n        \"[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]+)*|[a-zA-Z\\\\d]+(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)\",\n        \"(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-ntqry=><~]))\"\n    ].join(\"|\");\n    return new RegExp(pattern, options.onlyFirst ? undefined : \"g\");\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9ub2RlX21vZHVsZXMvYW5zaS1yZWdleC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBQSxPQUFPQyxPQUFPLEdBQUdDLENBQUFBO0lBQ2hCQSxVQUFVQyxPQUFPQyxNQUFNLENBQUM7UUFDdkJDLFdBQVc7SUFDWixHQUFHSDtJQUVILE1BQU1JLFVBQVU7UUFDZjtRQUNBO0tBQ0EsQ0FBQ0MsSUFBSSxDQUFDO0lBRVAsT0FBTyxJQUFJQyxPQUFPRixTQUFTSixRQUFRRyxTQUFTLEdBQUdJLFlBQVk7QUFDNUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aXZlLXZpYmUtYWktbmV4dC8uL25vZGVfbW9kdWxlcy9pbm5nZXN0L25vZGVfbW9kdWxlcy9hbnNpLXJlZ2V4L2luZGV4LmpzPzFiY2EiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG9wdGlvbnMgPT4ge1xuXHRvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG5cdFx0b25seUZpcnN0OiBmYWxzZVxuXHR9LCBvcHRpb25zKTtcblxuXHRjb25zdCBwYXR0ZXJuID0gW1xuXHRcdCdbXFxcXHUwMDFCXFxcXHUwMDlCXVtbXFxcXF0oKSM7P10qKD86KD86KD86KD86O1stYS16QS1aXFxcXGRcXFxcLyMmLjo9PyVAfl9dKykqfFthLXpBLVpcXFxcZF0rKD86O1stYS16QS1aXFxcXGRcXFxcLyMmLjo9PyVAfl9dKikqKT9cXFxcdTAwMDcpJyxcblx0XHQnKD86KD86XFxcXGR7MSw0fSg/OjtcXFxcZHswLDR9KSopP1tcXFxcZEEtUFItVFpjZi1udHFyeT0+PH5dKSknXG5cdF0uam9pbignfCcpO1xuXG5cdHJldHVybiBuZXcgUmVnRXhwKHBhdHRlcm4sIG9wdGlvbnMub25seUZpcnN0ID8gdW5kZWZpbmVkIDogJ2cnKTtcbn07XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsIm9wdGlvbnMiLCJPYmplY3QiLCJhc3NpZ24iLCJvbmx5Rmlyc3QiLCJwYXR0ZXJuIiwiam9pbiIsIlJlZ0V4cCIsInVuZGVmaW5lZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/node_modules/ansi-regex/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/node_modules/strip-ansi/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/inngest/node_modules/strip-ansi/index.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst ansiRegex = __webpack_require__(/*! ansi-regex */ \"(rsc)/./node_modules/inngest/node_modules/ansi-regex/index.js\");\nconst stripAnsi = (string)=>typeof string === \"string\" ? string.replace(ansiRegex(), \"\") : string;\nmodule.exports = stripAnsi;\nmodule.exports[\"default\"] = stripAnsi;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9ub2RlX21vZHVsZXMvc3RyaXAtYW5zaS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLE1BQU1BLFlBQVlDLG1CQUFPQSxDQUFDO0FBRTFCLE1BQU1DLFlBQVlDLENBQUFBLFNBQVUsT0FBT0EsV0FBVyxXQUFXQSxPQUFPQyxPQUFPLENBQUNKLGFBQWEsTUFBTUc7QUFFM0ZFLE9BQU9DLE9BQU8sR0FBR0o7QUFDakJHLHlCQUFzQixHQUFHSCIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpdmUtdmliZS1haS1uZXh0Ly4vbm9kZV9tb2R1bGVzL2lubmdlc3Qvbm9kZV9tb2R1bGVzL3N0cmlwLWFuc2kvaW5kZXguanM/MDEyNiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5jb25zdCBhbnNpUmVnZXggPSByZXF1aXJlKCdhbnNpLXJlZ2V4Jyk7XG5cbmNvbnN0IHN0cmlwQW5zaSA9IHN0cmluZyA9PiB0eXBlb2Ygc3RyaW5nID09PSAnc3RyaW5nJyA/IHN0cmluZy5yZXBsYWNlKGFuc2lSZWdleCgpLCAnJykgOiBzdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gc3RyaXBBbnNpO1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IHN0cmlwQW5zaTtcbiJdLCJuYW1lcyI6WyJhbnNpUmVnZXgiLCJyZXF1aXJlIiwic3RyaXBBbnNpIiwic3RyaW5nIiwicmVwbGFjZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/node_modules/strip-ansi/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/node_modules/zod/lib/ZodError.js":
/*!***************************************************************!*\
  !*** ./node_modules/inngest/node_modules/zod/lib/ZodError.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ZodError = exports.quotelessJson = exports.ZodIssueCode = void 0;\nconst util_1 = __webpack_require__(/*! ./helpers/util */ \"(rsc)/./node_modules/inngest/node_modules/zod/lib/helpers/util.js\");\nexports.ZodIssueCode = util_1.util.arrayToEnum([\n    \"invalid_type\",\n    \"invalid_literal\",\n    \"custom\",\n    \"invalid_union\",\n    \"invalid_union_discriminator\",\n    \"invalid_enum_value\",\n    \"unrecognized_keys\",\n    \"invalid_arguments\",\n    \"invalid_return_type\",\n    \"invalid_date\",\n    \"invalid_string\",\n    \"too_small\",\n    \"too_big\",\n    \"invalid_intersection_types\",\n    \"not_multiple_of\",\n    \"not_finite\",\n]);\nconst quotelessJson = (obj) => {\n    const json = JSON.stringify(obj, null, 2);\n    return json.replace(/\"([^\"]+)\":/g, \"$1:\");\n};\nexports.quotelessJson = quotelessJson;\nclass ZodError extends Error {\n    constructor(issues) {\n        super();\n        this.issues = [];\n        this.addIssue = (sub) => {\n            this.issues = [...this.issues, sub];\n        };\n        this.addIssues = (subs = []) => {\n            this.issues = [...this.issues, ...subs];\n        };\n        const actualProto = new.target.prototype;\n        if (Object.setPrototypeOf) {\n            // eslint-disable-next-line ban/ban\n            Object.setPrototypeOf(this, actualProto);\n        }\n        else {\n            this.__proto__ = actualProto;\n        }\n        this.name = \"ZodError\";\n        this.issues = issues;\n    }\n    get errors() {\n        return this.issues;\n    }\n    format(_mapper) {\n        const mapper = _mapper ||\n            function (issue) {\n                return issue.message;\n            };\n        const fieldErrors = { _errors: [] };\n        const processError = (error) => {\n            for (const issue of error.issues) {\n                if (issue.code === \"invalid_union\") {\n                    issue.unionErrors.map(processError);\n                }\n                else if (issue.code === \"invalid_return_type\") {\n                    processError(issue.returnTypeError);\n                }\n                else if (issue.code === \"invalid_arguments\") {\n                    processError(issue.argumentsError);\n                }\n                else if (issue.path.length === 0) {\n                    fieldErrors._errors.push(mapper(issue));\n                }\n                else {\n                    let curr = fieldErrors;\n                    let i = 0;\n                    while (i < issue.path.length) {\n                        const el = issue.path[i];\n                        const terminal = i === issue.path.length - 1;\n                        if (!terminal) {\n                            curr[el] = curr[el] || { _errors: [] };\n                            // if (typeof el === \"string\") {\n                            //   curr[el] = curr[el] || { _errors: [] };\n                            // } else if (typeof el === \"number\") {\n                            //   const errorArray: any = [];\n                            //   errorArray._errors = [];\n                            //   curr[el] = curr[el] || errorArray;\n                            // }\n                        }\n                        else {\n                            curr[el] = curr[el] || { _errors: [] };\n                            curr[el]._errors.push(mapper(issue));\n                        }\n                        curr = curr[el];\n                        i++;\n                    }\n                }\n            }\n        };\n        processError(this);\n        return fieldErrors;\n    }\n    toString() {\n        return this.message;\n    }\n    get message() {\n        return JSON.stringify(this.issues, util_1.util.jsonStringifyReplacer, 2);\n    }\n    get isEmpty() {\n        return this.issues.length === 0;\n    }\n    flatten(mapper = (issue) => issue.message) {\n        const fieldErrors = {};\n        const formErrors = [];\n        for (const sub of this.issues) {\n            if (sub.path.length > 0) {\n                fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];\n                fieldErrors[sub.path[0]].push(mapper(sub));\n            }\n            else {\n                formErrors.push(mapper(sub));\n            }\n        }\n        return { formErrors, fieldErrors };\n    }\n    get formErrors() {\n        return this.flatten();\n    }\n}\nexports.ZodError = ZodError;\nZodError.create = (issues) => {\n    const error = new ZodError(issues);\n    return error;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9ub2RlX21vZHVsZXMvem9kL2xpYi9ab2RFcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0IsR0FBRyxxQkFBcUIsR0FBRyxvQkFBb0I7QUFDL0QsZUFBZSxtQkFBTyxDQUFDLHlGQUFnQjtBQUN2QyxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0EsMERBQTBEO0FBQzFELGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdml2ZS12aWJlLWFpLW5leHQvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9ub2RlX21vZHVsZXMvem9kL2xpYi9ab2RFcnJvci5qcz8yZTMwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ab2RFcnJvciA9IGV4cG9ydHMucXVvdGVsZXNzSnNvbiA9IGV4cG9ydHMuWm9kSXNzdWVDb2RlID0gdm9pZCAwO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4vaGVscGVycy91dGlsXCIpO1xuZXhwb3J0cy5ab2RJc3N1ZUNvZGUgPSB1dGlsXzEudXRpbC5hcnJheVRvRW51bShbXG4gICAgXCJpbnZhbGlkX3R5cGVcIixcbiAgICBcImludmFsaWRfbGl0ZXJhbFwiLFxuICAgIFwiY3VzdG9tXCIsXG4gICAgXCJpbnZhbGlkX3VuaW9uXCIsXG4gICAgXCJpbnZhbGlkX3VuaW9uX2Rpc2NyaW1pbmF0b3JcIixcbiAgICBcImludmFsaWRfZW51bV92YWx1ZVwiLFxuICAgIFwidW5yZWNvZ25pemVkX2tleXNcIixcbiAgICBcImludmFsaWRfYXJndW1lbnRzXCIsXG4gICAgXCJpbnZhbGlkX3JldHVybl90eXBlXCIsXG4gICAgXCJpbnZhbGlkX2RhdGVcIixcbiAgICBcImludmFsaWRfc3RyaW5nXCIsXG4gICAgXCJ0b29fc21hbGxcIixcbiAgICBcInRvb19iaWdcIixcbiAgICBcImludmFsaWRfaW50ZXJzZWN0aW9uX3R5cGVzXCIsXG4gICAgXCJub3RfbXVsdGlwbGVfb2ZcIixcbiAgICBcIm5vdF9maW5pdGVcIixcbl0pO1xuY29uc3QgcXVvdGVsZXNzSnNvbiA9IChvYmopID0+IHtcbiAgICBjb25zdCBqc29uID0gSlNPTi5zdHJpbmdpZnkob2JqLCBudWxsLCAyKTtcbiAgICByZXR1cm4ganNvbi5yZXBsYWNlKC9cIihbXlwiXSspXCI6L2csIFwiJDE6XCIpO1xufTtcbmV4cG9ydHMucXVvdGVsZXNzSnNvbiA9IHF1b3RlbGVzc0pzb247XG5jbGFzcyBab2RFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihpc3N1ZXMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5pc3N1ZXMgPSBbXTtcbiAgICAgICAgdGhpcy5hZGRJc3N1ZSA9IChzdWIpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaXNzdWVzID0gWy4uLnRoaXMuaXNzdWVzLCBzdWJdO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmFkZElzc3VlcyA9IChzdWJzID0gW10pID0+IHtcbiAgICAgICAgICAgIHRoaXMuaXNzdWVzID0gWy4uLnRoaXMuaXNzdWVzLCAuLi5zdWJzXTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYWN0dWFsUHJvdG8gPSBuZXcudGFyZ2V0LnByb3RvdHlwZTtcbiAgICAgICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGJhbi9iYW5cbiAgICAgICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBhY3R1YWxQcm90byk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9fcHJvdG9fXyA9IGFjdHVhbFByb3RvO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmFtZSA9IFwiWm9kRXJyb3JcIjtcbiAgICAgICAgdGhpcy5pc3N1ZXMgPSBpc3N1ZXM7XG4gICAgfVxuICAgIGdldCBlcnJvcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzc3VlcztcbiAgICB9XG4gICAgZm9ybWF0KF9tYXBwZXIpIHtcbiAgICAgICAgY29uc3QgbWFwcGVyID0gX21hcHBlciB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGlzc3VlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzc3VlLm1lc3NhZ2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICBjb25zdCBmaWVsZEVycm9ycyA9IHsgX2Vycm9yczogW10gfTtcbiAgICAgICAgY29uc3QgcHJvY2Vzc0Vycm9yID0gKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIGVycm9yLmlzc3Vlcykge1xuICAgICAgICAgICAgICAgIGlmIChpc3N1ZS5jb2RlID09PSBcImludmFsaWRfdW5pb25cIikge1xuICAgICAgICAgICAgICAgICAgICBpc3N1ZS51bmlvbkVycm9ycy5tYXAocHJvY2Vzc0Vycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUuY29kZSA9PT0gXCJpbnZhbGlkX3JldHVybl90eXBlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0Vycm9yKGlzc3VlLnJldHVyblR5cGVFcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLmNvZGUgPT09IFwiaW52YWxpZF9hcmd1bWVudHNcIikge1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzRXJyb3IoaXNzdWUuYXJndW1lbnRzRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS5wYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZEVycm9ycy5fZXJyb3JzLnB1c2gobWFwcGVyKGlzc3VlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY3VyciA9IGZpZWxkRXJyb3JzO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChpIDwgaXNzdWUucGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVsID0gaXNzdWUucGF0aFtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRlcm1pbmFsID0gaSA9PT0gaXNzdWUucGF0aC5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0ZXJtaW5hbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJbZWxdID0gY3VycltlbF0gfHwgeyBfZXJyb3JzOiBbXSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmICh0eXBlb2YgZWwgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGN1cnJbZWxdID0gY3VycltlbF0gfHwgeyBfZXJyb3JzOiBbXSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIH0gZWxzZSBpZiAodHlwZW9mIGVsID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBjb25zdCBlcnJvckFycmF5OiBhbnkgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGVycm9yQXJyYXkuX2Vycm9ycyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgY3VycltlbF0gPSBjdXJyW2VsXSB8fCBlcnJvckFycmF5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJbZWxdID0gY3VycltlbF0gfHwgeyBfZXJyb3JzOiBbXSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJbZWxdLl9lcnJvcnMucHVzaChtYXBwZXIoaXNzdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnIgPSBjdXJyW2VsXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcHJvY2Vzc0Vycm9yKHRoaXMpO1xuICAgICAgICByZXR1cm4gZmllbGRFcnJvcnM7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlO1xuICAgIH1cbiAgICBnZXQgbWVzc2FnZSgpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMuaXNzdWVzLCB1dGlsXzEudXRpbC5qc29uU3RyaW5naWZ5UmVwbGFjZXIsIDIpO1xuICAgIH1cbiAgICBnZXQgaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNzdWVzLmxlbmd0aCA9PT0gMDtcbiAgICB9XG4gICAgZmxhdHRlbihtYXBwZXIgPSAoaXNzdWUpID0+IGlzc3VlLm1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgZmllbGRFcnJvcnMgPSB7fTtcbiAgICAgICAgY29uc3QgZm9ybUVycm9ycyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHN1YiBvZiB0aGlzLmlzc3Vlcykge1xuICAgICAgICAgICAgaWYgKHN1Yi5wYXRoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBmaWVsZEVycm9yc1tzdWIucGF0aFswXV0gPSBmaWVsZEVycm9yc1tzdWIucGF0aFswXV0gfHwgW107XG4gICAgICAgICAgICAgICAgZmllbGRFcnJvcnNbc3ViLnBhdGhbMF1dLnB1c2gobWFwcGVyKHN1YikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9ybUVycm9ycy5wdXNoKG1hcHBlcihzdWIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBmb3JtRXJyb3JzLCBmaWVsZEVycm9ycyB9O1xuICAgIH1cbiAgICBnZXQgZm9ybUVycm9ycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxhdHRlbigpO1xuICAgIH1cbn1cbmV4cG9ydHMuWm9kRXJyb3IgPSBab2RFcnJvcjtcblpvZEVycm9yLmNyZWF0ZSA9IChpc3N1ZXMpID0+IHtcbiAgICBjb25zdCBlcnJvciA9IG5ldyBab2RFcnJvcihpc3N1ZXMpO1xuICAgIHJldHVybiBlcnJvcjtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/node_modules/zod/lib/ZodError.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/node_modules/zod/lib/errors.js":
/*!*************************************************************!*\
  !*** ./node_modules/inngest/node_modules/zod/lib/errors.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getErrorMap = exports.setErrorMap = exports.defaultErrorMap = void 0;\nconst en_1 = __importDefault(__webpack_require__(/*! ./locales/en */ \"(rsc)/./node_modules/inngest/node_modules/zod/lib/locales/en.js\"));\nexports.defaultErrorMap = en_1.default;\nlet overrideErrorMap = en_1.default;\nfunction setErrorMap(map) {\n    overrideErrorMap = map;\n}\nexports.setErrorMap = setErrorMap;\nfunction getErrorMap() {\n    return overrideErrorMap;\n}\nexports.getErrorMap = getErrorMap;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9ub2RlX21vZHVsZXMvem9kL2xpYi9lcnJvcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUIsR0FBRyxtQkFBbUIsR0FBRyx1QkFBdUI7QUFDbkUsNkJBQTZCLG1CQUFPLENBQUMscUZBQWM7QUFDbkQsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpdmUtdmliZS1haS1uZXh0Ly4vbm9kZV9tb2R1bGVzL2lubmdlc3Qvbm9kZV9tb2R1bGVzL3pvZC9saWIvZXJyb3JzLmpzPzAxZDkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldEVycm9yTWFwID0gZXhwb3J0cy5zZXRFcnJvck1hcCA9IGV4cG9ydHMuZGVmYXVsdEVycm9yTWFwID0gdm9pZCAwO1xuY29uc3QgZW5fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9sb2NhbGVzL2VuXCIpKTtcbmV4cG9ydHMuZGVmYXVsdEVycm9yTWFwID0gZW5fMS5kZWZhdWx0O1xubGV0IG92ZXJyaWRlRXJyb3JNYXAgPSBlbl8xLmRlZmF1bHQ7XG5mdW5jdGlvbiBzZXRFcnJvck1hcChtYXApIHtcbiAgICBvdmVycmlkZUVycm9yTWFwID0gbWFwO1xufVxuZXhwb3J0cy5zZXRFcnJvck1hcCA9IHNldEVycm9yTWFwO1xuZnVuY3Rpb24gZ2V0RXJyb3JNYXAoKSB7XG4gICAgcmV0dXJuIG92ZXJyaWRlRXJyb3JNYXA7XG59XG5leHBvcnRzLmdldEVycm9yTWFwID0gZ2V0RXJyb3JNYXA7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/node_modules/zod/lib/errors.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/node_modules/zod/lib/external.js":
/*!***************************************************************!*\
  !*** ./node_modules/inngest/node_modules/zod/lib/external.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/inngest/node_modules/zod/lib/errors.js\"), exports);\n__exportStar(__webpack_require__(/*! ./helpers/parseUtil */ \"(rsc)/./node_modules/inngest/node_modules/zod/lib/helpers/parseUtil.js\"), exports);\n__exportStar(__webpack_require__(/*! ./helpers/typeAliases */ \"(rsc)/./node_modules/inngest/node_modules/zod/lib/helpers/typeAliases.js\"), exports);\n__exportStar(__webpack_require__(/*! ./helpers/util */ \"(rsc)/./node_modules/inngest/node_modules/zod/lib/helpers/util.js\"), exports);\n__exportStar(__webpack_require__(/*! ./types */ \"(rsc)/./node_modules/inngest/node_modules/zod/lib/types.js\"), exports);\n__exportStar(__webpack_require__(/*! ./ZodError */ \"(rsc)/./node_modules/inngest/node_modules/zod/lib/ZodError.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9ub2RlX21vZHVsZXMvem9kL2xpYi9leHRlcm5hbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQSxtQ0FBbUMsb0NBQW9DLGdCQUFnQjtBQUN2RixDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxtQkFBTyxDQUFDLDZFQUFVO0FBQy9CLGFBQWEsbUJBQU8sQ0FBQyxtR0FBcUI7QUFDMUMsYUFBYSxtQkFBTyxDQUFDLHVHQUF1QjtBQUM1QyxhQUFhLG1CQUFPLENBQUMseUZBQWdCO0FBQ3JDLGFBQWEsbUJBQU8sQ0FBQywyRUFBUztBQUM5QixhQUFhLG1CQUFPLENBQUMsaUZBQVkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aXZlLXZpYmUtYWktbmV4dC8uL25vZGVfbW9kdWxlcy9pbm5nZXN0L25vZGVfbW9kdWxlcy96b2QvbGliL2V4dGVybmFsLmpzP2ZmNGUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9lcnJvcnNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2hlbHBlcnMvcGFyc2VVdGlsXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9oZWxwZXJzL3R5cGVBbGlhc2VzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9oZWxwZXJzL3V0aWxcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3R5cGVzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ab2RFcnJvclwiKSwgZXhwb3J0cyk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/node_modules/zod/lib/external.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/node_modules/zod/lib/helpers/errorUtil.js":
/*!************************************************************************!*\
  !*** ./node_modules/inngest/node_modules/zod/lib/helpers/errorUtil.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.errorUtil = void 0;\nvar errorUtil;\n(function (errorUtil) {\n    errorUtil.errToObj = (message) => typeof message === \"string\" ? { message } : message || {};\n    errorUtil.toString = (message) => typeof message === \"string\" ? message : message === null || message === void 0 ? void 0 : message.message;\n})(errorUtil = exports.errorUtil || (exports.errorUtil = {}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9ub2RlX21vZHVsZXMvem9kL2xpYi9oZWxwZXJzL2Vycm9yVXRpbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLHNFQUFzRSxVQUFVO0FBQ2hGO0FBQ0EsQ0FBQyxvQ0FBb0MsaUJBQWlCLEtBQUsiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aXZlLXZpYmUtYWktbmV4dC8uL25vZGVfbW9kdWxlcy9pbm5nZXN0L25vZGVfbW9kdWxlcy96b2QvbGliL2hlbHBlcnMvZXJyb3JVdGlsLmpzP2UxM2EiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmVycm9yVXRpbCA9IHZvaWQgMDtcbnZhciBlcnJvclV0aWw7XG4oZnVuY3Rpb24gKGVycm9yVXRpbCkge1xuICAgIGVycm9yVXRpbC5lcnJUb09iaiA9IChtZXNzYWdlKSA9PiB0eXBlb2YgbWVzc2FnZSA9PT0gXCJzdHJpbmdcIiA/IHsgbWVzc2FnZSB9IDogbWVzc2FnZSB8fCB7fTtcbiAgICBlcnJvclV0aWwudG9TdHJpbmcgPSAobWVzc2FnZSkgPT4gdHlwZW9mIG1lc3NhZ2UgPT09IFwic3RyaW5nXCIgPyBtZXNzYWdlIDogbWVzc2FnZSA9PT0gbnVsbCB8fCBtZXNzYWdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtZXNzYWdlLm1lc3NhZ2U7XG59KShlcnJvclV0aWwgPSBleHBvcnRzLmVycm9yVXRpbCB8fCAoZXhwb3J0cy5lcnJvclV0aWwgPSB7fSkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/node_modules/zod/lib/helpers/errorUtil.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/node_modules/zod/lib/helpers/parseUtil.js":
/*!************************************************************************!*\
  !*** ./node_modules/inngest/node_modules/zod/lib/helpers/parseUtil.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isAsync = exports.isValid = exports.isDirty = exports.isAborted = exports.OK = exports.DIRTY = exports.INVALID = exports.ParseStatus = exports.addIssueToContext = exports.EMPTY_PATH = exports.makeIssue = void 0;\nconst errors_1 = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/inngest/node_modules/zod/lib/errors.js\");\nconst en_1 = __importDefault(__webpack_require__(/*! ../locales/en */ \"(rsc)/./node_modules/inngest/node_modules/zod/lib/locales/en.js\"));\nconst makeIssue = (params) => {\n    const { data, path, errorMaps, issueData } = params;\n    const fullPath = [...path, ...(issueData.path || [])];\n    const fullIssue = {\n        ...issueData,\n        path: fullPath,\n    };\n    let errorMessage = \"\";\n    const maps = errorMaps\n        .filter((m) => !!m)\n        .slice()\n        .reverse();\n    for (const map of maps) {\n        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;\n    }\n    return {\n        ...issueData,\n        path: fullPath,\n        message: issueData.message || errorMessage,\n    };\n};\nexports.makeIssue = makeIssue;\nexports.EMPTY_PATH = [];\nfunction addIssueToContext(ctx, issueData) {\n    const issue = (0, exports.makeIssue)({\n        issueData: issueData,\n        data: ctx.data,\n        path: ctx.path,\n        errorMaps: [\n            ctx.common.contextualErrorMap,\n            ctx.schemaErrorMap,\n            (0, errors_1.getErrorMap)(),\n            en_1.default, // then global default map\n        ].filter((x) => !!x),\n    });\n    ctx.common.issues.push(issue);\n}\nexports.addIssueToContext = addIssueToContext;\nclass ParseStatus {\n    constructor() {\n        this.value = \"valid\";\n    }\n    dirty() {\n        if (this.value === \"valid\")\n            this.value = \"dirty\";\n    }\n    abort() {\n        if (this.value !== \"aborted\")\n            this.value = \"aborted\";\n    }\n    static mergeArray(status, results) {\n        const arrayValue = [];\n        for (const s of results) {\n            if (s.status === \"aborted\")\n                return exports.INVALID;\n            if (s.status === \"dirty\")\n                status.dirty();\n            arrayValue.push(s.value);\n        }\n        return { status: status.value, value: arrayValue };\n    }\n    static async mergeObjectAsync(status, pairs) {\n        const syncPairs = [];\n        for (const pair of pairs) {\n            syncPairs.push({\n                key: await pair.key,\n                value: await pair.value,\n            });\n        }\n        return ParseStatus.mergeObjectSync(status, syncPairs);\n    }\n    static mergeObjectSync(status, pairs) {\n        const finalObject = {};\n        for (const pair of pairs) {\n            const { key, value } = pair;\n            if (key.status === \"aborted\")\n                return exports.INVALID;\n            if (value.status === \"aborted\")\n                return exports.INVALID;\n            if (key.status === \"dirty\")\n                status.dirty();\n            if (value.status === \"dirty\")\n                status.dirty();\n            if (key.value !== \"__proto__\" &&\n                (typeof value.value !== \"undefined\" || pair.alwaysSet)) {\n                finalObject[key.value] = value.value;\n            }\n        }\n        return { status: status.value, value: finalObject };\n    }\n}\nexports.ParseStatus = ParseStatus;\nexports.INVALID = Object.freeze({\n    status: \"aborted\",\n});\nconst DIRTY = (value) => ({ status: \"dirty\", value });\nexports.DIRTY = DIRTY;\nconst OK = (value) => ({ status: \"valid\", value });\nexports.OK = OK;\nconst isAborted = (x) => x.status === \"aborted\";\nexports.isAborted = isAborted;\nconst isDirty = (x) => x.status === \"dirty\";\nexports.isDirty = isDirty;\nconst isValid = (x) => x.status === \"valid\";\nexports.isValid = isValid;\nconst isAsync = (x) => typeof Promise !== \"undefined\" && x instanceof Promise;\nexports.isAsync = isAsync;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9ub2RlX21vZHVsZXMvem9kL2xpYi9oZWxwZXJzL3BhcnNlVXRpbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWUsR0FBRyxlQUFlLEdBQUcsZUFBZSxHQUFHLGlCQUFpQixHQUFHLFVBQVUsR0FBRyxhQUFhLEdBQUcsZUFBZSxHQUFHLG1CQUFtQixHQUFHLHlCQUF5QixHQUFHLGtCQUFrQixHQUFHLGlCQUFpQjtBQUNqTixpQkFBaUIsbUJBQU8sQ0FBQyw4RUFBVztBQUNwQyw2QkFBNkIsbUJBQU8sQ0FBQyxzRkFBZTtBQUNwRDtBQUNBLFlBQVksbUNBQW1DO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msa0NBQWtDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsZUFBZTtBQUNmO0FBQ0EsQ0FBQztBQUNELDRCQUE0Qix3QkFBd0I7QUFDcEQsYUFBYTtBQUNiLHlCQUF5Qix3QkFBd0I7QUFDakQsVUFBVTtBQUNWO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsZUFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpdmUtdmliZS1haS1uZXh0Ly4vbm9kZV9tb2R1bGVzL2lubmdlc3Qvbm9kZV9tb2R1bGVzL3pvZC9saWIvaGVscGVycy9wYXJzZVV0aWwuanM/Yjk1ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXNBc3luYyA9IGV4cG9ydHMuaXNWYWxpZCA9IGV4cG9ydHMuaXNEaXJ0eSA9IGV4cG9ydHMuaXNBYm9ydGVkID0gZXhwb3J0cy5PSyA9IGV4cG9ydHMuRElSVFkgPSBleHBvcnRzLklOVkFMSUQgPSBleHBvcnRzLlBhcnNlU3RhdHVzID0gZXhwb3J0cy5hZGRJc3N1ZVRvQ29udGV4dCA9IGV4cG9ydHMuRU1QVFlfUEFUSCA9IGV4cG9ydHMubWFrZUlzc3VlID0gdm9pZCAwO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpO1xuY29uc3QgZW5fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vbG9jYWxlcy9lblwiKSk7XG5jb25zdCBtYWtlSXNzdWUgPSAocGFyYW1zKSA9PiB7XG4gICAgY29uc3QgeyBkYXRhLCBwYXRoLCBlcnJvck1hcHMsIGlzc3VlRGF0YSB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IGZ1bGxQYXRoID0gWy4uLnBhdGgsIC4uLihpc3N1ZURhdGEucGF0aCB8fCBbXSldO1xuICAgIGNvbnN0IGZ1bGxJc3N1ZSA9IHtcbiAgICAgICAgLi4uaXNzdWVEYXRhLFxuICAgICAgICBwYXRoOiBmdWxsUGF0aCxcbiAgICB9O1xuICAgIGxldCBlcnJvck1lc3NhZ2UgPSBcIlwiO1xuICAgIGNvbnN0IG1hcHMgPSBlcnJvck1hcHNcbiAgICAgICAgLmZpbHRlcigobSkgPT4gISFtKVxuICAgICAgICAuc2xpY2UoKVxuICAgICAgICAucmV2ZXJzZSgpO1xuICAgIGZvciAoY29uc3QgbWFwIG9mIG1hcHMpIHtcbiAgICAgICAgZXJyb3JNZXNzYWdlID0gbWFwKGZ1bGxJc3N1ZSwgeyBkYXRhLCBkZWZhdWx0RXJyb3I6IGVycm9yTWVzc2FnZSB9KS5tZXNzYWdlO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5pc3N1ZURhdGEsXG4gICAgICAgIHBhdGg6IGZ1bGxQYXRoLFxuICAgICAgICBtZXNzYWdlOiBpc3N1ZURhdGEubWVzc2FnZSB8fCBlcnJvck1lc3NhZ2UsXG4gICAgfTtcbn07XG5leHBvcnRzLm1ha2VJc3N1ZSA9IG1ha2VJc3N1ZTtcbmV4cG9ydHMuRU1QVFlfUEFUSCA9IFtdO1xuZnVuY3Rpb24gYWRkSXNzdWVUb0NvbnRleHQoY3R4LCBpc3N1ZURhdGEpIHtcbiAgICBjb25zdCBpc3N1ZSA9ICgwLCBleHBvcnRzLm1ha2VJc3N1ZSkoe1xuICAgICAgICBpc3N1ZURhdGE6IGlzc3VlRGF0YSxcbiAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICBlcnJvck1hcHM6IFtcbiAgICAgICAgICAgIGN0eC5jb21tb24uY29udGV4dHVhbEVycm9yTWFwLFxuICAgICAgICAgICAgY3R4LnNjaGVtYUVycm9yTWFwLFxuICAgICAgICAgICAgKDAsIGVycm9yc18xLmdldEVycm9yTWFwKSgpLFxuICAgICAgICAgICAgZW5fMS5kZWZhdWx0LCAvLyB0aGVuIGdsb2JhbCBkZWZhdWx0IG1hcFxuICAgICAgICBdLmZpbHRlcigoeCkgPT4gISF4KSxcbiAgICB9KTtcbiAgICBjdHguY29tbW9uLmlzc3Vlcy5wdXNoKGlzc3VlKTtcbn1cbmV4cG9ydHMuYWRkSXNzdWVUb0NvbnRleHQgPSBhZGRJc3N1ZVRvQ29udGV4dDtcbmNsYXNzIFBhcnNlU3RhdHVzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IFwidmFsaWRcIjtcbiAgICB9XG4gICAgZGlydHkoKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlID09PSBcInZhbGlkXCIpXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gXCJkaXJ0eVwiO1xuICAgIH1cbiAgICBhYm9ydCgpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgIT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFwiYWJvcnRlZFwiO1xuICAgIH1cbiAgICBzdGF0aWMgbWVyZ2VBcnJheShzdGF0dXMsIHJlc3VsdHMpIHtcbiAgICAgICAgY29uc3QgYXJyYXlWYWx1ZSA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHMgb2YgcmVzdWx0cykge1xuICAgICAgICAgICAgaWYgKHMuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5JTlZBTElEO1xuICAgICAgICAgICAgaWYgKHMuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICBhcnJheVZhbHVlLnB1c2gocy52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBhcnJheVZhbHVlIH07XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBtZXJnZU9iamVjdEFzeW5jKHN0YXR1cywgcGFpcnMpIHtcbiAgICAgICAgY29uc3Qgc3luY1BhaXJzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgICAgICAgc3luY1BhaXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIGtleTogYXdhaXQgcGFpci5rZXksXG4gICAgICAgICAgICAgICAgdmFsdWU6IGF3YWl0IHBhaXIudmFsdWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VPYmplY3RTeW5jKHN0YXR1cywgc3luY1BhaXJzKTtcbiAgICB9XG4gICAgc3RhdGljIG1lcmdlT2JqZWN0U3luYyhzdGF0dXMsIHBhaXJzKSB7XG4gICAgICAgIGNvbnN0IGZpbmFsT2JqZWN0ID0ge307XG4gICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgICAgICAgY29uc3QgeyBrZXksIHZhbHVlIH0gPSBwYWlyO1xuICAgICAgICAgICAgaWYgKGtleS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBleHBvcnRzLklOVkFMSUQ7XG4gICAgICAgICAgICBpZiAodmFsdWUuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5JTlZBTElEO1xuICAgICAgICAgICAgaWYgKGtleS5zdGF0dXMgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5zdGF0dXMgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIGlmIChrZXkudmFsdWUgIT09IFwiX19wcm90b19fXCIgJiZcbiAgICAgICAgICAgICAgICAodHlwZW9mIHZhbHVlLnZhbHVlICE9PSBcInVuZGVmaW5lZFwiIHx8IHBhaXIuYWx3YXlzU2V0KSkge1xuICAgICAgICAgICAgICAgIGZpbmFsT2JqZWN0W2tleS52YWx1ZV0gPSB2YWx1ZS52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGZpbmFsT2JqZWN0IH07XG4gICAgfVxufVxuZXhwb3J0cy5QYXJzZVN0YXR1cyA9IFBhcnNlU3RhdHVzO1xuZXhwb3J0cy5JTlZBTElEID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgc3RhdHVzOiBcImFib3J0ZWRcIixcbn0pO1xuY29uc3QgRElSVFkgPSAodmFsdWUpID0+ICh7IHN0YXR1czogXCJkaXJ0eVwiLCB2YWx1ZSB9KTtcbmV4cG9ydHMuRElSVFkgPSBESVJUWTtcbmNvbnN0IE9LID0gKHZhbHVlKSA9PiAoeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWUgfSk7XG5leHBvcnRzLk9LID0gT0s7XG5jb25zdCBpc0Fib3J0ZWQgPSAoeCkgPT4geC5zdGF0dXMgPT09IFwiYWJvcnRlZFwiO1xuZXhwb3J0cy5pc0Fib3J0ZWQgPSBpc0Fib3J0ZWQ7XG5jb25zdCBpc0RpcnR5ID0gKHgpID0+IHguc3RhdHVzID09PSBcImRpcnR5XCI7XG5leHBvcnRzLmlzRGlydHkgPSBpc0RpcnR5O1xuY29uc3QgaXNWYWxpZCA9ICh4KSA9PiB4LnN0YXR1cyA9PT0gXCJ2YWxpZFwiO1xuZXhwb3J0cy5pc1ZhbGlkID0gaXNWYWxpZDtcbmNvbnN0IGlzQXN5bmMgPSAoeCkgPT4gdHlwZW9mIFByb21pc2UgIT09IFwidW5kZWZpbmVkXCIgJiYgeCBpbnN0YW5jZW9mIFByb21pc2U7XG5leHBvcnRzLmlzQXN5bmMgPSBpc0FzeW5jO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/node_modules/zod/lib/helpers/parseUtil.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/node_modules/zod/lib/helpers/typeAliases.js":
/*!**************************************************************************!*\
  !*** ./node_modules/inngest/node_modules/zod/lib/helpers/typeAliases.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9ub2RlX21vZHVsZXMvem9kL2xpYi9oZWxwZXJzL3R5cGVBbGlhc2VzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdml2ZS12aWJlLWFpLW5leHQvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9ub2RlX21vZHVsZXMvem9kL2xpYi9oZWxwZXJzL3R5cGVBbGlhc2VzLmpzPzYxMmYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/node_modules/zod/lib/helpers/typeAliases.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/node_modules/zod/lib/helpers/util.js":
/*!*******************************************************************!*\
  !*** ./node_modules/inngest/node_modules/zod/lib/helpers/util.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getParsedType = exports.ZodParsedType = exports.objectUtil = exports.util = void 0;\nvar util;\n(function (util) {\n    util.assertEqual = (val) => val;\n    function assertIs(_arg) { }\n    util.assertIs = assertIs;\n    function assertNever(_x) {\n        throw new Error();\n    }\n    util.assertNever = assertNever;\n    util.arrayToEnum = (items) => {\n        const obj = {};\n        for (const item of items) {\n            obj[item] = item;\n        }\n        return obj;\n    };\n    util.getValidEnumValues = (obj) => {\n        const validKeys = util.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== \"number\");\n        const filtered = {};\n        for (const k of validKeys) {\n            filtered[k] = obj[k];\n        }\n        return util.objectValues(filtered);\n    };\n    util.objectValues = (obj) => {\n        return util.objectKeys(obj).map(function (e) {\n            return obj[e];\n        });\n    };\n    util.objectKeys = typeof Object.keys === \"function\" // eslint-disable-line ban/ban\n        ? (obj) => Object.keys(obj) // eslint-disable-line ban/ban\n        : (object) => {\n            const keys = [];\n            for (const key in object) {\n                if (Object.prototype.hasOwnProperty.call(object, key)) {\n                    keys.push(key);\n                }\n            }\n            return keys;\n        };\n    util.find = (arr, checker) => {\n        for (const item of arr) {\n            if (checker(item))\n                return item;\n        }\n        return undefined;\n    };\n    util.isInteger = typeof Number.isInteger === \"function\"\n        ? (val) => Number.isInteger(val) // eslint-disable-line ban/ban\n        : (val) => typeof val === \"number\" && isFinite(val) && Math.floor(val) === val;\n    function joinValues(array, separator = \" | \") {\n        return array\n            .map((val) => (typeof val === \"string\" ? `'${val}'` : val))\n            .join(separator);\n    }\n    util.joinValues = joinValues;\n    util.jsonStringifyReplacer = (_, value) => {\n        if (typeof value === \"bigint\") {\n            return value.toString();\n        }\n        return value;\n    };\n})(util = exports.util || (exports.util = {}));\nvar objectUtil;\n(function (objectUtil) {\n    objectUtil.mergeShapes = (first, second) => {\n        return {\n            ...first,\n            ...second, // second overwrites first\n        };\n    };\n})(objectUtil = exports.objectUtil || (exports.objectUtil = {}));\nexports.ZodParsedType = util.arrayToEnum([\n    \"string\",\n    \"nan\",\n    \"number\",\n    \"integer\",\n    \"float\",\n    \"boolean\",\n    \"date\",\n    \"bigint\",\n    \"symbol\",\n    \"function\",\n    \"undefined\",\n    \"null\",\n    \"array\",\n    \"object\",\n    \"unknown\",\n    \"promise\",\n    \"void\",\n    \"never\",\n    \"map\",\n    \"set\",\n]);\nconst getParsedType = (data) => {\n    const t = typeof data;\n    switch (t) {\n        case \"undefined\":\n            return exports.ZodParsedType.undefined;\n        case \"string\":\n            return exports.ZodParsedType.string;\n        case \"number\":\n            return isNaN(data) ? exports.ZodParsedType.nan : exports.ZodParsedType.number;\n        case \"boolean\":\n            return exports.ZodParsedType.boolean;\n        case \"function\":\n            return exports.ZodParsedType.function;\n        case \"bigint\":\n            return exports.ZodParsedType.bigint;\n        case \"symbol\":\n            return exports.ZodParsedType.symbol;\n        case \"object\":\n            if (Array.isArray(data)) {\n                return exports.ZodParsedType.array;\n            }\n            if (data === null) {\n                return exports.ZodParsedType.null;\n            }\n            if (data.then &&\n                typeof data.then === \"function\" &&\n                data.catch &&\n                typeof data.catch === \"function\") {\n                return exports.ZodParsedType.promise;\n            }\n            if (typeof Map !== \"undefined\" && data instanceof Map) {\n                return exports.ZodParsedType.map;\n            }\n            if (typeof Set !== \"undefined\" && data instanceof Set) {\n                return exports.ZodParsedType.set;\n            }\n            if (typeof Date !== \"undefined\" && data instanceof Date) {\n                return exports.ZodParsedType.date;\n            }\n            return exports.ZodParsedType.object;\n        default:\n            return exports.ZodParsedType.unknown;\n    }\n};\nexports.getParsedType = getParsedType;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9ub2RlX21vZHVsZXMvem9kL2xpYi9oZWxwZXJzL3V0aWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcsa0JBQWtCLEdBQUcsWUFBWTtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELElBQUk7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQkFBMEIsWUFBWSxLQUFLO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNDQUFzQyxrQkFBa0IsS0FBSztBQUM5RCxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpdmUtdmliZS1haS1uZXh0Ly4vbm9kZV9tb2R1bGVzL2lubmdlc3Qvbm9kZV9tb2R1bGVzL3pvZC9saWIvaGVscGVycy91dGlsLmpzPzFmMzQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldFBhcnNlZFR5cGUgPSBleHBvcnRzLlpvZFBhcnNlZFR5cGUgPSBleHBvcnRzLm9iamVjdFV0aWwgPSBleHBvcnRzLnV0aWwgPSB2b2lkIDA7XG52YXIgdXRpbDtcbihmdW5jdGlvbiAodXRpbCkge1xuICAgIHV0aWwuYXNzZXJ0RXF1YWwgPSAodmFsKSA9PiB2YWw7XG4gICAgZnVuY3Rpb24gYXNzZXJ0SXMoX2FyZykgeyB9XG4gICAgdXRpbC5hc3NlcnRJcyA9IGFzc2VydElzO1xuICAgIGZ1bmN0aW9uIGFzc2VydE5ldmVyKF94KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgIH1cbiAgICB1dGlsLmFzc2VydE5ldmVyID0gYXNzZXJ0TmV2ZXI7XG4gICAgdXRpbC5hcnJheVRvRW51bSA9IChpdGVtcykgPT4ge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICAgICAgICBvYmpbaXRlbV0gPSBpdGVtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcbiAgICB1dGlsLmdldFZhbGlkRW51bVZhbHVlcyA9IChvYmopID0+IHtcbiAgICAgICAgY29uc3QgdmFsaWRLZXlzID0gdXRpbC5vYmplY3RLZXlzKG9iaikuZmlsdGVyKChrKSA9PiB0eXBlb2Ygb2JqW29ialtrXV0gIT09IFwibnVtYmVyXCIpO1xuICAgICAgICBjb25zdCBmaWx0ZXJlZCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGsgb2YgdmFsaWRLZXlzKSB7XG4gICAgICAgICAgICBmaWx0ZXJlZFtrXSA9IG9ialtrXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXRpbC5vYmplY3RWYWx1ZXMoZmlsdGVyZWQpO1xuICAgIH07XG4gICAgdXRpbC5vYmplY3RWYWx1ZXMgPSAob2JqKSA9PiB7XG4gICAgICAgIHJldHVybiB1dGlsLm9iamVjdEtleXMob2JqKS5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmpbZV07XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgdXRpbC5vYmplY3RLZXlzID0gdHlwZW9mIE9iamVjdC5rZXlzID09PSBcImZ1bmN0aW9uXCIgLy8gZXNsaW50LWRpc2FibGUtbGluZSBiYW4vYmFuXG4gICAgICAgID8gKG9iaikgPT4gT2JqZWN0LmtleXMob2JqKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGJhbi9iYW5cbiAgICAgICAgOiAob2JqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBrZXlzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ga2V5cztcbiAgICAgICAgfTtcbiAgICB1dGlsLmZpbmQgPSAoYXJyLCBjaGVja2VyKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBhcnIpIHtcbiAgICAgICAgICAgIGlmIChjaGVja2VyKGl0ZW0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICB1dGlsLmlzSW50ZWdlciA9IHR5cGVvZiBOdW1iZXIuaXNJbnRlZ2VyID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgPyAodmFsKSA9PiBOdW1iZXIuaXNJbnRlZ2VyKHZhbCkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBiYW4vYmFuXG4gICAgICAgIDogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIiAmJiBpc0Zpbml0ZSh2YWwpICYmIE1hdGguZmxvb3IodmFsKSA9PT0gdmFsO1xuICAgIGZ1bmN0aW9uIGpvaW5WYWx1ZXMoYXJyYXksIHNlcGFyYXRvciA9IFwiIHwgXCIpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5XG4gICAgICAgICAgICAubWFwKCh2YWwpID0+ICh0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiID8gYCcke3ZhbH0nYCA6IHZhbCkpXG4gICAgICAgICAgICAuam9pbihzZXBhcmF0b3IpO1xuICAgIH1cbiAgICB1dGlsLmpvaW5WYWx1ZXMgPSBqb2luVmFsdWVzO1xuICAgIHV0aWwuanNvblN0cmluZ2lmeVJlcGxhY2VyID0gKF8sIHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYmlnaW50XCIpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xufSkodXRpbCA9IGV4cG9ydHMudXRpbCB8fCAoZXhwb3J0cy51dGlsID0ge30pKTtcbnZhciBvYmplY3RVdGlsO1xuKGZ1bmN0aW9uIChvYmplY3RVdGlsKSB7XG4gICAgb2JqZWN0VXRpbC5tZXJnZVNoYXBlcyA9IChmaXJzdCwgc2Vjb25kKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5maXJzdCxcbiAgICAgICAgICAgIC4uLnNlY29uZCwgLy8gc2Vjb25kIG92ZXJ3cml0ZXMgZmlyc3RcbiAgICAgICAgfTtcbiAgICB9O1xufSkob2JqZWN0VXRpbCA9IGV4cG9ydHMub2JqZWN0VXRpbCB8fCAoZXhwb3J0cy5vYmplY3RVdGlsID0ge30pKTtcbmV4cG9ydHMuWm9kUGFyc2VkVHlwZSA9IHV0aWwuYXJyYXlUb0VudW0oW1xuICAgIFwic3RyaW5nXCIsXG4gICAgXCJuYW5cIixcbiAgICBcIm51bWJlclwiLFxuICAgIFwiaW50ZWdlclwiLFxuICAgIFwiZmxvYXRcIixcbiAgICBcImJvb2xlYW5cIixcbiAgICBcImRhdGVcIixcbiAgICBcImJpZ2ludFwiLFxuICAgIFwic3ltYm9sXCIsXG4gICAgXCJmdW5jdGlvblwiLFxuICAgIFwidW5kZWZpbmVkXCIsXG4gICAgXCJudWxsXCIsXG4gICAgXCJhcnJheVwiLFxuICAgIFwib2JqZWN0XCIsXG4gICAgXCJ1bmtub3duXCIsXG4gICAgXCJwcm9taXNlXCIsXG4gICAgXCJ2b2lkXCIsXG4gICAgXCJuZXZlclwiLFxuICAgIFwibWFwXCIsXG4gICAgXCJzZXRcIixcbl0pO1xuY29uc3QgZ2V0UGFyc2VkVHlwZSA9IChkYXRhKSA9PiB7XG4gICAgY29uc3QgdCA9IHR5cGVvZiBkYXRhO1xuICAgIHN3aXRjaCAodCkge1xuICAgICAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5ab2RQYXJzZWRUeXBlLnVuZGVmaW5lZDtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuWm9kUGFyc2VkVHlwZS5zdHJpbmc7XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgIHJldHVybiBpc05hTihkYXRhKSA/IGV4cG9ydHMuWm9kUGFyc2VkVHlwZS5uYW4gOiBleHBvcnRzLlpvZFBhcnNlZFR5cGUubnVtYmVyO1xuICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuWm9kUGFyc2VkVHlwZS5ib29sZWFuO1xuICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLlpvZFBhcnNlZFR5cGUuZnVuY3Rpb247XG4gICAgICAgIGNhc2UgXCJiaWdpbnRcIjpcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLlpvZFBhcnNlZFR5cGUuYmlnaW50O1xuICAgICAgICBjYXNlIFwic3ltYm9sXCI6XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5ab2RQYXJzZWRUeXBlLnN5bWJvbDtcbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5ab2RQYXJzZWRUeXBlLmFycmF5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5ab2RQYXJzZWRUeXBlLm51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YS50aGVuICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGRhdGEudGhlbiA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICAgICAgZGF0YS5jYXRjaCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBkYXRhLmNhdGNoID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5ab2RQYXJzZWRUeXBlLnByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIE1hcCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkYXRhIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuWm9kUGFyc2VkVHlwZS5tYXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIFNldCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkYXRhIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuWm9kUGFyc2VkVHlwZS5zZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIERhdGUgIT09IFwidW5kZWZpbmVkXCIgJiYgZGF0YSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5ab2RQYXJzZWRUeXBlLmRhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5ab2RQYXJzZWRUeXBlLm9iamVjdDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLlpvZFBhcnNlZFR5cGUudW5rbm93bjtcbiAgICB9XG59O1xuZXhwb3J0cy5nZXRQYXJzZWRUeXBlID0gZ2V0UGFyc2VkVHlwZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/node_modules/zod/lib/helpers/util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/node_modules/zod/lib/index.js":
/*!************************************************************!*\
  !*** ./node_modules/inngest/node_modules/zod/lib/index.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.z = void 0;\nconst z = __importStar(__webpack_require__(/*! ./external */ \"(rsc)/./node_modules/inngest/node_modules/zod/lib/external.js\"));\nexports.z = z;\n__exportStar(__webpack_require__(/*! ./external */ \"(rsc)/./node_modules/inngest/node_modules/zod/lib/external.js\"), exports);\nexports[\"default\"] = z;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9ub2RlX21vZHVsZXMvem9kL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQSxtQ0FBbUMsb0NBQW9DLGdCQUFnQjtBQUN2RixDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELFNBQVM7QUFDVCx1QkFBdUIsbUJBQU8sQ0FBQyxpRkFBWTtBQUMzQyxTQUFTO0FBQ1QsYUFBYSxtQkFBTyxDQUFDLGlGQUFZO0FBQ2pDLGtCQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdml2ZS12aWJlLWFpLW5leHQvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9ub2RlX21vZHVsZXMvem9kL2xpYi9pbmRleC5qcz81YjYzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy56ID0gdm9pZCAwO1xuY29uc3QgeiA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9leHRlcm5hbFwiKSk7XG5leHBvcnRzLnogPSB6O1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2V4dGVybmFsXCIpLCBleHBvcnRzKTtcbmV4cG9ydHMuZGVmYXVsdCA9IHo7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/node_modules/zod/lib/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/node_modules/zod/lib/locales/en.js":
/*!*****************************************************************!*\
  !*** ./node_modules/inngest/node_modules/zod/lib/locales/en.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst util_1 = __webpack_require__(/*! ../helpers/util */ \"(rsc)/./node_modules/inngest/node_modules/zod/lib/helpers/util.js\");\nconst ZodError_1 = __webpack_require__(/*! ../ZodError */ \"(rsc)/./node_modules/inngest/node_modules/zod/lib/ZodError.js\");\nconst errorMap = (issue, _ctx) => {\n    let message;\n    switch (issue.code) {\n        case ZodError_1.ZodIssueCode.invalid_type:\n            if (issue.received === util_1.ZodParsedType.undefined) {\n                message = \"Required\";\n            }\n            else {\n                message = `Expected ${issue.expected}, received ${issue.received}`;\n            }\n            break;\n        case ZodError_1.ZodIssueCode.invalid_literal:\n            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util_1.util.jsonStringifyReplacer)}`;\n            break;\n        case ZodError_1.ZodIssueCode.unrecognized_keys:\n            message = `Unrecognized key(s) in object: ${util_1.util.joinValues(issue.keys, \", \")}`;\n            break;\n        case ZodError_1.ZodIssueCode.invalid_union:\n            message = `Invalid input`;\n            break;\n        case ZodError_1.ZodIssueCode.invalid_union_discriminator:\n            message = `Invalid discriminator value. Expected ${util_1.util.joinValues(issue.options)}`;\n            break;\n        case ZodError_1.ZodIssueCode.invalid_enum_value:\n            message = `Invalid enum value. Expected ${util_1.util.joinValues(issue.options)}, received '${issue.received}'`;\n            break;\n        case ZodError_1.ZodIssueCode.invalid_arguments:\n            message = `Invalid function arguments`;\n            break;\n        case ZodError_1.ZodIssueCode.invalid_return_type:\n            message = `Invalid function return type`;\n            break;\n        case ZodError_1.ZodIssueCode.invalid_date:\n            message = `Invalid date`;\n            break;\n        case ZodError_1.ZodIssueCode.invalid_string:\n            if (typeof issue.validation === \"object\") {\n                if (\"includes\" in issue.validation) {\n                    message = `Invalid input: must include \"${issue.validation.includes}\"`;\n                    if (typeof issue.validation.position === \"number\") {\n                        message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;\n                    }\n                }\n                else if (\"startsWith\" in issue.validation) {\n                    message = `Invalid input: must start with \"${issue.validation.startsWith}\"`;\n                }\n                else if (\"endsWith\" in issue.validation) {\n                    message = `Invalid input: must end with \"${issue.validation.endsWith}\"`;\n                }\n                else {\n                    util_1.util.assertNever(issue.validation);\n                }\n            }\n            else if (issue.validation !== \"regex\") {\n                message = `Invalid ${issue.validation}`;\n            }\n            else {\n                message = \"Invalid\";\n            }\n            break;\n        case ZodError_1.ZodIssueCode.too_small:\n            if (issue.type === \"array\")\n                message = `Array must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;\n            else if (issue.type === \"string\")\n                message = `String must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;\n            else if (issue.type === \"number\")\n                message = `Number must be ${issue.exact\n                    ? `exactly equal to `\n                    : issue.inclusive\n                        ? `greater than or equal to `\n                        : `greater than `}${issue.minimum}`;\n            else if (issue.type === \"date\")\n                message = `Date must be ${issue.exact\n                    ? `exactly equal to `\n                    : issue.inclusive\n                        ? `greater than or equal to `\n                        : `greater than `}${new Date(Number(issue.minimum))}`;\n            else\n                message = \"Invalid input\";\n            break;\n        case ZodError_1.ZodIssueCode.too_big:\n            if (issue.type === \"array\")\n                message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;\n            else if (issue.type === \"string\")\n                message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;\n            else if (issue.type === \"number\")\n                message = `Number must be ${issue.exact\n                    ? `exactly`\n                    : issue.inclusive\n                        ? `less than or equal to`\n                        : `less than`} ${issue.maximum}`;\n            else if (issue.type === \"bigint\")\n                message = `BigInt must be ${issue.exact\n                    ? `exactly`\n                    : issue.inclusive\n                        ? `less than or equal to`\n                        : `less than`} ${issue.maximum}`;\n            else if (issue.type === \"date\")\n                message = `Date must be ${issue.exact\n                    ? `exactly`\n                    : issue.inclusive\n                        ? `smaller than or equal to`\n                        : `smaller than`} ${new Date(Number(issue.maximum))}`;\n            else\n                message = \"Invalid input\";\n            break;\n        case ZodError_1.ZodIssueCode.custom:\n            message = `Invalid input`;\n            break;\n        case ZodError_1.ZodIssueCode.invalid_intersection_types:\n            message = `Intersection results could not be merged`;\n            break;\n        case ZodError_1.ZodIssueCode.not_multiple_of:\n            message = `Number must be a multiple of ${issue.multipleOf}`;\n            break;\n        case ZodError_1.ZodIssueCode.not_finite:\n            message = \"Number must be finite\";\n            break;\n        default:\n            message = _ctx.defaultError;\n            util_1.util.assertNever(issue);\n    }\n    return { message };\n};\nexports[\"default\"] = errorMap;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9ub2RlX21vZHVsZXMvem9kL2xpYi9sb2NhbGVzL2VuLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWUsbUJBQU8sQ0FBQywwRkFBaUI7QUFDeEMsbUJBQW1CLG1CQUFPLENBQUMsa0ZBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxlQUFlLGFBQWEsZUFBZTtBQUNqRjtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsa0VBQWtFO0FBQzNIO0FBQ0E7QUFDQSx3REFBd0QseUNBQXlDO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Qsc0NBQXNDO0FBQ3JHO0FBQ0E7QUFDQSxzREFBc0Qsc0NBQXNDLGNBQWMsZUFBZTtBQUN6SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCwwQkFBMEI7QUFDeEY7QUFDQSxxQ0FBcUMsU0FBUyxvREFBb0QsMEJBQTBCO0FBQzVIO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSw0QkFBNEI7QUFDN0Y7QUFDQTtBQUNBLCtEQUErRCwwQkFBMEI7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGlCQUFpQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxzRUFBc0UsRUFBRSxlQUFlO0FBQ3ZJO0FBQ0EsaURBQWlELGlFQUFpRSxFQUFFLGVBQWU7QUFDbkk7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLEVBQUUsY0FBYztBQUMxRDtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsRUFBRSxnQ0FBZ0M7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxxRUFBcUUsRUFBRSxlQUFlO0FBQ3RJO0FBQ0EsaURBQWlELGlFQUFpRSxFQUFFLGVBQWU7QUFDbkk7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLEVBQUUsY0FBYztBQUN2RDtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsRUFBRSxjQUFjO0FBQ3ZEO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxFQUFFLGdDQUFnQztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxpQkFBaUI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGtCQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdml2ZS12aWJlLWFpLW5leHQvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9ub2RlX21vZHVsZXMvem9kL2xpYi9sb2NhbGVzL2VuLmpzPzE5ZDQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy91dGlsXCIpO1xuY29uc3QgWm9kRXJyb3JfMSA9IHJlcXVpcmUoXCIuLi9ab2RFcnJvclwiKTtcbmNvbnN0IGVycm9yTWFwID0gKGlzc3VlLCBfY3R4KSA9PiB7XG4gICAgbGV0IG1lc3NhZ2U7XG4gICAgc3dpdGNoIChpc3N1ZS5jb2RlKSB7XG4gICAgICAgIGNhc2UgWm9kRXJyb3JfMS5ab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlOlxuICAgICAgICAgICAgaWYgKGlzc3VlLnJlY2VpdmVkID09PSB1dGlsXzEuWm9kUGFyc2VkVHlwZS51bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJSZXF1aXJlZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBFeHBlY3RlZCAke2lzc3VlLmV4cGVjdGVkfSwgcmVjZWl2ZWQgJHtpc3N1ZS5yZWNlaXZlZH1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kRXJyb3JfMS5ab2RJc3N1ZUNvZGUuaW52YWxpZF9saXRlcmFsOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGxpdGVyYWwgdmFsdWUsIGV4cGVjdGVkICR7SlNPTi5zdHJpbmdpZnkoaXNzdWUuZXhwZWN0ZWQsIHV0aWxfMS51dGlsLmpzb25TdHJpbmdpZnlSZXBsYWNlcil9YDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZEVycm9yXzEuWm9kSXNzdWVDb2RlLnVucmVjb2duaXplZF9rZXlzOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBVbnJlY29nbml6ZWQga2V5KHMpIGluIG9iamVjdDogJHt1dGlsXzEudXRpbC5qb2luVmFsdWVzKGlzc3VlLmtleXMsIFwiLCBcIil9YDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZEVycm9yXzEuWm9kSXNzdWVDb2RlLmludmFsaWRfdW5pb246XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgaW5wdXRgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kRXJyb3JfMS5ab2RJc3N1ZUNvZGUuaW52YWxpZF91bmlvbl9kaXNjcmltaW5hdG9yOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGRpc2NyaW1pbmF0b3IgdmFsdWUuIEV4cGVjdGVkICR7dXRpbF8xLnV0aWwuam9pblZhbHVlcyhpc3N1ZS5vcHRpb25zKX1gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kRXJyb3JfMS5ab2RJc3N1ZUNvZGUuaW52YWxpZF9lbnVtX3ZhbHVlOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGVudW0gdmFsdWUuIEV4cGVjdGVkICR7dXRpbF8xLnV0aWwuam9pblZhbHVlcyhpc3N1ZS5vcHRpb25zKX0sIHJlY2VpdmVkICcke2lzc3VlLnJlY2VpdmVkfSdgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kRXJyb3JfMS5ab2RJc3N1ZUNvZGUuaW52YWxpZF9hcmd1bWVudHM6XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgZnVuY3Rpb24gYXJndW1lbnRzYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZEVycm9yXzEuWm9kSXNzdWVDb2RlLmludmFsaWRfcmV0dXJuX3R5cGU6XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgZnVuY3Rpb24gcmV0dXJuIHR5cGVgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kRXJyb3JfMS5ab2RJc3N1ZUNvZGUuaW52YWxpZF9kYXRlOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGRhdGVgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kRXJyb3JfMS5ab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmc6XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlzc3VlLnZhbGlkYXRpb24gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoXCJpbmNsdWRlc1wiIGluIGlzc3VlLnZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGlucHV0OiBtdXN0IGluY2x1ZGUgXCIke2lzc3VlLnZhbGlkYXRpb24uaW5jbHVkZXN9XCJgO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGlzc3VlLnZhbGlkYXRpb24ucG9zaXRpb24gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgJHttZXNzYWdlfSBhdCBvbmUgb3IgbW9yZSBwb3NpdGlvbnMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvICR7aXNzdWUudmFsaWRhdGlvbi5wb3NpdGlvbn1gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKFwic3RhcnRzV2l0aFwiIGluIGlzc3VlLnZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGlucHV0OiBtdXN0IHN0YXJ0IHdpdGggXCIke2lzc3VlLnZhbGlkYXRpb24uc3RhcnRzV2l0aH1cImA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKFwiZW5kc1dpdGhcIiBpbiBpc3N1ZS52YWxpZGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBpbnB1dDogbXVzdCBlbmQgd2l0aCBcIiR7aXNzdWUudmFsaWRhdGlvbi5lbmRzV2l0aH1cImA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB1dGlsXzEudXRpbC5hc3NlcnROZXZlcihpc3N1ZS52YWxpZGF0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS52YWxpZGF0aW9uICE9PSBcInJlZ2V4XCIpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgJHtpc3N1ZS52YWxpZGF0aW9ufWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJJbnZhbGlkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RFcnJvcl8xLlpvZElzc3VlQ29kZS50b29fc21hbGw6XG4gICAgICAgICAgICBpZiAoaXNzdWUudHlwZSA9PT0gXCJhcnJheVwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgQXJyYXkgbXVzdCBjb250YWluICR7aXNzdWUuZXhhY3QgPyBcImV4YWN0bHlcIiA6IGlzc3VlLmluY2x1c2l2ZSA/IGBhdCBsZWFzdGAgOiBgbW9yZSB0aGFuYH0gJHtpc3N1ZS5taW5pbXVtfSBlbGVtZW50KHMpYDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBTdHJpbmcgbXVzdCBjb250YWluICR7aXNzdWUuZXhhY3QgPyBcImV4YWN0bHlcIiA6IGlzc3VlLmluY2x1c2l2ZSA/IGBhdCBsZWFzdGAgOiBgb3ZlcmB9ICR7aXNzdWUubWluaW11bX0gY2hhcmFjdGVyKHMpYDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBOdW1iZXIgbXVzdCBiZSAke2lzc3VlLmV4YWN0XG4gICAgICAgICAgICAgICAgICAgID8gYGV4YWN0bHkgZXF1YWwgdG8gYFxuICAgICAgICAgICAgICAgICAgICA6IGlzc3VlLmluY2x1c2l2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGBcbiAgICAgICAgICAgICAgICAgICAgICAgIDogYGdyZWF0ZXIgdGhhbiBgfSR7aXNzdWUubWluaW11bX1gO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJkYXRlXCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBEYXRlIG11c3QgYmUgJHtpc3N1ZS5leGFjdFxuICAgICAgICAgICAgICAgICAgICA/IGBleGFjdGx5IGVxdWFsIHRvIGBcbiAgICAgICAgICAgICAgICAgICAgOiBpc3N1ZS5pbmNsdXNpdmVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBgXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGBncmVhdGVyIHRoYW4gYH0ke25ldyBEYXRlKE51bWJlcihpc3N1ZS5taW5pbXVtKSl9YDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJJbnZhbGlkIGlucHV0XCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RFcnJvcl8xLlpvZElzc3VlQ29kZS50b29fYmlnOlxuICAgICAgICAgICAgaWYgKGlzc3VlLnR5cGUgPT09IFwiYXJyYXlcIilcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYEFycmF5IG11c3QgY29udGFpbiAke2lzc3VlLmV4YWN0ID8gYGV4YWN0bHlgIDogaXNzdWUuaW5jbHVzaXZlID8gYGF0IG1vc3RgIDogYGxlc3MgdGhhbmB9ICR7aXNzdWUubWF4aW11bX0gZWxlbWVudChzKWA7XG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgU3RyaW5nIG11c3QgY29udGFpbiAke2lzc3VlLmV4YWN0ID8gYGV4YWN0bHlgIDogaXNzdWUuaW5jbHVzaXZlID8gYGF0IG1vc3RgIDogYHVuZGVyYH0gJHtpc3N1ZS5tYXhpbXVtfSBjaGFyYWN0ZXIocylgO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYE51bWJlciBtdXN0IGJlICR7aXNzdWUuZXhhY3RcbiAgICAgICAgICAgICAgICAgICAgPyBgZXhhY3RseWBcbiAgICAgICAgICAgICAgICAgICAgOiBpc3N1ZS5pbmNsdXNpdmVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYGxlc3MgdGhhbiBvciBlcXVhbCB0b2BcbiAgICAgICAgICAgICAgICAgICAgICAgIDogYGxlc3MgdGhhbmB9ICR7aXNzdWUubWF4aW11bX1gO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJiaWdpbnRcIilcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYEJpZ0ludCBtdXN0IGJlICR7aXNzdWUuZXhhY3RcbiAgICAgICAgICAgICAgICAgICAgPyBgZXhhY3RseWBcbiAgICAgICAgICAgICAgICAgICAgOiBpc3N1ZS5pbmNsdXNpdmVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYGxlc3MgdGhhbiBvciBlcXVhbCB0b2BcbiAgICAgICAgICAgICAgICAgICAgICAgIDogYGxlc3MgdGhhbmB9ICR7aXNzdWUubWF4aW11bX1gO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJkYXRlXCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBEYXRlIG11c3QgYmUgJHtpc3N1ZS5leGFjdFxuICAgICAgICAgICAgICAgICAgICA/IGBleGFjdGx5YFxuICAgICAgICAgICAgICAgICAgICA6IGlzc3VlLmluY2x1c2l2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBgc21hbGxlciB0aGFuIG9yIGVxdWFsIHRvYFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBgc21hbGxlciB0aGFuYH0gJHtuZXcgRGF0ZShOdW1iZXIoaXNzdWUubWF4aW11bSkpfWA7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IFwiSW52YWxpZCBpbnB1dFwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kRXJyb3JfMS5ab2RJc3N1ZUNvZGUuY3VzdG9tOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGlucHV0YDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZEVycm9yXzEuWm9kSXNzdWVDb2RlLmludmFsaWRfaW50ZXJzZWN0aW9uX3R5cGVzOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnRlcnNlY3Rpb24gcmVzdWx0cyBjb3VsZCBub3QgYmUgbWVyZ2VkYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZEVycm9yXzEuWm9kSXNzdWVDb2RlLm5vdF9tdWx0aXBsZV9vZjpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgTnVtYmVyIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAke2lzc3VlLm11bHRpcGxlT2Z9YDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZEVycm9yXzEuWm9kSXNzdWVDb2RlLm5vdF9maW5pdGU6XG4gICAgICAgICAgICBtZXNzYWdlID0gXCJOdW1iZXIgbXVzdCBiZSBmaW5pdGVcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgbWVzc2FnZSA9IF9jdHguZGVmYXVsdEVycm9yO1xuICAgICAgICAgICAgdXRpbF8xLnV0aWwuYXNzZXJ0TmV2ZXIoaXNzdWUpO1xuICAgIH1cbiAgICByZXR1cm4geyBtZXNzYWdlIH07XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZXJyb3JNYXA7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/node_modules/zod/lib/locales/en.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/node_modules/zod/lib/types.js":
/*!************************************************************!*\
  !*** ./node_modules/inngest/node_modules/zod/lib/types.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.date = exports.boolean = exports.bigint = exports.array = exports.any = exports.coerce = exports.ZodFirstPartyTypeKind = exports.late = exports.ZodSchema = exports.Schema = exports.custom = exports.ZodReadonly = exports.ZodPipeline = exports.ZodBranded = exports.BRAND = exports.ZodNaN = exports.ZodCatch = exports.ZodDefault = exports.ZodNullable = exports.ZodOptional = exports.ZodTransformer = exports.ZodEffects = exports.ZodPromise = exports.ZodNativeEnum = exports.ZodEnum = exports.ZodLiteral = exports.ZodLazy = exports.ZodFunction = exports.ZodSet = exports.ZodMap = exports.ZodRecord = exports.ZodTuple = exports.ZodIntersection = exports.ZodDiscriminatedUnion = exports.ZodUnion = exports.ZodObject = exports.ZodArray = exports.ZodVoid = exports.ZodNever = exports.ZodUnknown = exports.ZodAny = exports.ZodNull = exports.ZodUndefined = exports.ZodSymbol = exports.ZodDate = exports.ZodBoolean = exports.ZodBigInt = exports.ZodNumber = exports.ZodString = exports.ZodType = void 0;\nexports.NEVER = exports[\"void\"] = exports.unknown = exports.union = exports.undefined = exports.tuple = exports.transformer = exports.symbol = exports.string = exports.strictObject = exports.set = exports.record = exports.promise = exports.preprocess = exports.pipeline = exports.ostring = exports.optional = exports.onumber = exports.oboolean = exports.object = exports.number = exports.nullable = exports[\"null\"] = exports.never = exports.nativeEnum = exports.nan = exports.map = exports.literal = exports.lazy = exports.intersection = exports[\"instanceof\"] = exports[\"function\"] = exports[\"enum\"] = exports.effect = exports.discriminatedUnion = void 0;\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/inngest/node_modules/zod/lib/errors.js\");\nconst errorUtil_1 = __webpack_require__(/*! ./helpers/errorUtil */ \"(rsc)/./node_modules/inngest/node_modules/zod/lib/helpers/errorUtil.js\");\nconst parseUtil_1 = __webpack_require__(/*! ./helpers/parseUtil */ \"(rsc)/./node_modules/inngest/node_modules/zod/lib/helpers/parseUtil.js\");\nconst util_1 = __webpack_require__(/*! ./helpers/util */ \"(rsc)/./node_modules/inngest/node_modules/zod/lib/helpers/util.js\");\nconst ZodError_1 = __webpack_require__(/*! ./ZodError */ \"(rsc)/./node_modules/inngest/node_modules/zod/lib/ZodError.js\");\nclass ParseInputLazyPath {\n    constructor(parent, value, path, key) {\n        this._cachedPath = [];\n        this.parent = parent;\n        this.data = value;\n        this._path = path;\n        this._key = key;\n    }\n    get path() {\n        if (!this._cachedPath.length) {\n            if (this._key instanceof Array) {\n                this._cachedPath.push(...this._path, ...this._key);\n            }\n            else {\n                this._cachedPath.push(...this._path, this._key);\n            }\n        }\n        return this._cachedPath;\n    }\n}\nconst handleResult = (ctx, result) => {\n    if ((0, parseUtil_1.isValid)(result)) {\n        return { success: true, data: result.value };\n    }\n    else {\n        if (!ctx.common.issues.length) {\n            throw new Error(\"Validation failed but no issues detected.\");\n        }\n        return {\n            success: false,\n            get error() {\n                if (this._error)\n                    return this._error;\n                const error = new ZodError_1.ZodError(ctx.common.issues);\n                this._error = error;\n                return this._error;\n            },\n        };\n    }\n};\nfunction processCreateParams(params) {\n    if (!params)\n        return {};\n    const { errorMap, invalid_type_error, required_error, description } = params;\n    if (errorMap && (invalid_type_error || required_error)) {\n        throw new Error(`Can't use \"invalid_type_error\" or \"required_error\" in conjunction with custom error map.`);\n    }\n    if (errorMap)\n        return { errorMap: errorMap, description };\n    const customMap = (iss, ctx) => {\n        if (iss.code !== \"invalid_type\")\n            return { message: ctx.defaultError };\n        if (typeof ctx.data === \"undefined\") {\n            return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };\n        }\n        return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };\n    };\n    return { errorMap: customMap, description };\n}\nclass ZodType {\n    constructor(def) {\n        /** Alias of safeParseAsync */\n        this.spa = this.safeParseAsync;\n        this._def = def;\n        this.parse = this.parse.bind(this);\n        this.safeParse = this.safeParse.bind(this);\n        this.parseAsync = this.parseAsync.bind(this);\n        this.safeParseAsync = this.safeParseAsync.bind(this);\n        this.spa = this.spa.bind(this);\n        this.refine = this.refine.bind(this);\n        this.refinement = this.refinement.bind(this);\n        this.superRefine = this.superRefine.bind(this);\n        this.optional = this.optional.bind(this);\n        this.nullable = this.nullable.bind(this);\n        this.nullish = this.nullish.bind(this);\n        this.array = this.array.bind(this);\n        this.promise = this.promise.bind(this);\n        this.or = this.or.bind(this);\n        this.and = this.and.bind(this);\n        this.transform = this.transform.bind(this);\n        this.brand = this.brand.bind(this);\n        this.default = this.default.bind(this);\n        this.catch = this.catch.bind(this);\n        this.describe = this.describe.bind(this);\n        this.pipe = this.pipe.bind(this);\n        this.readonly = this.readonly.bind(this);\n        this.isNullable = this.isNullable.bind(this);\n        this.isOptional = this.isOptional.bind(this);\n    }\n    get description() {\n        return this._def.description;\n    }\n    _getType(input) {\n        return (0, util_1.getParsedType)(input.data);\n    }\n    _getOrReturnCtx(input, ctx) {\n        return (ctx || {\n            common: input.parent.common,\n            data: input.data,\n            parsedType: (0, util_1.getParsedType)(input.data),\n            schemaErrorMap: this._def.errorMap,\n            path: input.path,\n            parent: input.parent,\n        });\n    }\n    _processInputParams(input) {\n        return {\n            status: new parseUtil_1.ParseStatus(),\n            ctx: {\n                common: input.parent.common,\n                data: input.data,\n                parsedType: (0, util_1.getParsedType)(input.data),\n                schemaErrorMap: this._def.errorMap,\n                path: input.path,\n                parent: input.parent,\n            },\n        };\n    }\n    _parseSync(input) {\n        const result = this._parse(input);\n        if ((0, parseUtil_1.isAsync)(result)) {\n            throw new Error(\"Synchronous parse encountered promise.\");\n        }\n        return result;\n    }\n    _parseAsync(input) {\n        const result = this._parse(input);\n        return Promise.resolve(result);\n    }\n    parse(data, params) {\n        const result = this.safeParse(data, params);\n        if (result.success)\n            return result.data;\n        throw result.error;\n    }\n    safeParse(data, params) {\n        var _a;\n        const ctx = {\n            common: {\n                issues: [],\n                async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,\n                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,\n            },\n            path: (params === null || params === void 0 ? void 0 : params.path) || [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: (0, util_1.getParsedType)(data),\n        };\n        const result = this._parseSync({ data, path: ctx.path, parent: ctx });\n        return handleResult(ctx, result);\n    }\n    async parseAsync(data, params) {\n        const result = await this.safeParseAsync(data, params);\n        if (result.success)\n            return result.data;\n        throw result.error;\n    }\n    async safeParseAsync(data, params) {\n        const ctx = {\n            common: {\n                issues: [],\n                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,\n                async: true,\n            },\n            path: (params === null || params === void 0 ? void 0 : params.path) || [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: (0, util_1.getParsedType)(data),\n        };\n        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });\n        const result = await ((0, parseUtil_1.isAsync)(maybeAsyncResult)\n            ? maybeAsyncResult\n            : Promise.resolve(maybeAsyncResult));\n        return handleResult(ctx, result);\n    }\n    refine(check, message) {\n        const getIssueProperties = (val) => {\n            if (typeof message === \"string\" || typeof message === \"undefined\") {\n                return { message };\n            }\n            else if (typeof message === \"function\") {\n                return message(val);\n            }\n            else {\n                return message;\n            }\n        };\n        return this._refinement((val, ctx) => {\n            const result = check(val);\n            const setError = () => ctx.addIssue({\n                code: ZodError_1.ZodIssueCode.custom,\n                ...getIssueProperties(val),\n            });\n            if (typeof Promise !== \"undefined\" && result instanceof Promise) {\n                return result.then((data) => {\n                    if (!data) {\n                        setError();\n                        return false;\n                    }\n                    else {\n                        return true;\n                    }\n                });\n            }\n            if (!result) {\n                setError();\n                return false;\n            }\n            else {\n                return true;\n            }\n        });\n    }\n    refinement(check, refinementData) {\n        return this._refinement((val, ctx) => {\n            if (!check(val)) {\n                ctx.addIssue(typeof refinementData === \"function\"\n                    ? refinementData(val, ctx)\n                    : refinementData);\n                return false;\n            }\n            else {\n                return true;\n            }\n        });\n    }\n    _refinement(refinement) {\n        return new ZodEffects({\n            schema: this,\n            typeName: ZodFirstPartyTypeKind.ZodEffects,\n            effect: { type: \"refinement\", refinement },\n        });\n    }\n    superRefine(refinement) {\n        return this._refinement(refinement);\n    }\n    optional() {\n        return ZodOptional.create(this, this._def);\n    }\n    nullable() {\n        return ZodNullable.create(this, this._def);\n    }\n    nullish() {\n        return this.nullable().optional();\n    }\n    array() {\n        return ZodArray.create(this, this._def);\n    }\n    promise() {\n        return ZodPromise.create(this, this._def);\n    }\n    or(option) {\n        return ZodUnion.create([this, option], this._def);\n    }\n    and(incoming) {\n        return ZodIntersection.create(this, incoming, this._def);\n    }\n    transform(transform) {\n        return new ZodEffects({\n            ...processCreateParams(this._def),\n            schema: this,\n            typeName: ZodFirstPartyTypeKind.ZodEffects,\n            effect: { type: \"transform\", transform },\n        });\n    }\n    default(def) {\n        const defaultValueFunc = typeof def === \"function\" ? def : () => def;\n        return new ZodDefault({\n            ...processCreateParams(this._def),\n            innerType: this,\n            defaultValue: defaultValueFunc,\n            typeName: ZodFirstPartyTypeKind.ZodDefault,\n        });\n    }\n    brand() {\n        return new ZodBranded({\n            typeName: ZodFirstPartyTypeKind.ZodBranded,\n            type: this,\n            ...processCreateParams(this._def),\n        });\n    }\n    catch(def) {\n        const catchValueFunc = typeof def === \"function\" ? def : () => def;\n        return new ZodCatch({\n            ...processCreateParams(this._def),\n            innerType: this,\n            catchValue: catchValueFunc,\n            typeName: ZodFirstPartyTypeKind.ZodCatch,\n        });\n    }\n    describe(description) {\n        const This = this.constructor;\n        return new This({\n            ...this._def,\n            description,\n        });\n    }\n    pipe(target) {\n        return ZodPipeline.create(this, target);\n    }\n    readonly() {\n        return ZodReadonly.create(this);\n    }\n    isOptional() {\n        return this.safeParse(undefined).success;\n    }\n    isNullable() {\n        return this.safeParse(null).success;\n    }\n}\nexports.ZodType = ZodType;\nexports.Schema = ZodType;\nexports.ZodSchema = ZodType;\nconst cuidRegex = /^c[^\\s-]{8,}$/i;\nconst cuid2Regex = /^[a-z][a-z0-9]*$/;\nconst ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;\n// const uuidRegex =\n//   /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;\nconst uuidRegex = /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/i;\n// from https://stackoverflow.com/a/46181/1550155\n// old version: too slow, didn't support unicode\n// const emailRegex = /^((([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))$/i;\n//old email regex\n// const emailRegex = /^(([^<>()[\\].,;:\\s@\"]+(\\.[^<>()[\\].,;:\\s@\"]+)*)|(\".+\"))@((?!-)([^<>()[\\].,;:\\s@\"]+\\.)+[^<>()[\\].,;:\\s@\"]{1,})[^-<>()[\\].,;:\\s@\"]$/i;\n// eslint-disable-next-line\n// const emailRegex =\n//   /^(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\])|(\\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\\.[A-Za-z]{2,})+))$/;\n// const emailRegex =\n//   /^[a-zA-Z0-9\\.\\!\\#\\$\\%\\&\\'\\*\\+\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~\\-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n// const emailRegex =\n//   /^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])$/i;\nconst emailRegex = /^(?!\\.)(?!.*\\.\\.)([A-Z0-9_+-\\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\\-]*\\.)+[A-Z]{2,}$/i;\n// const emailRegex =\n//   /^[a-z0-9.!#$%&*+/=?^_`{|}~-]+@[a-z0-9-]+(?:\\.[a-z0-9\\-]+)*$/i;\n// from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression\nconst _emojiRegex = `^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$`;\nlet emojiRegex;\nconst ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;\nconst ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;\n// Adapted from https://stackoverflow.com/a/3143231\nconst datetimeRegex = (args) => {\n    if (args.precision) {\n        if (args.offset) {\n            return new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}\\\\.\\\\d{${args.precision}}(([+-]\\\\d{2}(:?\\\\d{2})?)|Z)$`);\n        }\n        else {\n            return new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}\\\\.\\\\d{${args.precision}}Z$`);\n        }\n    }\n    else if (args.precision === 0) {\n        if (args.offset) {\n            return new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}(([+-]\\\\d{2}(:?\\\\d{2})?)|Z)$`);\n        }\n        else {\n            return new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}Z$`);\n        }\n    }\n    else {\n        if (args.offset) {\n            return new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}(\\\\.\\\\d+)?(([+-]\\\\d{2}(:?\\\\d{2})?)|Z)$`);\n        }\n        else {\n            return new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}(\\\\.\\\\d+)?Z$`);\n        }\n    }\n};\nfunction isValidIP(ip, version) {\n    if ((version === \"v4\" || !version) && ipv4Regex.test(ip)) {\n        return true;\n    }\n    if ((version === \"v6\" || !version) && ipv6Regex.test(ip)) {\n        return true;\n    }\n    return false;\n}\nclass ZodString extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = String(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== util_1.ZodParsedType.string) {\n            const ctx = this._getOrReturnCtx(input);\n            (0, parseUtil_1.addIssueToContext)(ctx, {\n                code: ZodError_1.ZodIssueCode.invalid_type,\n                expected: util_1.ZodParsedType.string,\n                received: ctx.parsedType,\n            }\n            //\n            );\n            return parseUtil_1.INVALID;\n        }\n        const status = new parseUtil_1.ParseStatus();\n        let ctx = undefined;\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                if (input.data.length < check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_1.addIssueToContext)(ctx, {\n                        code: ZodError_1.ZodIssueCode.too_small,\n                        minimum: check.value,\n                        type: \"string\",\n                        inclusive: true,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                if (input.data.length > check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_1.addIssueToContext)(ctx, {\n                        code: ZodError_1.ZodIssueCode.too_big,\n                        maximum: check.value,\n                        type: \"string\",\n                        inclusive: true,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"length\") {\n                const tooBig = input.data.length > check.value;\n                const tooSmall = input.data.length < check.value;\n                if (tooBig || tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    if (tooBig) {\n                        (0, parseUtil_1.addIssueToContext)(ctx, {\n                            code: ZodError_1.ZodIssueCode.too_big,\n                            maximum: check.value,\n                            type: \"string\",\n                            inclusive: true,\n                            exact: true,\n                            message: check.message,\n                        });\n                    }\n                    else if (tooSmall) {\n                        (0, parseUtil_1.addIssueToContext)(ctx, {\n                            code: ZodError_1.ZodIssueCode.too_small,\n                            minimum: check.value,\n                            type: \"string\",\n                            inclusive: true,\n                            exact: true,\n                            message: check.message,\n                        });\n                    }\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"email\") {\n                if (!emailRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_1.addIssueToContext)(ctx, {\n                        validation: \"email\",\n                        code: ZodError_1.ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"emoji\") {\n                if (!emojiRegex) {\n                    emojiRegex = new RegExp(_emojiRegex, \"u\");\n                }\n                if (!emojiRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_1.addIssueToContext)(ctx, {\n                        validation: \"emoji\",\n                        code: ZodError_1.ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"uuid\") {\n                if (!uuidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_1.addIssueToContext)(ctx, {\n                        validation: \"uuid\",\n                        code: ZodError_1.ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"cuid\") {\n                if (!cuidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_1.addIssueToContext)(ctx, {\n                        validation: \"cuid\",\n                        code: ZodError_1.ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"cuid2\") {\n                if (!cuid2Regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_1.addIssueToContext)(ctx, {\n                        validation: \"cuid2\",\n                        code: ZodError_1.ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"ulid\") {\n                if (!ulidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_1.addIssueToContext)(ctx, {\n                        validation: \"ulid\",\n                        code: ZodError_1.ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"url\") {\n                try {\n                    new URL(input.data);\n                }\n                catch (_a) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_1.addIssueToContext)(ctx, {\n                        validation: \"url\",\n                        code: ZodError_1.ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"regex\") {\n                check.regex.lastIndex = 0;\n                const testResult = check.regex.test(input.data);\n                if (!testResult) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_1.addIssueToContext)(ctx, {\n                        validation: \"regex\",\n                        code: ZodError_1.ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"trim\") {\n                input.data = input.data.trim();\n            }\n            else if (check.kind === \"includes\") {\n                if (!input.data.includes(check.value, check.position)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_1.addIssueToContext)(ctx, {\n                        code: ZodError_1.ZodIssueCode.invalid_string,\n                        validation: { includes: check.value, position: check.position },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"toLowerCase\") {\n                input.data = input.data.toLowerCase();\n            }\n            else if (check.kind === \"toUpperCase\") {\n                input.data = input.data.toUpperCase();\n            }\n            else if (check.kind === \"startsWith\") {\n                if (!input.data.startsWith(check.value)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_1.addIssueToContext)(ctx, {\n                        code: ZodError_1.ZodIssueCode.invalid_string,\n                        validation: { startsWith: check.value },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"endsWith\") {\n                if (!input.data.endsWith(check.value)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_1.addIssueToContext)(ctx, {\n                        code: ZodError_1.ZodIssueCode.invalid_string,\n                        validation: { endsWith: check.value },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"datetime\") {\n                const regex = datetimeRegex(check);\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_1.addIssueToContext)(ctx, {\n                        code: ZodError_1.ZodIssueCode.invalid_string,\n                        validation: \"datetime\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"ip\") {\n                if (!isValidIP(input.data, check.version)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_1.addIssueToContext)(ctx, {\n                        validation: \"ip\",\n                        code: ZodError_1.ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util_1.util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    _regex(regex, validation, message) {\n        return this.refinement((data) => regex.test(data), {\n            validation,\n            code: ZodError_1.ZodIssueCode.invalid_string,\n            ...errorUtil_1.errorUtil.errToObj(message),\n        });\n    }\n    _addCheck(check) {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    email(message) {\n        return this._addCheck({ kind: \"email\", ...errorUtil_1.errorUtil.errToObj(message) });\n    }\n    url(message) {\n        return this._addCheck({ kind: \"url\", ...errorUtil_1.errorUtil.errToObj(message) });\n    }\n    emoji(message) {\n        return this._addCheck({ kind: \"emoji\", ...errorUtil_1.errorUtil.errToObj(message) });\n    }\n    uuid(message) {\n        return this._addCheck({ kind: \"uuid\", ...errorUtil_1.errorUtil.errToObj(message) });\n    }\n    cuid(message) {\n        return this._addCheck({ kind: \"cuid\", ...errorUtil_1.errorUtil.errToObj(message) });\n    }\n    cuid2(message) {\n        return this._addCheck({ kind: \"cuid2\", ...errorUtil_1.errorUtil.errToObj(message) });\n    }\n    ulid(message) {\n        return this._addCheck({ kind: \"ulid\", ...errorUtil_1.errorUtil.errToObj(message) });\n    }\n    ip(options) {\n        return this._addCheck({ kind: \"ip\", ...errorUtil_1.errorUtil.errToObj(options) });\n    }\n    datetime(options) {\n        var _a;\n        if (typeof options === \"string\") {\n            return this._addCheck({\n                kind: \"datetime\",\n                precision: null,\n                offset: false,\n                message: options,\n            });\n        }\n        return this._addCheck({\n            kind: \"datetime\",\n            precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === \"undefined\" ? null : options === null || options === void 0 ? void 0 : options.precision,\n            offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,\n            ...errorUtil_1.errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),\n        });\n    }\n    regex(regex, message) {\n        return this._addCheck({\n            kind: \"regex\",\n            regex: regex,\n            ...errorUtil_1.errorUtil.errToObj(message),\n        });\n    }\n    includes(value, options) {\n        return this._addCheck({\n            kind: \"includes\",\n            value: value,\n            position: options === null || options === void 0 ? void 0 : options.position,\n            ...errorUtil_1.errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),\n        });\n    }\n    startsWith(value, message) {\n        return this._addCheck({\n            kind: \"startsWith\",\n            value: value,\n            ...errorUtil_1.errorUtil.errToObj(message),\n        });\n    }\n    endsWith(value, message) {\n        return this._addCheck({\n            kind: \"endsWith\",\n            value: value,\n            ...errorUtil_1.errorUtil.errToObj(message),\n        });\n    }\n    min(minLength, message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: minLength,\n            ...errorUtil_1.errorUtil.errToObj(message),\n        });\n    }\n    max(maxLength, message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: maxLength,\n            ...errorUtil_1.errorUtil.errToObj(message),\n        });\n    }\n    length(len, message) {\n        return this._addCheck({\n            kind: \"length\",\n            value: len,\n            ...errorUtil_1.errorUtil.errToObj(message),\n        });\n    }\n    /**\n     * @deprecated Use z.string().min(1) instead.\n     * @see {@link ZodString.min}\n     */\n    nonempty(message) {\n        return this.min(1, errorUtil_1.errorUtil.errToObj(message));\n    }\n    trim() {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"trim\" }],\n        });\n    }\n    toLowerCase() {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"toLowerCase\" }],\n        });\n    }\n    toUpperCase() {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"toUpperCase\" }],\n        });\n    }\n    get isDatetime() {\n        return !!this._def.checks.find((ch) => ch.kind === \"datetime\");\n    }\n    get isEmail() {\n        return !!this._def.checks.find((ch) => ch.kind === \"email\");\n    }\n    get isURL() {\n        return !!this._def.checks.find((ch) => ch.kind === \"url\");\n    }\n    get isEmoji() {\n        return !!this._def.checks.find((ch) => ch.kind === \"emoji\");\n    }\n    get isUUID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"uuid\");\n    }\n    get isCUID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"cuid\");\n    }\n    get isCUID2() {\n        return !!this._def.checks.find((ch) => ch.kind === \"cuid2\");\n    }\n    get isULID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"ulid\");\n    }\n    get isIP() {\n        return !!this._def.checks.find((ch) => ch.kind === \"ip\");\n    }\n    get minLength() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxLength() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n}\nexports.ZodString = ZodString;\nZodString.create = (params) => {\n    var _a;\n    return new ZodString({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodString,\n        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,\n        ...processCreateParams(params),\n    });\n};\n// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034\nfunction floatSafeRemainder(val, step) {\n    const valDecCount = (val.toString().split(\".\")[1] || \"\").length;\n    const stepDecCount = (step.toString().split(\".\")[1] || \"\").length;\n    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;\n    const valInt = parseInt(val.toFixed(decCount).replace(\".\", \"\"));\n    const stepInt = parseInt(step.toFixed(decCount).replace(\".\", \"\"));\n    return (valInt % stepInt) / Math.pow(10, decCount);\n}\nclass ZodNumber extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.min = this.gte;\n        this.max = this.lte;\n        this.step = this.multipleOf;\n    }\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = Number(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== util_1.ZodParsedType.number) {\n            const ctx = this._getOrReturnCtx(input);\n            (0, parseUtil_1.addIssueToContext)(ctx, {\n                code: ZodError_1.ZodIssueCode.invalid_type,\n                expected: util_1.ZodParsedType.number,\n                received: ctx.parsedType,\n            });\n            return parseUtil_1.INVALID;\n        }\n        let ctx = undefined;\n        const status = new parseUtil_1.ParseStatus();\n        for (const check of this._def.checks) {\n            if (check.kind === \"int\") {\n                if (!util_1.util.isInteger(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_1.addIssueToContext)(ctx, {\n                        code: ZodError_1.ZodIssueCode.invalid_type,\n                        expected: \"integer\",\n                        received: \"float\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"min\") {\n                const tooSmall = check.inclusive\n                    ? input.data < check.value\n                    : input.data <= check.value;\n                if (tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_1.addIssueToContext)(ctx, {\n                        code: ZodError_1.ZodIssueCode.too_small,\n                        minimum: check.value,\n                        type: \"number\",\n                        inclusive: check.inclusive,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                const tooBig = check.inclusive\n                    ? input.data > check.value\n                    : input.data >= check.value;\n                if (tooBig) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_1.addIssueToContext)(ctx, {\n                        code: ZodError_1.ZodIssueCode.too_big,\n                        maximum: check.value,\n                        type: \"number\",\n                        inclusive: check.inclusive,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"multipleOf\") {\n                if (floatSafeRemainder(input.data, check.value) !== 0) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_1.addIssueToContext)(ctx, {\n                        code: ZodError_1.ZodIssueCode.not_multiple_of,\n                        multipleOf: check.value,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"finite\") {\n                if (!Number.isFinite(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_1.addIssueToContext)(ctx, {\n                        code: ZodError_1.ZodIssueCode.not_finite,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util_1.util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    gte(value, message) {\n        return this.setLimit(\"min\", value, true, errorUtil_1.errorUtil.toString(message));\n    }\n    gt(value, message) {\n        return this.setLimit(\"min\", value, false, errorUtil_1.errorUtil.toString(message));\n    }\n    lte(value, message) {\n        return this.setLimit(\"max\", value, true, errorUtil_1.errorUtil.toString(message));\n    }\n    lt(value, message) {\n        return this.setLimit(\"max\", value, false, errorUtil_1.errorUtil.toString(message));\n    }\n    setLimit(kind, value, inclusive, message) {\n        return new ZodNumber({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind,\n                    value,\n                    inclusive,\n                    message: errorUtil_1.errorUtil.toString(message),\n                },\n            ],\n        });\n    }\n    _addCheck(check) {\n        return new ZodNumber({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    int(message) {\n        return this._addCheck({\n            kind: \"int\",\n            message: errorUtil_1.errorUtil.toString(message),\n        });\n    }\n    positive(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: 0,\n            inclusive: false,\n            message: errorUtil_1.errorUtil.toString(message),\n        });\n    }\n    negative(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: 0,\n            inclusive: false,\n            message: errorUtil_1.errorUtil.toString(message),\n        });\n    }\n    nonpositive(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: 0,\n            inclusive: true,\n            message: errorUtil_1.errorUtil.toString(message),\n        });\n    }\n    nonnegative(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: 0,\n            inclusive: true,\n            message: errorUtil_1.errorUtil.toString(message),\n        });\n    }\n    multipleOf(value, message) {\n        return this._addCheck({\n            kind: \"multipleOf\",\n            value: value,\n            message: errorUtil_1.errorUtil.toString(message),\n        });\n    }\n    finite(message) {\n        return this._addCheck({\n            kind: \"finite\",\n            message: errorUtil_1.errorUtil.toString(message),\n        });\n    }\n    safe(message) {\n        return this._addCheck({\n            kind: \"min\",\n            inclusive: true,\n            value: Number.MIN_SAFE_INTEGER,\n            message: errorUtil_1.errorUtil.toString(message),\n        })._addCheck({\n            kind: \"max\",\n            inclusive: true,\n            value: Number.MAX_SAFE_INTEGER,\n            message: errorUtil_1.errorUtil.toString(message),\n        });\n    }\n    get minValue() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxValue() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n    get isInt() {\n        return !!this._def.checks.find((ch) => ch.kind === \"int\" ||\n            (ch.kind === \"multipleOf\" && util_1.util.isInteger(ch.value)));\n    }\n    get isFinite() {\n        let max = null, min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"finite\" ||\n                ch.kind === \"int\" ||\n                ch.kind === \"multipleOf\") {\n                return true;\n            }\n            else if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n            else if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return Number.isFinite(min) && Number.isFinite(max);\n    }\n}\nexports.ZodNumber = ZodNumber;\nZodNumber.create = (params) => {\n    return new ZodNumber({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodNumber,\n        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\n        ...processCreateParams(params),\n    });\n};\nclass ZodBigInt extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.min = this.gte;\n        this.max = this.lte;\n    }\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = BigInt(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== util_1.ZodParsedType.bigint) {\n            const ctx = this._getOrReturnCtx(input);\n            (0, parseUtil_1.addIssueToContext)(ctx, {\n                code: ZodError_1.ZodIssueCode.invalid_type,\n                expected: util_1.ZodParsedType.bigint,\n                received: ctx.parsedType,\n            });\n            return parseUtil_1.INVALID;\n        }\n        let ctx = undefined;\n        const status = new parseUtil_1.ParseStatus();\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                const tooSmall = check.inclusive\n                    ? input.data < check.value\n                    : input.data <= check.value;\n                if (tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_1.addIssueToContext)(ctx, {\n                        code: ZodError_1.ZodIssueCode.too_small,\n                        type: \"bigint\",\n                        minimum: check.value,\n                        inclusive: check.inclusive,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                const tooBig = check.inclusive\n                    ? input.data > check.value\n                    : input.data >= check.value;\n                if (tooBig) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_1.addIssueToContext)(ctx, {\n                        code: ZodError_1.ZodIssueCode.too_big,\n                        type: \"bigint\",\n                        maximum: check.value,\n                        inclusive: check.inclusive,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"multipleOf\") {\n                if (input.data % check.value !== BigInt(0)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_1.addIssueToContext)(ctx, {\n                        code: ZodError_1.ZodIssueCode.not_multiple_of,\n                        multipleOf: check.value,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util_1.util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    gte(value, message) {\n        return this.setLimit(\"min\", value, true, errorUtil_1.errorUtil.toString(message));\n    }\n    gt(value, message) {\n        return this.setLimit(\"min\", value, false, errorUtil_1.errorUtil.toString(message));\n    }\n    lte(value, message) {\n        return this.setLimit(\"max\", value, true, errorUtil_1.errorUtil.toString(message));\n    }\n    lt(value, message) {\n        return this.setLimit(\"max\", value, false, errorUtil_1.errorUtil.toString(message));\n    }\n    setLimit(kind, value, inclusive, message) {\n        return new ZodBigInt({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind,\n                    value,\n                    inclusive,\n                    message: errorUtil_1.errorUtil.toString(message),\n                },\n            ],\n        });\n    }\n    _addCheck(check) {\n        return new ZodBigInt({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    positive(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: BigInt(0),\n            inclusive: false,\n            message: errorUtil_1.errorUtil.toString(message),\n        });\n    }\n    negative(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: BigInt(0),\n            inclusive: false,\n            message: errorUtil_1.errorUtil.toString(message),\n        });\n    }\n    nonpositive(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: BigInt(0),\n            inclusive: true,\n            message: errorUtil_1.errorUtil.toString(message),\n        });\n    }\n    nonnegative(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: BigInt(0),\n            inclusive: true,\n            message: errorUtil_1.errorUtil.toString(message),\n        });\n    }\n    multipleOf(value, message) {\n        return this._addCheck({\n            kind: \"multipleOf\",\n            value,\n            message: errorUtil_1.errorUtil.toString(message),\n        });\n    }\n    get minValue() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxValue() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n}\nexports.ZodBigInt = ZodBigInt;\nZodBigInt.create = (params) => {\n    var _a;\n    return new ZodBigInt({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodBigInt,\n        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,\n        ...processCreateParams(params),\n    });\n};\nclass ZodBoolean extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = Boolean(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== util_1.ZodParsedType.boolean) {\n            const ctx = this._getOrReturnCtx(input);\n            (0, parseUtil_1.addIssueToContext)(ctx, {\n                code: ZodError_1.ZodIssueCode.invalid_type,\n                expected: util_1.ZodParsedType.boolean,\n                received: ctx.parsedType,\n            });\n            return parseUtil_1.INVALID;\n        }\n        return (0, parseUtil_1.OK)(input.data);\n    }\n}\nexports.ZodBoolean = ZodBoolean;\nZodBoolean.create = (params) => {\n    return new ZodBoolean({\n        typeName: ZodFirstPartyTypeKind.ZodBoolean,\n        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\n        ...processCreateParams(params),\n    });\n};\nclass ZodDate extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = new Date(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== util_1.ZodParsedType.date) {\n            const ctx = this._getOrReturnCtx(input);\n            (0, parseUtil_1.addIssueToContext)(ctx, {\n                code: ZodError_1.ZodIssueCode.invalid_type,\n                expected: util_1.ZodParsedType.date,\n                received: ctx.parsedType,\n            });\n            return parseUtil_1.INVALID;\n        }\n        if (isNaN(input.data.getTime())) {\n            const ctx = this._getOrReturnCtx(input);\n            (0, parseUtil_1.addIssueToContext)(ctx, {\n                code: ZodError_1.ZodIssueCode.invalid_date,\n            });\n            return parseUtil_1.INVALID;\n        }\n        const status = new parseUtil_1.ParseStatus();\n        let ctx = undefined;\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                if (input.data.getTime() < check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_1.addIssueToContext)(ctx, {\n                        code: ZodError_1.ZodIssueCode.too_small,\n                        message: check.message,\n                        inclusive: true,\n                        exact: false,\n                        minimum: check.value,\n                        type: \"date\",\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                if (input.data.getTime() > check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_1.addIssueToContext)(ctx, {\n                        code: ZodError_1.ZodIssueCode.too_big,\n                        message: check.message,\n                        inclusive: true,\n                        exact: false,\n                        maximum: check.value,\n                        type: \"date\",\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util_1.util.assertNever(check);\n            }\n        }\n        return {\n            status: status.value,\n            value: new Date(input.data.getTime()),\n        };\n    }\n    _addCheck(check) {\n        return new ZodDate({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    min(minDate, message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: minDate.getTime(),\n            message: errorUtil_1.errorUtil.toString(message),\n        });\n    }\n    max(maxDate, message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: maxDate.getTime(),\n            message: errorUtil_1.errorUtil.toString(message),\n        });\n    }\n    get minDate() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min != null ? new Date(min) : null;\n    }\n    get maxDate() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max != null ? new Date(max) : null;\n    }\n}\nexports.ZodDate = ZodDate;\nZodDate.create = (params) => {\n    return new ZodDate({\n        checks: [],\n        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\n        typeName: ZodFirstPartyTypeKind.ZodDate,\n        ...processCreateParams(params),\n    });\n};\nclass ZodSymbol extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== util_1.ZodParsedType.symbol) {\n            const ctx = this._getOrReturnCtx(input);\n            (0, parseUtil_1.addIssueToContext)(ctx, {\n                code: ZodError_1.ZodIssueCode.invalid_type,\n                expected: util_1.ZodParsedType.symbol,\n                received: ctx.parsedType,\n            });\n            return parseUtil_1.INVALID;\n        }\n        return (0, parseUtil_1.OK)(input.data);\n    }\n}\nexports.ZodSymbol = ZodSymbol;\nZodSymbol.create = (params) => {\n    return new ZodSymbol({\n        typeName: ZodFirstPartyTypeKind.ZodSymbol,\n        ...processCreateParams(params),\n    });\n};\nclass ZodUndefined extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== util_1.ZodParsedType.undefined) {\n            const ctx = this._getOrReturnCtx(input);\n            (0, parseUtil_1.addIssueToContext)(ctx, {\n                code: ZodError_1.ZodIssueCode.invalid_type,\n                expected: util_1.ZodParsedType.undefined,\n                received: ctx.parsedType,\n            });\n            return parseUtil_1.INVALID;\n        }\n        return (0, parseUtil_1.OK)(input.data);\n    }\n}\nexports.ZodUndefined = ZodUndefined;\nZodUndefined.create = (params) => {\n    return new ZodUndefined({\n        typeName: ZodFirstPartyTypeKind.ZodUndefined,\n        ...processCreateParams(params),\n    });\n};\nclass ZodNull extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== util_1.ZodParsedType.null) {\n            const ctx = this._getOrReturnCtx(input);\n            (0, parseUtil_1.addIssueToContext)(ctx, {\n                code: ZodError_1.ZodIssueCode.invalid_type,\n                expected: util_1.ZodParsedType.null,\n                received: ctx.parsedType,\n            });\n            return parseUtil_1.INVALID;\n        }\n        return (0, parseUtil_1.OK)(input.data);\n    }\n}\nexports.ZodNull = ZodNull;\nZodNull.create = (params) => {\n    return new ZodNull({\n        typeName: ZodFirstPartyTypeKind.ZodNull,\n        ...processCreateParams(params),\n    });\n};\nclass ZodAny extends ZodType {\n    constructor() {\n        super(...arguments);\n        // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.\n        this._any = true;\n    }\n    _parse(input) {\n        return (0, parseUtil_1.OK)(input.data);\n    }\n}\nexports.ZodAny = ZodAny;\nZodAny.create = (params) => {\n    return new ZodAny({\n        typeName: ZodFirstPartyTypeKind.ZodAny,\n        ...processCreateParams(params),\n    });\n};\nclass ZodUnknown extends ZodType {\n    constructor() {\n        super(...arguments);\n        // required\n        this._unknown = true;\n    }\n    _parse(input) {\n        return (0, parseUtil_1.OK)(input.data);\n    }\n}\nexports.ZodUnknown = ZodUnknown;\nZodUnknown.create = (params) => {\n    return new ZodUnknown({\n        typeName: ZodFirstPartyTypeKind.ZodUnknown,\n        ...processCreateParams(params),\n    });\n};\nclass ZodNever extends ZodType {\n    _parse(input) {\n        const ctx = this._getOrReturnCtx(input);\n        (0, parseUtil_1.addIssueToContext)(ctx, {\n            code: ZodError_1.ZodIssueCode.invalid_type,\n            expected: util_1.ZodParsedType.never,\n            received: ctx.parsedType,\n        });\n        return parseUtil_1.INVALID;\n    }\n}\nexports.ZodNever = ZodNever;\nZodNever.create = (params) => {\n    return new ZodNever({\n        typeName: ZodFirstPartyTypeKind.ZodNever,\n        ...processCreateParams(params),\n    });\n};\nclass ZodVoid extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== util_1.ZodParsedType.undefined) {\n            const ctx = this._getOrReturnCtx(input);\n            (0, parseUtil_1.addIssueToContext)(ctx, {\n                code: ZodError_1.ZodIssueCode.invalid_type,\n                expected: util_1.ZodParsedType.void,\n                received: ctx.parsedType,\n            });\n            return parseUtil_1.INVALID;\n        }\n        return (0, parseUtil_1.OK)(input.data);\n    }\n}\nexports.ZodVoid = ZodVoid;\nZodVoid.create = (params) => {\n    return new ZodVoid({\n        typeName: ZodFirstPartyTypeKind.ZodVoid,\n        ...processCreateParams(params),\n    });\n};\nclass ZodArray extends ZodType {\n    _parse(input) {\n        const { ctx, status } = this._processInputParams(input);\n        const def = this._def;\n        if (ctx.parsedType !== util_1.ZodParsedType.array) {\n            (0, parseUtil_1.addIssueToContext)(ctx, {\n                code: ZodError_1.ZodIssueCode.invalid_type,\n                expected: util_1.ZodParsedType.array,\n                received: ctx.parsedType,\n            });\n            return parseUtil_1.INVALID;\n        }\n        if (def.exactLength !== null) {\n            const tooBig = ctx.data.length > def.exactLength.value;\n            const tooSmall = ctx.data.length < def.exactLength.value;\n            if (tooBig || tooSmall) {\n                (0, parseUtil_1.addIssueToContext)(ctx, {\n                    code: tooBig ? ZodError_1.ZodIssueCode.too_big : ZodError_1.ZodIssueCode.too_small,\n                    minimum: (tooSmall ? def.exactLength.value : undefined),\n                    maximum: (tooBig ? def.exactLength.value : undefined),\n                    type: \"array\",\n                    inclusive: true,\n                    exact: true,\n                    message: def.exactLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.minLength !== null) {\n            if (ctx.data.length < def.minLength.value) {\n                (0, parseUtil_1.addIssueToContext)(ctx, {\n                    code: ZodError_1.ZodIssueCode.too_small,\n                    minimum: def.minLength.value,\n                    type: \"array\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.minLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.maxLength !== null) {\n            if (ctx.data.length > def.maxLength.value) {\n                (0, parseUtil_1.addIssueToContext)(ctx, {\n                    code: ZodError_1.ZodIssueCode.too_big,\n                    maximum: def.maxLength.value,\n                    type: \"array\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.maxLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (ctx.common.async) {\n            return Promise.all([...ctx.data].map((item, i) => {\n                return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n            })).then((result) => {\n                return parseUtil_1.ParseStatus.mergeArray(status, result);\n            });\n        }\n        const result = [...ctx.data].map((item, i) => {\n            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n        });\n        return parseUtil_1.ParseStatus.mergeArray(status, result);\n    }\n    get element() {\n        return this._def.type;\n    }\n    min(minLength, message) {\n        return new ZodArray({\n            ...this._def,\n            minLength: { value: minLength, message: errorUtil_1.errorUtil.toString(message) },\n        });\n    }\n    max(maxLength, message) {\n        return new ZodArray({\n            ...this._def,\n            maxLength: { value: maxLength, message: errorUtil_1.errorUtil.toString(message) },\n        });\n    }\n    length(len, message) {\n        return new ZodArray({\n            ...this._def,\n            exactLength: { value: len, message: errorUtil_1.errorUtil.toString(message) },\n        });\n    }\n    nonempty(message) {\n        return this.min(1, message);\n    }\n}\nexports.ZodArray = ZodArray;\nZodArray.create = (schema, params) => {\n    return new ZodArray({\n        type: schema,\n        minLength: null,\n        maxLength: null,\n        exactLength: null,\n        typeName: ZodFirstPartyTypeKind.ZodArray,\n        ...processCreateParams(params),\n    });\n};\nfunction deepPartialify(schema) {\n    if (schema instanceof ZodObject) {\n        const newShape = {};\n        for (const key in schema.shape) {\n            const fieldSchema = schema.shape[key];\n            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));\n        }\n        return new ZodObject({\n            ...schema._def,\n            shape: () => newShape,\n        });\n    }\n    else if (schema instanceof ZodArray) {\n        return new ZodArray({\n            ...schema._def,\n            type: deepPartialify(schema.element),\n        });\n    }\n    else if (schema instanceof ZodOptional) {\n        return ZodOptional.create(deepPartialify(schema.unwrap()));\n    }\n    else if (schema instanceof ZodNullable) {\n        return ZodNullable.create(deepPartialify(schema.unwrap()));\n    }\n    else if (schema instanceof ZodTuple) {\n        return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));\n    }\n    else {\n        return schema;\n    }\n}\nclass ZodObject extends ZodType {\n    constructor() {\n        super(...arguments);\n        this._cached = null;\n        /**\n         * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.\n         * If you want to pass through unknown properties, use `.passthrough()` instead.\n         */\n        this.nonstrict = this.passthrough;\n        // extend<\n        //   Augmentation extends ZodRawShape,\n        //   NewOutput extends util.flatten<{\n        //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n        //       ? Augmentation[k][\"_output\"]\n        //       : k extends keyof Output\n        //       ? Output[k]\n        //       : never;\n        //   }>,\n        //   NewInput extends util.flatten<{\n        //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n        //       ? Augmentation[k][\"_input\"]\n        //       : k extends keyof Input\n        //       ? Input[k]\n        //       : never;\n        //   }>\n        // >(\n        //   augmentation: Augmentation\n        // ): ZodObject<\n        //   extendShape<T, Augmentation>,\n        //   UnknownKeys,\n        //   Catchall,\n        //   NewOutput,\n        //   NewInput\n        // > {\n        //   return new ZodObject({\n        //     ...this._def,\n        //     shape: () => ({\n        //       ...this._def.shape(),\n        //       ...augmentation,\n        //     }),\n        //   }) as any;\n        // }\n        /**\n         * @deprecated Use `.extend` instead\n         *  */\n        this.augment = this.extend;\n    }\n    _getCached() {\n        if (this._cached !== null)\n            return this._cached;\n        const shape = this._def.shape();\n        const keys = util_1.util.objectKeys(shape);\n        return (this._cached = { shape, keys });\n    }\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== util_1.ZodParsedType.object) {\n            const ctx = this._getOrReturnCtx(input);\n            (0, parseUtil_1.addIssueToContext)(ctx, {\n                code: ZodError_1.ZodIssueCode.invalid_type,\n                expected: util_1.ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return parseUtil_1.INVALID;\n        }\n        const { status, ctx } = this._processInputParams(input);\n        const { shape, keys: shapeKeys } = this._getCached();\n        const extraKeys = [];\n        if (!(this._def.catchall instanceof ZodNever &&\n            this._def.unknownKeys === \"strip\")) {\n            for (const key in ctx.data) {\n                if (!shapeKeys.includes(key)) {\n                    extraKeys.push(key);\n                }\n            }\n        }\n        const pairs = [];\n        for (const key of shapeKeys) {\n            const keyValidator = shape[key];\n            const value = ctx.data[key];\n            pairs.push({\n                key: { status: \"valid\", value: key },\n                value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),\n                alwaysSet: key in ctx.data,\n            });\n        }\n        if (this._def.catchall instanceof ZodNever) {\n            const unknownKeys = this._def.unknownKeys;\n            if (unknownKeys === \"passthrough\") {\n                for (const key of extraKeys) {\n                    pairs.push({\n                        key: { status: \"valid\", value: key },\n                        value: { status: \"valid\", value: ctx.data[key] },\n                    });\n                }\n            }\n            else if (unknownKeys === \"strict\") {\n                if (extraKeys.length > 0) {\n                    (0, parseUtil_1.addIssueToContext)(ctx, {\n                        code: ZodError_1.ZodIssueCode.unrecognized_keys,\n                        keys: extraKeys,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (unknownKeys === \"strip\") {\n            }\n            else {\n                throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);\n            }\n        }\n        else {\n            // run catchall validation\n            const catchall = this._def.catchall;\n            for (const key of extraKeys) {\n                const value = ctx.data[key];\n                pairs.push({\n                    key: { status: \"valid\", value: key },\n                    value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key) //, ctx.child(key), value, getParsedType(value)\n                    ),\n                    alwaysSet: key in ctx.data,\n                });\n            }\n        }\n        if (ctx.common.async) {\n            return Promise.resolve()\n                .then(async () => {\n                const syncPairs = [];\n                for (const pair of pairs) {\n                    const key = await pair.key;\n                    syncPairs.push({\n                        key,\n                        value: await pair.value,\n                        alwaysSet: pair.alwaysSet,\n                    });\n                }\n                return syncPairs;\n            })\n                .then((syncPairs) => {\n                return parseUtil_1.ParseStatus.mergeObjectSync(status, syncPairs);\n            });\n        }\n        else {\n            return parseUtil_1.ParseStatus.mergeObjectSync(status, pairs);\n        }\n    }\n    get shape() {\n        return this._def.shape();\n    }\n    strict(message) {\n        errorUtil_1.errorUtil.errToObj;\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"strict\",\n            ...(message !== undefined\n                ? {\n                    errorMap: (issue, ctx) => {\n                        var _a, _b, _c, _d;\n                        const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;\n                        if (issue.code === \"unrecognized_keys\")\n                            return {\n                                message: (_d = errorUtil_1.errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError,\n                            };\n                        return {\n                            message: defaultError,\n                        };\n                    },\n                }\n                : {}),\n        });\n    }\n    strip() {\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"strip\",\n        });\n    }\n    passthrough() {\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"passthrough\",\n        });\n    }\n    // const AugmentFactory =\n    //   <Def extends ZodObjectDef>(def: Def) =>\n    //   <Augmentation extends ZodRawShape>(\n    //     augmentation: Augmentation\n    //   ): ZodObject<\n    //     extendShape<ReturnType<Def[\"shape\"]>, Augmentation>,\n    //     Def[\"unknownKeys\"],\n    //     Def[\"catchall\"]\n    //   > => {\n    //     return new ZodObject({\n    //       ...def,\n    //       shape: () => ({\n    //         ...def.shape(),\n    //         ...augmentation,\n    //       }),\n    //     }) as any;\n    //   };\n    extend(augmentation) {\n        return new ZodObject({\n            ...this._def,\n            shape: () => ({\n                ...this._def.shape(),\n                ...augmentation,\n            }),\n        });\n    }\n    /**\n     * Prior to zod@1.0.12 there was a bug in the\n     * inferred type of merged objects. Please\n     * upgrade if you are experiencing issues.\n     */\n    merge(merging) {\n        const merged = new ZodObject({\n            unknownKeys: merging._def.unknownKeys,\n            catchall: merging._def.catchall,\n            shape: () => ({\n                ...this._def.shape(),\n                ...merging._def.shape(),\n            }),\n            typeName: ZodFirstPartyTypeKind.ZodObject,\n        });\n        return merged;\n    }\n    // merge<\n    //   Incoming extends AnyZodObject,\n    //   Augmentation extends Incoming[\"shape\"],\n    //   NewOutput extends {\n    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n    //       ? Augmentation[k][\"_output\"]\n    //       : k extends keyof Output\n    //       ? Output[k]\n    //       : never;\n    //   },\n    //   NewInput extends {\n    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n    //       ? Augmentation[k][\"_input\"]\n    //       : k extends keyof Input\n    //       ? Input[k]\n    //       : never;\n    //   }\n    // >(\n    //   merging: Incoming\n    // ): ZodObject<\n    //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n    //   Incoming[\"_def\"][\"unknownKeys\"],\n    //   Incoming[\"_def\"][\"catchall\"],\n    //   NewOutput,\n    //   NewInput\n    // > {\n    //   const merged: any = new ZodObject({\n    //     unknownKeys: merging._def.unknownKeys,\n    //     catchall: merging._def.catchall,\n    //     shape: () =>\n    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n    //     typeName: ZodFirstPartyTypeKind.ZodObject,\n    //   }) as any;\n    //   return merged;\n    // }\n    setKey(key, schema) {\n        return this.augment({ [key]: schema });\n    }\n    // merge<Incoming extends AnyZodObject>(\n    //   merging: Incoming\n    // ): //ZodObject<T & Incoming[\"_shape\"], UnknownKeys, Catchall> = (merging) => {\n    // ZodObject<\n    //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n    //   Incoming[\"_def\"][\"unknownKeys\"],\n    //   Incoming[\"_def\"][\"catchall\"]\n    // > {\n    //   // const mergedShape = objectUtil.mergeShapes(\n    //   //   this._def.shape(),\n    //   //   merging._def.shape()\n    //   // );\n    //   const merged: any = new ZodObject({\n    //     unknownKeys: merging._def.unknownKeys,\n    //     catchall: merging._def.catchall,\n    //     shape: () =>\n    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n    //     typeName: ZodFirstPartyTypeKind.ZodObject,\n    //   }) as any;\n    //   return merged;\n    // }\n    catchall(index) {\n        return new ZodObject({\n            ...this._def,\n            catchall: index,\n        });\n    }\n    pick(mask) {\n        const shape = {};\n        util_1.util.objectKeys(mask).forEach((key) => {\n            if (mask[key] && this.shape[key]) {\n                shape[key] = this.shape[key];\n            }\n        });\n        return new ZodObject({\n            ...this._def,\n            shape: () => shape,\n        });\n    }\n    omit(mask) {\n        const shape = {};\n        util_1.util.objectKeys(this.shape).forEach((key) => {\n            if (!mask[key]) {\n                shape[key] = this.shape[key];\n            }\n        });\n        return new ZodObject({\n            ...this._def,\n            shape: () => shape,\n        });\n    }\n    /**\n     * @deprecated\n     */\n    deepPartial() {\n        return deepPartialify(this);\n    }\n    partial(mask) {\n        const newShape = {};\n        util_1.util.objectKeys(this.shape).forEach((key) => {\n            const fieldSchema = this.shape[key];\n            if (mask && !mask[key]) {\n                newShape[key] = fieldSchema;\n            }\n            else {\n                newShape[key] = fieldSchema.optional();\n            }\n        });\n        return new ZodObject({\n            ...this._def,\n            shape: () => newShape,\n        });\n    }\n    required(mask) {\n        const newShape = {};\n        util_1.util.objectKeys(this.shape).forEach((key) => {\n            if (mask && !mask[key]) {\n                newShape[key] = this.shape[key];\n            }\n            else {\n                const fieldSchema = this.shape[key];\n                let newField = fieldSchema;\n                while (newField instanceof ZodOptional) {\n                    newField = newField._def.innerType;\n                }\n                newShape[key] = newField;\n            }\n        });\n        return new ZodObject({\n            ...this._def,\n            shape: () => newShape,\n        });\n    }\n    keyof() {\n        return createZodEnum(util_1.util.objectKeys(this.shape));\n    }\n}\nexports.ZodObject = ZodObject;\nZodObject.create = (shape, params) => {\n    return new ZodObject({\n        shape: () => shape,\n        unknownKeys: \"strip\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nZodObject.strictCreate = (shape, params) => {\n    return new ZodObject({\n        shape: () => shape,\n        unknownKeys: \"strict\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nZodObject.lazycreate = (shape, params) => {\n    return new ZodObject({\n        shape,\n        unknownKeys: \"strip\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nclass ZodUnion extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const options = this._def.options;\n        function handleResults(results) {\n            // return first issue-free validation if it exists\n            for (const result of results) {\n                if (result.result.status === \"valid\") {\n                    return result.result;\n                }\n            }\n            for (const result of results) {\n                if (result.result.status === \"dirty\") {\n                    // add issues from dirty option\n                    ctx.common.issues.push(...result.ctx.common.issues);\n                    return result.result;\n                }\n            }\n            // return invalid\n            const unionErrors = results.map((result) => new ZodError_1.ZodError(result.ctx.common.issues));\n            (0, parseUtil_1.addIssueToContext)(ctx, {\n                code: ZodError_1.ZodIssueCode.invalid_union,\n                unionErrors,\n            });\n            return parseUtil_1.INVALID;\n        }\n        if (ctx.common.async) {\n            return Promise.all(options.map(async (option) => {\n                const childCtx = {\n                    ...ctx,\n                    common: {\n                        ...ctx.common,\n                        issues: [],\n                    },\n                    parent: null,\n                };\n                return {\n                    result: await option._parseAsync({\n                        data: ctx.data,\n                        path: ctx.path,\n                        parent: childCtx,\n                    }),\n                    ctx: childCtx,\n                };\n            })).then(handleResults);\n        }\n        else {\n            let dirty = undefined;\n            const issues = [];\n            for (const option of options) {\n                const childCtx = {\n                    ...ctx,\n                    common: {\n                        ...ctx.common,\n                        issues: [],\n                    },\n                    parent: null,\n                };\n                const result = option._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: childCtx,\n                });\n                if (result.status === \"valid\") {\n                    return result;\n                }\n                else if (result.status === \"dirty\" && !dirty) {\n                    dirty = { result, ctx: childCtx };\n                }\n                if (childCtx.common.issues.length) {\n                    issues.push(childCtx.common.issues);\n                }\n            }\n            if (dirty) {\n                ctx.common.issues.push(...dirty.ctx.common.issues);\n                return dirty.result;\n            }\n            const unionErrors = issues.map((issues) => new ZodError_1.ZodError(issues));\n            (0, parseUtil_1.addIssueToContext)(ctx, {\n                code: ZodError_1.ZodIssueCode.invalid_union,\n                unionErrors,\n            });\n            return parseUtil_1.INVALID;\n        }\n    }\n    get options() {\n        return this._def.options;\n    }\n}\nexports.ZodUnion = ZodUnion;\nZodUnion.create = (types, params) => {\n    return new ZodUnion({\n        options: types,\n        typeName: ZodFirstPartyTypeKind.ZodUnion,\n        ...processCreateParams(params),\n    });\n};\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n//////////                                 //////////\n//////////      ZodDiscriminatedUnion      //////////\n//////////                                 //////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\nconst getDiscriminator = (type) => {\n    if (type instanceof ZodLazy) {\n        return getDiscriminator(type.schema);\n    }\n    else if (type instanceof ZodEffects) {\n        return getDiscriminator(type.innerType());\n    }\n    else if (type instanceof ZodLiteral) {\n        return [type.value];\n    }\n    else if (type instanceof ZodEnum) {\n        return type.options;\n    }\n    else if (type instanceof ZodNativeEnum) {\n        // eslint-disable-next-line ban/ban\n        return Object.keys(type.enum);\n    }\n    else if (type instanceof ZodDefault) {\n        return getDiscriminator(type._def.innerType);\n    }\n    else if (type instanceof ZodUndefined) {\n        return [undefined];\n    }\n    else if (type instanceof ZodNull) {\n        return [null];\n    }\n    else {\n        return null;\n    }\n};\nclass ZodDiscriminatedUnion extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== util_1.ZodParsedType.object) {\n            (0, parseUtil_1.addIssueToContext)(ctx, {\n                code: ZodError_1.ZodIssueCode.invalid_type,\n                expected: util_1.ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return parseUtil_1.INVALID;\n        }\n        const discriminator = this.discriminator;\n        const discriminatorValue = ctx.data[discriminator];\n        const option = this.optionsMap.get(discriminatorValue);\n        if (!option) {\n            (0, parseUtil_1.addIssueToContext)(ctx, {\n                code: ZodError_1.ZodIssueCode.invalid_union_discriminator,\n                options: Array.from(this.optionsMap.keys()),\n                path: [discriminator],\n            });\n            return parseUtil_1.INVALID;\n        }\n        if (ctx.common.async) {\n            return option._parseAsync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n        }\n        else {\n            return option._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n        }\n    }\n    get discriminator() {\n        return this._def.discriminator;\n    }\n    get options() {\n        return this._def.options;\n    }\n    get optionsMap() {\n        return this._def.optionsMap;\n    }\n    /**\n     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.\n     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must\n     * have a different value for each object in the union.\n     * @param discriminator the name of the discriminator property\n     * @param types an array of object schemas\n     * @param params\n     */\n    static create(discriminator, options, params) {\n        // Get all the valid discriminator values\n        const optionsMap = new Map();\n        // try {\n        for (const type of options) {\n            const discriminatorValues = getDiscriminator(type.shape[discriminator]);\n            if (!discriminatorValues) {\n                throw new Error(`A discriminator value for key \\`${discriminator}\\` could not be extracted from all schema options`);\n            }\n            for (const value of discriminatorValues) {\n                if (optionsMap.has(value)) {\n                    throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);\n                }\n                optionsMap.set(value, type);\n            }\n        }\n        return new ZodDiscriminatedUnion({\n            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,\n            discriminator,\n            options,\n            optionsMap,\n            ...processCreateParams(params),\n        });\n    }\n}\nexports.ZodDiscriminatedUnion = ZodDiscriminatedUnion;\nfunction mergeValues(a, b) {\n    const aType = (0, util_1.getParsedType)(a);\n    const bType = (0, util_1.getParsedType)(b);\n    if (a === b) {\n        return { valid: true, data: a };\n    }\n    else if (aType === util_1.ZodParsedType.object && bType === util_1.ZodParsedType.object) {\n        const bKeys = util_1.util.objectKeys(b);\n        const sharedKeys = util_1.util\n            .objectKeys(a)\n            .filter((key) => bKeys.indexOf(key) !== -1);\n        const newObj = { ...a, ...b };\n        for (const key of sharedKeys) {\n            const sharedValue = mergeValues(a[key], b[key]);\n            if (!sharedValue.valid) {\n                return { valid: false };\n            }\n            newObj[key] = sharedValue.data;\n        }\n        return { valid: true, data: newObj };\n    }\n    else if (aType === util_1.ZodParsedType.array && bType === util_1.ZodParsedType.array) {\n        if (a.length !== b.length) {\n            return { valid: false };\n        }\n        const newArray = [];\n        for (let index = 0; index < a.length; index++) {\n            const itemA = a[index];\n            const itemB = b[index];\n            const sharedValue = mergeValues(itemA, itemB);\n            if (!sharedValue.valid) {\n                return { valid: false };\n            }\n            newArray.push(sharedValue.data);\n        }\n        return { valid: true, data: newArray };\n    }\n    else if (aType === util_1.ZodParsedType.date &&\n        bType === util_1.ZodParsedType.date &&\n        +a === +b) {\n        return { valid: true, data: a };\n    }\n    else {\n        return { valid: false };\n    }\n}\nclass ZodIntersection extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        const handleParsed = (parsedLeft, parsedRight) => {\n            if ((0, parseUtil_1.isAborted)(parsedLeft) || (0, parseUtil_1.isAborted)(parsedRight)) {\n                return parseUtil_1.INVALID;\n            }\n            const merged = mergeValues(parsedLeft.value, parsedRight.value);\n            if (!merged.valid) {\n                (0, parseUtil_1.addIssueToContext)(ctx, {\n                    code: ZodError_1.ZodIssueCode.invalid_intersection_types,\n                });\n                return parseUtil_1.INVALID;\n            }\n            if ((0, parseUtil_1.isDirty)(parsedLeft) || (0, parseUtil_1.isDirty)(parsedRight)) {\n                status.dirty();\n            }\n            return { status: status.value, value: merged.data };\n        };\n        if (ctx.common.async) {\n            return Promise.all([\n                this._def.left._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                }),\n                this._def.right._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                }),\n            ]).then(([left, right]) => handleParsed(left, right));\n        }\n        else {\n            return handleParsed(this._def.left._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            }), this._def.right._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            }));\n        }\n    }\n}\nexports.ZodIntersection = ZodIntersection;\nZodIntersection.create = (left, right, params) => {\n    return new ZodIntersection({\n        left: left,\n        right: right,\n        typeName: ZodFirstPartyTypeKind.ZodIntersection,\n        ...processCreateParams(params),\n    });\n};\nclass ZodTuple extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== util_1.ZodParsedType.array) {\n            (0, parseUtil_1.addIssueToContext)(ctx, {\n                code: ZodError_1.ZodIssueCode.invalid_type,\n                expected: util_1.ZodParsedType.array,\n                received: ctx.parsedType,\n            });\n            return parseUtil_1.INVALID;\n        }\n        if (ctx.data.length < this._def.items.length) {\n            (0, parseUtil_1.addIssueToContext)(ctx, {\n                code: ZodError_1.ZodIssueCode.too_small,\n                minimum: this._def.items.length,\n                inclusive: true,\n                exact: false,\n                type: \"array\",\n            });\n            return parseUtil_1.INVALID;\n        }\n        const rest = this._def.rest;\n        if (!rest && ctx.data.length > this._def.items.length) {\n            (0, parseUtil_1.addIssueToContext)(ctx, {\n                code: ZodError_1.ZodIssueCode.too_big,\n                maximum: this._def.items.length,\n                inclusive: true,\n                exact: false,\n                type: \"array\",\n            });\n            status.dirty();\n        }\n        const items = [...ctx.data]\n            .map((item, itemIndex) => {\n            const schema = this._def.items[itemIndex] || this._def.rest;\n            if (!schema)\n                return null;\n            return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));\n        })\n            .filter((x) => !!x); // filter nulls\n        if (ctx.common.async) {\n            return Promise.all(items).then((results) => {\n                return parseUtil_1.ParseStatus.mergeArray(status, results);\n            });\n        }\n        else {\n            return parseUtil_1.ParseStatus.mergeArray(status, items);\n        }\n    }\n    get items() {\n        return this._def.items;\n    }\n    rest(rest) {\n        return new ZodTuple({\n            ...this._def,\n            rest,\n        });\n    }\n}\nexports.ZodTuple = ZodTuple;\nZodTuple.create = (schemas, params) => {\n    if (!Array.isArray(schemas)) {\n        throw new Error(\"You must pass an array of schemas to z.tuple([ ... ])\");\n    }\n    return new ZodTuple({\n        items: schemas,\n        typeName: ZodFirstPartyTypeKind.ZodTuple,\n        rest: null,\n        ...processCreateParams(params),\n    });\n};\nclass ZodRecord extends ZodType {\n    get keySchema() {\n        return this._def.keyType;\n    }\n    get valueSchema() {\n        return this._def.valueType;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== util_1.ZodParsedType.object) {\n            (0, parseUtil_1.addIssueToContext)(ctx, {\n                code: ZodError_1.ZodIssueCode.invalid_type,\n                expected: util_1.ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return parseUtil_1.INVALID;\n        }\n        const pairs = [];\n        const keyType = this._def.keyType;\n        const valueType = this._def.valueType;\n        for (const key in ctx.data) {\n            pairs.push({\n                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),\n                value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),\n            });\n        }\n        if (ctx.common.async) {\n            return parseUtil_1.ParseStatus.mergeObjectAsync(status, pairs);\n        }\n        else {\n            return parseUtil_1.ParseStatus.mergeObjectSync(status, pairs);\n        }\n    }\n    get element() {\n        return this._def.valueType;\n    }\n    static create(first, second, third) {\n        if (second instanceof ZodType) {\n            return new ZodRecord({\n                keyType: first,\n                valueType: second,\n                typeName: ZodFirstPartyTypeKind.ZodRecord,\n                ...processCreateParams(third),\n            });\n        }\n        return new ZodRecord({\n            keyType: ZodString.create(),\n            valueType: first,\n            typeName: ZodFirstPartyTypeKind.ZodRecord,\n            ...processCreateParams(second),\n        });\n    }\n}\nexports.ZodRecord = ZodRecord;\nclass ZodMap extends ZodType {\n    get keySchema() {\n        return this._def.keyType;\n    }\n    get valueSchema() {\n        return this._def.valueType;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== util_1.ZodParsedType.map) {\n            (0, parseUtil_1.addIssueToContext)(ctx, {\n                code: ZodError_1.ZodIssueCode.invalid_type,\n                expected: util_1.ZodParsedType.map,\n                received: ctx.parsedType,\n            });\n            return parseUtil_1.INVALID;\n        }\n        const keyType = this._def.keyType;\n        const valueType = this._def.valueType;\n        const pairs = [...ctx.data.entries()].map(([key, value], index) => {\n            return {\n                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, \"key\"])),\n                value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, \"value\"])),\n            };\n        });\n        if (ctx.common.async) {\n            const finalMap = new Map();\n            return Promise.resolve().then(async () => {\n                for (const pair of pairs) {\n                    const key = await pair.key;\n                    const value = await pair.value;\n                    if (key.status === \"aborted\" || value.status === \"aborted\") {\n                        return parseUtil_1.INVALID;\n                    }\n                    if (key.status === \"dirty\" || value.status === \"dirty\") {\n                        status.dirty();\n                    }\n                    finalMap.set(key.value, value.value);\n                }\n                return { status: status.value, value: finalMap };\n            });\n        }\n        else {\n            const finalMap = new Map();\n            for (const pair of pairs) {\n                const key = pair.key;\n                const value = pair.value;\n                if (key.status === \"aborted\" || value.status === \"aborted\") {\n                    return parseUtil_1.INVALID;\n                }\n                if (key.status === \"dirty\" || value.status === \"dirty\") {\n                    status.dirty();\n                }\n                finalMap.set(key.value, value.value);\n            }\n            return { status: status.value, value: finalMap };\n        }\n    }\n}\nexports.ZodMap = ZodMap;\nZodMap.create = (keyType, valueType, params) => {\n    return new ZodMap({\n        valueType,\n        keyType,\n        typeName: ZodFirstPartyTypeKind.ZodMap,\n        ...processCreateParams(params),\n    });\n};\nclass ZodSet extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== util_1.ZodParsedType.set) {\n            (0, parseUtil_1.addIssueToContext)(ctx, {\n                code: ZodError_1.ZodIssueCode.invalid_type,\n                expected: util_1.ZodParsedType.set,\n                received: ctx.parsedType,\n            });\n            return parseUtil_1.INVALID;\n        }\n        const def = this._def;\n        if (def.minSize !== null) {\n            if (ctx.data.size < def.minSize.value) {\n                (0, parseUtil_1.addIssueToContext)(ctx, {\n                    code: ZodError_1.ZodIssueCode.too_small,\n                    minimum: def.minSize.value,\n                    type: \"set\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.minSize.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.maxSize !== null) {\n            if (ctx.data.size > def.maxSize.value) {\n                (0, parseUtil_1.addIssueToContext)(ctx, {\n                    code: ZodError_1.ZodIssueCode.too_big,\n                    maximum: def.maxSize.value,\n                    type: \"set\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.maxSize.message,\n                });\n                status.dirty();\n            }\n        }\n        const valueType = this._def.valueType;\n        function finalizeSet(elements) {\n            const parsedSet = new Set();\n            for (const element of elements) {\n                if (element.status === \"aborted\")\n                    return parseUtil_1.INVALID;\n                if (element.status === \"dirty\")\n                    status.dirty();\n                parsedSet.add(element.value);\n            }\n            return { status: status.value, value: parsedSet };\n        }\n        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));\n        if (ctx.common.async) {\n            return Promise.all(elements).then((elements) => finalizeSet(elements));\n        }\n        else {\n            return finalizeSet(elements);\n        }\n    }\n    min(minSize, message) {\n        return new ZodSet({\n            ...this._def,\n            minSize: { value: minSize, message: errorUtil_1.errorUtil.toString(message) },\n        });\n    }\n    max(maxSize, message) {\n        return new ZodSet({\n            ...this._def,\n            maxSize: { value: maxSize, message: errorUtil_1.errorUtil.toString(message) },\n        });\n    }\n    size(size, message) {\n        return this.min(size, message).max(size, message);\n    }\n    nonempty(message) {\n        return this.min(1, message);\n    }\n}\nexports.ZodSet = ZodSet;\nZodSet.create = (valueType, params) => {\n    return new ZodSet({\n        valueType,\n        minSize: null,\n        maxSize: null,\n        typeName: ZodFirstPartyTypeKind.ZodSet,\n        ...processCreateParams(params),\n    });\n};\nclass ZodFunction extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.validate = this.implement;\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== util_1.ZodParsedType.function) {\n            (0, parseUtil_1.addIssueToContext)(ctx, {\n                code: ZodError_1.ZodIssueCode.invalid_type,\n                expected: util_1.ZodParsedType.function,\n                received: ctx.parsedType,\n            });\n            return parseUtil_1.INVALID;\n        }\n        function makeArgsIssue(args, error) {\n            return (0, parseUtil_1.makeIssue)({\n                data: args,\n                path: ctx.path,\n                errorMaps: [\n                    ctx.common.contextualErrorMap,\n                    ctx.schemaErrorMap,\n                    (0, errors_1.getErrorMap)(),\n                    errors_1.defaultErrorMap,\n                ].filter((x) => !!x),\n                issueData: {\n                    code: ZodError_1.ZodIssueCode.invalid_arguments,\n                    argumentsError: error,\n                },\n            });\n        }\n        function makeReturnsIssue(returns, error) {\n            return (0, parseUtil_1.makeIssue)({\n                data: returns,\n                path: ctx.path,\n                errorMaps: [\n                    ctx.common.contextualErrorMap,\n                    ctx.schemaErrorMap,\n                    (0, errors_1.getErrorMap)(),\n                    errors_1.defaultErrorMap,\n                ].filter((x) => !!x),\n                issueData: {\n                    code: ZodError_1.ZodIssueCode.invalid_return_type,\n                    returnTypeError: error,\n                },\n            });\n        }\n        const params = { errorMap: ctx.common.contextualErrorMap };\n        const fn = ctx.data;\n        if (this._def.returns instanceof ZodPromise) {\n            // Would love a way to avoid disabling this rule, but we need\n            // an alias (using an arrow function was what caused 2651).\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            const me = this;\n            return (0, parseUtil_1.OK)(async function (...args) {\n                const error = new ZodError_1.ZodError([]);\n                const parsedArgs = await me._def.args\n                    .parseAsync(args, params)\n                    .catch((e) => {\n                    error.addIssue(makeArgsIssue(args, e));\n                    throw error;\n                });\n                const result = await Reflect.apply(fn, this, parsedArgs);\n                const parsedReturns = await me._def.returns._def.type\n                    .parseAsync(result, params)\n                    .catch((e) => {\n                    error.addIssue(makeReturnsIssue(result, e));\n                    throw error;\n                });\n                return parsedReturns;\n            });\n        }\n        else {\n            // Would love a way to avoid disabling this rule, but we need\n            // an alias (using an arrow function was what caused 2651).\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            const me = this;\n            return (0, parseUtil_1.OK)(function (...args) {\n                const parsedArgs = me._def.args.safeParse(args, params);\n                if (!parsedArgs.success) {\n                    throw new ZodError_1.ZodError([makeArgsIssue(args, parsedArgs.error)]);\n                }\n                const result = Reflect.apply(fn, this, parsedArgs.data);\n                const parsedReturns = me._def.returns.safeParse(result, params);\n                if (!parsedReturns.success) {\n                    throw new ZodError_1.ZodError([makeReturnsIssue(result, parsedReturns.error)]);\n                }\n                return parsedReturns.data;\n            });\n        }\n    }\n    parameters() {\n        return this._def.args;\n    }\n    returnType() {\n        return this._def.returns;\n    }\n    args(...items) {\n        return new ZodFunction({\n            ...this._def,\n            args: ZodTuple.create(items).rest(ZodUnknown.create()),\n        });\n    }\n    returns(returnType) {\n        return new ZodFunction({\n            ...this._def,\n            returns: returnType,\n        });\n    }\n    implement(func) {\n        const validatedFunc = this.parse(func);\n        return validatedFunc;\n    }\n    strictImplement(func) {\n        const validatedFunc = this.parse(func);\n        return validatedFunc;\n    }\n    static create(args, returns, params) {\n        return new ZodFunction({\n            args: (args\n                ? args\n                : ZodTuple.create([]).rest(ZodUnknown.create())),\n            returns: returns || ZodUnknown.create(),\n            typeName: ZodFirstPartyTypeKind.ZodFunction,\n            ...processCreateParams(params),\n        });\n    }\n}\nexports.ZodFunction = ZodFunction;\nclass ZodLazy extends ZodType {\n    get schema() {\n        return this._def.getter();\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const lazySchema = this._def.getter();\n        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });\n    }\n}\nexports.ZodLazy = ZodLazy;\nZodLazy.create = (getter, params) => {\n    return new ZodLazy({\n        getter: getter,\n        typeName: ZodFirstPartyTypeKind.ZodLazy,\n        ...processCreateParams(params),\n    });\n};\nclass ZodLiteral extends ZodType {\n    _parse(input) {\n        if (input.data !== this._def.value) {\n            const ctx = this._getOrReturnCtx(input);\n            (0, parseUtil_1.addIssueToContext)(ctx, {\n                received: ctx.data,\n                code: ZodError_1.ZodIssueCode.invalid_literal,\n                expected: this._def.value,\n            });\n            return parseUtil_1.INVALID;\n        }\n        return { status: \"valid\", value: input.data };\n    }\n    get value() {\n        return this._def.value;\n    }\n}\nexports.ZodLiteral = ZodLiteral;\nZodLiteral.create = (value, params) => {\n    return new ZodLiteral({\n        value: value,\n        typeName: ZodFirstPartyTypeKind.ZodLiteral,\n        ...processCreateParams(params),\n    });\n};\nfunction createZodEnum(values, params) {\n    return new ZodEnum({\n        values,\n        typeName: ZodFirstPartyTypeKind.ZodEnum,\n        ...processCreateParams(params),\n    });\n}\nclass ZodEnum extends ZodType {\n    _parse(input) {\n        if (typeof input.data !== \"string\") {\n            const ctx = this._getOrReturnCtx(input);\n            const expectedValues = this._def.values;\n            (0, parseUtil_1.addIssueToContext)(ctx, {\n                expected: util_1.util.joinValues(expectedValues),\n                received: ctx.parsedType,\n                code: ZodError_1.ZodIssueCode.invalid_type,\n            });\n            return parseUtil_1.INVALID;\n        }\n        if (this._def.values.indexOf(input.data) === -1) {\n            const ctx = this._getOrReturnCtx(input);\n            const expectedValues = this._def.values;\n            (0, parseUtil_1.addIssueToContext)(ctx, {\n                received: ctx.data,\n                code: ZodError_1.ZodIssueCode.invalid_enum_value,\n                options: expectedValues,\n            });\n            return parseUtil_1.INVALID;\n        }\n        return (0, parseUtil_1.OK)(input.data);\n    }\n    get options() {\n        return this._def.values;\n    }\n    get enum() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    get Values() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    get Enum() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    extract(values) {\n        return ZodEnum.create(values);\n    }\n    exclude(values) {\n        return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));\n    }\n}\nexports.ZodEnum = ZodEnum;\nZodEnum.create = createZodEnum;\nclass ZodNativeEnum extends ZodType {\n    _parse(input) {\n        const nativeEnumValues = util_1.util.getValidEnumValues(this._def.values);\n        const ctx = this._getOrReturnCtx(input);\n        if (ctx.parsedType !== util_1.ZodParsedType.string &&\n            ctx.parsedType !== util_1.ZodParsedType.number) {\n            const expectedValues = util_1.util.objectValues(nativeEnumValues);\n            (0, parseUtil_1.addIssueToContext)(ctx, {\n                expected: util_1.util.joinValues(expectedValues),\n                received: ctx.parsedType,\n                code: ZodError_1.ZodIssueCode.invalid_type,\n            });\n            return parseUtil_1.INVALID;\n        }\n        if (nativeEnumValues.indexOf(input.data) === -1) {\n            const expectedValues = util_1.util.objectValues(nativeEnumValues);\n            (0, parseUtil_1.addIssueToContext)(ctx, {\n                received: ctx.data,\n                code: ZodError_1.ZodIssueCode.invalid_enum_value,\n                options: expectedValues,\n            });\n            return parseUtil_1.INVALID;\n        }\n        return (0, parseUtil_1.OK)(input.data);\n    }\n    get enum() {\n        return this._def.values;\n    }\n}\nexports.ZodNativeEnum = ZodNativeEnum;\nZodNativeEnum.create = (values, params) => {\n    return new ZodNativeEnum({\n        values: values,\n        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,\n        ...processCreateParams(params),\n    });\n};\nclass ZodPromise extends ZodType {\n    unwrap() {\n        return this._def.type;\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== util_1.ZodParsedType.promise &&\n            ctx.common.async === false) {\n            (0, parseUtil_1.addIssueToContext)(ctx, {\n                code: ZodError_1.ZodIssueCode.invalid_type,\n                expected: util_1.ZodParsedType.promise,\n                received: ctx.parsedType,\n            });\n            return parseUtil_1.INVALID;\n        }\n        const promisified = ctx.parsedType === util_1.ZodParsedType.promise\n            ? ctx.data\n            : Promise.resolve(ctx.data);\n        return (0, parseUtil_1.OK)(promisified.then((data) => {\n            return this._def.type.parseAsync(data, {\n                path: ctx.path,\n                errorMap: ctx.common.contextualErrorMap,\n            });\n        }));\n    }\n}\nexports.ZodPromise = ZodPromise;\nZodPromise.create = (schema, params) => {\n    return new ZodPromise({\n        type: schema,\n        typeName: ZodFirstPartyTypeKind.ZodPromise,\n        ...processCreateParams(params),\n    });\n};\nclass ZodEffects extends ZodType {\n    innerType() {\n        return this._def.schema;\n    }\n    sourceType() {\n        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects\n            ? this._def.schema.sourceType()\n            : this._def.schema;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        const effect = this._def.effect || null;\n        const checkCtx = {\n            addIssue: (arg) => {\n                (0, parseUtil_1.addIssueToContext)(ctx, arg);\n                if (arg.fatal) {\n                    status.abort();\n                }\n                else {\n                    status.dirty();\n                }\n            },\n            get path() {\n                return ctx.path;\n            },\n        };\n        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);\n        if (effect.type === \"preprocess\") {\n            const processed = effect.transform(ctx.data, checkCtx);\n            if (ctx.common.issues.length) {\n                return {\n                    status: \"dirty\",\n                    value: ctx.data,\n                };\n            }\n            if (ctx.common.async) {\n                return Promise.resolve(processed).then((processed) => {\n                    return this._def.schema._parseAsync({\n                        data: processed,\n                        path: ctx.path,\n                        parent: ctx,\n                    });\n                });\n            }\n            else {\n                return this._def.schema._parseSync({\n                    data: processed,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n            }\n        }\n        if (effect.type === \"refinement\") {\n            const executeRefinement = (acc\n            // effect: RefinementEffect<any>\n            ) => {\n                const result = effect.refinement(acc, checkCtx);\n                if (ctx.common.async) {\n                    return Promise.resolve(result);\n                }\n                if (result instanceof Promise) {\n                    throw new Error(\"Async refinement encountered during synchronous parse operation. Use .parseAsync instead.\");\n                }\n                return acc;\n            };\n            if (ctx.common.async === false) {\n                const inner = this._def.schema._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (inner.status === \"aborted\")\n                    return parseUtil_1.INVALID;\n                if (inner.status === \"dirty\")\n                    status.dirty();\n                // return value is ignored\n                executeRefinement(inner.value);\n                return { status: status.value, value: inner.value };\n            }\n            else {\n                return this._def.schema\n                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })\n                    .then((inner) => {\n                    if (inner.status === \"aborted\")\n                        return parseUtil_1.INVALID;\n                    if (inner.status === \"dirty\")\n                        status.dirty();\n                    return executeRefinement(inner.value).then(() => {\n                        return { status: status.value, value: inner.value };\n                    });\n                });\n            }\n        }\n        if (effect.type === \"transform\") {\n            if (ctx.common.async === false) {\n                const base = this._def.schema._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (!(0, parseUtil_1.isValid)(base))\n                    return base;\n                const result = effect.transform(base.value, checkCtx);\n                if (result instanceof Promise) {\n                    throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);\n                }\n                return { status: status.value, value: result };\n            }\n            else {\n                return this._def.schema\n                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })\n                    .then((base) => {\n                    if (!(0, parseUtil_1.isValid)(base))\n                        return base;\n                    return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));\n                });\n            }\n        }\n        util_1.util.assertNever(effect);\n    }\n}\nexports.ZodEffects = ZodEffects;\nexports.ZodTransformer = ZodEffects;\nZodEffects.create = (schema, effect, params) => {\n    return new ZodEffects({\n        schema,\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\n        effect,\n        ...processCreateParams(params),\n    });\n};\nZodEffects.createWithPreprocess = (preprocess, schema, params) => {\n    return new ZodEffects({\n        schema,\n        effect: { type: \"preprocess\", transform: preprocess },\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\n        ...processCreateParams(params),\n    });\n};\nclass ZodOptional extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType === util_1.ZodParsedType.undefined) {\n            return (0, parseUtil_1.OK)(undefined);\n        }\n        return this._def.innerType._parse(input);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nexports.ZodOptional = ZodOptional;\nZodOptional.create = (type, params) => {\n    return new ZodOptional({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodOptional,\n        ...processCreateParams(params),\n    });\n};\nclass ZodNullable extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType === util_1.ZodParsedType.null) {\n            return (0, parseUtil_1.OK)(null);\n        }\n        return this._def.innerType._parse(input);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nexports.ZodNullable = ZodNullable;\nZodNullable.create = (type, params) => {\n    return new ZodNullable({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodNullable,\n        ...processCreateParams(params),\n    });\n};\nclass ZodDefault extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        let data = ctx.data;\n        if (ctx.parsedType === util_1.ZodParsedType.undefined) {\n            data = this._def.defaultValue();\n        }\n        return this._def.innerType._parse({\n            data,\n            path: ctx.path,\n            parent: ctx,\n        });\n    }\n    removeDefault() {\n        return this._def.innerType;\n    }\n}\nexports.ZodDefault = ZodDefault;\nZodDefault.create = (type, params) => {\n    return new ZodDefault({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodDefault,\n        defaultValue: typeof params.default === \"function\"\n            ? params.default\n            : () => params.default,\n        ...processCreateParams(params),\n    });\n};\nclass ZodCatch extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        // newCtx is used to not collect issues from inner types in ctx\n        const newCtx = {\n            ...ctx,\n            common: {\n                ...ctx.common,\n                issues: [],\n            },\n        };\n        const result = this._def.innerType._parse({\n            data: newCtx.data,\n            path: newCtx.path,\n            parent: {\n                ...newCtx,\n            },\n        });\n        if ((0, parseUtil_1.isAsync)(result)) {\n            return result.then((result) => {\n                return {\n                    status: \"valid\",\n                    value: result.status === \"valid\"\n                        ? result.value\n                        : this._def.catchValue({\n                            get error() {\n                                return new ZodError_1.ZodError(newCtx.common.issues);\n                            },\n                            input: newCtx.data,\n                        }),\n                };\n            });\n        }\n        else {\n            return {\n                status: \"valid\",\n                value: result.status === \"valid\"\n                    ? result.value\n                    : this._def.catchValue({\n                        get error() {\n                            return new ZodError_1.ZodError(newCtx.common.issues);\n                        },\n                        input: newCtx.data,\n                    }),\n            };\n        }\n    }\n    removeCatch() {\n        return this._def.innerType;\n    }\n}\nexports.ZodCatch = ZodCatch;\nZodCatch.create = (type, params) => {\n    return new ZodCatch({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodCatch,\n        catchValue: typeof params.catch === \"function\" ? params.catch : () => params.catch,\n        ...processCreateParams(params),\n    });\n};\nclass ZodNaN extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== util_1.ZodParsedType.nan) {\n            const ctx = this._getOrReturnCtx(input);\n            (0, parseUtil_1.addIssueToContext)(ctx, {\n                code: ZodError_1.ZodIssueCode.invalid_type,\n                expected: util_1.ZodParsedType.nan,\n                received: ctx.parsedType,\n            });\n            return parseUtil_1.INVALID;\n        }\n        return { status: \"valid\", value: input.data };\n    }\n}\nexports.ZodNaN = ZodNaN;\nZodNaN.create = (params) => {\n    return new ZodNaN({\n        typeName: ZodFirstPartyTypeKind.ZodNaN,\n        ...processCreateParams(params),\n    });\n};\nexports.BRAND = Symbol(\"zod_brand\");\nclass ZodBranded extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const data = ctx.data;\n        return this._def.type._parse({\n            data,\n            path: ctx.path,\n            parent: ctx,\n        });\n    }\n    unwrap() {\n        return this._def.type;\n    }\n}\nexports.ZodBranded = ZodBranded;\nclass ZodPipeline extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.common.async) {\n            const handleAsync = async () => {\n                const inResult = await this._def.in._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (inResult.status === \"aborted\")\n                    return parseUtil_1.INVALID;\n                if (inResult.status === \"dirty\") {\n                    status.dirty();\n                    return (0, parseUtil_1.DIRTY)(inResult.value);\n                }\n                else {\n                    return this._def.out._parseAsync({\n                        data: inResult.value,\n                        path: ctx.path,\n                        parent: ctx,\n                    });\n                }\n            };\n            return handleAsync();\n        }\n        else {\n            const inResult = this._def.in._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n            if (inResult.status === \"aborted\")\n                return parseUtil_1.INVALID;\n            if (inResult.status === \"dirty\") {\n                status.dirty();\n                return {\n                    status: \"dirty\",\n                    value: inResult.value,\n                };\n            }\n            else {\n                return this._def.out._parseSync({\n                    data: inResult.value,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n            }\n        }\n    }\n    static create(a, b) {\n        return new ZodPipeline({\n            in: a,\n            out: b,\n            typeName: ZodFirstPartyTypeKind.ZodPipeline,\n        });\n    }\n}\nexports.ZodPipeline = ZodPipeline;\nclass ZodReadonly extends ZodType {\n    _parse(input) {\n        const result = this._def.innerType._parse(input);\n        if ((0, parseUtil_1.isValid)(result)) {\n            result.value = Object.freeze(result.value);\n        }\n        return result;\n    }\n}\nexports.ZodReadonly = ZodReadonly;\nZodReadonly.create = (type, params) => {\n    return new ZodReadonly({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodReadonly,\n        ...processCreateParams(params),\n    });\n};\nconst custom = (check, params = {}, \n/**\n * @deprecated\n *\n * Pass `fatal` into the params object instead:\n *\n * ```ts\n * z.string().custom((val) => val.length > 5, { fatal: false })\n * ```\n *\n */\nfatal) => {\n    if (check)\n        return ZodAny.create().superRefine((data, ctx) => {\n            var _a, _b;\n            if (!check(data)) {\n                const p = typeof params === \"function\"\n                    ? params(data)\n                    : typeof params === \"string\"\n                        ? { message: params }\n                        : params;\n                const _fatal = (_b = (_a = p.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;\n                const p2 = typeof p === \"string\" ? { message: p } : p;\n                ctx.addIssue({ code: \"custom\", ...p2, fatal: _fatal });\n            }\n        });\n    return ZodAny.create();\n};\nexports.custom = custom;\nexports.late = {\n    object: ZodObject.lazycreate,\n};\nvar ZodFirstPartyTypeKind;\n(function (ZodFirstPartyTypeKind) {\n    ZodFirstPartyTypeKind[\"ZodString\"] = \"ZodString\";\n    ZodFirstPartyTypeKind[\"ZodNumber\"] = \"ZodNumber\";\n    ZodFirstPartyTypeKind[\"ZodNaN\"] = \"ZodNaN\";\n    ZodFirstPartyTypeKind[\"ZodBigInt\"] = \"ZodBigInt\";\n    ZodFirstPartyTypeKind[\"ZodBoolean\"] = \"ZodBoolean\";\n    ZodFirstPartyTypeKind[\"ZodDate\"] = \"ZodDate\";\n    ZodFirstPartyTypeKind[\"ZodSymbol\"] = \"ZodSymbol\";\n    ZodFirstPartyTypeKind[\"ZodUndefined\"] = \"ZodUndefined\";\n    ZodFirstPartyTypeKind[\"ZodNull\"] = \"ZodNull\";\n    ZodFirstPartyTypeKind[\"ZodAny\"] = \"ZodAny\";\n    ZodFirstPartyTypeKind[\"ZodUnknown\"] = \"ZodUnknown\";\n    ZodFirstPartyTypeKind[\"ZodNever\"] = \"ZodNever\";\n    ZodFirstPartyTypeKind[\"ZodVoid\"] = \"ZodVoid\";\n    ZodFirstPartyTypeKind[\"ZodArray\"] = \"ZodArray\";\n    ZodFirstPartyTypeKind[\"ZodObject\"] = \"ZodObject\";\n    ZodFirstPartyTypeKind[\"ZodUnion\"] = \"ZodUnion\";\n    ZodFirstPartyTypeKind[\"ZodDiscriminatedUnion\"] = \"ZodDiscriminatedUnion\";\n    ZodFirstPartyTypeKind[\"ZodIntersection\"] = \"ZodIntersection\";\n    ZodFirstPartyTypeKind[\"ZodTuple\"] = \"ZodTuple\";\n    ZodFirstPartyTypeKind[\"ZodRecord\"] = \"ZodRecord\";\n    ZodFirstPartyTypeKind[\"ZodMap\"] = \"ZodMap\";\n    ZodFirstPartyTypeKind[\"ZodSet\"] = \"ZodSet\";\n    ZodFirstPartyTypeKind[\"ZodFunction\"] = \"ZodFunction\";\n    ZodFirstPartyTypeKind[\"ZodLazy\"] = \"ZodLazy\";\n    ZodFirstPartyTypeKind[\"ZodLiteral\"] = \"ZodLiteral\";\n    ZodFirstPartyTypeKind[\"ZodEnum\"] = \"ZodEnum\";\n    ZodFirstPartyTypeKind[\"ZodEffects\"] = \"ZodEffects\";\n    ZodFirstPartyTypeKind[\"ZodNativeEnum\"] = \"ZodNativeEnum\";\n    ZodFirstPartyTypeKind[\"ZodOptional\"] = \"ZodOptional\";\n    ZodFirstPartyTypeKind[\"ZodNullable\"] = \"ZodNullable\";\n    ZodFirstPartyTypeKind[\"ZodDefault\"] = \"ZodDefault\";\n    ZodFirstPartyTypeKind[\"ZodCatch\"] = \"ZodCatch\";\n    ZodFirstPartyTypeKind[\"ZodPromise\"] = \"ZodPromise\";\n    ZodFirstPartyTypeKind[\"ZodBranded\"] = \"ZodBranded\";\n    ZodFirstPartyTypeKind[\"ZodPipeline\"] = \"ZodPipeline\";\n    ZodFirstPartyTypeKind[\"ZodReadonly\"] = \"ZodReadonly\";\n})(ZodFirstPartyTypeKind = exports.ZodFirstPartyTypeKind || (exports.ZodFirstPartyTypeKind = {}));\n// requires TS 4.4+\nclass Class {\n    constructor(..._) { }\n}\nconst instanceOfType = (\n// const instanceOfType = <T extends new (...args: any[]) => any>(\ncls, params = {\n    message: `Input not instance of ${cls.name}`,\n}) => (0, exports.custom)((data) => data instanceof cls, params);\nexports[\"instanceof\"] = instanceOfType;\nconst stringType = ZodString.create;\nexports.string = stringType;\nconst numberType = ZodNumber.create;\nexports.number = numberType;\nconst nanType = ZodNaN.create;\nexports.nan = nanType;\nconst bigIntType = ZodBigInt.create;\nexports.bigint = bigIntType;\nconst booleanType = ZodBoolean.create;\nexports.boolean = booleanType;\nconst dateType = ZodDate.create;\nexports.date = dateType;\nconst symbolType = ZodSymbol.create;\nexports.symbol = symbolType;\nconst undefinedType = ZodUndefined.create;\nexports.undefined = undefinedType;\nconst nullType = ZodNull.create;\nexports[\"null\"] = nullType;\nconst anyType = ZodAny.create;\nexports.any = anyType;\nconst unknownType = ZodUnknown.create;\nexports.unknown = unknownType;\nconst neverType = ZodNever.create;\nexports.never = neverType;\nconst voidType = ZodVoid.create;\nexports[\"void\"] = voidType;\nconst arrayType = ZodArray.create;\nexports.array = arrayType;\nconst objectType = ZodObject.create;\nexports.object = objectType;\nconst strictObjectType = ZodObject.strictCreate;\nexports.strictObject = strictObjectType;\nconst unionType = ZodUnion.create;\nexports.union = unionType;\nconst discriminatedUnionType = ZodDiscriminatedUnion.create;\nexports.discriminatedUnion = discriminatedUnionType;\nconst intersectionType = ZodIntersection.create;\nexports.intersection = intersectionType;\nconst tupleType = ZodTuple.create;\nexports.tuple = tupleType;\nconst recordType = ZodRecord.create;\nexports.record = recordType;\nconst mapType = ZodMap.create;\nexports.map = mapType;\nconst setType = ZodSet.create;\nexports.set = setType;\nconst functionType = ZodFunction.create;\nexports[\"function\"] = functionType;\nconst lazyType = ZodLazy.create;\nexports.lazy = lazyType;\nconst literalType = ZodLiteral.create;\nexports.literal = literalType;\nconst enumType = ZodEnum.create;\nexports[\"enum\"] = enumType;\nconst nativeEnumType = ZodNativeEnum.create;\nexports.nativeEnum = nativeEnumType;\nconst promiseType = ZodPromise.create;\nexports.promise = promiseType;\nconst effectsType = ZodEffects.create;\nexports.effect = effectsType;\nexports.transformer = effectsType;\nconst optionalType = ZodOptional.create;\nexports.optional = optionalType;\nconst nullableType = ZodNullable.create;\nexports.nullable = nullableType;\nconst preprocessType = ZodEffects.createWithPreprocess;\nexports.preprocess = preprocessType;\nconst pipelineType = ZodPipeline.create;\nexports.pipeline = pipelineType;\nconst ostring = () => stringType().optional();\nexports.ostring = ostring;\nconst onumber = () => numberType().optional();\nexports.onumber = onumber;\nconst oboolean = () => booleanType().optional();\nexports.oboolean = oboolean;\nexports.coerce = {\n    string: ((arg) => ZodString.create({ ...arg, coerce: true })),\n    number: ((arg) => ZodNumber.create({ ...arg, coerce: true })),\n    boolean: ((arg) => ZodBoolean.create({\n        ...arg,\n        coerce: true,\n    })),\n    bigint: ((arg) => ZodBigInt.create({ ...arg, coerce: true })),\n    date: ((arg) => ZodDate.create({ ...arg, coerce: true })),\n};\nexports.NEVER = parseUtil_1.INVALID;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9ub2RlX21vZHVsZXMvem9kL2xpYi90eXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxZQUFZLEdBQUcsZUFBZSxHQUFHLGNBQWMsR0FBRyxhQUFhLEdBQUcsV0FBVyxHQUFHLGNBQWMsR0FBRyw2QkFBNkIsR0FBRyxZQUFZLEdBQUcsaUJBQWlCLEdBQUcsY0FBYyxHQUFHLGNBQWMsR0FBRyxtQkFBbUIsR0FBRyxtQkFBbUIsR0FBRyxrQkFBa0IsR0FBRyxhQUFhLEdBQUcsY0FBYyxHQUFHLGdCQUFnQixHQUFHLGtCQUFrQixHQUFHLG1CQUFtQixHQUFHLG1CQUFtQixHQUFHLHNCQUFzQixHQUFHLGtCQUFrQixHQUFHLGtCQUFrQixHQUFHLHFCQUFxQixHQUFHLGVBQWUsR0FBRyxrQkFBa0IsR0FBRyxlQUFlLEdBQUcsbUJBQW1CLEdBQUcsY0FBYyxHQUFHLGNBQWMsR0FBRyxpQkFBaUIsR0FBRyxnQkFBZ0IsR0FBRyx1QkFBdUIsR0FBRyw2QkFBNkIsR0FBRyxnQkFBZ0IsR0FBRyxpQkFBaUIsR0FBRyxnQkFBZ0IsR0FBRyxlQUFlLEdBQUcsZ0JBQWdCLEdBQUcsa0JBQWtCLEdBQUcsY0FBYyxHQUFHLGVBQWUsR0FBRyxvQkFBb0IsR0FBRyxpQkFBaUIsR0FBRyxlQUFlLEdBQUcsa0JBQWtCLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsZUFBZTtBQUM3OUIsYUFBYSxHQUFHLGVBQVksR0FBRyxlQUFlLEdBQUcsYUFBYSxHQUFHLGlCQUFpQixHQUFHLGFBQWEsR0FBRyxtQkFBbUIsR0FBRyxjQUFjLEdBQUcsY0FBYyxHQUFHLG9CQUFvQixHQUFHLFdBQVcsR0FBRyxjQUFjLEdBQUcsZUFBZSxHQUFHLGtCQUFrQixHQUFHLGdCQUFnQixHQUFHLGVBQWUsR0FBRyxnQkFBZ0IsR0FBRyxlQUFlLEdBQUcsZ0JBQWdCLEdBQUcsY0FB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O0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGlEQUFpRDtBQUN2RjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHlCQUF5QjtBQUMvRDtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHVCQUF1QjtBQUM3RDtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnQ0FBZ0MsMkRBQTJEO0FBQzNGO0FBQ0E7QUFDQSxnQ0FBZ0MseURBQXlEO0FBQ3pGO0FBQ0E7QUFDQSxnQ0FBZ0MsMkRBQTJEO0FBQzNGO0FBQ0E7QUFDQSxnQ0FBZ0MsMERBQTBEO0FBQzFGO0FBQ0E7QUFDQSxnQ0FBZ0MsMERBQTBEO0FBQzFGO0FBQ0E7QUFDQSxnQ0FBZ0MsMkRBQTJEO0FBQzNGO0FBQ0E7QUFDQSxnQ0FBZ0MsMERBQTBEO0FBQzFGO0FBQ0E7QUFDQSxnQ0FBZ0Msd0RBQXdEO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGNBQWM7QUFDMUQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHFCQUFxQjtBQUNqRSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMscUJBQXFCO0FBQ2pFLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsZUFBZTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFD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RCxxQ0FBcUMsc0JBQXNCO0FBQzNEO0FBQ0EsYUFBYSIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpdmUtdmliZS1haS1uZXh0Ly4vbm9kZV9tb2R1bGVzL2lubmdlc3Qvbm9kZV9tb2R1bGVzL3pvZC9saWIvdHlwZXMuanM/ZjQ2ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGF0ZSA9IGV4cG9ydHMuYm9vbGVhbiA9IGV4cG9ydHMuYmlnaW50ID0gZXhwb3J0cy5hcnJheSA9IGV4cG9ydHMuYW55ID0gZXhwb3J0cy5jb2VyY2UgPSBleHBvcnRzLlpvZEZpcnN0UGFydHlUeXBlS2luZCA9IGV4cG9ydHMubGF0ZSA9IGV4cG9ydHMuWm9kU2NoZW1hID0gZXhwb3J0cy5TY2hlbWEgPSBleHBvcnRzLmN1c3RvbSA9IGV4cG9ydHMuWm9kUmVhZG9ubHkgPSBleHBvcnRzLlpvZFBpcGVsaW5lID0gZXhwb3J0cy5ab2RCcmFuZGVkID0gZXhwb3J0cy5CUkFORCA9IGV4cG9ydHMuWm9kTmFOID0gZXhwb3J0cy5ab2RDYXRjaCA9IGV4cG9ydHMuWm9kRGVmYXVsdCA9IGV4cG9ydHMuWm9kTnVsbGFibGUgPSBleHBvcnRzLlpvZE9wdGlvbmFsID0gZXhwb3J0cy5ab2RUcmFuc2Zvcm1lciA9IGV4cG9ydHMuWm9kRWZmZWN0cyA9IGV4cG9ydHMuWm9kUHJvbWlzZSA9IGV4cG9ydHMuWm9kTmF0aXZlRW51bSA9IGV4cG9ydHMuWm9kRW51bSA9IGV4cG9ydHMuWm9kTGl0ZXJhbCA9IGV4cG9ydHMuWm9kTGF6eSA9IGV4cG9ydHMuWm9kRnVuY3Rpb24gPSBleHBvcnRzLlpvZFNldCA9IGV4cG9ydHMuWm9kTWFwID0gZXhwb3J0cy5ab2RSZWNvcmQgPSBleHBvcnRzLlpvZFR1cGxlID0gZXhwb3J0cy5ab2RJbnRlcnNlY3Rpb24gPSBleHBvcnRzLlpvZERpc2NyaW1pbmF0ZWRVbmlvbiA9IGV4cG9ydHMuWm9kVW5pb24gPSBleHBvcnRzLlpvZE9iamVjdCA9IGV4cG9ydHMuWm9kQXJyYXkgPSBleHBvcnRzLlpvZFZvaWQgPSBleHBvcnRzLlpvZE5ldmVyID0gZXhwb3J0cy5ab2RVbmtub3duID0gZXhwb3J0cy5ab2RBbnkgPSBleHBvcnRzLlpvZE51bGwgPSBleHBvcnRzLlpvZFVuZGVmaW5lZCA9IGV4cG9ydHMuWm9kU3ltYm9sID0gZXhwb3J0cy5ab2REYXRlID0gZXhwb3J0cy5ab2RCb29sZWFuID0gZXhwb3J0cy5ab2RCaWdJbnQgPSBleHBvcnRzLlpvZE51bWJlciA9IGV4cG9ydHMuWm9kU3RyaW5nID0gZXhwb3J0cy5ab2RUeXBlID0gdm9pZCAwO1xuZXhwb3J0cy5ORVZFUiA9IGV4cG9ydHMudm9pZCA9IGV4cG9ydHMudW5rbm93biA9IGV4cG9ydHMudW5pb24gPSBleHBvcnRzLnVuZGVmaW5lZCA9IGV4cG9ydHMudHVwbGUgPSBleHBvcnRzLnRyYW5zZm9ybWVyID0gZXhwb3J0cy5zeW1ib2wgPSBleHBvcnRzLnN0cmluZyA9IGV4cG9ydHMuc3RyaWN0T2JqZWN0ID0gZXhwb3J0cy5zZXQgPSBleHBvcnRzLnJlY29yZCA9IGV4cG9ydHMucHJvbWlzZSA9IGV4cG9ydHMucHJlcHJvY2VzcyA9IGV4cG9ydHMucGlwZWxpbmUgPSBleHBvcnRzLm9zdHJpbmcgPSBleHBvcnRzLm9wdGlvbmFsID0gZXhwb3J0cy5vbnVtYmVyID0gZXhwb3J0cy5vYm9vbGVhbiA9IGV4cG9ydHMub2JqZWN0ID0gZXhwb3J0cy5udW1iZXIgPSBleHBvcnRzLm51bGxhYmxlID0gZXhwb3J0cy5udWxsID0gZXhwb3J0cy5uZXZlciA9IGV4cG9ydHMubmF0aXZlRW51bSA9IGV4cG9ydHMubmFuID0gZXhwb3J0cy5tYXAgPSBleHBvcnRzLmxpdGVyYWwgPSBleHBvcnRzLmxhenkgPSBleHBvcnRzLmludGVyc2VjdGlvbiA9IGV4cG9ydHMuaW5zdGFuY2VvZiA9IGV4cG9ydHMuZnVuY3Rpb24gPSBleHBvcnRzLmVudW0gPSBleHBvcnRzLmVmZmVjdCA9IGV4cG9ydHMuZGlzY3JpbWluYXRlZFVuaW9uID0gdm9pZCAwO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi9lcnJvcnNcIik7XG5jb25zdCBlcnJvclV0aWxfMSA9IHJlcXVpcmUoXCIuL2hlbHBlcnMvZXJyb3JVdGlsXCIpO1xuY29uc3QgcGFyc2VVdGlsXzEgPSByZXF1aXJlKFwiLi9oZWxwZXJzL3BhcnNlVXRpbFwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuL2hlbHBlcnMvdXRpbFwiKTtcbmNvbnN0IFpvZEVycm9yXzEgPSByZXF1aXJlKFwiLi9ab2RFcnJvclwiKTtcbmNsYXNzIFBhcnNlSW5wdXRMYXp5UGF0aCB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCB2YWx1ZSwgcGF0aCwga2V5KSB7XG4gICAgICAgIHRoaXMuX2NhY2hlZFBhdGggPSBbXTtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMuZGF0YSA9IHZhbHVlO1xuICAgICAgICB0aGlzLl9wYXRoID0gcGF0aDtcbiAgICAgICAgdGhpcy5fa2V5ID0ga2V5O1xuICAgIH1cbiAgICBnZXQgcGF0aCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jYWNoZWRQYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2tleSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVkUGF0aC5wdXNoKC4uLnRoaXMuX3BhdGgsIC4uLnRoaXMuX2tleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZWRQYXRoLnB1c2goLi4udGhpcy5fcGF0aCwgdGhpcy5fa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVkUGF0aDtcbiAgICB9XG59XG5jb25zdCBoYW5kbGVSZXN1bHQgPSAoY3R4LCByZXN1bHQpID0+IHtcbiAgICBpZiAoKDAsIHBhcnNlVXRpbF8xLmlzVmFsaWQpKHJlc3VsdCkpIHtcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogcmVzdWx0LnZhbHVlIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoIWN0eC5jb21tb24uaXNzdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmFsaWRhdGlvbiBmYWlsZWQgYnV0IG5vIGlzc3VlcyBkZXRlY3RlZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgZ2V0IGVycm9yKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9lcnJvcilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Vycm9yO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IFpvZEVycm9yXzEuWm9kRXJyb3IoY3R4LmNvbW1vbi5pc3N1ZXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Vycm9yID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Vycm9yO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG59O1xuZnVuY3Rpb24gcHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpIHtcbiAgICBpZiAoIXBhcmFtcylcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIGNvbnN0IHsgZXJyb3JNYXAsIGludmFsaWRfdHlwZV9lcnJvciwgcmVxdWlyZWRfZXJyb3IsIGRlc2NyaXB0aW9uIH0gPSBwYXJhbXM7XG4gICAgaWYgKGVycm9yTWFwICYmIChpbnZhbGlkX3R5cGVfZXJyb3IgfHwgcmVxdWlyZWRfZXJyb3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuJ3QgdXNlIFwiaW52YWxpZF90eXBlX2Vycm9yXCIgb3IgXCJyZXF1aXJlZF9lcnJvclwiIGluIGNvbmp1bmN0aW9uIHdpdGggY3VzdG9tIGVycm9yIG1hcC5gKTtcbiAgICB9XG4gICAgaWYgKGVycm9yTWFwKVxuICAgICAgICByZXR1cm4geyBlcnJvck1hcDogZXJyb3JNYXAsIGRlc2NyaXB0aW9uIH07XG4gICAgY29uc3QgY3VzdG9tTWFwID0gKGlzcywgY3R4KSA9PiB7XG4gICAgICAgIGlmIChpc3MuY29kZSAhPT0gXCJpbnZhbGlkX3R5cGVcIilcbiAgICAgICAgICAgIHJldHVybiB7IG1lc3NhZ2U6IGN0eC5kZWZhdWx0RXJyb3IgfTtcbiAgICAgICAgaWYgKHR5cGVvZiBjdHguZGF0YSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogcmVxdWlyZWRfZXJyb3IgIT09IG51bGwgJiYgcmVxdWlyZWRfZXJyb3IgIT09IHZvaWQgMCA/IHJlcXVpcmVkX2Vycm9yIDogY3R4LmRlZmF1bHRFcnJvciB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IG1lc3NhZ2U6IGludmFsaWRfdHlwZV9lcnJvciAhPT0gbnVsbCAmJiBpbnZhbGlkX3R5cGVfZXJyb3IgIT09IHZvaWQgMCA/IGludmFsaWRfdHlwZV9lcnJvciA6IGN0eC5kZWZhdWx0RXJyb3IgfTtcbiAgICB9O1xuICAgIHJldHVybiB7IGVycm9yTWFwOiBjdXN0b21NYXAsIGRlc2NyaXB0aW9uIH07XG59XG5jbGFzcyBab2RUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihkZWYpIHtcbiAgICAgICAgLyoqIEFsaWFzIG9mIHNhZmVQYXJzZUFzeW5jICovXG4gICAgICAgIHRoaXMuc3BhID0gdGhpcy5zYWZlUGFyc2VBc3luYztcbiAgICAgICAgdGhpcy5fZGVmID0gZGVmO1xuICAgICAgICB0aGlzLnBhcnNlID0gdGhpcy5wYXJzZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNhZmVQYXJzZSA9IHRoaXMuc2FmZVBhcnNlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucGFyc2VBc3luYyA9IHRoaXMucGFyc2VBc3luYy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNhZmVQYXJzZUFzeW5jID0gdGhpcy5zYWZlUGFyc2VBc3luYy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNwYSA9IHRoaXMuc3BhLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucmVmaW5lID0gdGhpcy5yZWZpbmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZWZpbmVtZW50ID0gdGhpcy5yZWZpbmVtZW50LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc3VwZXJSZWZpbmUgPSB0aGlzLnN1cGVyUmVmaW5lLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub3B0aW9uYWwgPSB0aGlzLm9wdGlvbmFsLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMubnVsbGFibGUgPSB0aGlzLm51bGxhYmxlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMubnVsbGlzaCA9IHRoaXMubnVsbGlzaC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmFycmF5ID0gdGhpcy5hcnJheS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnByb21pc2UgPSB0aGlzLnByb21pc2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vciA9IHRoaXMub3IuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5hbmQgPSB0aGlzLmFuZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybSA9IHRoaXMudHJhbnNmb3JtLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYnJhbmQgPSB0aGlzLmJyYW5kLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZGVmYXVsdCA9IHRoaXMuZGVmYXVsdC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmNhdGNoID0gdGhpcy5jYXRjaC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmRlc2NyaWJlID0gdGhpcy5kZXNjcmliZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnBpcGUgPSB0aGlzLnBpcGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZWFkb25seSA9IHRoaXMucmVhZG9ubHkuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5pc051bGxhYmxlID0gdGhpcy5pc051bGxhYmxlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaXNPcHRpb25hbCA9IHRoaXMuaXNPcHRpb25hbC5iaW5kKHRoaXMpO1xuICAgIH1cbiAgICBnZXQgZGVzY3JpcHRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuZGVzY3JpcHRpb247XG4gICAgfVxuICAgIF9nZXRUeXBlKGlucHV0KSB7XG4gICAgICAgIHJldHVybiAoMCwgdXRpbF8xLmdldFBhcnNlZFR5cGUpKGlucHV0LmRhdGEpO1xuICAgIH1cbiAgICBfZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCkge1xuICAgICAgICByZXR1cm4gKGN0eCB8fCB7XG4gICAgICAgICAgICBjb21tb246IGlucHV0LnBhcmVudC5jb21tb24sXG4gICAgICAgICAgICBkYXRhOiBpbnB1dC5kYXRhLFxuICAgICAgICAgICAgcGFyc2VkVHlwZTogKDAsIHV0aWxfMS5nZXRQYXJzZWRUeXBlKShpbnB1dC5kYXRhKSxcbiAgICAgICAgICAgIHNjaGVtYUVycm9yTWFwOiB0aGlzLl9kZWYuZXJyb3JNYXAsXG4gICAgICAgICAgICBwYXRoOiBpbnB1dC5wYXRoLFxuICAgICAgICAgICAgcGFyZW50OiBpbnB1dC5wYXJlbnQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGF0dXM6IG5ldyBwYXJzZVV0aWxfMS5QYXJzZVN0YXR1cygpLFxuICAgICAgICAgICAgY3R4OiB7XG4gICAgICAgICAgICAgICAgY29tbW9uOiBpbnB1dC5wYXJlbnQuY29tbW9uLFxuICAgICAgICAgICAgICAgIGRhdGE6IGlucHV0LmRhdGEsXG4gICAgICAgICAgICAgICAgcGFyc2VkVHlwZTogKDAsIHV0aWxfMS5nZXRQYXJzZWRUeXBlKShpbnB1dC5kYXRhKSxcbiAgICAgICAgICAgICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxuICAgICAgICAgICAgICAgIHBhdGg6IGlucHV0LnBhdGgsXG4gICAgICAgICAgICAgICAgcGFyZW50OiBpbnB1dC5wYXJlbnQsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBfcGFyc2VTeW5jKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3BhcnNlKGlucHV0KTtcbiAgICAgICAgaWYgKCgwLCBwYXJzZVV0aWxfMS5pc0FzeW5jKShyZXN1bHQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTeW5jaHJvbm91cyBwYXJzZSBlbmNvdW50ZXJlZCBwcm9taXNlLlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBfcGFyc2VBc3luYyhpbnB1dCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9wYXJzZShpbnB1dCk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcbiAgICB9XG4gICAgcGFyc2UoZGF0YSwgcGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuc2FmZVBhcnNlKGRhdGEsIHBhcmFtcyk7XG4gICAgICAgIGlmIChyZXN1bHQuc3VjY2VzcylcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuZGF0YTtcbiAgICAgICAgdGhyb3cgcmVzdWx0LmVycm9yO1xuICAgIH1cbiAgICBzYWZlUGFyc2UoZGF0YSwgcGFyYW1zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgY3R4ID0ge1xuICAgICAgICAgICAgY29tbW9uOiB7XG4gICAgICAgICAgICAgICAgaXNzdWVzOiBbXSxcbiAgICAgICAgICAgICAgICBhc3luYzogKF9hID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmFzeW5jKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb250ZXh0dWFsRXJyb3JNYXA6IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5lcnJvck1hcCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXRoOiAocGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLnBhdGgpIHx8IFtdLFxuICAgICAgICAgICAgc2NoZW1hRXJyb3JNYXA6IHRoaXMuX2RlZi5lcnJvck1hcCxcbiAgICAgICAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBwYXJzZWRUeXBlOiAoMCwgdXRpbF8xLmdldFBhcnNlZFR5cGUpKGRhdGEpLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9wYXJzZVN5bmMoeyBkYXRhLCBwYXRoOiBjdHgucGF0aCwgcGFyZW50OiBjdHggfSk7XG4gICAgICAgIHJldHVybiBoYW5kbGVSZXN1bHQoY3R4LCByZXN1bHQpO1xuICAgIH1cbiAgICBhc3luYyBwYXJzZUFzeW5jKGRhdGEsIHBhcmFtcykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnNhZmVQYXJzZUFzeW5jKGRhdGEsIHBhcmFtcyk7XG4gICAgICAgIGlmIChyZXN1bHQuc3VjY2VzcylcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuZGF0YTtcbiAgICAgICAgdGhyb3cgcmVzdWx0LmVycm9yO1xuICAgIH1cbiAgICBhc3luYyBzYWZlUGFyc2VBc3luYyhkYXRhLCBwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgY3R4ID0ge1xuICAgICAgICAgICAgY29tbW9uOiB7XG4gICAgICAgICAgICAgICAgaXNzdWVzOiBbXSxcbiAgICAgICAgICAgICAgICBjb250ZXh0dWFsRXJyb3JNYXA6IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5lcnJvck1hcCxcbiAgICAgICAgICAgICAgICBhc3luYzogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXRoOiAocGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLnBhdGgpIHx8IFtdLFxuICAgICAgICAgICAgc2NoZW1hRXJyb3JNYXA6IHRoaXMuX2RlZi5lcnJvck1hcCxcbiAgICAgICAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBwYXJzZWRUeXBlOiAoMCwgdXRpbF8xLmdldFBhcnNlZFR5cGUpKGRhdGEpLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBtYXliZUFzeW5jUmVzdWx0ID0gdGhpcy5fcGFyc2UoeyBkYXRhLCBwYXRoOiBjdHgucGF0aCwgcGFyZW50OiBjdHggfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0ICgoMCwgcGFyc2VVdGlsXzEuaXNBc3luYykobWF5YmVBc3luY1Jlc3VsdClcbiAgICAgICAgICAgID8gbWF5YmVBc3luY1Jlc3VsdFxuICAgICAgICAgICAgOiBQcm9taXNlLnJlc29sdmUobWF5YmVBc3luY1Jlc3VsdCkpO1xuICAgICAgICByZXR1cm4gaGFuZGxlUmVzdWx0KGN0eCwgcmVzdWx0KTtcbiAgICB9XG4gICAgcmVmaW5lKGNoZWNrLCBtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IGdldElzc3VlUHJvcGVydGllcyA9ICh2YWwpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgbWVzc2FnZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IG1lc3NhZ2UgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBtZXNzYWdlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZSh2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWZpbmVtZW50KCh2YWwsIGN0eCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gY2hlY2sodmFsKTtcbiAgICAgICAgICAgIGNvbnN0IHNldEVycm9yID0gKCkgPT4gY3R4LmFkZElzc3VlKHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl8xLlpvZElzc3VlQ29kZS5jdXN0b20sXG4gICAgICAgICAgICAgICAgLi4uZ2V0SXNzdWVQcm9wZXJ0aWVzKHZhbCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgUHJvbWlzZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiByZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0RXJyb3IoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHNldEVycm9yKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZWZpbmVtZW50KGNoZWNrLCByZWZpbmVtZW50RGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVmaW5lbWVudCgodmFsLCBjdHgpID0+IHtcbiAgICAgICAgICAgIGlmICghY2hlY2sodmFsKSkge1xuICAgICAgICAgICAgICAgIGN0eC5hZGRJc3N1ZSh0eXBlb2YgcmVmaW5lbWVudERhdGEgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgICAgICAgICA/IHJlZmluZW1lbnREYXRhKHZhbCwgY3R4KVxuICAgICAgICAgICAgICAgICAgICA6IHJlZmluZW1lbnREYXRhKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9yZWZpbmVtZW50KHJlZmluZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RFZmZlY3RzKHtcbiAgICAgICAgICAgIHNjaGVtYTogdGhpcyxcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRWZmZWN0cyxcbiAgICAgICAgICAgIGVmZmVjdDogeyB0eXBlOiBcInJlZmluZW1lbnRcIiwgcmVmaW5lbWVudCB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3VwZXJSZWZpbmUocmVmaW5lbWVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVmaW5lbWVudChyZWZpbmVtZW50KTtcbiAgICB9XG4gICAgb3B0aW9uYWwoKSB7XG4gICAgICAgIHJldHVybiBab2RPcHRpb25hbC5jcmVhdGUodGhpcywgdGhpcy5fZGVmKTtcbiAgICB9XG4gICAgbnVsbGFibGUoKSB7XG4gICAgICAgIHJldHVybiBab2ROdWxsYWJsZS5jcmVhdGUodGhpcywgdGhpcy5fZGVmKTtcbiAgICB9XG4gICAgbnVsbGlzaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubnVsbGFibGUoKS5vcHRpb25hbCgpO1xuICAgIH1cbiAgICBhcnJheSgpIHtcbiAgICAgICAgcmV0dXJuIFpvZEFycmF5LmNyZWF0ZSh0aGlzLCB0aGlzLl9kZWYpO1xuICAgIH1cbiAgICBwcm9taXNlKCkge1xuICAgICAgICByZXR1cm4gWm9kUHJvbWlzZS5jcmVhdGUodGhpcywgdGhpcy5fZGVmKTtcbiAgICB9XG4gICAgb3Iob3B0aW9uKSB7XG4gICAgICAgIHJldHVybiBab2RVbmlvbi5jcmVhdGUoW3RoaXMsIG9wdGlvbl0sIHRoaXMuX2RlZik7XG4gICAgfVxuICAgIGFuZChpbmNvbWluZykge1xuICAgICAgICByZXR1cm4gWm9kSW50ZXJzZWN0aW9uLmNyZWF0ZSh0aGlzLCBpbmNvbWluZywgdGhpcy5fZGVmKTtcbiAgICB9XG4gICAgdHJhbnNmb3JtKHRyYW5zZm9ybSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEVmZmVjdHMoe1xuICAgICAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyh0aGlzLl9kZWYpLFxuICAgICAgICAgICAgc2NoZW1hOiB0aGlzLFxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFZmZlY3RzLFxuICAgICAgICAgICAgZWZmZWN0OiB7IHR5cGU6IFwidHJhbnNmb3JtXCIsIHRyYW5zZm9ybSB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGVmYXVsdChkZWYpIHtcbiAgICAgICAgY29uc3QgZGVmYXVsdFZhbHVlRnVuYyA9IHR5cGVvZiBkZWYgPT09IFwiZnVuY3Rpb25cIiA/IGRlZiA6ICgpID0+IGRlZjtcbiAgICAgICAgcmV0dXJuIG5ldyBab2REZWZhdWx0KHtcbiAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXModGhpcy5fZGVmKSxcbiAgICAgICAgICAgIGlubmVyVHlwZTogdGhpcyxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogZGVmYXVsdFZhbHVlRnVuYyxcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRGVmYXVsdCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGJyYW5kKCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEJyYW5kZWQoe1xuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RCcmFuZGVkLFxuICAgICAgICAgICAgdHlwZTogdGhpcyxcbiAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXModGhpcy5fZGVmKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNhdGNoKGRlZikge1xuICAgICAgICBjb25zdCBjYXRjaFZhbHVlRnVuYyA9IHR5cGVvZiBkZWYgPT09IFwiZnVuY3Rpb25cIiA/IGRlZiA6ICgpID0+IGRlZjtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RDYXRjaCh7XG4gICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHRoaXMuX2RlZiksXG4gICAgICAgICAgICBpbm5lclR5cGU6IHRoaXMsXG4gICAgICAgICAgICBjYXRjaFZhbHVlOiBjYXRjaFZhbHVlRnVuYyxcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQ2F0Y2gsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkZXNjcmliZShkZXNjcmlwdGlvbikge1xuICAgICAgICBjb25zdCBUaGlzID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgcmV0dXJuIG5ldyBUaGlzKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcGlwZSh0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIFpvZFBpcGVsaW5lLmNyZWF0ZSh0aGlzLCB0YXJnZXQpO1xuICAgIH1cbiAgICByZWFkb25seSgpIHtcbiAgICAgICAgcmV0dXJuIFpvZFJlYWRvbmx5LmNyZWF0ZSh0aGlzKTtcbiAgICB9XG4gICAgaXNPcHRpb25hbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2FmZVBhcnNlKHVuZGVmaW5lZCkuc3VjY2VzcztcbiAgICB9XG4gICAgaXNOdWxsYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2FmZVBhcnNlKG51bGwpLnN1Y2Nlc3M7XG4gICAgfVxufVxuZXhwb3J0cy5ab2RUeXBlID0gWm9kVHlwZTtcbmV4cG9ydHMuU2NoZW1hID0gWm9kVHlwZTtcbmV4cG9ydHMuWm9kU2NoZW1hID0gWm9kVHlwZTtcbmNvbnN0IGN1aWRSZWdleCA9IC9eY1teXFxzLV17OCx9JC9pO1xuY29uc3QgY3VpZDJSZWdleCA9IC9eW2Etel1bYS16MC05XSokLztcbmNvbnN0IHVsaWRSZWdleCA9IC9eWzAtOUEtSEpLTU5QLVRWLVpdezI2fSQvO1xuLy8gY29uc3QgdXVpZFJlZ2V4ID1cbi8vICAgL14oW2EtZjAtOV17OH0tW2EtZjAtOV17NH0tWzEtNV1bYS1mMC05XXszfS1bYS1mMC05XXs0fS1bYS1mMC05XXsxMn18MDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwKSQvaTtcbmNvbnN0IHV1aWRSZWdleCA9IC9eWzAtOWEtZkEtRl17OH1cXGItWzAtOWEtZkEtRl17NH1cXGItWzAtOWEtZkEtRl17NH1cXGItWzAtOWEtZkEtRl17NH1cXGItWzAtOWEtZkEtRl17MTJ9JC9pO1xuLy8gZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDYxODEvMTU1MDE1NVxuLy8gb2xkIHZlcnNpb246IHRvbyBzbG93LCBkaWRuJ3Qgc3VwcG9ydCB1bmljb2RlXG4vLyBjb25zdCBlbWFpbFJlZ2V4ID0gL14oKChbYS16XXxcXGR8WyEjXFwkJSYnXFwqXFwrXFwtXFwvPVxcP1xcXl9ge1xcfH1+XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkrKFxcLihbYS16XXxcXGR8WyEjXFwkJSYnXFwqXFwrXFwtXFwvPVxcP1xcXl9ge1xcfH1+XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkrKSopfCgoXFx4MjIpKCgoKFxceDIwfFxceDA5KSooXFx4MGRcXHgwYSkpPyhcXHgyMHxcXHgwOSkrKT8oKFtcXHgwMS1cXHgwOFxceDBiXFx4MGNcXHgwZS1cXHgxZlxceDdmXXxcXHgyMXxbXFx4MjMtXFx4NWJdfFtcXHg1ZC1cXHg3ZV18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfChcXFxcKFtcXHgwMS1cXHgwOVxceDBiXFx4MGNcXHgwZC1cXHg3Zl18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKSkpKigoKFxceDIwfFxceDA5KSooXFx4MGRcXHgwYSkpPyhcXHgyMHxcXHgwOSkrKT8oXFx4MjIpKSlAKCgoW2Etel18XFxkfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoKFthLXpdfFxcZHxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkoW2Etel18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkqKFthLXpdfFxcZHxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkpKVxcLikrKChbYS16XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KChbYS16XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkoW2Etel18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkqKFthLXpdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSkpJC9pO1xuLy9vbGQgZW1haWwgcmVnZXhcbi8vIGNvbnN0IGVtYWlsUmVnZXggPSAvXigoW148PigpW1xcXS4sOzpcXHNAXCJdKyhcXC5bXjw+KClbXFxdLiw7Olxcc0BcIl0rKSopfChcIi4rXCIpKUAoKD8hLSkoW148PigpW1xcXS4sOzpcXHNAXCJdK1xcLikrW148PigpW1xcXS4sOzpcXHNAXCJdezEsfSlbXi08PigpW1xcXS4sOzpcXHNAXCJdJC9pO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4vLyBjb25zdCBlbWFpbFJlZ2V4ID1cbi8vICAgL14oKFtePD4oKVtcXF1cXFxcLiw7Olxcc0BcXFwiXSsoXFwuW148PigpW1xcXVxcXFwuLDs6XFxzQFxcXCJdKykqKXwoXFxcIi4rXFxcIikpQCgoXFxbKCgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpXFwuKXszfSgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpXFxdKXwoXFxbSVB2NjooKFthLWYwLTldezEsNH06KXs3fXw6OihbYS1mMC05XXsxLDR9Oil7MCw2fXwoW2EtZjAtOV17MSw0fTopezF9OihbYS1mMC05XXsxLDR9Oil7MCw1fXwoW2EtZjAtOV17MSw0fTopezJ9OihbYS1mMC05XXsxLDR9Oil7MCw0fXwoW2EtZjAtOV17MSw0fTopezN9OihbYS1mMC05XXsxLDR9Oil7MCwzfXwoW2EtZjAtOV17MSw0fTopezR9OihbYS1mMC05XXsxLDR9Oil7MCwyfXwoW2EtZjAtOV17MSw0fTopezV9OihbYS1mMC05XXsxLDR9Oil7MCwxfSkoW2EtZjAtOV17MSw0fXwoKCgyNVswLTVdKXwoMlswLTRdWzAtOV0pfCgxWzAtOV17Mn0pfChbMC05XXsxLDJ9KSlcXC4pezN9KCgyNVswLTVdKXwoMlswLTRdWzAtOV0pfCgxWzAtOV17Mn0pfChbMC05XXsxLDJ9KSkpXFxdKXwoW0EtWmEtejAtOV0oW0EtWmEtejAtOS1dKltBLVphLXowLTldKSooXFwuW0EtWmEtel17Mix9KSspKSQvO1xuLy8gY29uc3QgZW1haWxSZWdleCA9XG4vLyAgIC9eW2EtekEtWjAtOVxcLlxcIVxcI1xcJFxcJVxcJlxcJ1xcKlxcK1xcL1xcPVxcP1xcXlxcX1xcYFxce1xcfFxcfVxcflxcLV0rQFthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPyg/OlxcLlthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPykqJC87XG4vLyBjb25zdCBlbWFpbFJlZ2V4ID1cbi8vICAgL14oPzpbYS16MC05ISMkJSYnKisvPT9eX2B7fH1+LV0rKD86XFwuW2EtejAtOSEjJCUmJyorLz0/Xl9ge3x9fi1dKykqfFwiKD86W1xceDAxLVxceDA4XFx4MGJcXHgwY1xceDBlLVxceDFmXFx4MjFcXHgyMy1cXHg1YlxceDVkLVxceDdmXXxcXFxcW1xceDAxLVxceDA5XFx4MGJcXHgwY1xceDBlLVxceDdmXSkqXCIpQCg/Oig/OlthLXowLTldKD86W2EtejAtOS1dKlthLXowLTldKT9cXC4pK1thLXowLTldKD86W2EtejAtOS1dKlthLXowLTldKT98XFxbKD86KD86MjVbMC01XXwyWzAtNF1bMC05XXxbMDFdP1swLTldWzAtOV0/KVxcLil7M30oPzoyNVswLTVdfDJbMC00XVswLTldfFswMV0/WzAtOV1bMC05XT98W2EtejAtOS1dKlthLXowLTldOig/OltcXHgwMS1cXHgwOFxceDBiXFx4MGNcXHgwZS1cXHgxZlxceDIxLVxceDVhXFx4NTMtXFx4N2ZdfFxcXFxbXFx4MDEtXFx4MDlcXHgwYlxceDBjXFx4MGUtXFx4N2ZdKSspXFxdKSQvaTtcbmNvbnN0IGVtYWlsUmVnZXggPSAvXig/IVxcLikoPyEuKlxcLlxcLikoW0EtWjAtOV8rLVxcLl0qKVtBLVowLTlfKy1dQChbQS1aMC05XVtBLVowLTlcXC1dKlxcLikrW0EtWl17Mix9JC9pO1xuLy8gY29uc3QgZW1haWxSZWdleCA9XG4vLyAgIC9eW2EtejAtOS4hIyQlJuKAmSorLz0/Xl9ge3x9fi1dK0BbYS16MC05LV0rKD86XFwuW2EtejAtOVxcLV0rKSokL2k7XG4vLyBmcm9tIGh0dHBzOi8vdGhla2V2aW5zY290dC5jb20vZW1vamlzLWluLWphdmFzY3JpcHQvI3dyaXRpbmctYS1yZWd1bGFyLWV4cHJlc3Npb25cbmNvbnN0IF9lbW9qaVJlZ2V4ID0gYF4oXFxcXHB7RXh0ZW5kZWRfUGljdG9ncmFwaGljfXxcXFxccHtFbW9qaV9Db21wb25lbnR9KSskYDtcbmxldCBlbW9qaVJlZ2V4O1xuY29uc3QgaXB2NFJlZ2V4ID0gL14oKCgyNVswLTVdKXwoMlswLTRdWzAtOV0pfCgxWzAtOV17Mn0pfChbMC05XXsxLDJ9KSlcXC4pezN9KCgyNVswLTVdKXwoMlswLTRdWzAtOV0pfCgxWzAtOV17Mn0pfChbMC05XXsxLDJ9KSkkLztcbmNvbnN0IGlwdjZSZWdleCA9IC9eKChbYS1mMC05XXsxLDR9Oil7N318OjooW2EtZjAtOV17MSw0fTopezAsNn18KFthLWYwLTldezEsNH06KXsxfTooW2EtZjAtOV17MSw0fTopezAsNX18KFthLWYwLTldezEsNH06KXsyfTooW2EtZjAtOV17MSw0fTopezAsNH18KFthLWYwLTldezEsNH06KXszfTooW2EtZjAtOV17MSw0fTopezAsM318KFthLWYwLTldezEsNH06KXs0fTooW2EtZjAtOV17MSw0fTopezAsMn18KFthLWYwLTldezEsNH06KXs1fTooW2EtZjAtOV17MSw0fTopezAsMX0pKFthLWYwLTldezEsNH18KCgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpXFwuKXszfSgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpKSQvO1xuLy8gQWRhcHRlZCBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zMTQzMjMxXG5jb25zdCBkYXRldGltZVJlZ2V4ID0gKGFyZ3MpID0+IHtcbiAgICBpZiAoYXJncy5wcmVjaXNpb24pIHtcbiAgICAgICAgaWYgKGFyZ3Mub2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChgXlxcXFxkezR9LVxcXFxkezJ9LVxcXFxkezJ9VFxcXFxkezJ9OlxcXFxkezJ9OlxcXFxkezJ9XFxcXC5cXFxcZHske2FyZ3MucHJlY2lzaW9ufX0oKFsrLV1cXFxcZHsyfSg6P1xcXFxkezJ9KT8pfFopJGApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoYF5cXFxcZHs0fS1cXFxcZHsyfS1cXFxcZHsyfVRcXFxcZHsyfTpcXFxcZHsyfTpcXFxcZHsyfVxcXFwuXFxcXGR7JHthcmdzLnByZWNpc2lvbn19WiRgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChhcmdzLnByZWNpc2lvbiA9PT0gMCkge1xuICAgICAgICBpZiAoYXJncy5vZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKGBeXFxcXGR7NH0tXFxcXGR7Mn0tXFxcXGR7Mn1UXFxcXGR7Mn06XFxcXGR7Mn06XFxcXGR7Mn0oKFsrLV1cXFxcZHsyfSg6P1xcXFxkezJ9KT8pfFopJGApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoYF5cXFxcZHs0fS1cXFxcZHsyfS1cXFxcZHsyfVRcXFxcZHsyfTpcXFxcZHsyfTpcXFxcZHsyfVokYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChhcmdzLm9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoYF5cXFxcZHs0fS1cXFxcZHsyfS1cXFxcZHsyfVRcXFxcZHsyfTpcXFxcZHsyfTpcXFxcZHsyfShcXFxcLlxcXFxkKyk/KChbKy1dXFxcXGR7Mn0oOj9cXFxcZHsyfSk/KXxaKSRgKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKGBeXFxcXGR7NH0tXFxcXGR7Mn0tXFxcXGR7Mn1UXFxcXGR7Mn06XFxcXGR7Mn06XFxcXGR7Mn0oXFxcXC5cXFxcZCspP1okYCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuZnVuY3Rpb24gaXNWYWxpZElQKGlwLCB2ZXJzaW9uKSB7XG4gICAgaWYgKCh2ZXJzaW9uID09PSBcInY0XCIgfHwgIXZlcnNpb24pICYmIGlwdjRSZWdleC50ZXN0KGlwKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCh2ZXJzaW9uID09PSBcInY2XCIgfHwgIXZlcnNpb24pICYmIGlwdjZSZWdleC50ZXN0KGlwKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuY2xhc3MgWm9kU3RyaW5nIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWYuY29lcmNlKSB7XG4gICAgICAgICAgICBpbnB1dC5kYXRhID0gU3RyaW5nKGlucHV0LmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IHV0aWxfMS5ab2RQYXJzZWRUeXBlLnN0cmluZykge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgKDAsIHBhcnNlVXRpbF8xLmFkZElzc3VlVG9Db250ZXh0KShjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl8xLlpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IHV0aWxfMS5ab2RQYXJzZWRUeXBlLnN0cmluZyxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVV0aWxfMS5JTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IG5ldyBwYXJzZVV0aWxfMS5QYXJzZVN0YXR1cygpO1xuICAgICAgICBsZXQgY3R4ID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGNoZWNrIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaGVjay5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmRhdGEubGVuZ3RoIDwgY2hlY2sudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgICgwLCBwYXJzZVV0aWxfMS5hZGRJc3N1ZVRvQ29udGV4dCkoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl8xLlpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5pbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5kYXRhLmxlbmd0aCA+IGNoZWNrLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICAoMCwgcGFyc2VVdGlsXzEuYWRkSXNzdWVUb0NvbnRleHQpKGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfMS5ab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heGltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImxlbmd0aFwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9vQmlnID0gaW5wdXQuZGF0YS5sZW5ndGggPiBjaGVjay52YWx1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCB0b29TbWFsbCA9IGlucHV0LmRhdGEubGVuZ3RoIDwgY2hlY2sudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHRvb0JpZyB8fCB0b29TbWFsbCkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvb0JpZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIHBhcnNlVXRpbF8xLmFkZElzc3VlVG9Db250ZXh0KShjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl8xLlpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heGltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0b29TbWFsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIHBhcnNlVXRpbF8xLmFkZElzc3VlVG9Db250ZXh0KShjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl8xLlpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluaW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZW1haWxcIikge1xuICAgICAgICAgICAgICAgIGlmICghZW1haWxSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICAoMCwgcGFyc2VVdGlsXzEuYWRkSXNzdWVUb0NvbnRleHQpKGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJlbWFpbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfMS5ab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJlbW9qaVwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlbW9qaVJlZ2V4KSB7XG4gICAgICAgICAgICAgICAgICAgIGVtb2ppUmVnZXggPSBuZXcgUmVnRXhwKF9lbW9qaVJlZ2V4LCBcInVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghZW1vamlSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICAoMCwgcGFyc2VVdGlsXzEuYWRkSXNzdWVUb0NvbnRleHQpKGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJlbW9qaVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfMS5ab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ1dWlkXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXV1aWRSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICAoMCwgcGFyc2VVdGlsXzEuYWRkSXNzdWVUb0NvbnRleHQpKGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJ1dWlkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl8xLlpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImN1aWRcIikge1xuICAgICAgICAgICAgICAgIGlmICghY3VpZFJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgICgwLCBwYXJzZVV0aWxfMS5hZGRJc3N1ZVRvQ29udGV4dCkoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImN1aWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yXzEuWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiY3VpZDJcIikge1xuICAgICAgICAgICAgICAgIGlmICghY3VpZDJSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICAoMCwgcGFyc2VVdGlsXzEuYWRkSXNzdWVUb0NvbnRleHQpKGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJjdWlkMlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfMS5ab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ1bGlkXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXVsaWRSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICAoMCwgcGFyc2VVdGlsXzEuYWRkSXNzdWVUb0NvbnRleHQpKGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJ1bGlkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl8xLlpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInVybFwiKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgbmV3IFVSTChpbnB1dC5kYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICAoMCwgcGFyc2VVdGlsXzEuYWRkSXNzdWVUb0NvbnRleHQpKGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJ1cmxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yXzEuWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwicmVnZXhcIikge1xuICAgICAgICAgICAgICAgIGNoZWNrLnJlZ2V4Lmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgY29uc3QgdGVzdFJlc3VsdCA9IGNoZWNrLnJlZ2V4LnRlc3QoaW5wdXQuZGF0YSk7XG4gICAgICAgICAgICAgICAgaWYgKCF0ZXN0UmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICAoMCwgcGFyc2VVdGlsXzEuYWRkSXNzdWVUb0NvbnRleHQpKGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJyZWdleFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfMS5ab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ0cmltXCIpIHtcbiAgICAgICAgICAgICAgICBpbnB1dC5kYXRhID0gaW5wdXQuZGF0YS50cmltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImluY2x1ZGVzXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlucHV0LmRhdGEuaW5jbHVkZXMoY2hlY2sudmFsdWUsIGNoZWNrLnBvc2l0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgKDAsIHBhcnNlVXRpbF8xLmFkZElzc3VlVG9Db250ZXh0KShjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yXzEuWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogeyBpbmNsdWRlczogY2hlY2sudmFsdWUsIHBvc2l0aW9uOiBjaGVjay5wb3NpdGlvbiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwidG9Mb3dlckNhc2VcIikge1xuICAgICAgICAgICAgICAgIGlucHV0LmRhdGEgPSBpbnB1dC5kYXRhLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInRvVXBwZXJDYXNlXCIpIHtcbiAgICAgICAgICAgICAgICBpbnB1dC5kYXRhID0gaW5wdXQuZGF0YS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJzdGFydHNXaXRoXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlucHV0LmRhdGEuc3RhcnRzV2l0aChjaGVjay52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgICgwLCBwYXJzZVV0aWxfMS5hZGRJc3N1ZVRvQ29udGV4dCkoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl8xLlpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IHsgc3RhcnRzV2l0aDogY2hlY2sudmFsdWUgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImVuZHNXaXRoXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlucHV0LmRhdGEuZW5kc1dpdGgoY2hlY2sudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICAoMCwgcGFyc2VVdGlsXzEuYWRkSXNzdWVUb0NvbnRleHQpKGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfMS5ab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiB7IGVuZHNXaXRoOiBjaGVjay52YWx1ZSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZGF0ZXRpbWVcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2V4ID0gZGF0ZXRpbWVSZWdleChjaGVjayk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICAoMCwgcGFyc2VVdGlsXzEuYWRkSXNzdWVUb0NvbnRleHQpKGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfMS5ab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImRhdGV0aW1lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJpcFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkSVAoaW5wdXQuZGF0YSwgY2hlY2sudmVyc2lvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgICgwLCBwYXJzZVV0aWxfMS5hZGRJc3N1ZVRvQ29udGV4dCkoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImlwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl8xLlpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1dGlsXzEudXRpbC5hc3NlcnROZXZlcihjaGVjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBpbnB1dC5kYXRhIH07XG4gICAgfVxuICAgIF9yZWdleChyZWdleCwgdmFsaWRhdGlvbiwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWZpbmVtZW50KChkYXRhKSA9PiByZWdleC50ZXN0KGRhdGEpLCB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uLFxuICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfMS5ab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWxfMS5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfYWRkQ2hlY2soY2hlY2spIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RTdHJpbmcoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgY2hlY2tdLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZW1haWwobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImVtYWlsXCIsIC4uLmVycm9yVXRpbF8xLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgdXJsKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJ1cmxcIiwgLi4uZXJyb3JVdGlsXzEuZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICAgIH1cbiAgICBlbW9qaShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiZW1vamlcIiwgLi4uZXJyb3JVdGlsXzEuZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICAgIH1cbiAgICB1dWlkKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJ1dWlkXCIsIC4uLmVycm9yVXRpbF8xLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgY3VpZChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiY3VpZFwiLCAuLi5lcnJvclV0aWxfMS5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gICAgfVxuICAgIGN1aWQyKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJjdWlkMlwiLCAuLi5lcnJvclV0aWxfMS5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gICAgfVxuICAgIHVsaWQobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcInVsaWRcIiwgLi4uZXJyb3JVdGlsXzEuZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICAgIH1cbiAgICBpcChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiaXBcIiwgLi4uZXJyb3JVdGlsXzEuZXJyb3JVdGlsLmVyclRvT2JqKG9wdGlvbnMpIH0pO1xuICAgIH1cbiAgICBkYXRldGltZShvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAgICAgIGtpbmQ6IFwiZGF0ZXRpbWVcIixcbiAgICAgICAgICAgICAgICBwcmVjaXNpb246IG51bGwsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBvcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwiZGF0ZXRpbWVcIixcbiAgICAgICAgICAgIHByZWNpc2lvbjogdHlwZW9mIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucHJlY2lzaW9uKSA9PT0gXCJ1bmRlZmluZWRcIiA/IG51bGwgOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucHJlY2lzaW9uLFxuICAgICAgICAgICAgb2Zmc2V0OiAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMub2Zmc2V0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZSxcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbF8xLmVycm9yVXRpbC5lcnJUb09iaihvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZWdleChyZWdleCwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJyZWdleFwiLFxuICAgICAgICAgICAgcmVnZXg6IHJlZ2V4LFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsXzEuZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW5jbHVkZXModmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwiaW5jbHVkZXNcIixcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucG9zaXRpb24sXG4gICAgICAgICAgICAuLi5lcnJvclV0aWxfMS5lcnJvclV0aWwuZXJyVG9PYmoob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhcnRzV2l0aCh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJzdGFydHNXaXRoXCIsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWxfMS5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbmRzV2l0aCh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJlbmRzV2l0aFwiLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsXzEuZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWluKG1pbkxlbmd0aCwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtaW5cIixcbiAgICAgICAgICAgIHZhbHVlOiBtaW5MZW5ndGgsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWxfMS5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtYXgobWF4TGVuZ3RoLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgICAgICAgdmFsdWU6IG1heExlbmd0aCxcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbF8xLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxlbmd0aChsZW4sIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibGVuZ3RoXCIsXG4gICAgICAgICAgICB2YWx1ZTogbGVuLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsXzEuZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIHouc3RyaW5nKCkubWluKDEpIGluc3RlYWQuXG4gICAgICogQHNlZSB7QGxpbmsgWm9kU3RyaW5nLm1pbn1cbiAgICAgKi9cbiAgICBub25lbXB0eShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbigxLCBlcnJvclV0aWxfMS5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkpO1xuICAgIH1cbiAgICB0cmltKCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFN0cmluZyh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCB7IGtpbmQ6IFwidHJpbVwiIH1dLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdG9Mb3dlckNhc2UoKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kU3RyaW5nKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIHsga2luZDogXCJ0b0xvd2VyQ2FzZVwiIH1dLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdG9VcHBlckNhc2UoKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kU3RyaW5nKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIHsga2luZDogXCJ0b1VwcGVyQ2FzZVwiIH1dLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IGlzRGF0ZXRpbWUoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiZGF0ZXRpbWVcIik7XG4gICAgfVxuICAgIGdldCBpc0VtYWlsKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImVtYWlsXCIpO1xuICAgIH1cbiAgICBnZXQgaXNVUkwoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwidXJsXCIpO1xuICAgIH1cbiAgICBnZXQgaXNFbW9qaSgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJlbW9qaVwiKTtcbiAgICB9XG4gICAgZ2V0IGlzVVVJRCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJ1dWlkXCIpO1xuICAgIH1cbiAgICBnZXQgaXNDVUlEKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImN1aWRcIik7XG4gICAgfVxuICAgIGdldCBpc0NVSUQyKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImN1aWQyXCIpO1xuICAgIH1cbiAgICBnZXQgaXNVTElEKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcInVsaWRcIik7XG4gICAgfVxuICAgIGdldCBpc0lQKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImlwXCIpO1xuICAgIH1cbiAgICBnZXQgbWluTGVuZ3RoKCkge1xuICAgICAgICBsZXQgbWluID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGlmIChtaW4gPT09IG51bGwgfHwgY2gudmFsdWUgPiBtaW4pXG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaW47XG4gICAgfVxuICAgIGdldCBtYXhMZW5ndGgoKSB7XG4gICAgICAgIGxldCBtYXggPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaC5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1heCA9PT0gbnVsbCB8fCBjaC52YWx1ZSA8IG1heClcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICB9XG59XG5leHBvcnRzLlpvZFN0cmluZyA9IFpvZFN0cmluZztcblpvZFN0cmluZy5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBuZXcgWm9kU3RyaW5nKHtcbiAgICAgICAgY2hlY2tzOiBbXSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RTdHJpbmcsXG4gICAgICAgIGNvZXJjZTogKF9hID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmNvZXJjZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2UsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG4vLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zOTY2NDg0L3doeS1kb2VzLW1vZHVsdXMtb3BlcmF0b3ItcmV0dXJuLWZyYWN0aW9uYWwtbnVtYmVyLWluLWphdmFzY3JpcHQvMzE3MTEwMzQjMzE3MTEwMzRcbmZ1bmN0aW9uIGZsb2F0U2FmZVJlbWFpbmRlcih2YWwsIHN0ZXApIHtcbiAgICBjb25zdCB2YWxEZWNDb3VudCA9ICh2YWwudG9TdHJpbmcoKS5zcGxpdChcIi5cIilbMV0gfHwgXCJcIikubGVuZ3RoO1xuICAgIGNvbnN0IHN0ZXBEZWNDb3VudCA9IChzdGVwLnRvU3RyaW5nKCkuc3BsaXQoXCIuXCIpWzFdIHx8IFwiXCIpLmxlbmd0aDtcbiAgICBjb25zdCBkZWNDb3VudCA9IHZhbERlY0NvdW50ID4gc3RlcERlY0NvdW50ID8gdmFsRGVjQ291bnQgOiBzdGVwRGVjQ291bnQ7XG4gICAgY29uc3QgdmFsSW50ID0gcGFyc2VJbnQodmFsLnRvRml4ZWQoZGVjQ291bnQpLnJlcGxhY2UoXCIuXCIsIFwiXCIpKTtcbiAgICBjb25zdCBzdGVwSW50ID0gcGFyc2VJbnQoc3RlcC50b0ZpeGVkKGRlY0NvdW50KS5yZXBsYWNlKFwiLlwiLCBcIlwiKSk7XG4gICAgcmV0dXJuICh2YWxJbnQgJSBzdGVwSW50KSAvIE1hdGgucG93KDEwLCBkZWNDb3VudCk7XG59XG5jbGFzcyBab2ROdW1iZXIgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5taW4gPSB0aGlzLmd0ZTtcbiAgICAgICAgdGhpcy5tYXggPSB0aGlzLmx0ZTtcbiAgICAgICAgdGhpcy5zdGVwID0gdGhpcy5tdWx0aXBsZU9mO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlZi5jb2VyY2UpIHtcbiAgICAgICAgICAgIGlucHV0LmRhdGEgPSBOdW1iZXIoaW5wdXQuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gdXRpbF8xLlpvZFBhcnNlZFR5cGUubnVtYmVyKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICAoMCwgcGFyc2VVdGlsXzEuYWRkSXNzdWVUb0NvbnRleHQpKGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yXzEuWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogdXRpbF8xLlpvZFBhcnNlZFR5cGUubnVtYmVyLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVXRpbF8xLklOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN0eCA9IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0gbmV3IHBhcnNlVXRpbF8xLlBhcnNlU3RhdHVzKCk7XG4gICAgICAgIGZvciAoY29uc3QgY2hlY2sgb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoZWNrLmtpbmQgPT09IFwiaW50XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXV0aWxfMS51dGlsLmlzSW50ZWdlcihpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgKDAsIHBhcnNlVXRpbF8xLmFkZElzc3VlVG9Db250ZXh0KShjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yXzEuWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBcImludGVnZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBcImZsb2F0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvb1NtYWxsID0gY2hlY2suaW5jbHVzaXZlXG4gICAgICAgICAgICAgICAgICAgID8gaW5wdXQuZGF0YSA8IGNoZWNrLnZhbHVlXG4gICAgICAgICAgICAgICAgICAgIDogaW5wdXQuZGF0YSA8PSBjaGVjay52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodG9vU21hbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgICgwLCBwYXJzZVV0aWxfMS5hZGRJc3N1ZVRvQ29udGV4dCkoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl8xLlpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5pbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IGNoZWNrLmluY2x1c2l2ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9vQmlnID0gY2hlY2suaW5jbHVzaXZlXG4gICAgICAgICAgICAgICAgICAgID8gaW5wdXQuZGF0YSA+IGNoZWNrLnZhbHVlXG4gICAgICAgICAgICAgICAgICAgIDogaW5wdXQuZGF0YSA+PSBjaGVjay52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodG9vQmlnKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICAoMCwgcGFyc2VVdGlsXzEuYWRkSXNzdWVUb0NvbnRleHQpKGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfMS5ab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heGltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogY2hlY2suaW5jbHVzaXZlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibXVsdGlwbGVPZlwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZsb2F0U2FmZVJlbWFpbmRlcihpbnB1dC5kYXRhLCBjaGVjay52YWx1ZSkgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgICgwLCBwYXJzZVV0aWxfMS5hZGRJc3N1ZVRvQ29udGV4dCkoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl8xLlpvZElzc3VlQ29kZS5ub3RfbXVsdGlwbGVfb2YsXG4gICAgICAgICAgICAgICAgICAgICAgICBtdWx0aXBsZU9mOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImZpbml0ZVwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgICgwLCBwYXJzZVV0aWxfMS5hZGRJc3N1ZVRvQ29udGV4dCkoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl8xLlpvZElzc3VlQ29kZS5ub3RfZmluaXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHV0aWxfMS51dGlsLmFzc2VydE5ldmVyKGNoZWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlucHV0LmRhdGEgfTtcbiAgICB9XG4gICAgZ3RlKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWluXCIsIHZhbHVlLCB0cnVlLCBlcnJvclV0aWxfMS5lcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICAgIH1cbiAgICBndCh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1pblwiLCB2YWx1ZSwgZmFsc2UsIGVycm9yVXRpbF8xLmVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XG4gICAgfVxuICAgIGx0ZSh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1heFwiLCB2YWx1ZSwgdHJ1ZSwgZXJyb3JVdGlsXzEuZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgbHQodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtYXhcIiwgdmFsdWUsIGZhbHNlLCBlcnJvclV0aWxfMS5lcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICAgIH1cbiAgICBzZXRMaW1pdChraW5kLCB2YWx1ZSwgaW5jbHVzaXZlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kTnVtYmVyKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNoZWNrczogW1xuICAgICAgICAgICAgICAgIC4uLnRoaXMuX2RlZi5jaGVja3MsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBraW5kLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWxfMS5lcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfYWRkQ2hlY2soY2hlY2spIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2ROdW1iZXIoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgY2hlY2tdLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW50KG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwiaW50XCIsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWxfMS5lcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwb3NpdGl2ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgICAgICAgdmFsdWU6IDAsXG4gICAgICAgICAgICBpbmNsdXNpdmU6IGZhbHNlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsXzEuZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbmVnYXRpdmUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtYXhcIixcbiAgICAgICAgICAgIHZhbHVlOiAwLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiBmYWxzZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbF8xLmVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5vbnBvc2l0aXZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICAgICAgICB2YWx1ZTogMCxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbF8xLmVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5vbm5lZ2F0aXZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICAgICAgICB2YWx1ZTogMCxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbF8xLmVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG11bHRpcGxlT2YodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibXVsdGlwbGVPZlwiLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsXzEuZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZmluaXRlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwiZmluaXRlXCIsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWxfMS5lcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzYWZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWxfMS5lcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsXzEuZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IG1pblZhbHVlKCkge1xuICAgICAgICBsZXQgbWluID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGlmIChtaW4gPT09IG51bGwgfHwgY2gudmFsdWUgPiBtaW4pXG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaW47XG4gICAgfVxuICAgIGdldCBtYXhWYWx1ZSgpIHtcbiAgICAgICAgbGV0IG1heCA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWF4ID09PSBudWxsIHx8IGNoLnZhbHVlIDwgbWF4KVxuICAgICAgICAgICAgICAgICAgICBtYXggPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF4O1xuICAgIH1cbiAgICBnZXQgaXNJbnQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiaW50XCIgfHxcbiAgICAgICAgICAgIChjaC5raW5kID09PSBcIm11bHRpcGxlT2ZcIiAmJiB1dGlsXzEudXRpbC5pc0ludGVnZXIoY2gudmFsdWUpKSk7XG4gICAgfVxuICAgIGdldCBpc0Zpbml0ZSgpIHtcbiAgICAgICAgbGV0IG1heCA9IG51bGwsIG1pbiA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwiZmluaXRlXCIgfHxcbiAgICAgICAgICAgICAgICBjaC5raW5kID09PSBcImludFwiIHx8XG4gICAgICAgICAgICAgICAgY2gua2luZCA9PT0gXCJtdWx0aXBsZU9mXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWluID09PSBudWxsIHx8IGNoLnZhbHVlID4gbWluKVxuICAgICAgICAgICAgICAgICAgICBtaW4gPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWF4ID09PSBudWxsIHx8IGNoLnZhbHVlIDwgbWF4KVxuICAgICAgICAgICAgICAgICAgICBtYXggPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTnVtYmVyLmlzRmluaXRlKG1pbikgJiYgTnVtYmVyLmlzRmluaXRlKG1heCk7XG4gICAgfVxufVxuZXhwb3J0cy5ab2ROdW1iZXIgPSBab2ROdW1iZXI7XG5ab2ROdW1iZXIuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTnVtYmVyKHtcbiAgICAgICAgY2hlY2tzOiBbXSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2ROdW1iZXIsXG4gICAgICAgIGNvZXJjZTogKHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5jb2VyY2UpIHx8IGZhbHNlLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kQmlnSW50IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubWluID0gdGhpcy5ndGU7XG4gICAgICAgIHRoaXMubWF4ID0gdGhpcy5sdGU7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBpZiAodGhpcy5fZGVmLmNvZXJjZSkge1xuICAgICAgICAgICAgaW5wdXQuZGF0YSA9IEJpZ0ludChpbnB1dC5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSB1dGlsXzEuWm9kUGFyc2VkVHlwZS5iaWdpbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgICgwLCBwYXJzZVV0aWxfMS5hZGRJc3N1ZVRvQ29udGV4dCkoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfMS5ab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiB1dGlsXzEuWm9kUGFyc2VkVHlwZS5iaWdpbnQsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VVdGlsXzEuSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY3R4ID0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBzdGF0dXMgPSBuZXcgcGFyc2VVdGlsXzEuUGFyc2VTdGF0dXMoKTtcbiAgICAgICAgZm9yIChjb25zdCBjaGVjayBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2hlY2sua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvb1NtYWxsID0gY2hlY2suaW5jbHVzaXZlXG4gICAgICAgICAgICAgICAgICAgID8gaW5wdXQuZGF0YSA8IGNoZWNrLnZhbHVlXG4gICAgICAgICAgICAgICAgICAgIDogaW5wdXQuZGF0YSA8PSBjaGVjay52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodG9vU21hbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgICgwLCBwYXJzZVV0aWxfMS5hZGRJc3N1ZVRvQ29udGV4dCkoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl8xLlpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImJpZ2ludFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWluaW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IGNoZWNrLmluY2x1c2l2ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9vQmlnID0gY2hlY2suaW5jbHVzaXZlXG4gICAgICAgICAgICAgICAgICAgID8gaW5wdXQuZGF0YSA+IGNoZWNrLnZhbHVlXG4gICAgICAgICAgICAgICAgICAgIDogaW5wdXQuZGF0YSA+PSBjaGVjay52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodG9vQmlnKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICAoMCwgcGFyc2VVdGlsXzEuYWRkSXNzdWVUb0NvbnRleHQpKGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfMS5ab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYmlnaW50XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhpbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogY2hlY2suaW5jbHVzaXZlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibXVsdGlwbGVPZlwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmRhdGEgJSBjaGVjay52YWx1ZSAhPT0gQmlnSW50KDApKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICAoMCwgcGFyc2VVdGlsXzEuYWRkSXNzdWVUb0NvbnRleHQpKGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfMS5ab2RJc3N1ZUNvZGUubm90X211bHRpcGxlX29mLFxuICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlwbGVPZjogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdXRpbF8xLnV0aWwuYXNzZXJ0TmV2ZXIoY2hlY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogaW5wdXQuZGF0YSB9O1xuICAgIH1cbiAgICBndGUodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtaW5cIiwgdmFsdWUsIHRydWUsIGVycm9yVXRpbF8xLmVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XG4gICAgfVxuICAgIGd0KHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWluXCIsIHZhbHVlLCBmYWxzZSwgZXJyb3JVdGlsXzEuZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgbHRlKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWF4XCIsIHZhbHVlLCB0cnVlLCBlcnJvclV0aWxfMS5lcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICAgIH1cbiAgICBsdCh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1heFwiLCB2YWx1ZSwgZmFsc2UsIGVycm9yVXRpbF8xLmVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XG4gICAgfVxuICAgIHNldExpbWl0KGtpbmQsIHZhbHVlLCBpbmNsdXNpdmUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RCaWdJbnQoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbXG4gICAgICAgICAgICAgICAgLi4udGhpcy5fZGVmLmNoZWNrcyxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmUsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbF8xLmVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9hZGRDaGVjayhjaGVjaykge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEJpZ0ludCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCBjaGVja10sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwb3NpdGl2ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgICAgICAgdmFsdWU6IEJpZ0ludCgwKSxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogZmFsc2UsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWxfMS5lcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBuZWdhdGl2ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgICAgICAgdmFsdWU6IEJpZ0ludCgwKSxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogZmFsc2UsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWxfMS5lcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBub25wb3NpdGl2ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgICAgICAgdmFsdWU6IEJpZ0ludCgwKSxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbF8xLmVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5vbm5lZ2F0aXZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICAgICAgICB2YWx1ZTogQmlnSW50KDApLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsXzEuZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbXVsdGlwbGVPZih2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtdWx0aXBsZU9mXCIsXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbF8xLmVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBtaW5WYWx1ZSgpIHtcbiAgICAgICAgbGV0IG1pbiA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWluID09PSBudWxsIHx8IGNoLnZhbHVlID4gbWluKVxuICAgICAgICAgICAgICAgICAgICBtaW4gPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWluO1xuICAgIH1cbiAgICBnZXQgbWF4VmFsdWUoKSB7XG4gICAgICAgIGxldCBtYXggPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaC5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1heCA9PT0gbnVsbCB8fCBjaC52YWx1ZSA8IG1heClcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICB9XG59XG5leHBvcnRzLlpvZEJpZ0ludCA9IFpvZEJpZ0ludDtcblpvZEJpZ0ludC5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBuZXcgWm9kQmlnSW50KHtcbiAgICAgICAgY2hlY2tzOiBbXSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RCaWdJbnQsXG4gICAgICAgIGNvZXJjZTogKF9hID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmNvZXJjZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2UsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RCb29sZWFuIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWYuY29lcmNlKSB7XG4gICAgICAgICAgICBpbnB1dC5kYXRhID0gQm9vbGVhbihpbnB1dC5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSB1dGlsXzEuWm9kUGFyc2VkVHlwZS5ib29sZWFuKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICAoMCwgcGFyc2VVdGlsXzEuYWRkSXNzdWVUb0NvbnRleHQpKGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yXzEuWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogdXRpbF8xLlpvZFBhcnNlZFR5cGUuYm9vbGVhbixcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVV0aWxfMS5JTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoMCwgcGFyc2VVdGlsXzEuT0spKGlucHV0LmRhdGEpO1xuICAgIH1cbn1cbmV4cG9ydHMuWm9kQm9vbGVhbiA9IFpvZEJvb2xlYW47XG5ab2RCb29sZWFuLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZEJvb2xlYW4oe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEJvb2xlYW4sXG4gICAgICAgIGNvZXJjZTogKHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5jb2VyY2UpIHx8IGZhbHNlLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kRGF0ZSBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBpZiAodGhpcy5fZGVmLmNvZXJjZSkge1xuICAgICAgICAgICAgaW5wdXQuZGF0YSA9IG5ldyBEYXRlKGlucHV0LmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IHV0aWxfMS5ab2RQYXJzZWRUeXBlLmRhdGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgICgwLCBwYXJzZVV0aWxfMS5hZGRJc3N1ZVRvQ29udGV4dCkoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfMS5ab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiB1dGlsXzEuWm9kUGFyc2VkVHlwZS5kYXRlLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVXRpbF8xLklOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTmFOKGlucHV0LmRhdGEuZ2V0VGltZSgpKSkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgKDAsIHBhcnNlVXRpbF8xLmFkZElzc3VlVG9Db250ZXh0KShjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl8xLlpvZElzc3VlQ29kZS5pbnZhbGlkX2RhdGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVV0aWxfMS5JTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IG5ldyBwYXJzZVV0aWxfMS5QYXJzZVN0YXR1cygpO1xuICAgICAgICBsZXQgY3R4ID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGNoZWNrIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaGVjay5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmRhdGEuZ2V0VGltZSgpIDwgY2hlY2sudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgICgwLCBwYXJzZVV0aWxfMS5hZGRJc3N1ZVRvQ29udGV4dCkoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl8xLlpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWluaW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImRhdGVcIixcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuZGF0YS5nZXRUaW1lKCkgPiBjaGVjay52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgKDAsIHBhcnNlVXRpbF8xLmFkZElzc3VlVG9Db250ZXh0KShjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yXzEuWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImRhdGVcIixcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHV0aWxfMS51dGlsLmFzc2VydE5ldmVyKGNoZWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhdHVzOiBzdGF0dXMudmFsdWUsXG4gICAgICAgICAgICB2YWx1ZTogbmV3IERhdGUoaW5wdXQuZGF0YS5nZXRUaW1lKCkpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBfYWRkQ2hlY2soY2hlY2spIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2REYXRlKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIGNoZWNrXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1pbihtaW5EYXRlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgICAgICAgdmFsdWU6IG1pbkRhdGUuZ2V0VGltZSgpLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsXzEuZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWF4KG1heERhdGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICAgICAgICB2YWx1ZTogbWF4RGF0ZS5nZXRUaW1lKCksXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWxfMS5lcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgbWluRGF0ZSgpIHtcbiAgICAgICAgbGV0IG1pbiA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWluID09PSBudWxsIHx8IGNoLnZhbHVlID4gbWluKVxuICAgICAgICAgICAgICAgICAgICBtaW4gPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWluICE9IG51bGwgPyBuZXcgRGF0ZShtaW4pIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0IG1heERhdGUoKSB7XG4gICAgICAgIGxldCBtYXggPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaC5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1heCA9PT0gbnVsbCB8fCBjaC52YWx1ZSA8IG1heClcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heCAhPSBudWxsID8gbmV3IERhdGUobWF4KSA6IG51bGw7XG4gICAgfVxufVxuZXhwb3J0cy5ab2REYXRlID0gWm9kRGF0ZTtcblpvZERhdGUuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kRGF0ZSh7XG4gICAgICAgIGNoZWNrczogW10sXG4gICAgICAgIGNvZXJjZTogKHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5jb2VyY2UpIHx8IGZhbHNlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZERhdGUsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RTeW1ib2wgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gdXRpbF8xLlpvZFBhcnNlZFR5cGUuc3ltYm9sKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICAoMCwgcGFyc2VVdGlsXzEuYWRkSXNzdWVUb0NvbnRleHQpKGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yXzEuWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogdXRpbF8xLlpvZFBhcnNlZFR5cGUuc3ltYm9sLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVXRpbF8xLklOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCBwYXJzZVV0aWxfMS5PSykoaW5wdXQuZGF0YSk7XG4gICAgfVxufVxuZXhwb3J0cy5ab2RTeW1ib2wgPSBab2RTeW1ib2w7XG5ab2RTeW1ib2wuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kU3ltYm9sKHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RTeW1ib2wsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RVbmRlZmluZWQgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gdXRpbF8xLlpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICAoMCwgcGFyc2VVdGlsXzEuYWRkSXNzdWVUb0NvbnRleHQpKGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yXzEuWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogdXRpbF8xLlpvZFBhcnNlZFR5cGUudW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVXRpbF8xLklOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCBwYXJzZVV0aWxfMS5PSykoaW5wdXQuZGF0YSk7XG4gICAgfVxufVxuZXhwb3J0cy5ab2RVbmRlZmluZWQgPSBab2RVbmRlZmluZWQ7XG5ab2RVbmRlZmluZWQuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kVW5kZWZpbmVkKHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RVbmRlZmluZWQsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2ROdWxsIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IHV0aWxfMS5ab2RQYXJzZWRUeXBlLm51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgICgwLCBwYXJzZVV0aWxfMS5hZGRJc3N1ZVRvQ29udGV4dCkoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfMS5ab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiB1dGlsXzEuWm9kUGFyc2VkVHlwZS5udWxsLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVXRpbF8xLklOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCBwYXJzZVV0aWxfMS5PSykoaW5wdXQuZGF0YSk7XG4gICAgfVxufVxuZXhwb3J0cy5ab2ROdWxsID0gWm9kTnVsbDtcblpvZE51bGwuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTnVsbCh7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTnVsbCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZEFueSBleHRlbmRzIFpvZFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICAvLyB0byBwcmV2ZW50IGluc3RhbmNlcyBvZiBvdGhlciBjbGFzc2VzIGZyb20gZXh0ZW5kaW5nIFpvZEFueS4gdGhpcyBjYXVzZXMgaXNzdWVzIHdpdGggY2F0Y2hhbGwgaW4gWm9kT2JqZWN0LlxuICAgICAgICB0aGlzLl9hbnkgPSB0cnVlO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuICgwLCBwYXJzZVV0aWxfMS5PSykoaW5wdXQuZGF0YSk7XG4gICAgfVxufVxuZXhwb3J0cy5ab2RBbnkgPSBab2RBbnk7XG5ab2RBbnkuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kQW55KHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RBbnksXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RVbmtub3duIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIC8vIHJlcXVpcmVkXG4gICAgICAgIHRoaXMuX3Vua25vd24gPSB0cnVlO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuICgwLCBwYXJzZVV0aWxfMS5PSykoaW5wdXQuZGF0YSk7XG4gICAgfVxufVxuZXhwb3J0cy5ab2RVbmtub3duID0gWm9kVW5rbm93bjtcblpvZFVua25vd24uY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kVW5rbm93bih7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kVW5rbm93bixcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZE5ldmVyIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgKDAsIHBhcnNlVXRpbF8xLmFkZElzc3VlVG9Db250ZXh0KShjdHgsIHtcbiAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yXzEuWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgIGV4cGVjdGVkOiB1dGlsXzEuWm9kUGFyc2VkVHlwZS5uZXZlcixcbiAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwYXJzZVV0aWxfMS5JTlZBTElEO1xuICAgIH1cbn1cbmV4cG9ydHMuWm9kTmV2ZXIgPSBab2ROZXZlcjtcblpvZE5ldmVyLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE5ldmVyKHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2ROZXZlcixcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZFZvaWQgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gdXRpbF8xLlpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICAoMCwgcGFyc2VVdGlsXzEuYWRkSXNzdWVUb0NvbnRleHQpKGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yXzEuWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogdXRpbF8xLlpvZFBhcnNlZFR5cGUudm9pZCxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVV0aWxfMS5JTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoMCwgcGFyc2VVdGlsXzEuT0spKGlucHV0LmRhdGEpO1xuICAgIH1cbn1cbmV4cG9ydHMuWm9kVm9pZCA9IFpvZFZvaWQ7XG5ab2RWb2lkLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFZvaWQoe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFZvaWQsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RBcnJheSBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCwgc3RhdHVzIH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCBkZWYgPSB0aGlzLl9kZWY7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gdXRpbF8xLlpvZFBhcnNlZFR5cGUuYXJyYXkpIHtcbiAgICAgICAgICAgICgwLCBwYXJzZVV0aWxfMS5hZGRJc3N1ZVRvQ29udGV4dCkoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfMS5ab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiB1dGlsXzEuWm9kUGFyc2VkVHlwZS5hcnJheSxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVV0aWxfMS5JTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWYuZXhhY3RMZW5ndGggIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvb0JpZyA9IGN0eC5kYXRhLmxlbmd0aCA+IGRlZi5leGFjdExlbmd0aC52YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IHRvb1NtYWxsID0gY3R4LmRhdGEubGVuZ3RoIDwgZGVmLmV4YWN0TGVuZ3RoLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHRvb0JpZyB8fCB0b29TbWFsbCkge1xuICAgICAgICAgICAgICAgICgwLCBwYXJzZVV0aWxfMS5hZGRJc3N1ZVRvQ29udGV4dCkoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IHRvb0JpZyA/IFpvZEVycm9yXzEuWm9kSXNzdWVDb2RlLnRvb19iaWcgOiBab2RFcnJvcl8xLlpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgICAgIG1pbmltdW06ICh0b29TbWFsbCA/IGRlZi5leGFjdExlbmd0aC52YWx1ZSA6IHVuZGVmaW5lZCksXG4gICAgICAgICAgICAgICAgICAgIG1heGltdW06ICh0b29CaWcgPyBkZWYuZXhhY3RMZW5ndGgudmFsdWUgOiB1bmRlZmluZWQpLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGRlZi5leGFjdExlbmd0aC5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkZWYubWluTGVuZ3RoICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoY3R4LmRhdGEubGVuZ3RoIDwgZGVmLm1pbkxlbmd0aC52YWx1ZSkge1xuICAgICAgICAgICAgICAgICgwLCBwYXJzZVV0aWxfMS5hZGRJc3N1ZVRvQ29udGV4dCkoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yXzEuWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICAgICAgbWluaW11bTogZGVmLm1pbkxlbmd0aC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZGVmLm1pbkxlbmd0aC5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkZWYubWF4TGVuZ3RoICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoY3R4LmRhdGEubGVuZ3RoID4gZGVmLm1heExlbmd0aC52YWx1ZSkge1xuICAgICAgICAgICAgICAgICgwLCBwYXJzZVV0aWxfMS5hZGRJc3N1ZVRvQ29udGV4dCkoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yXzEuWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgICAgIG1heGltdW06IGRlZi5tYXhMZW5ndGgudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGRlZi5tYXhMZW5ndGgubWVzc2FnZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFsuLi5jdHguZGF0YV0ubWFwKChpdGVtLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZi50eXBlLl9wYXJzZUFzeW5jKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBpdGVtLCBjdHgucGF0aCwgaSkpO1xuICAgICAgICAgICAgfSkpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZVV0aWxfMS5QYXJzZVN0YXR1cy5tZXJnZUFycmF5KHN0YXR1cywgcmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFsuLi5jdHguZGF0YV0ubWFwKChpdGVtLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZGVmLnR5cGUuX3BhcnNlU3luYyhuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgaXRlbSwgY3R4LnBhdGgsIGkpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwYXJzZVV0aWxfMS5QYXJzZVN0YXR1cy5tZXJnZUFycmF5KHN0YXR1cywgcmVzdWx0KTtcbiAgICB9XG4gICAgZ2V0IGVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudHlwZTtcbiAgICB9XG4gICAgbWluKG1pbkxlbmd0aCwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEFycmF5KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIG1pbkxlbmd0aDogeyB2YWx1ZTogbWluTGVuZ3RoLCBtZXNzYWdlOiBlcnJvclV0aWxfMS5lcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1heChtYXhMZW5ndGgsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RBcnJheSh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBtYXhMZW5ndGg6IHsgdmFsdWU6IG1heExlbmd0aCwgbWVzc2FnZTogZXJyb3JVdGlsXzEuZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsZW5ndGgobGVuLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kQXJyYXkoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgZXhhY3RMZW5ndGg6IHsgdmFsdWU6IGxlbiwgbWVzc2FnZTogZXJyb3JVdGlsXzEuZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBub25lbXB0eShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbigxLCBtZXNzYWdlKTtcbiAgICB9XG59XG5leHBvcnRzLlpvZEFycmF5ID0gWm9kQXJyYXk7XG5ab2RBcnJheS5jcmVhdGUgPSAoc2NoZW1hLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZEFycmF5KHtcbiAgICAgICAgdHlwZTogc2NoZW1hLFxuICAgICAgICBtaW5MZW5ndGg6IG51bGwsXG4gICAgICAgIG1heExlbmd0aDogbnVsbCxcbiAgICAgICAgZXhhY3RMZW5ndGg6IG51bGwsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQXJyYXksXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5mdW5jdGlvbiBkZWVwUGFydGlhbGlmeShzY2hlbWEpIHtcbiAgICBpZiAoc2NoZW1hIGluc3RhbmNlb2YgWm9kT2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG5ld1NoYXBlID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYS5zaGFwZSkge1xuICAgICAgICAgICAgY29uc3QgZmllbGRTY2hlbWEgPSBzY2hlbWEuc2hhcGVba2V5XTtcbiAgICAgICAgICAgIG5ld1NoYXBlW2tleV0gPSBab2RPcHRpb25hbC5jcmVhdGUoZGVlcFBhcnRpYWxpZnkoZmllbGRTY2hlbWEpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi5zY2hlbWEuX2RlZixcbiAgICAgICAgICAgIHNoYXBlOiAoKSA9PiBuZXdTaGFwZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNjaGVtYSBpbnN0YW5jZW9mIFpvZEFycmF5KSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kQXJyYXkoe1xuICAgICAgICAgICAgLi4uc2NoZW1hLl9kZWYsXG4gICAgICAgICAgICB0eXBlOiBkZWVwUGFydGlhbGlmeShzY2hlbWEuZWxlbWVudCksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBab2RPcHRpb25hbCkge1xuICAgICAgICByZXR1cm4gWm9kT3B0aW9uYWwuY3JlYXRlKGRlZXBQYXJ0aWFsaWZ5KHNjaGVtYS51bndyYXAoKSkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBab2ROdWxsYWJsZSkge1xuICAgICAgICByZXR1cm4gWm9kTnVsbGFibGUuY3JlYXRlKGRlZXBQYXJ0aWFsaWZ5KHNjaGVtYS51bndyYXAoKSkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBab2RUdXBsZSkge1xuICAgICAgICByZXR1cm4gWm9kVHVwbGUuY3JlYXRlKHNjaGVtYS5pdGVtcy5tYXAoKGl0ZW0pID0+IGRlZXBQYXJ0aWFsaWZ5KGl0ZW0pKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gc2NoZW1hO1xuICAgIH1cbn1cbmNsYXNzIFpvZE9iamVjdCBleHRlbmRzIFpvZFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLl9jYWNoZWQgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgSW4gbW9zdCBjYXNlcywgdGhpcyBpcyBubyBsb25nZXIgbmVlZGVkIC0gdW5rbm93biBwcm9wZXJ0aWVzIGFyZSBub3cgc2lsZW50bHkgc3RyaXBwZWQuXG4gICAgICAgICAqIElmIHlvdSB3YW50IHRvIHBhc3MgdGhyb3VnaCB1bmtub3duIHByb3BlcnRpZXMsIHVzZSBgLnBhc3N0aHJvdWdoKClgIGluc3RlYWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5vbnN0cmljdCA9IHRoaXMucGFzc3Rocm91Z2g7XG4gICAgICAgIC8vIGV4dGVuZDxcbiAgICAgICAgLy8gICBBdWdtZW50YXRpb24gZXh0ZW5kcyBab2RSYXdTaGFwZSxcbiAgICAgICAgLy8gICBOZXdPdXRwdXQgZXh0ZW5kcyB1dGlsLmZsYXR0ZW48e1xuICAgICAgICAvLyAgICAgW2sgaW4ga2V5b2YgQXVnbWVudGF0aW9uIHwga2V5b2YgT3V0cHV0XTogayBleHRlbmRzIGtleW9mIEF1Z21lbnRhdGlvblxuICAgICAgICAvLyAgICAgICA/IEF1Z21lbnRhdGlvbltrXVtcIl9vdXRwdXRcIl1cbiAgICAgICAgLy8gICAgICAgOiBrIGV4dGVuZHMga2V5b2YgT3V0cHV0XG4gICAgICAgIC8vICAgICAgID8gT3V0cHV0W2tdXG4gICAgICAgIC8vICAgICAgIDogbmV2ZXI7XG4gICAgICAgIC8vICAgfT4sXG4gICAgICAgIC8vICAgTmV3SW5wdXQgZXh0ZW5kcyB1dGlsLmZsYXR0ZW48e1xuICAgICAgICAvLyAgICAgW2sgaW4ga2V5b2YgQXVnbWVudGF0aW9uIHwga2V5b2YgSW5wdXRdOiBrIGV4dGVuZHMga2V5b2YgQXVnbWVudGF0aW9uXG4gICAgICAgIC8vICAgICAgID8gQXVnbWVudGF0aW9uW2tdW1wiX2lucHV0XCJdXG4gICAgICAgIC8vICAgICAgIDogayBleHRlbmRzIGtleW9mIElucHV0XG4gICAgICAgIC8vICAgICAgID8gSW5wdXRba11cbiAgICAgICAgLy8gICAgICAgOiBuZXZlcjtcbiAgICAgICAgLy8gICB9PlxuICAgICAgICAvLyA+KFxuICAgICAgICAvLyAgIGF1Z21lbnRhdGlvbjogQXVnbWVudGF0aW9uXG4gICAgICAgIC8vICk6IFpvZE9iamVjdDxcbiAgICAgICAgLy8gICBleHRlbmRTaGFwZTxULCBBdWdtZW50YXRpb24+LFxuICAgICAgICAvLyAgIFVua25vd25LZXlzLFxuICAgICAgICAvLyAgIENhdGNoYWxsLFxuICAgICAgICAvLyAgIE5ld091dHB1dCxcbiAgICAgICAgLy8gICBOZXdJbnB1dFxuICAgICAgICAvLyA+IHtcbiAgICAgICAgLy8gICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgIC8vICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgIC8vICAgICBzaGFwZTogKCkgPT4gKHtcbiAgICAgICAgLy8gICAgICAgLi4udGhpcy5fZGVmLnNoYXBlKCksXG4gICAgICAgIC8vICAgICAgIC4uLmF1Z21lbnRhdGlvbixcbiAgICAgICAgLy8gICAgIH0pLFxuICAgICAgICAvLyAgIH0pIGFzIGFueTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvKipcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgVXNlIGAuZXh0ZW5kYCBpbnN0ZWFkXG4gICAgICAgICAqICAqL1xuICAgICAgICB0aGlzLmF1Z21lbnQgPSB0aGlzLmV4dGVuZDtcbiAgICB9XG4gICAgX2dldENhY2hlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NhY2hlZCAhPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWNoZWQ7XG4gICAgICAgIGNvbnN0IHNoYXBlID0gdGhpcy5fZGVmLnNoYXBlKCk7XG4gICAgICAgIGNvbnN0IGtleXMgPSB1dGlsXzEudXRpbC5vYmplY3RLZXlzKHNoYXBlKTtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9jYWNoZWQgPSB7IHNoYXBlLCBrZXlzIH0pO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gdXRpbF8xLlpvZFBhcnNlZFR5cGUub2JqZWN0KSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICAoMCwgcGFyc2VVdGlsXzEuYWRkSXNzdWVUb0NvbnRleHQpKGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yXzEuWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogdXRpbF8xLlpvZFBhcnNlZFR5cGUub2JqZWN0LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVXRpbF8xLklOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgY29uc3QgeyBzaGFwZSwga2V5czogc2hhcGVLZXlzIH0gPSB0aGlzLl9nZXRDYWNoZWQoKTtcbiAgICAgICAgY29uc3QgZXh0cmFLZXlzID0gW107XG4gICAgICAgIGlmICghKHRoaXMuX2RlZi5jYXRjaGFsbCBpbnN0YW5jZW9mIFpvZE5ldmVyICYmXG4gICAgICAgICAgICB0aGlzLl9kZWYudW5rbm93bktleXMgPT09IFwic3RyaXBcIikpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGN0eC5kYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzaGFwZUtleXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBleHRyYUtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYWlycyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBzaGFwZUtleXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleVZhbGlkYXRvciA9IHNoYXBlW2tleV07XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGN0eC5kYXRhW2tleV07XG4gICAgICAgICAgICBwYWlycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBrZXk6IHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBrZXkgfSxcbiAgICAgICAgICAgICAgICB2YWx1ZToga2V5VmFsaWRhdG9yLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgdmFsdWUsIGN0eC5wYXRoLCBrZXkpKSxcbiAgICAgICAgICAgICAgICBhbHdheXNTZXQ6IGtleSBpbiBjdHguZGF0YSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9kZWYuY2F0Y2hhbGwgaW5zdGFuY2VvZiBab2ROZXZlcikge1xuICAgICAgICAgICAgY29uc3QgdW5rbm93bktleXMgPSB0aGlzLl9kZWYudW5rbm93bktleXM7XG4gICAgICAgICAgICBpZiAodW5rbm93bktleXMgPT09IFwicGFzc3Rocm91Z2hcIikge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGV4dHJhS2V5cykge1xuICAgICAgICAgICAgICAgICAgICBwYWlycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGtleSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBjdHguZGF0YVtrZXldIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHVua25vd25LZXlzID09PSBcInN0cmljdFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4dHJhS2V5cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICgwLCBwYXJzZVV0aWxfMS5hZGRJc3N1ZVRvQ29udGV4dCkoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl8xLlpvZElzc3VlQ29kZS51bnJlY29nbml6ZWRfa2V5cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleXM6IGV4dHJhS2V5cyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHVua25vd25LZXlzID09PSBcInN0cmlwXCIpIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW50ZXJuYWwgWm9kT2JqZWN0IGVycm9yOiBpbnZhbGlkIHVua25vd25LZXlzIHZhbHVlLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gcnVuIGNhdGNoYWxsIHZhbGlkYXRpb25cbiAgICAgICAgICAgIGNvbnN0IGNhdGNoYWxsID0gdGhpcy5fZGVmLmNhdGNoYWxsO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgZXh0cmFLZXlzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBjdHguZGF0YVtrZXldO1xuICAgICAgICAgICAgICAgIHBhaXJzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBrZXk6IHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBrZXkgfSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNhdGNoYWxsLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgdmFsdWUsIGN0eC5wYXRoLCBrZXkpIC8vLCBjdHguY2hpbGQoa2V5KSwgdmFsdWUsIGdldFBhcnNlZFR5cGUodmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIGFsd2F5c1NldDoga2V5IGluIGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgICAgICAgICAgICAudGhlbihhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3luY1BhaXJzID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwYWlyIG9mIHBhaXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IHBhaXIua2V5O1xuICAgICAgICAgICAgICAgICAgICBzeW5jUGFpcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogYXdhaXQgcGFpci52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsd2F5c1NldDogcGFpci5hbHdheXNTZXQsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc3luY1BhaXJzO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoc3luY1BhaXJzKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlVXRpbF8xLlBhcnNlU3RhdHVzLm1lcmdlT2JqZWN0U3luYyhzdGF0dXMsIHN5bmNQYWlycyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVV0aWxfMS5QYXJzZVN0YXR1cy5tZXJnZU9iamVjdFN5bmMoc3RhdHVzLCBwYWlycyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHNoYXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnNoYXBlKCk7XG4gICAgfVxuICAgIHN0cmljdChtZXNzYWdlKSB7XG4gICAgICAgIGVycm9yVXRpbF8xLmVycm9yVXRpbC5lcnJUb09iajtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgdW5rbm93bktleXM6IFwic3RyaWN0XCIsXG4gICAgICAgICAgICAuLi4obWVzc2FnZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yTWFwOiAoaXNzdWUsIGN0eCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVmYXVsdEVycm9yID0gKF9jID0gKF9iID0gKF9hID0gdGhpcy5fZGVmKS5lcnJvck1hcCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIGlzc3VlLCBjdHgpLm1lc3NhZ2UpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGN0eC5kZWZhdWx0RXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNzdWUuY29kZSA9PT0gXCJ1bnJlY29nbml6ZWRfa2V5c1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IChfZCA9IGVycm9yVXRpbF8xLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKS5tZXNzYWdlKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBkZWZhdWx0RXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZGVmYXVsdEVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgOiB7fSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdHJpcCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgdW5rbm93bktleXM6IFwic3RyaXBcIixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBhc3N0aHJvdWdoKCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICB1bmtub3duS2V5czogXCJwYXNzdGhyb3VnaFwiLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gY29uc3QgQXVnbWVudEZhY3RvcnkgPVxuICAgIC8vICAgPERlZiBleHRlbmRzIFpvZE9iamVjdERlZj4oZGVmOiBEZWYpID0+XG4gICAgLy8gICA8QXVnbWVudGF0aW9uIGV4dGVuZHMgWm9kUmF3U2hhcGU+KFxuICAgIC8vICAgICBhdWdtZW50YXRpb246IEF1Z21lbnRhdGlvblxuICAgIC8vICAgKTogWm9kT2JqZWN0PFxuICAgIC8vICAgICBleHRlbmRTaGFwZTxSZXR1cm5UeXBlPERlZltcInNoYXBlXCJdPiwgQXVnbWVudGF0aW9uPixcbiAgICAvLyAgICAgRGVmW1widW5rbm93bktleXNcIl0sXG4gICAgLy8gICAgIERlZltcImNhdGNoYWxsXCJdXG4gICAgLy8gICA+ID0+IHtcbiAgICAvLyAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgIC8vICAgICAgIC4uLmRlZixcbiAgICAvLyAgICAgICBzaGFwZTogKCkgPT4gKHtcbiAgICAvLyAgICAgICAgIC4uLmRlZi5zaGFwZSgpLFxuICAgIC8vICAgICAgICAgLi4uYXVnbWVudGF0aW9uLFxuICAgIC8vICAgICAgIH0pLFxuICAgIC8vICAgICB9KSBhcyBhbnk7XG4gICAgLy8gICB9O1xuICAgIGV4dGVuZChhdWdtZW50YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgc2hhcGU6ICgpID0+ICh7XG4gICAgICAgICAgICAgICAgLi4udGhpcy5fZGVmLnNoYXBlKCksXG4gICAgICAgICAgICAgICAgLi4uYXVnbWVudGF0aW9uLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcmlvciB0byB6b2RAMS4wLjEyIHRoZXJlIHdhcyBhIGJ1ZyBpbiB0aGVcbiAgICAgKiBpbmZlcnJlZCB0eXBlIG9mIG1lcmdlZCBvYmplY3RzLiBQbGVhc2VcbiAgICAgKiB1cGdyYWRlIGlmIHlvdSBhcmUgZXhwZXJpZW5jaW5nIGlzc3Vlcy5cbiAgICAgKi9cbiAgICBtZXJnZShtZXJnaW5nKSB7XG4gICAgICAgIGNvbnN0IG1lcmdlZCA9IG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgdW5rbm93bktleXM6IG1lcmdpbmcuX2RlZi51bmtub3duS2V5cyxcbiAgICAgICAgICAgIGNhdGNoYWxsOiBtZXJnaW5nLl9kZWYuY2F0Y2hhbGwsXG4gICAgICAgICAgICBzaGFwZTogKCkgPT4gKHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLl9kZWYuc2hhcGUoKSxcbiAgICAgICAgICAgICAgICAuLi5tZXJnaW5nLl9kZWYuc2hhcGUoKSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbWVyZ2VkO1xuICAgIH1cbiAgICAvLyBtZXJnZTxcbiAgICAvLyAgIEluY29taW5nIGV4dGVuZHMgQW55Wm9kT2JqZWN0LFxuICAgIC8vICAgQXVnbWVudGF0aW9uIGV4dGVuZHMgSW5jb21pbmdbXCJzaGFwZVwiXSxcbiAgICAvLyAgIE5ld091dHB1dCBleHRlbmRzIHtcbiAgICAvLyAgICAgW2sgaW4ga2V5b2YgQXVnbWVudGF0aW9uIHwga2V5b2YgT3V0cHV0XTogayBleHRlbmRzIGtleW9mIEF1Z21lbnRhdGlvblxuICAgIC8vICAgICAgID8gQXVnbWVudGF0aW9uW2tdW1wiX291dHB1dFwiXVxuICAgIC8vICAgICAgIDogayBleHRlbmRzIGtleW9mIE91dHB1dFxuICAgIC8vICAgICAgID8gT3V0cHV0W2tdXG4gICAgLy8gICAgICAgOiBuZXZlcjtcbiAgICAvLyAgIH0sXG4gICAgLy8gICBOZXdJbnB1dCBleHRlbmRzIHtcbiAgICAvLyAgICAgW2sgaW4ga2V5b2YgQXVnbWVudGF0aW9uIHwga2V5b2YgSW5wdXRdOiBrIGV4dGVuZHMga2V5b2YgQXVnbWVudGF0aW9uXG4gICAgLy8gICAgICAgPyBBdWdtZW50YXRpb25ba11bXCJfaW5wdXRcIl1cbiAgICAvLyAgICAgICA6IGsgZXh0ZW5kcyBrZXlvZiBJbnB1dFxuICAgIC8vICAgICAgID8gSW5wdXRba11cbiAgICAvLyAgICAgICA6IG5ldmVyO1xuICAgIC8vICAgfVxuICAgIC8vID4oXG4gICAgLy8gICBtZXJnaW5nOiBJbmNvbWluZ1xuICAgIC8vICk6IFpvZE9iamVjdDxcbiAgICAvLyAgIGV4dGVuZFNoYXBlPFQsIFJldHVyblR5cGU8SW5jb21pbmdbXCJfZGVmXCJdW1wic2hhcGVcIl0+PixcbiAgICAvLyAgIEluY29taW5nW1wiX2RlZlwiXVtcInVua25vd25LZXlzXCJdLFxuICAgIC8vICAgSW5jb21pbmdbXCJfZGVmXCJdW1wiY2F0Y2hhbGxcIl0sXG4gICAgLy8gICBOZXdPdXRwdXQsXG4gICAgLy8gICBOZXdJbnB1dFxuICAgIC8vID4ge1xuICAgIC8vICAgY29uc3QgbWVyZ2VkOiBhbnkgPSBuZXcgWm9kT2JqZWN0KHtcbiAgICAvLyAgICAgdW5rbm93bktleXM6IG1lcmdpbmcuX2RlZi51bmtub3duS2V5cyxcbiAgICAvLyAgICAgY2F0Y2hhbGw6IG1lcmdpbmcuX2RlZi5jYXRjaGFsbCxcbiAgICAvLyAgICAgc2hhcGU6ICgpID0+XG4gICAgLy8gICAgICAgb2JqZWN0VXRpbC5tZXJnZVNoYXBlcyh0aGlzLl9kZWYuc2hhcGUoKSwgbWVyZ2luZy5fZGVmLnNoYXBlKCkpLFxuICAgIC8vICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9iamVjdCxcbiAgICAvLyAgIH0pIGFzIGFueTtcbiAgICAvLyAgIHJldHVybiBtZXJnZWQ7XG4gICAgLy8gfVxuICAgIHNldEtleShrZXksIHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdWdtZW50KHsgW2tleV06IHNjaGVtYSB9KTtcbiAgICB9XG4gICAgLy8gbWVyZ2U8SW5jb21pbmcgZXh0ZW5kcyBBbnlab2RPYmplY3Q+KFxuICAgIC8vICAgbWVyZ2luZzogSW5jb21pbmdcbiAgICAvLyApOiAvL1pvZE9iamVjdDxUICYgSW5jb21pbmdbXCJfc2hhcGVcIl0sIFVua25vd25LZXlzLCBDYXRjaGFsbD4gPSAobWVyZ2luZykgPT4ge1xuICAgIC8vIFpvZE9iamVjdDxcbiAgICAvLyAgIGV4dGVuZFNoYXBlPFQsIFJldHVyblR5cGU8SW5jb21pbmdbXCJfZGVmXCJdW1wic2hhcGVcIl0+PixcbiAgICAvLyAgIEluY29taW5nW1wiX2RlZlwiXVtcInVua25vd25LZXlzXCJdLFxuICAgIC8vICAgSW5jb21pbmdbXCJfZGVmXCJdW1wiY2F0Y2hhbGxcIl1cbiAgICAvLyA+IHtcbiAgICAvLyAgIC8vIGNvbnN0IG1lcmdlZFNoYXBlID0gb2JqZWN0VXRpbC5tZXJnZVNoYXBlcyhcbiAgICAvLyAgIC8vICAgdGhpcy5fZGVmLnNoYXBlKCksXG4gICAgLy8gICAvLyAgIG1lcmdpbmcuX2RlZi5zaGFwZSgpXG4gICAgLy8gICAvLyApO1xuICAgIC8vICAgY29uc3QgbWVyZ2VkOiBhbnkgPSBuZXcgWm9kT2JqZWN0KHtcbiAgICAvLyAgICAgdW5rbm93bktleXM6IG1lcmdpbmcuX2RlZi51bmtub3duS2V5cyxcbiAgICAvLyAgICAgY2F0Y2hhbGw6IG1lcmdpbmcuX2RlZi5jYXRjaGFsbCxcbiAgICAvLyAgICAgc2hhcGU6ICgpID0+XG4gICAgLy8gICAgICAgb2JqZWN0VXRpbC5tZXJnZVNoYXBlcyh0aGlzLl9kZWYuc2hhcGUoKSwgbWVyZ2luZy5fZGVmLnNoYXBlKCkpLFxuICAgIC8vICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9iamVjdCxcbiAgICAvLyAgIH0pIGFzIGFueTtcbiAgICAvLyAgIHJldHVybiBtZXJnZWQ7XG4gICAgLy8gfVxuICAgIGNhdGNoYWxsKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNhdGNoYWxsOiBpbmRleCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBpY2sobWFzaykge1xuICAgICAgICBjb25zdCBzaGFwZSA9IHt9O1xuICAgICAgICB1dGlsXzEudXRpbC5vYmplY3RLZXlzKG1hc2spLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKG1hc2tba2V5XSAmJiB0aGlzLnNoYXBlW2tleV0pIHtcbiAgICAgICAgICAgICAgICBzaGFwZVtrZXldID0gdGhpcy5zaGFwZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgc2hhcGU6ICgpID0+IHNoYXBlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgb21pdChtYXNrKSB7XG4gICAgICAgIGNvbnN0IHNoYXBlID0ge307XG4gICAgICAgIHV0aWxfMS51dGlsLm9iamVjdEtleXModGhpcy5zaGFwZSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAoIW1hc2tba2V5XSkge1xuICAgICAgICAgICAgICAgIHNoYXBlW2tleV0gPSB0aGlzLnNoYXBlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBzaGFwZTogKCkgPT4gc2hhcGUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICAgIGRlZXBQYXJ0aWFsKCkge1xuICAgICAgICByZXR1cm4gZGVlcFBhcnRpYWxpZnkodGhpcyk7XG4gICAgfVxuICAgIHBhcnRpYWwobWFzaykge1xuICAgICAgICBjb25zdCBuZXdTaGFwZSA9IHt9O1xuICAgICAgICB1dGlsXzEudXRpbC5vYmplY3RLZXlzKHRoaXMuc2hhcGUpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZmllbGRTY2hlbWEgPSB0aGlzLnNoYXBlW2tleV07XG4gICAgICAgICAgICBpZiAobWFzayAmJiAhbWFza1trZXldKSB7XG4gICAgICAgICAgICAgICAgbmV3U2hhcGVba2V5XSA9IGZpZWxkU2NoZW1hO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3U2hhcGVba2V5XSA9IGZpZWxkU2NoZW1hLm9wdGlvbmFsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBzaGFwZTogKCkgPT4gbmV3U2hhcGUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXF1aXJlZChtYXNrKSB7XG4gICAgICAgIGNvbnN0IG5ld1NoYXBlID0ge307XG4gICAgICAgIHV0aWxfMS51dGlsLm9iamVjdEtleXModGhpcy5zaGFwZSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAobWFzayAmJiAhbWFza1trZXldKSB7XG4gICAgICAgICAgICAgICAgbmV3U2hhcGVba2V5XSA9IHRoaXMuc2hhcGVba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkU2NoZW1hID0gdGhpcy5zaGFwZVtrZXldO1xuICAgICAgICAgICAgICAgIGxldCBuZXdGaWVsZCA9IGZpZWxkU2NoZW1hO1xuICAgICAgICAgICAgICAgIHdoaWxlIChuZXdGaWVsZCBpbnN0YW5jZW9mIFpvZE9wdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0ZpZWxkID0gbmV3RmllbGQuX2RlZi5pbm5lclR5cGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5ld1NoYXBlW2tleV0gPSBuZXdGaWVsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHNoYXBlOiAoKSA9PiBuZXdTaGFwZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGtleW9mKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlWm9kRW51bSh1dGlsXzEudXRpbC5vYmplY3RLZXlzKHRoaXMuc2hhcGUpKTtcbiAgICB9XG59XG5leHBvcnRzLlpvZE9iamVjdCA9IFpvZE9iamVjdDtcblpvZE9iamVjdC5jcmVhdGUgPSAoc2hhcGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgc2hhcGU6ICgpID0+IHNoYXBlLFxuICAgICAgICB1bmtub3duS2V5czogXCJzdHJpcFwiLFxuICAgICAgICBjYXRjaGFsbDogWm9kTmV2ZXIuY3JlYXRlKCksXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT2JqZWN0LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuWm9kT2JqZWN0LnN0cmljdENyZWF0ZSA9IChzaGFwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICBzaGFwZTogKCkgPT4gc2hhcGUsXG4gICAgICAgIHVua25vd25LZXlzOiBcInN0cmljdFwiLFxuICAgICAgICBjYXRjaGFsbDogWm9kTmV2ZXIuY3JlYXRlKCksXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT2JqZWN0LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuWm9kT2JqZWN0LmxhenljcmVhdGUgPSAoc2hhcGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgc2hhcGUsXG4gICAgICAgIHVua25vd25LZXlzOiBcInN0cmlwXCIsXG4gICAgICAgIGNhdGNoYWxsOiBab2ROZXZlci5jcmVhdGUoKSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RVbmlvbiBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX2RlZi5vcHRpb25zO1xuICAgICAgICBmdW5jdGlvbiBoYW5kbGVSZXN1bHRzKHJlc3VsdHMpIHtcbiAgICAgICAgICAgIC8vIHJldHVybiBmaXJzdCBpc3N1ZS1mcmVlIHZhbGlkYXRpb24gaWYgaXQgZXhpc3RzXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJlc3VsdCBvZiByZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5yZXN1bHQuc3RhdHVzID09PSBcInZhbGlkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cykge1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQucmVzdWx0LnN0YXR1cyA9PT0gXCJkaXJ0eVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZCBpc3N1ZXMgZnJvbSBkaXJ0eSBvcHRpb25cbiAgICAgICAgICAgICAgICAgICAgY3R4LmNvbW1vbi5pc3N1ZXMucHVzaCguLi5yZXN1bHQuY3R4LmNvbW1vbi5pc3N1ZXMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZXR1cm4gaW52YWxpZFxuICAgICAgICAgICAgY29uc3QgdW5pb25FcnJvcnMgPSByZXN1bHRzLm1hcCgocmVzdWx0KSA9PiBuZXcgWm9kRXJyb3JfMS5ab2RFcnJvcihyZXN1bHQuY3R4LmNvbW1vbi5pc3N1ZXMpKTtcbiAgICAgICAgICAgICgwLCBwYXJzZVV0aWxfMS5hZGRJc3N1ZVRvQ29udGV4dCkoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfMS5ab2RJc3N1ZUNvZGUuaW52YWxpZF91bmlvbixcbiAgICAgICAgICAgICAgICB1bmlvbkVycm9ycyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVXRpbF8xLklOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChvcHRpb25zLm1hcChhc3luYyAob3B0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRDdHggPSB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmN0eCxcbiAgICAgICAgICAgICAgICAgICAgY29tbW9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5jdHguY29tbW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNzdWVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiBhd2FpdCBvcHRpb24uX3BhcnNlQXN5bmMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudDogY2hpbGRDdHgsXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBjdHg6IGNoaWxkQ3R4LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSkudGhlbihoYW5kbGVSZXN1bHRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBkaXJ0eSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnN0IGlzc3VlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBvcHRpb24gb2Ygb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkQ3R4ID0ge1xuICAgICAgICAgICAgICAgICAgICAuLi5jdHgsXG4gICAgICAgICAgICAgICAgICAgIGNvbW1vbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uY3R4LmNvbW1vbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzc3VlczogW10sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG9wdGlvbi5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGNoaWxkQ3R4LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSBcInZhbGlkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0LnN0YXR1cyA9PT0gXCJkaXJ0eVwiICYmICFkaXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICBkaXJ0eSA9IHsgcmVzdWx0LCBjdHg6IGNoaWxkQ3R4IH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjaGlsZEN0eC5jb21tb24uaXNzdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBpc3N1ZXMucHVzaChjaGlsZEN0eC5jb21tb24uaXNzdWVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGlydHkpIHtcbiAgICAgICAgICAgICAgICBjdHguY29tbW9uLmlzc3Vlcy5wdXNoKC4uLmRpcnR5LmN0eC5jb21tb24uaXNzdWVzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlydHkucmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdW5pb25FcnJvcnMgPSBpc3N1ZXMubWFwKChpc3N1ZXMpID0+IG5ldyBab2RFcnJvcl8xLlpvZEVycm9yKGlzc3VlcykpO1xuICAgICAgICAgICAgKDAsIHBhcnNlVXRpbF8xLmFkZElzc3VlVG9Db250ZXh0KShjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl8xLlpvZElzc3VlQ29kZS5pbnZhbGlkX3VuaW9uLFxuICAgICAgICAgICAgICAgIHVuaW9uRXJyb3JzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VVdGlsXzEuSU5WQUxJRDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgb3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5vcHRpb25zO1xuICAgIH1cbn1cbmV4cG9ydHMuWm9kVW5pb24gPSBab2RVbmlvbjtcblpvZFVuaW9uLmNyZWF0ZSA9ICh0eXBlcywgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RVbmlvbih7XG4gICAgICAgIG9wdGlvbnM6IHR5cGVzLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFVuaW9uLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vLy8vLy8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vLy8vLy8vL1xuLy8vLy8vLy8vLyAgICAgIFpvZERpc2NyaW1pbmF0ZWRVbmlvbiAgICAgIC8vLy8vLy8vLy9cbi8vLy8vLy8vLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLy8vLy8vLy8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbmNvbnN0IGdldERpc2NyaW1pbmF0b3IgPSAodHlwZSkgPT4ge1xuICAgIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kTGF6eSkge1xuICAgICAgICByZXR1cm4gZ2V0RGlzY3JpbWluYXRvcih0eXBlLnNjaGVtYSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RFZmZlY3RzKSB7XG4gICAgICAgIHJldHVybiBnZXREaXNjcmltaW5hdG9yKHR5cGUuaW5uZXJUeXBlKCkpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kTGl0ZXJhbCkge1xuICAgICAgICByZXR1cm4gW3R5cGUudmFsdWVdO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kRW51bSkge1xuICAgICAgICByZXR1cm4gdHlwZS5vcHRpb25zO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kTmF0aXZlRW51bSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgYmFuL2JhblxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModHlwZS5lbnVtKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZERlZmF1bHQpIHtcbiAgICAgICAgcmV0dXJuIGdldERpc2NyaW1pbmF0b3IodHlwZS5fZGVmLmlubmVyVHlwZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RVbmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIFt1bmRlZmluZWRdO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kTnVsbCkge1xuICAgICAgICByZXR1cm4gW251bGxdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufTtcbmNsYXNzIFpvZERpc2NyaW1pbmF0ZWRVbmlvbiBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSB1dGlsXzEuWm9kUGFyc2VkVHlwZS5vYmplY3QpIHtcbiAgICAgICAgICAgICgwLCBwYXJzZVV0aWxfMS5hZGRJc3N1ZVRvQ29udGV4dCkoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfMS5ab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiB1dGlsXzEuWm9kUGFyc2VkVHlwZS5vYmplY3QsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VVdGlsXzEuSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yID0gdGhpcy5kaXNjcmltaW5hdG9yO1xuICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yVmFsdWUgPSBjdHguZGF0YVtkaXNjcmltaW5hdG9yXTtcbiAgICAgICAgY29uc3Qgb3B0aW9uID0gdGhpcy5vcHRpb25zTWFwLmdldChkaXNjcmltaW5hdG9yVmFsdWUpO1xuICAgICAgICBpZiAoIW9wdGlvbikge1xuICAgICAgICAgICAgKDAsIHBhcnNlVXRpbF8xLmFkZElzc3VlVG9Db250ZXh0KShjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl8xLlpvZElzc3VlQ29kZS5pbnZhbGlkX3VuaW9uX2Rpc2NyaW1pbmF0b3IsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogQXJyYXkuZnJvbSh0aGlzLm9wdGlvbnNNYXAua2V5cygpKSxcbiAgICAgICAgICAgICAgICBwYXRoOiBbZGlzY3JpbWluYXRvcl0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVV0aWxfMS5JTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9uLl9wYXJzZUFzeW5jKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbi5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBkaXNjcmltaW5hdG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmRpc2NyaW1pbmF0b3I7XG4gICAgfVxuICAgIGdldCBvcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLm9wdGlvbnM7XG4gICAgfVxuICAgIGdldCBvcHRpb25zTWFwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLm9wdGlvbnNNYXA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgZGlzY3JpbWluYXRlZCB1bmlvbiBzY2hlbWEuIEl0cyBiZWhhdmlvdXIgaXMgdmVyeSBzaW1pbGFyIHRvIHRoYXQgb2YgdGhlIG5vcm1hbCB6LnVuaW9uKCkgY29uc3RydWN0b3IuXG4gICAgICogSG93ZXZlciwgaXQgb25seSBhbGxvd3MgYSB1bmlvbiBvZiBvYmplY3RzLCBhbGwgb2Ygd2hpY2ggbmVlZCB0byBzaGFyZSBhIGRpc2NyaW1pbmF0b3IgcHJvcGVydHkuIFRoaXMgcHJvcGVydHkgbXVzdFxuICAgICAqIGhhdmUgYSBkaWZmZXJlbnQgdmFsdWUgZm9yIGVhY2ggb2JqZWN0IGluIHRoZSB1bmlvbi5cbiAgICAgKiBAcGFyYW0gZGlzY3JpbWluYXRvciB0aGUgbmFtZSBvZiB0aGUgZGlzY3JpbWluYXRvciBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB0eXBlcyBhbiBhcnJheSBvZiBvYmplY3Qgc2NoZW1hc1xuICAgICAqIEBwYXJhbSBwYXJhbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKGRpc2NyaW1pbmF0b3IsIG9wdGlvbnMsIHBhcmFtcykge1xuICAgICAgICAvLyBHZXQgYWxsIHRoZSB2YWxpZCBkaXNjcmltaW5hdG9yIHZhbHVlc1xuICAgICAgICBjb25zdCBvcHRpb25zTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyB0cnkge1xuICAgICAgICBmb3IgKGNvbnN0IHR5cGUgb2Ygb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgZGlzY3JpbWluYXRvclZhbHVlcyA9IGdldERpc2NyaW1pbmF0b3IodHlwZS5zaGFwZVtkaXNjcmltaW5hdG9yXSk7XG4gICAgICAgICAgICBpZiAoIWRpc2NyaW1pbmF0b3JWYWx1ZXMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEEgZGlzY3JpbWluYXRvciB2YWx1ZSBmb3Iga2V5IFxcYCR7ZGlzY3JpbWluYXRvcn1cXGAgY291bGQgbm90IGJlIGV4dHJhY3RlZCBmcm9tIGFsbCBzY2hlbWEgb3B0aW9uc2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBkaXNjcmltaW5hdG9yVmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnNNYXAuaGFzKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERpc2NyaW1pbmF0b3IgcHJvcGVydHkgJHtTdHJpbmcoZGlzY3JpbWluYXRvcil9IGhhcyBkdXBsaWNhdGUgdmFsdWUgJHtTdHJpbmcodmFsdWUpfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvcHRpb25zTWFwLnNldCh2YWx1ZSwgdHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBab2REaXNjcmltaW5hdGVkVW5pb24oe1xuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2REaXNjcmltaW5hdGVkVW5pb24sXG4gICAgICAgICAgICBkaXNjcmltaW5hdG9yLFxuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIG9wdGlvbnNNYXAsXG4gICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuWm9kRGlzY3JpbWluYXRlZFVuaW9uID0gWm9kRGlzY3JpbWluYXRlZFVuaW9uO1xuZnVuY3Rpb24gbWVyZ2VWYWx1ZXMoYSwgYikge1xuICAgIGNvbnN0IGFUeXBlID0gKDAsIHV0aWxfMS5nZXRQYXJzZWRUeXBlKShhKTtcbiAgICBjb25zdCBiVHlwZSA9ICgwLCB1dGlsXzEuZ2V0UGFyc2VkVHlwZSkoYik7XG4gICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUsIGRhdGE6IGEgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYVR5cGUgPT09IHV0aWxfMS5ab2RQYXJzZWRUeXBlLm9iamVjdCAmJiBiVHlwZSA9PT0gdXRpbF8xLlpvZFBhcnNlZFR5cGUub2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IGJLZXlzID0gdXRpbF8xLnV0aWwub2JqZWN0S2V5cyhiKTtcbiAgICAgICAgY29uc3Qgc2hhcmVkS2V5cyA9IHV0aWxfMS51dGlsXG4gICAgICAgICAgICAub2JqZWN0S2V5cyhhKVxuICAgICAgICAgICAgLmZpbHRlcigoa2V5KSA9PiBiS2V5cy5pbmRleE9mKGtleSkgIT09IC0xKTtcbiAgICAgICAgY29uc3QgbmV3T2JqID0geyAuLi5hLCAuLi5iIH07XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHNoYXJlZEtleXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNoYXJlZFZhbHVlID0gbWVyZ2VWYWx1ZXMoYVtrZXldLCBiW2tleV0pO1xuICAgICAgICAgICAgaWYgKCFzaGFyZWRWYWx1ZS52YWxpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3T2JqW2tleV0gPSBzaGFyZWRWYWx1ZS5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHZhbGlkOiB0cnVlLCBkYXRhOiBuZXdPYmogfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYVR5cGUgPT09IHV0aWxfMS5ab2RQYXJzZWRUeXBlLmFycmF5ICYmIGJUeXBlID09PSB1dGlsXzEuWm9kUGFyc2VkVHlwZS5hcnJheSkge1xuICAgICAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdBcnJheSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgYS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1BID0gYVtpbmRleF07XG4gICAgICAgICAgICBjb25zdCBpdGVtQiA9IGJbaW5kZXhdO1xuICAgICAgICAgICAgY29uc3Qgc2hhcmVkVmFsdWUgPSBtZXJnZVZhbHVlcyhpdGVtQSwgaXRlbUIpO1xuICAgICAgICAgICAgaWYgKCFzaGFyZWRWYWx1ZS52YWxpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3QXJyYXkucHVzaChzaGFyZWRWYWx1ZS5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSwgZGF0YTogbmV3QXJyYXkgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYVR5cGUgPT09IHV0aWxfMS5ab2RQYXJzZWRUeXBlLmRhdGUgJiZcbiAgICAgICAgYlR5cGUgPT09IHV0aWxfMS5ab2RQYXJzZWRUeXBlLmRhdGUgJiZcbiAgICAgICAgK2EgPT09ICtiKSB7XG4gICAgICAgIHJldHVybiB7IHZhbGlkOiB0cnVlLCBkYXRhOiBhIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UgfTtcbiAgICB9XG59XG5jbGFzcyBab2RJbnRlcnNlY3Rpb24gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgY29uc3QgaGFuZGxlUGFyc2VkID0gKHBhcnNlZExlZnQsIHBhcnNlZFJpZ2h0KSA9PiB7XG4gICAgICAgICAgICBpZiAoKDAsIHBhcnNlVXRpbF8xLmlzQWJvcnRlZCkocGFyc2VkTGVmdCkgfHwgKDAsIHBhcnNlVXRpbF8xLmlzQWJvcnRlZCkocGFyc2VkUmlnaHQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlVXRpbF8xLklOVkFMSUQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtZXJnZWQgPSBtZXJnZVZhbHVlcyhwYXJzZWRMZWZ0LnZhbHVlLCBwYXJzZWRSaWdodC52YWx1ZSk7XG4gICAgICAgICAgICBpZiAoIW1lcmdlZC52YWxpZCkge1xuICAgICAgICAgICAgICAgICgwLCBwYXJzZVV0aWxfMS5hZGRJc3N1ZVRvQ29udGV4dCkoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yXzEuWm9kSXNzdWVDb2RlLmludmFsaWRfaW50ZXJzZWN0aW9uX3R5cGVzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZVV0aWxfMS5JTlZBTElEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCgwLCBwYXJzZVV0aWxfMS5pc0RpcnR5KShwYXJzZWRMZWZ0KSB8fCAoMCwgcGFyc2VVdGlsXzEuaXNEaXJ0eSkocGFyc2VkUmlnaHQpKSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IG1lcmdlZC5kYXRhIH07XG4gICAgICAgIH07XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlZi5sZWZ0Ll9wYXJzZUFzeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWYucmlnaHQuX3BhcnNlQXN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgXSkudGhlbigoW2xlZnQsIHJpZ2h0XSkgPT4gaGFuZGxlUGFyc2VkKGxlZnQsIHJpZ2h0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlUGFyc2VkKHRoaXMuX2RlZi5sZWZ0Ll9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgfSksIHRoaXMuX2RlZi5yaWdodC5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuWm9kSW50ZXJzZWN0aW9uID0gWm9kSW50ZXJzZWN0aW9uO1xuWm9kSW50ZXJzZWN0aW9uLmNyZWF0ZSA9IChsZWZ0LCByaWdodCwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RJbnRlcnNlY3Rpb24oe1xuICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICByaWdodDogcmlnaHQsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kSW50ZXJzZWN0aW9uLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kVHVwbGUgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSB1dGlsXzEuWm9kUGFyc2VkVHlwZS5hcnJheSkge1xuICAgICAgICAgICAgKDAsIHBhcnNlVXRpbF8xLmFkZElzc3VlVG9Db250ZXh0KShjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl8xLlpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IHV0aWxfMS5ab2RQYXJzZWRUeXBlLmFycmF5LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVXRpbF8xLklOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0eC5kYXRhLmxlbmd0aCA8IHRoaXMuX2RlZi5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICgwLCBwYXJzZVV0aWxfMS5hZGRJc3N1ZVRvQ29udGV4dCkoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfMS5ab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICAgIG1pbmltdW06IHRoaXMuX2RlZi5pdGVtcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVV0aWxfMS5JTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3QgPSB0aGlzLl9kZWYucmVzdDtcbiAgICAgICAgaWYgKCFyZXN0ICYmIGN0eC5kYXRhLmxlbmd0aCA+IHRoaXMuX2RlZi5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICgwLCBwYXJzZVV0aWxfMS5hZGRJc3N1ZVRvQ29udGV4dCkoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfMS5ab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgICAgICBtYXhpbXVtOiB0aGlzLl9kZWYuaXRlbXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpdGVtcyA9IFsuLi5jdHguZGF0YV1cbiAgICAgICAgICAgIC5tYXAoKGl0ZW0sIGl0ZW1JbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2NoZW1hID0gdGhpcy5fZGVmLml0ZW1zW2l0ZW1JbmRleF0gfHwgdGhpcy5fZGVmLnJlc3Q7XG4gICAgICAgICAgICBpZiAoIXNjaGVtYSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBzY2hlbWEuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBpdGVtLCBjdHgucGF0aCwgaXRlbUluZGV4KSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuZmlsdGVyKCh4KSA9PiAhIXgpOyAvLyBmaWx0ZXIgbnVsbHNcbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChpdGVtcykudGhlbigocmVzdWx0cykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZVV0aWxfMS5QYXJzZVN0YXR1cy5tZXJnZUFycmF5KHN0YXR1cywgcmVzdWx0cyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVV0aWxfMS5QYXJzZVN0YXR1cy5tZXJnZUFycmF5KHN0YXR1cywgaXRlbXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBpdGVtcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pdGVtcztcbiAgICB9XG4gICAgcmVzdChyZXN0KSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kVHVwbGUoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgcmVzdCxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5ab2RUdXBsZSA9IFpvZFR1cGxlO1xuWm9kVHVwbGUuY3JlYXRlID0gKHNjaGVtYXMsIHBhcmFtcykgPT4ge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShzY2hlbWFzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgbXVzdCBwYXNzIGFuIGFycmF5IG9mIHNjaGVtYXMgdG8gei50dXBsZShbIC4uLiBdKVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBab2RUdXBsZSh7XG4gICAgICAgIGl0ZW1zOiBzY2hlbWFzLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFR1cGxlLFxuICAgICAgICByZXN0OiBudWxsLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kUmVjb3JkIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgZ2V0IGtleVNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5rZXlUeXBlO1xuICAgIH1cbiAgICBnZXQgdmFsdWVTY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWVUeXBlO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSB1dGlsXzEuWm9kUGFyc2VkVHlwZS5vYmplY3QpIHtcbiAgICAgICAgICAgICgwLCBwYXJzZVV0aWxfMS5hZGRJc3N1ZVRvQ29udGV4dCkoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfMS5ab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiB1dGlsXzEuWm9kUGFyc2VkVHlwZS5vYmplY3QsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VVdGlsXzEuSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYWlycyA9IFtdO1xuICAgICAgICBjb25zdCBrZXlUeXBlID0gdGhpcy5fZGVmLmtleVR5cGU7XG4gICAgICAgIGNvbnN0IHZhbHVlVHlwZSA9IHRoaXMuX2RlZi52YWx1ZVR5cGU7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGN0eC5kYXRhKSB7XG4gICAgICAgICAgICBwYWlycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBrZXk6IGtleVR5cGUuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBrZXksIGN0eC5wYXRoLCBrZXkpKSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVUeXBlLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgY3R4LmRhdGFba2V5XSwgY3R4LnBhdGgsIGtleSkpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVV0aWxfMS5QYXJzZVN0YXR1cy5tZXJnZU9iamVjdEFzeW5jKHN0YXR1cywgcGFpcnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVXRpbF8xLlBhcnNlU3RhdHVzLm1lcmdlT2JqZWN0U3luYyhzdGF0dXMsIHBhaXJzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgZWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi52YWx1ZVR5cGU7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUoZmlyc3QsIHNlY29uZCwgdGhpcmQpIHtcbiAgICAgICAgaWYgKHNlY29uZCBpbnN0YW5jZW9mIFpvZFR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgWm9kUmVjb3JkKHtcbiAgICAgICAgICAgICAgICBrZXlUeXBlOiBmaXJzdCxcbiAgICAgICAgICAgICAgICB2YWx1ZVR5cGU6IHNlY29uZCxcbiAgICAgICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFJlY29yZCxcbiAgICAgICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHRoaXJkKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgWm9kUmVjb3JkKHtcbiAgICAgICAgICAgIGtleVR5cGU6IFpvZFN0cmluZy5jcmVhdGUoKSxcbiAgICAgICAgICAgIHZhbHVlVHlwZTogZmlyc3QsXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFJlY29yZCxcbiAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMoc2Vjb25kKSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5ab2RSZWNvcmQgPSBab2RSZWNvcmQ7XG5jbGFzcyBab2RNYXAgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBnZXQga2V5U2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmtleVR5cGU7XG4gICAgfVxuICAgIGdldCB2YWx1ZVNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi52YWx1ZVR5cGU7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IHV0aWxfMS5ab2RQYXJzZWRUeXBlLm1hcCkge1xuICAgICAgICAgICAgKDAsIHBhcnNlVXRpbF8xLmFkZElzc3VlVG9Db250ZXh0KShjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl8xLlpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IHV0aWxfMS5ab2RQYXJzZWRUeXBlLm1hcCxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVV0aWxfMS5JTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtleVR5cGUgPSB0aGlzLl9kZWYua2V5VHlwZTtcbiAgICAgICAgY29uc3QgdmFsdWVUeXBlID0gdGhpcy5fZGVmLnZhbHVlVHlwZTtcbiAgICAgICAgY29uc3QgcGFpcnMgPSBbLi4uY3R4LmRhdGEuZW50cmllcygpXS5tYXAoKFtrZXksIHZhbHVlXSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAga2V5OiBrZXlUeXBlLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwga2V5LCBjdHgucGF0aCwgW2luZGV4LCBcImtleVwiXSkpLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVR5cGUuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCB2YWx1ZSwgY3R4LnBhdGgsIFtpbmRleCwgXCJ2YWx1ZVwiXSkpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICBjb25zdCBmaW5hbE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBhaXIgb2YgcGFpcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgcGFpci5rZXk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgcGFpci52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiIHx8IHZhbHVlLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZVV0aWxfMS5JTlZBTElEO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkuc3RhdHVzID09PSBcImRpcnR5XCIgfHwgdmFsdWUuc3RhdHVzID09PSBcImRpcnR5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsTWFwLnNldChrZXkudmFsdWUsIHZhbHVlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBmaW5hbE1hcCB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBmaW5hbE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IHBhaXIua2V5O1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcGFpci52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIgfHwgdmFsdWUuc3RhdHVzID09PSBcImFib3J0ZWRcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VVdGlsXzEuSU5WQUxJRDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGtleS5zdGF0dXMgPT09IFwiZGlydHlcIiB8fCB2YWx1ZS5zdGF0dXMgPT09IFwiZGlydHlcIikge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxNYXAuc2V0KGtleS52YWx1ZSwgdmFsdWUudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBmaW5hbE1hcCB9O1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5ab2RNYXAgPSBab2RNYXA7XG5ab2RNYXAuY3JlYXRlID0gKGtleVR5cGUsIHZhbHVlVHlwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RNYXAoe1xuICAgICAgICB2YWx1ZVR5cGUsXG4gICAgICAgIGtleVR5cGUsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTWFwLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kU2V0IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gdXRpbF8xLlpvZFBhcnNlZFR5cGUuc2V0KSB7XG4gICAgICAgICAgICAoMCwgcGFyc2VVdGlsXzEuYWRkSXNzdWVUb0NvbnRleHQpKGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yXzEuWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogdXRpbF8xLlpvZFBhcnNlZFR5cGUuc2V0LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVXRpbF8xLklOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVmID0gdGhpcy5fZGVmO1xuICAgICAgICBpZiAoZGVmLm1pblNpemUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjdHguZGF0YS5zaXplIDwgZGVmLm1pblNpemUudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAoMCwgcGFyc2VVdGlsXzEuYWRkSXNzdWVUb0NvbnRleHQpKGN0eCwge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl8xLlpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgICAgIG1pbmltdW06IGRlZi5taW5TaXplLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInNldFwiLFxuICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZGVmLm1pblNpemUubWVzc2FnZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmLm1heFNpemUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjdHguZGF0YS5zaXplID4gZGVmLm1heFNpemUudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAoMCwgcGFyc2VVdGlsXzEuYWRkSXNzdWVUb0NvbnRleHQpKGN0eCwge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl8xLlpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgICAgICAgICBtYXhpbXVtOiBkZWYubWF4U2l6ZS52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzZXRcIixcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGRlZi5tYXhTaXplLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWVUeXBlID0gdGhpcy5fZGVmLnZhbHVlVHlwZTtcbiAgICAgICAgZnVuY3Rpb24gZmluYWxpemVTZXQoZWxlbWVudHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZFNldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZVV0aWxfMS5JTlZBTElEO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICBwYXJzZWRTZXQuYWRkKGVsZW1lbnQudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBwYXJzZWRTZXQgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbGVtZW50cyA9IFsuLi5jdHguZGF0YS52YWx1ZXMoKV0ubWFwKChpdGVtLCBpKSA9PiB2YWx1ZVR5cGUuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBpdGVtLCBjdHgucGF0aCwgaSkpKTtcbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChlbGVtZW50cykudGhlbigoZWxlbWVudHMpID0+IGZpbmFsaXplU2V0KGVsZW1lbnRzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmluYWxpemVTZXQoZWxlbWVudHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1pbihtaW5TaXplLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kU2V0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIG1pblNpemU6IHsgdmFsdWU6IG1pblNpemUsIG1lc3NhZ2U6IGVycm9yVXRpbF8xLmVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWF4KG1heFNpemUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RTZXQoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgbWF4U2l6ZTogeyB2YWx1ZTogbWF4U2l6ZSwgbWVzc2FnZTogZXJyb3JVdGlsXzEuZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzaXplKHNpemUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWluKHNpemUsIG1lc3NhZ2UpLm1heChzaXplLCBtZXNzYWdlKTtcbiAgICB9XG4gICAgbm9uZW1wdHkobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5taW4oMSwgbWVzc2FnZSk7XG4gICAgfVxufVxuZXhwb3J0cy5ab2RTZXQgPSBab2RTZXQ7XG5ab2RTZXQuY3JlYXRlID0gKHZhbHVlVHlwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RTZXQoe1xuICAgICAgICB2YWx1ZVR5cGUsXG4gICAgICAgIG1pblNpemU6IG51bGwsXG4gICAgICAgIG1heFNpemU6IG51bGwsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kU2V0LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kRnVuY3Rpb24gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZSA9IHRoaXMuaW1wbGVtZW50O1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gdXRpbF8xLlpvZFBhcnNlZFR5cGUuZnVuY3Rpb24pIHtcbiAgICAgICAgICAgICgwLCBwYXJzZVV0aWxfMS5hZGRJc3N1ZVRvQ29udGV4dCkoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfMS5ab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiB1dGlsXzEuWm9kUGFyc2VkVHlwZS5mdW5jdGlvbixcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVV0aWxfMS5JTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG1ha2VBcmdzSXNzdWUoYXJncywgZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgcGFyc2VVdGlsXzEubWFrZUlzc3VlKSh7XG4gICAgICAgICAgICAgICAgZGF0YTogYXJncyxcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBlcnJvck1hcHM6IFtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAsXG4gICAgICAgICAgICAgICAgICAgIGN0eC5zY2hlbWFFcnJvck1hcCxcbiAgICAgICAgICAgICAgICAgICAgKDAsIGVycm9yc18xLmdldEVycm9yTWFwKSgpLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcnNfMS5kZWZhdWx0RXJyb3JNYXAsXG4gICAgICAgICAgICAgICAgXS5maWx0ZXIoKHgpID0+ICEheCksXG4gICAgICAgICAgICAgICAgaXNzdWVEYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yXzEuWm9kSXNzdWVDb2RlLmludmFsaWRfYXJndW1lbnRzLFxuICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHNFcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG1ha2VSZXR1cm5zSXNzdWUocmV0dXJucywgZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgcGFyc2VVdGlsXzEubWFrZUlzc3VlKSh7XG4gICAgICAgICAgICAgICAgZGF0YTogcmV0dXJucyxcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBlcnJvck1hcHM6IFtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAsXG4gICAgICAgICAgICAgICAgICAgIGN0eC5zY2hlbWFFcnJvck1hcCxcbiAgICAgICAgICAgICAgICAgICAgKDAsIGVycm9yc18xLmdldEVycm9yTWFwKSgpLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcnNfMS5kZWZhdWx0RXJyb3JNYXAsXG4gICAgICAgICAgICAgICAgXS5maWx0ZXIoKHgpID0+ICEheCksXG4gICAgICAgICAgICAgICAgaXNzdWVEYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yXzEuWm9kSXNzdWVDb2RlLmludmFsaWRfcmV0dXJuX3R5cGUsXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblR5cGVFcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHsgZXJyb3JNYXA6IGN0eC5jb21tb24uY29udGV4dHVhbEVycm9yTWFwIH07XG4gICAgICAgIGNvbnN0IGZuID0gY3R4LmRhdGE7XG4gICAgICAgIGlmICh0aGlzLl9kZWYucmV0dXJucyBpbnN0YW5jZW9mIFpvZFByb21pc2UpIHtcbiAgICAgICAgICAgIC8vIFdvdWxkIGxvdmUgYSB3YXkgdG8gYXZvaWQgZGlzYWJsaW5nIHRoaXMgcnVsZSwgYnV0IHdlIG5lZWRcbiAgICAgICAgICAgIC8vIGFuIGFsaWFzICh1c2luZyBhbiBhcnJvdyBmdW5jdGlvbiB3YXMgd2hhdCBjYXVzZWQgMjY1MSkuXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXNcbiAgICAgICAgICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiAoMCwgcGFyc2VVdGlsXzEuT0spKGFzeW5jIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgWm9kRXJyb3JfMS5ab2RFcnJvcihbXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkQXJncyA9IGF3YWl0IG1lLl9kZWYuYXJnc1xuICAgICAgICAgICAgICAgICAgICAucGFyc2VBc3luYyhhcmdzLCBwYXJhbXMpXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5hZGRJc3N1ZShtYWtlQXJnc0lzc3VlKGFyZ3MsIGUpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgUmVmbGVjdC5hcHBseShmbiwgdGhpcywgcGFyc2VkQXJncyk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkUmV0dXJucyA9IGF3YWl0IG1lLl9kZWYucmV0dXJucy5fZGVmLnR5cGVcbiAgICAgICAgICAgICAgICAgICAgLnBhcnNlQXN5bmMocmVzdWx0LCBwYXJhbXMpXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5hZGRJc3N1ZShtYWtlUmV0dXJuc0lzc3VlKHJlc3VsdCwgZSkpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VkUmV0dXJucztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gV291bGQgbG92ZSBhIHdheSB0byBhdm9pZCBkaXNhYmxpbmcgdGhpcyBydWxlLCBidXQgd2UgbmVlZFxuICAgICAgICAgICAgLy8gYW4gYWxpYXMgKHVzaW5nIGFuIGFycm93IGZ1bmN0aW9uIHdhcyB3aGF0IGNhdXNlZCAyNjUxKS5cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhc1xuICAgICAgICAgICAgY29uc3QgbWUgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuICgwLCBwYXJzZVV0aWxfMS5PSykoZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRBcmdzID0gbWUuX2RlZi5hcmdzLnNhZmVQYXJzZShhcmdzLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgIGlmICghcGFyc2VkQXJncy5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBab2RFcnJvcl8xLlpvZEVycm9yKFttYWtlQXJnc0lzc3VlKGFyZ3MsIHBhcnNlZEFyZ3MuZXJyb3IpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IFJlZmxlY3QuYXBwbHkoZm4sIHRoaXMsIHBhcnNlZEFyZ3MuZGF0YSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkUmV0dXJucyA9IG1lLl9kZWYucmV0dXJucy5zYWZlUGFyc2UocmVzdWx0LCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgIGlmICghcGFyc2VkUmV0dXJucy5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBab2RFcnJvcl8xLlpvZEVycm9yKFttYWtlUmV0dXJuc0lzc3VlKHJlc3VsdCwgcGFyc2VkUmV0dXJucy5lcnJvcildKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlZFJldHVybnMuZGF0YTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBhcmFtZXRlcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuYXJncztcbiAgICB9XG4gICAgcmV0dXJuVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5yZXR1cm5zO1xuICAgIH1cbiAgICBhcmdzKC4uLml0ZW1zKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kRnVuY3Rpb24oe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgYXJnczogWm9kVHVwbGUuY3JlYXRlKGl0ZW1zKS5yZXN0KFpvZFVua25vd24uY3JlYXRlKCkpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJucyhyZXR1cm5UeXBlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kRnVuY3Rpb24oe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgcmV0dXJuczogcmV0dXJuVHlwZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGltcGxlbWVudChmdW5jKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRlZEZ1bmMgPSB0aGlzLnBhcnNlKGZ1bmMpO1xuICAgICAgICByZXR1cm4gdmFsaWRhdGVkRnVuYztcbiAgICB9XG4gICAgc3RyaWN0SW1wbGVtZW50KGZ1bmMpIHtcbiAgICAgICAgY29uc3QgdmFsaWRhdGVkRnVuYyA9IHRoaXMucGFyc2UoZnVuYyk7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZWRGdW5jO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlKGFyZ3MsIHJldHVybnMsIHBhcmFtcykge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEZ1bmN0aW9uKHtcbiAgICAgICAgICAgIGFyZ3M6IChhcmdzXG4gICAgICAgICAgICAgICAgPyBhcmdzXG4gICAgICAgICAgICAgICAgOiBab2RUdXBsZS5jcmVhdGUoW10pLnJlc3QoWm9kVW5rbm93bi5jcmVhdGUoKSkpLFxuICAgICAgICAgICAgcmV0dXJuczogcmV0dXJucyB8fCBab2RVbmtub3duLmNyZWF0ZSgpLFxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RGdW5jdGlvbixcbiAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5ab2RGdW5jdGlvbiA9IFpvZEZ1bmN0aW9uO1xuY2xhc3MgWm9kTGF6eSBleHRlbmRzIFpvZFR5cGUge1xuICAgIGdldCBzY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuZ2V0dGVyKCk7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgY29uc3QgbGF6eVNjaGVtYSA9IHRoaXMuX2RlZi5nZXR0ZXIoKTtcbiAgICAgICAgcmV0dXJuIGxhenlTY2hlbWEuX3BhcnNlKHsgZGF0YTogY3R4LmRhdGEsIHBhdGg6IGN0eC5wYXRoLCBwYXJlbnQ6IGN0eCB9KTtcbiAgICB9XG59XG5leHBvcnRzLlpvZExhenkgPSBab2RMYXp5O1xuWm9kTGF6eS5jcmVhdGUgPSAoZ2V0dGVyLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZExhenkoe1xuICAgICAgICBnZXR0ZXI6IGdldHRlcixcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RMYXp5LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kTGl0ZXJhbCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBpZiAoaW5wdXQuZGF0YSAhPT0gdGhpcy5fZGVmLnZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICAoMCwgcGFyc2VVdGlsXzEuYWRkSXNzdWVUb0NvbnRleHQpKGN0eCwge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl8xLlpvZElzc3VlQ29kZS5pbnZhbGlkX2xpdGVyYWwsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IHRoaXMuX2RlZi52YWx1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVXRpbF8xLklOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBpbnB1dC5kYXRhIH07XG4gICAgfVxuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi52YWx1ZTtcbiAgICB9XG59XG5leHBvcnRzLlpvZExpdGVyYWwgPSBab2RMaXRlcmFsO1xuWm9kTGl0ZXJhbC5jcmVhdGUgPSAodmFsdWUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTGl0ZXJhbCh7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RMaXRlcmFsLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZnVuY3Rpb24gY3JlYXRlWm9kRW51bSh2YWx1ZXMsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgWm9kRW51bSh7XG4gICAgICAgIHZhbHVlcyxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFbnVtLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG5jbGFzcyBab2RFbnVtIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQuZGF0YSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRWYWx1ZXMgPSB0aGlzLl9kZWYudmFsdWVzO1xuICAgICAgICAgICAgKDAsIHBhcnNlVXRpbF8xLmFkZElzc3VlVG9Db250ZXh0KShjdHgsIHtcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogdXRpbF8xLnV0aWwuam9pblZhbHVlcyhleHBlY3RlZFZhbHVlcyksXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yXzEuWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVXRpbF8xLklOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2RlZi52YWx1ZXMuaW5kZXhPZihpbnB1dC5kYXRhKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkVmFsdWVzID0gdGhpcy5fZGVmLnZhbHVlcztcbiAgICAgICAgICAgICgwLCBwYXJzZVV0aWxfMS5hZGRJc3N1ZVRvQ29udGV4dCkoY3R4LCB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yXzEuWm9kSXNzdWVDb2RlLmludmFsaWRfZW51bV92YWx1ZSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBleHBlY3RlZFZhbHVlcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVXRpbF8xLklOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCBwYXJzZVV0aWxfMS5PSykoaW5wdXQuZGF0YSk7XG4gICAgfVxuICAgIGdldCBvcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlcztcbiAgICB9XG4gICAgZ2V0IGVudW0oKSB7XG4gICAgICAgIGNvbnN0IGVudW1WYWx1ZXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCB2YWwgb2YgdGhpcy5fZGVmLnZhbHVlcykge1xuICAgICAgICAgICAgZW51bVZhbHVlc1t2YWxdID0gdmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnVtVmFsdWVzO1xuICAgIH1cbiAgICBnZXQgVmFsdWVzKCkge1xuICAgICAgICBjb25zdCBlbnVtVmFsdWVzID0ge307XG4gICAgICAgIGZvciAoY29uc3QgdmFsIG9mIHRoaXMuX2RlZi52YWx1ZXMpIHtcbiAgICAgICAgICAgIGVudW1WYWx1ZXNbdmFsXSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW51bVZhbHVlcztcbiAgICB9XG4gICAgZ2V0IEVudW0oKSB7XG4gICAgICAgIGNvbnN0IGVudW1WYWx1ZXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCB2YWwgb2YgdGhpcy5fZGVmLnZhbHVlcykge1xuICAgICAgICAgICAgZW51bVZhbHVlc1t2YWxdID0gdmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnVtVmFsdWVzO1xuICAgIH1cbiAgICBleHRyYWN0KHZhbHVlcykge1xuICAgICAgICByZXR1cm4gWm9kRW51bS5jcmVhdGUodmFsdWVzKTtcbiAgICB9XG4gICAgZXhjbHVkZSh2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIFpvZEVudW0uY3JlYXRlKHRoaXMub3B0aW9ucy5maWx0ZXIoKG9wdCkgPT4gIXZhbHVlcy5pbmNsdWRlcyhvcHQpKSk7XG4gICAgfVxufVxuZXhwb3J0cy5ab2RFbnVtID0gWm9kRW51bTtcblpvZEVudW0uY3JlYXRlID0gY3JlYXRlWm9kRW51bTtcbmNsYXNzIFpvZE5hdGl2ZUVudW0gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgbmF0aXZlRW51bVZhbHVlcyA9IHV0aWxfMS51dGlsLmdldFZhbGlkRW51bVZhbHVlcyh0aGlzLl9kZWYudmFsdWVzKTtcbiAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IHV0aWxfMS5ab2RQYXJzZWRUeXBlLnN0cmluZyAmJlxuICAgICAgICAgICAgY3R4LnBhcnNlZFR5cGUgIT09IHV0aWxfMS5ab2RQYXJzZWRUeXBlLm51bWJlcikge1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRWYWx1ZXMgPSB1dGlsXzEudXRpbC5vYmplY3RWYWx1ZXMobmF0aXZlRW51bVZhbHVlcyk7XG4gICAgICAgICAgICAoMCwgcGFyc2VVdGlsXzEuYWRkSXNzdWVUb0NvbnRleHQpKGN0eCwge1xuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiB1dGlsXzEudXRpbC5qb2luVmFsdWVzKGV4cGVjdGVkVmFsdWVzKSxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfMS5ab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VVdGlsXzEuSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmF0aXZlRW51bVZhbHVlcy5pbmRleE9mKGlucHV0LmRhdGEpID09PSAtMSkge1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRWYWx1ZXMgPSB1dGlsXzEudXRpbC5vYmplY3RWYWx1ZXMobmF0aXZlRW51bVZhbHVlcyk7XG4gICAgICAgICAgICAoMCwgcGFyc2VVdGlsXzEuYWRkSXNzdWVUb0NvbnRleHQpKGN0eCwge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl8xLlpvZElzc3VlQ29kZS5pbnZhbGlkX2VudW1fdmFsdWUsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogZXhwZWN0ZWRWYWx1ZXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVV0aWxfMS5JTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoMCwgcGFyc2VVdGlsXzEuT0spKGlucHV0LmRhdGEpO1xuICAgIH1cbiAgICBnZXQgZW51bSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi52YWx1ZXM7XG4gICAgfVxufVxuZXhwb3J0cy5ab2ROYXRpdmVFbnVtID0gWm9kTmF0aXZlRW51bTtcblpvZE5hdGl2ZUVudW0uY3JlYXRlID0gKHZhbHVlcywgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2ROYXRpdmVFbnVtKHtcbiAgICAgICAgdmFsdWVzOiB2YWx1ZXMsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTmF0aXZlRW51bSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZFByb21pc2UgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICB1bndyYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudHlwZTtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IHV0aWxfMS5ab2RQYXJzZWRUeXBlLnByb21pc2UgJiZcbiAgICAgICAgICAgIGN0eC5jb21tb24uYXN5bmMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAoMCwgcGFyc2VVdGlsXzEuYWRkSXNzdWVUb0NvbnRleHQpKGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yXzEuWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogdXRpbF8xLlpvZFBhcnNlZFR5cGUucHJvbWlzZSxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVV0aWxfMS5JTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb21pc2lmaWVkID0gY3R4LnBhcnNlZFR5cGUgPT09IHV0aWxfMS5ab2RQYXJzZWRUeXBlLnByb21pc2VcbiAgICAgICAgICAgID8gY3R4LmRhdGFcbiAgICAgICAgICAgIDogUHJvbWlzZS5yZXNvbHZlKGN0eC5kYXRhKTtcbiAgICAgICAgcmV0dXJuICgwLCBwYXJzZVV0aWxfMS5PSykocHJvbWlzaWZpZWQudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi50eXBlLnBhcnNlQXN5bmMoZGF0YSwge1xuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIGVycm9yTWFwOiBjdHguY29tbW9uLmNvbnRleHR1YWxFcnJvck1hcCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KSk7XG4gICAgfVxufVxuZXhwb3J0cy5ab2RQcm9taXNlID0gWm9kUHJvbWlzZTtcblpvZFByb21pc2UuY3JlYXRlID0gKHNjaGVtYSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RQcm9taXNlKHtcbiAgICAgICAgdHlwZTogc2NoZW1hLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFByb21pc2UsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RFZmZlY3RzIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgaW5uZXJUeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnNjaGVtYTtcbiAgICB9XG4gICAgc291cmNlVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5zY2hlbWEuX2RlZi50eXBlTmFtZSA9PT0gWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVmZmVjdHNcbiAgICAgICAgICAgID8gdGhpcy5fZGVmLnNjaGVtYS5zb3VyY2VUeXBlKClcbiAgICAgICAgICAgIDogdGhpcy5fZGVmLnNjaGVtYTtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGNvbnN0IGVmZmVjdCA9IHRoaXMuX2RlZi5lZmZlY3QgfHwgbnVsbDtcbiAgICAgICAgY29uc3QgY2hlY2tDdHggPSB7XG4gICAgICAgICAgICBhZGRJc3N1ZTogKGFyZykgPT4ge1xuICAgICAgICAgICAgICAgICgwLCBwYXJzZVV0aWxfMS5hZGRJc3N1ZVRvQ29udGV4dCkoY3R4LCBhcmcpO1xuICAgICAgICAgICAgICAgIGlmIChhcmcuZmF0YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IHBhdGgoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN0eC5wYXRoO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgY2hlY2tDdHguYWRkSXNzdWUgPSBjaGVja0N0eC5hZGRJc3N1ZS5iaW5kKGNoZWNrQ3R4KTtcbiAgICAgICAgaWYgKGVmZmVjdC50eXBlID09PSBcInByZXByb2Nlc3NcIikge1xuICAgICAgICAgICAgY29uc3QgcHJvY2Vzc2VkID0gZWZmZWN0LnRyYW5zZm9ybShjdHguZGF0YSwgY2hlY2tDdHgpO1xuICAgICAgICAgICAgaWYgKGN0eC5jb21tb24uaXNzdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogXCJkaXJ0eVwiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwcm9jZXNzZWQpLnRoZW4oKHByb2Nlc3NlZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VBc3luYyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBwcm9jZXNzZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWYuc2NoZW1hLl9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBwcm9jZXNzZWQsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZWZmZWN0LnR5cGUgPT09IFwicmVmaW5lbWVudFwiKSB7XG4gICAgICAgICAgICBjb25zdCBleGVjdXRlUmVmaW5lbWVudCA9IChhY2NcbiAgICAgICAgICAgIC8vIGVmZmVjdDogUmVmaW5lbWVudEVmZmVjdDxhbnk+XG4gICAgICAgICAgICApID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBlZmZlY3QucmVmaW5lbWVudChhY2MsIGNoZWNrQ3R4KTtcbiAgICAgICAgICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFzeW5jIHJlZmluZW1lbnQgZW5jb3VudGVyZWQgZHVyaW5nIHN5bmNocm9ub3VzIHBhcnNlIG9wZXJhdGlvbi4gVXNlIC5wYXJzZUFzeW5jIGluc3RlYWQuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlubmVyID0gdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoaW5uZXIuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlVXRpbF8xLklOVkFMSUQ7XG4gICAgICAgICAgICAgICAgaWYgKGlubmVyLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gdmFsdWUgaXMgaWdub3JlZFxuICAgICAgICAgICAgICAgIGV4ZWN1dGVSZWZpbmVtZW50KGlubmVyLnZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlubmVyLnZhbHVlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnNjaGVtYVxuICAgICAgICAgICAgICAgICAgICAuX3BhcnNlQXN5bmMoeyBkYXRhOiBjdHguZGF0YSwgcGF0aDogY3R4LnBhdGgsIHBhcmVudDogY3R4IH0pXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKChpbm5lcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5uZXIuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZVV0aWxfMS5JTlZBTElEO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5uZXIuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4ZWN1dGVSZWZpbmVtZW50KGlubmVyLnZhbHVlKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogaW5uZXIudmFsdWUgfTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVmZmVjdC50eXBlID09PSBcInRyYW5zZm9ybVwiKSB7XG4gICAgICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlID0gdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoISgwLCBwYXJzZVV0aWxfMS5pc1ZhbGlkKShiYXNlKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gZWZmZWN0LnRyYW5zZm9ybShiYXNlLnZhbHVlLCBjaGVja0N0eCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBc3luY2hyb25vdXMgdHJhbnNmb3JtIGVuY291bnRlcmVkIGR1cmluZyBzeW5jaHJvbm91cyBwYXJzZSBvcGVyYXRpb24uIFVzZSAucGFyc2VBc3luYyBpbnN0ZWFkLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IHJlc3VsdCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5zY2hlbWFcbiAgICAgICAgICAgICAgICAgICAgLl9wYXJzZUFzeW5jKHsgZGF0YTogY3R4LmRhdGEsIHBhdGg6IGN0eC5wYXRoLCBwYXJlbnQ6IGN0eCB9KVxuICAgICAgICAgICAgICAgICAgICAudGhlbigoYmFzZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoISgwLCBwYXJzZVV0aWxfMS5pc1ZhbGlkKShiYXNlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGVmZmVjdC50cmFuc2Zvcm0oYmFzZS52YWx1ZSwgY2hlY2tDdHgpKS50aGVuKChyZXN1bHQpID0+ICh7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogcmVzdWx0IH0pKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB1dGlsXzEudXRpbC5hc3NlcnROZXZlcihlZmZlY3QpO1xuICAgIH1cbn1cbmV4cG9ydHMuWm9kRWZmZWN0cyA9IFpvZEVmZmVjdHM7XG5leHBvcnRzLlpvZFRyYW5zZm9ybWVyID0gWm9kRWZmZWN0cztcblpvZEVmZmVjdHMuY3JlYXRlID0gKHNjaGVtYSwgZWZmZWN0LCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZEVmZmVjdHMoe1xuICAgICAgICBzY2hlbWEsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRWZmZWN0cyxcbiAgICAgICAgZWZmZWN0LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuWm9kRWZmZWN0cy5jcmVhdGVXaXRoUHJlcHJvY2VzcyA9IChwcmVwcm9jZXNzLCBzY2hlbWEsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kRWZmZWN0cyh7XG4gICAgICAgIHNjaGVtYSxcbiAgICAgICAgZWZmZWN0OiB7IHR5cGU6IFwicHJlcHJvY2Vzc1wiLCB0cmFuc2Zvcm06IHByZXByb2Nlc3MgfSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFZmZlY3RzLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kT3B0aW9uYWwgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSA9PT0gdXRpbF8xLlpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIHBhcnNlVXRpbF8xLk9LKSh1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlLl9wYXJzZShpbnB1dCk7XG4gICAgfVxuICAgIHVud3JhcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGU7XG4gICAgfVxufVxuZXhwb3J0cy5ab2RPcHRpb25hbCA9IFpvZE9wdGlvbmFsO1xuWm9kT3B0aW9uYWwuY3JlYXRlID0gKHR5cGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kT3B0aW9uYWwoe1xuICAgICAgICBpbm5lclR5cGU6IHR5cGUsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT3B0aW9uYWwsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2ROdWxsYWJsZSBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlID09PSB1dGlsXzEuWm9kUGFyc2VkVHlwZS5udWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIHBhcnNlVXRpbF8xLk9LKShudWxsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2UoaW5wdXQpO1xuICAgIH1cbiAgICB1bndyYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xuICAgIH1cbn1cbmV4cG9ydHMuWm9kTnVsbGFibGUgPSBab2ROdWxsYWJsZTtcblpvZE51bGxhYmxlLmNyZWF0ZSA9ICh0eXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE51bGxhYmxlKHtcbiAgICAgICAgaW5uZXJUeXBlOiB0eXBlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE51bGxhYmxlLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kRGVmYXVsdCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgbGV0IGRhdGEgPSBjdHguZGF0YTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlID09PSB1dGlsXzEuWm9kUGFyc2VkVHlwZS51bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRhdGEgPSB0aGlzLl9kZWYuZGVmYXVsdFZhbHVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKHtcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVtb3ZlRGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGU7XG4gICAgfVxufVxuZXhwb3J0cy5ab2REZWZhdWx0ID0gWm9kRGVmYXVsdDtcblpvZERlZmF1bHQuY3JlYXRlID0gKHR5cGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kRGVmYXVsdCh7XG4gICAgICAgIGlubmVyVHlwZTogdHlwZSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2REZWZhdWx0LFxuICAgICAgICBkZWZhdWx0VmFsdWU6IHR5cGVvZiBwYXJhbXMuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICA/IHBhcmFtcy5kZWZhdWx0XG4gICAgICAgICAgICA6ICgpID0+IHBhcmFtcy5kZWZhdWx0LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kQ2F0Y2ggZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIC8vIG5ld0N0eCBpcyB1c2VkIHRvIG5vdCBjb2xsZWN0IGlzc3VlcyBmcm9tIGlubmVyIHR5cGVzIGluIGN0eFxuICAgICAgICBjb25zdCBuZXdDdHggPSB7XG4gICAgICAgICAgICAuLi5jdHgsXG4gICAgICAgICAgICBjb21tb246IHtcbiAgICAgICAgICAgICAgICAuLi5jdHguY29tbW9uLFxuICAgICAgICAgICAgICAgIGlzc3VlczogW10sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9kZWYuaW5uZXJUeXBlLl9wYXJzZSh7XG4gICAgICAgICAgICBkYXRhOiBuZXdDdHguZGF0YSxcbiAgICAgICAgICAgIHBhdGg6IG5ld0N0eC5wYXRoLFxuICAgICAgICAgICAgcGFyZW50OiB7XG4gICAgICAgICAgICAgICAgLi4ubmV3Q3R4LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICgoMCwgcGFyc2VVdGlsXzEuaXNBc3luYykocmVzdWx0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IFwidmFsaWRcIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdC5zdGF0dXMgPT09IFwidmFsaWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgPyByZXN1bHQudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy5fZGVmLmNhdGNoVmFsdWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCBlcnJvcigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBab2RFcnJvcl8xLlpvZEVycm9yKG5ld0N0eC5jb21tb24uaXNzdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0OiBuZXdDdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RhdHVzOiBcInZhbGlkXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdC5zdGF0dXMgPT09IFwidmFsaWRcIlxuICAgICAgICAgICAgICAgICAgICA/IHJlc3VsdC52YWx1ZVxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuX2RlZi5jYXRjaFZhbHVlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCBlcnJvcigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFpvZEVycm9yXzEuWm9kRXJyb3IobmV3Q3R4LmNvbW1vbi5pc3N1ZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0OiBuZXdDdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZUNhdGNoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZTtcbiAgICB9XG59XG5leHBvcnRzLlpvZENhdGNoID0gWm9kQ2F0Y2g7XG5ab2RDYXRjaC5jcmVhdGUgPSAodHlwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RDYXRjaCh7XG4gICAgICAgIGlubmVyVHlwZTogdHlwZSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RDYXRjaCxcbiAgICAgICAgY2F0Y2hWYWx1ZTogdHlwZW9mIHBhcmFtcy5jYXRjaCA9PT0gXCJmdW5jdGlvblwiID8gcGFyYW1zLmNhdGNoIDogKCkgPT4gcGFyYW1zLmNhdGNoLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kTmFOIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IHV0aWxfMS5ab2RQYXJzZWRUeXBlLm5hbikge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgKDAsIHBhcnNlVXRpbF8xLmFkZElzc3VlVG9Db250ZXh0KShjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl8xLlpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IHV0aWxfMS5ab2RQYXJzZWRUeXBlLm5hbixcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVV0aWxfMS5JTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZTogaW5wdXQuZGF0YSB9O1xuICAgIH1cbn1cbmV4cG9ydHMuWm9kTmFOID0gWm9kTmFOO1xuWm9kTmFOLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE5hTih7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTmFOLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZXhwb3J0cy5CUkFORCA9IFN5bWJvbChcInpvZF9icmFuZFwiKTtcbmNsYXNzIFpvZEJyYW5kZWQgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBjdHguZGF0YTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi50eXBlLl9wYXJzZSh7XG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHVud3JhcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi50eXBlO1xuICAgIH1cbn1cbmV4cG9ydHMuWm9kQnJhbmRlZCA9IFpvZEJyYW5kZWQ7XG5jbGFzcyBab2RQaXBlbGluZSBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlQXN5bmMgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5SZXN1bHQgPSBhd2FpdCB0aGlzLl9kZWYuaW4uX3BhcnNlQXN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChpblJlc3VsdC5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VVdGlsXzEuSU5WQUxJRDtcbiAgICAgICAgICAgICAgICBpZiAoaW5SZXN1bHQuc3RhdHVzID09PSBcImRpcnR5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgcGFyc2VVdGlsXzEuRElSVFkpKGluUmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWYub3V0Ll9wYXJzZUFzeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGluUmVzdWx0LnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVBc3luYygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaW5SZXN1bHQgPSB0aGlzLl9kZWYuaW4uX3BhcnNlU3luYyh7XG4gICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChpblJlc3VsdC5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZVV0aWxfMS5JTlZBTElEO1xuICAgICAgICAgICAgaWYgKGluUmVzdWx0LnN0YXR1cyA9PT0gXCJkaXJ0eVwiKSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBcImRpcnR5XCIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBpblJlc3VsdC52YWx1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5vdXQuX3BhcnNlU3luYyh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGluUmVzdWx0LnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZShhLCBiKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kUGlwZWxpbmUoe1xuICAgICAgICAgICAgaW46IGEsXG4gICAgICAgICAgICBvdXQ6IGIsXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFBpcGVsaW5lLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLlpvZFBpcGVsaW5lID0gWm9kUGlwZWxpbmU7XG5jbGFzcyBab2RSZWFkb25seSBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9kZWYuaW5uZXJUeXBlLl9wYXJzZShpbnB1dCk7XG4gICAgICAgIGlmICgoMCwgcGFyc2VVdGlsXzEuaXNWYWxpZCkocmVzdWx0KSkge1xuICAgICAgICAgICAgcmVzdWx0LnZhbHVlID0gT2JqZWN0LmZyZWV6ZShyZXN1bHQudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuZXhwb3J0cy5ab2RSZWFkb25seSA9IFpvZFJlYWRvbmx5O1xuWm9kUmVhZG9ubHkuY3JlYXRlID0gKHR5cGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kUmVhZG9ubHkoe1xuICAgICAgICBpbm5lclR5cGU6IHR5cGUsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kUmVhZG9ubHksXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jb25zdCBjdXN0b20gPSAoY2hlY2ssIHBhcmFtcyA9IHt9LCBcbi8qKlxuICogQGRlcHJlY2F0ZWRcbiAqXG4gKiBQYXNzIGBmYXRhbGAgaW50byB0aGUgcGFyYW1zIG9iamVjdCBpbnN0ZWFkOlxuICpcbiAqIGBgYHRzXG4gKiB6LnN0cmluZygpLmN1c3RvbSgodmFsKSA9PiB2YWwubGVuZ3RoID4gNSwgeyBmYXRhbDogZmFsc2UgfSlcbiAqIGBgYFxuICpcbiAqL1xuZmF0YWwpID0+IHtcbiAgICBpZiAoY2hlY2spXG4gICAgICAgIHJldHVybiBab2RBbnkuY3JlYXRlKCkuc3VwZXJSZWZpbmUoKGRhdGEsIGN0eCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGlmICghY2hlY2soZGF0YSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwID0gdHlwZW9mIHBhcmFtcyA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICAgICAgICAgID8gcGFyYW1zKGRhdGEpXG4gICAgICAgICAgICAgICAgICAgIDogdHlwZW9mIHBhcmFtcyA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgICAgICAgICAgICAgICAgPyB7IG1lc3NhZ2U6IHBhcmFtcyB9XG4gICAgICAgICAgICAgICAgICAgICAgICA6IHBhcmFtcztcbiAgICAgICAgICAgICAgICBjb25zdCBfZmF0YWwgPSAoX2IgPSAoX2EgPSBwLmZhdGFsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYXRhbCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBwMiA9IHR5cGVvZiBwID09PSBcInN0cmluZ1wiID8geyBtZXNzYWdlOiBwIH0gOiBwO1xuICAgICAgICAgICAgICAgIGN0eC5hZGRJc3N1ZSh7IGNvZGU6IFwiY3VzdG9tXCIsIC4uLnAyLCBmYXRhbDogX2ZhdGFsIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICByZXR1cm4gWm9kQW55LmNyZWF0ZSgpO1xufTtcbmV4cG9ydHMuY3VzdG9tID0gY3VzdG9tO1xuZXhwb3J0cy5sYXRlID0ge1xuICAgIG9iamVjdDogWm9kT2JqZWN0LmxhenljcmVhdGUsXG59O1xudmFyIFpvZEZpcnN0UGFydHlUeXBlS2luZDtcbihmdW5jdGlvbiAoWm9kRmlyc3RQYXJ0eVR5cGVLaW5kKSB7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kU3RyaW5nXCJdID0gXCJab2RTdHJpbmdcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2ROdW1iZXJcIl0gPSBcIlpvZE51bWJlclwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE5hTlwiXSA9IFwiWm9kTmFOXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kQmlnSW50XCJdID0gXCJab2RCaWdJbnRcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RCb29sZWFuXCJdID0gXCJab2RCb29sZWFuXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kRGF0ZVwiXSA9IFwiWm9kRGF0ZVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFN5bWJvbFwiXSA9IFwiWm9kU3ltYm9sXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kVW5kZWZpbmVkXCJdID0gXCJab2RVbmRlZmluZWRcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2ROdWxsXCJdID0gXCJab2ROdWxsXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kQW55XCJdID0gXCJab2RBbnlcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RVbmtub3duXCJdID0gXCJab2RVbmtub3duXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTmV2ZXJcIl0gPSBcIlpvZE5ldmVyXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kVm9pZFwiXSA9IFwiWm9kVm9pZFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEFycmF5XCJdID0gXCJab2RBcnJheVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE9iamVjdFwiXSA9IFwiWm9kT2JqZWN0XCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kVW5pb25cIl0gPSBcIlpvZFVuaW9uXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kRGlzY3JpbWluYXRlZFVuaW9uXCJdID0gXCJab2REaXNjcmltaW5hdGVkVW5pb25cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RJbnRlcnNlY3Rpb25cIl0gPSBcIlpvZEludGVyc2VjdGlvblwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFR1cGxlXCJdID0gXCJab2RUdXBsZVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFJlY29yZFwiXSA9IFwiWm9kUmVjb3JkXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTWFwXCJdID0gXCJab2RNYXBcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RTZXRcIl0gPSBcIlpvZFNldFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEZ1bmN0aW9uXCJdID0gXCJab2RGdW5jdGlvblwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZExhenlcIl0gPSBcIlpvZExhenlcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RMaXRlcmFsXCJdID0gXCJab2RMaXRlcmFsXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kRW51bVwiXSA9IFwiWm9kRW51bVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEVmZmVjdHNcIl0gPSBcIlpvZEVmZmVjdHNcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2ROYXRpdmVFbnVtXCJdID0gXCJab2ROYXRpdmVFbnVtXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kT3B0aW9uYWxcIl0gPSBcIlpvZE9wdGlvbmFsXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTnVsbGFibGVcIl0gPSBcIlpvZE51bGxhYmxlXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kRGVmYXVsdFwiXSA9IFwiWm9kRGVmYXVsdFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZENhdGNoXCJdID0gXCJab2RDYXRjaFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFByb21pc2VcIl0gPSBcIlpvZFByb21pc2VcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RCcmFuZGVkXCJdID0gXCJab2RCcmFuZGVkXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kUGlwZWxpbmVcIl0gPSBcIlpvZFBpcGVsaW5lXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kUmVhZG9ubHlcIl0gPSBcIlpvZFJlYWRvbmx5XCI7XG59KShab2RGaXJzdFBhcnR5VHlwZUtpbmQgPSBleHBvcnRzLlpvZEZpcnN0UGFydHlUeXBlS2luZCB8fCAoZXhwb3J0cy5ab2RGaXJzdFBhcnR5VHlwZUtpbmQgPSB7fSkpO1xuLy8gcmVxdWlyZXMgVFMgNC40K1xuY2xhc3MgQ2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKC4uLl8pIHsgfVxufVxuY29uc3QgaW5zdGFuY2VPZlR5cGUgPSAoXG4vLyBjb25zdCBpbnN0YW5jZU9mVHlwZSA9IDxUIGV4dGVuZHMgbmV3ICguLi5hcmdzOiBhbnlbXSkgPT4gYW55PihcbmNscywgcGFyYW1zID0ge1xuICAgIG1lc3NhZ2U6IGBJbnB1dCBub3QgaW5zdGFuY2Ugb2YgJHtjbHMubmFtZX1gLFxufSkgPT4gKDAsIGV4cG9ydHMuY3VzdG9tKSgoZGF0YSkgPT4gZGF0YSBpbnN0YW5jZW9mIGNscywgcGFyYW1zKTtcbmV4cG9ydHMuaW5zdGFuY2VvZiA9IGluc3RhbmNlT2ZUeXBlO1xuY29uc3Qgc3RyaW5nVHlwZSA9IFpvZFN0cmluZy5jcmVhdGU7XG5leHBvcnRzLnN0cmluZyA9IHN0cmluZ1R5cGU7XG5jb25zdCBudW1iZXJUeXBlID0gWm9kTnVtYmVyLmNyZWF0ZTtcbmV4cG9ydHMubnVtYmVyID0gbnVtYmVyVHlwZTtcbmNvbnN0IG5hblR5cGUgPSBab2ROYU4uY3JlYXRlO1xuZXhwb3J0cy5uYW4gPSBuYW5UeXBlO1xuY29uc3QgYmlnSW50VHlwZSA9IFpvZEJpZ0ludC5jcmVhdGU7XG5leHBvcnRzLmJpZ2ludCA9IGJpZ0ludFR5cGU7XG5jb25zdCBib29sZWFuVHlwZSA9IFpvZEJvb2xlYW4uY3JlYXRlO1xuZXhwb3J0cy5ib29sZWFuID0gYm9vbGVhblR5cGU7XG5jb25zdCBkYXRlVHlwZSA9IFpvZERhdGUuY3JlYXRlO1xuZXhwb3J0cy5kYXRlID0gZGF0ZVR5cGU7XG5jb25zdCBzeW1ib2xUeXBlID0gWm9kU3ltYm9sLmNyZWF0ZTtcbmV4cG9ydHMuc3ltYm9sID0gc3ltYm9sVHlwZTtcbmNvbnN0IHVuZGVmaW5lZFR5cGUgPSBab2RVbmRlZmluZWQuY3JlYXRlO1xuZXhwb3J0cy51bmRlZmluZWQgPSB1bmRlZmluZWRUeXBlO1xuY29uc3QgbnVsbFR5cGUgPSBab2ROdWxsLmNyZWF0ZTtcbmV4cG9ydHMubnVsbCA9IG51bGxUeXBlO1xuY29uc3QgYW55VHlwZSA9IFpvZEFueS5jcmVhdGU7XG5leHBvcnRzLmFueSA9IGFueVR5cGU7XG5jb25zdCB1bmtub3duVHlwZSA9IFpvZFVua25vd24uY3JlYXRlO1xuZXhwb3J0cy51bmtub3duID0gdW5rbm93blR5cGU7XG5jb25zdCBuZXZlclR5cGUgPSBab2ROZXZlci5jcmVhdGU7XG5leHBvcnRzLm5ldmVyID0gbmV2ZXJUeXBlO1xuY29uc3Qgdm9pZFR5cGUgPSBab2RWb2lkLmNyZWF0ZTtcbmV4cG9ydHMudm9pZCA9IHZvaWRUeXBlO1xuY29uc3QgYXJyYXlUeXBlID0gWm9kQXJyYXkuY3JlYXRlO1xuZXhwb3J0cy5hcnJheSA9IGFycmF5VHlwZTtcbmNvbnN0IG9iamVjdFR5cGUgPSBab2RPYmplY3QuY3JlYXRlO1xuZXhwb3J0cy5vYmplY3QgPSBvYmplY3RUeXBlO1xuY29uc3Qgc3RyaWN0T2JqZWN0VHlwZSA9IFpvZE9iamVjdC5zdHJpY3RDcmVhdGU7XG5leHBvcnRzLnN0cmljdE9iamVjdCA9IHN0cmljdE9iamVjdFR5cGU7XG5jb25zdCB1bmlvblR5cGUgPSBab2RVbmlvbi5jcmVhdGU7XG5leHBvcnRzLnVuaW9uID0gdW5pb25UeXBlO1xuY29uc3QgZGlzY3JpbWluYXRlZFVuaW9uVHlwZSA9IFpvZERpc2NyaW1pbmF0ZWRVbmlvbi5jcmVhdGU7XG5leHBvcnRzLmRpc2NyaW1pbmF0ZWRVbmlvbiA9IGRpc2NyaW1pbmF0ZWRVbmlvblR5cGU7XG5jb25zdCBpbnRlcnNlY3Rpb25UeXBlID0gWm9kSW50ZXJzZWN0aW9uLmNyZWF0ZTtcbmV4cG9ydHMuaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0aW9uVHlwZTtcbmNvbnN0IHR1cGxlVHlwZSA9IFpvZFR1cGxlLmNyZWF0ZTtcbmV4cG9ydHMudHVwbGUgPSB0dXBsZVR5cGU7XG5jb25zdCByZWNvcmRUeXBlID0gWm9kUmVjb3JkLmNyZWF0ZTtcbmV4cG9ydHMucmVjb3JkID0gcmVjb3JkVHlwZTtcbmNvbnN0IG1hcFR5cGUgPSBab2RNYXAuY3JlYXRlO1xuZXhwb3J0cy5tYXAgPSBtYXBUeXBlO1xuY29uc3Qgc2V0VHlwZSA9IFpvZFNldC5jcmVhdGU7XG5leHBvcnRzLnNldCA9IHNldFR5cGU7XG5jb25zdCBmdW5jdGlvblR5cGUgPSBab2RGdW5jdGlvbi5jcmVhdGU7XG5leHBvcnRzLmZ1bmN0aW9uID0gZnVuY3Rpb25UeXBlO1xuY29uc3QgbGF6eVR5cGUgPSBab2RMYXp5LmNyZWF0ZTtcbmV4cG9ydHMubGF6eSA9IGxhenlUeXBlO1xuY29uc3QgbGl0ZXJhbFR5cGUgPSBab2RMaXRlcmFsLmNyZWF0ZTtcbmV4cG9ydHMubGl0ZXJhbCA9IGxpdGVyYWxUeXBlO1xuY29uc3QgZW51bVR5cGUgPSBab2RFbnVtLmNyZWF0ZTtcbmV4cG9ydHMuZW51bSA9IGVudW1UeXBlO1xuY29uc3QgbmF0aXZlRW51bVR5cGUgPSBab2ROYXRpdmVFbnVtLmNyZWF0ZTtcbmV4cG9ydHMubmF0aXZlRW51bSA9IG5hdGl2ZUVudW1UeXBlO1xuY29uc3QgcHJvbWlzZVR5cGUgPSBab2RQcm9taXNlLmNyZWF0ZTtcbmV4cG9ydHMucHJvbWlzZSA9IHByb21pc2VUeXBlO1xuY29uc3QgZWZmZWN0c1R5cGUgPSBab2RFZmZlY3RzLmNyZWF0ZTtcbmV4cG9ydHMuZWZmZWN0ID0gZWZmZWN0c1R5cGU7XG5leHBvcnRzLnRyYW5zZm9ybWVyID0gZWZmZWN0c1R5cGU7XG5jb25zdCBvcHRpb25hbFR5cGUgPSBab2RPcHRpb25hbC5jcmVhdGU7XG5leHBvcnRzLm9wdGlvbmFsID0gb3B0aW9uYWxUeXBlO1xuY29uc3QgbnVsbGFibGVUeXBlID0gWm9kTnVsbGFibGUuY3JlYXRlO1xuZXhwb3J0cy5udWxsYWJsZSA9IG51bGxhYmxlVHlwZTtcbmNvbnN0IHByZXByb2Nlc3NUeXBlID0gWm9kRWZmZWN0cy5jcmVhdGVXaXRoUHJlcHJvY2VzcztcbmV4cG9ydHMucHJlcHJvY2VzcyA9IHByZXByb2Nlc3NUeXBlO1xuY29uc3QgcGlwZWxpbmVUeXBlID0gWm9kUGlwZWxpbmUuY3JlYXRlO1xuZXhwb3J0cy5waXBlbGluZSA9IHBpcGVsaW5lVHlwZTtcbmNvbnN0IG9zdHJpbmcgPSAoKSA9PiBzdHJpbmdUeXBlKCkub3B0aW9uYWwoKTtcbmV4cG9ydHMub3N0cmluZyA9IG9zdHJpbmc7XG5jb25zdCBvbnVtYmVyID0gKCkgPT4gbnVtYmVyVHlwZSgpLm9wdGlvbmFsKCk7XG5leHBvcnRzLm9udW1iZXIgPSBvbnVtYmVyO1xuY29uc3Qgb2Jvb2xlYW4gPSAoKSA9PiBib29sZWFuVHlwZSgpLm9wdGlvbmFsKCk7XG5leHBvcnRzLm9ib29sZWFuID0gb2Jvb2xlYW47XG5leHBvcnRzLmNvZXJjZSA9IHtcbiAgICBzdHJpbmc6ICgoYXJnKSA9PiBab2RTdHJpbmcuY3JlYXRlKHsgLi4uYXJnLCBjb2VyY2U6IHRydWUgfSkpLFxuICAgIG51bWJlcjogKChhcmcpID0+IFpvZE51bWJlci5jcmVhdGUoeyAuLi5hcmcsIGNvZXJjZTogdHJ1ZSB9KSksXG4gICAgYm9vbGVhbjogKChhcmcpID0+IFpvZEJvb2xlYW4uY3JlYXRlKHtcbiAgICAgICAgLi4uYXJnLFxuICAgICAgICBjb2VyY2U6IHRydWUsXG4gICAgfSkpLFxuICAgIGJpZ2ludDogKChhcmcpID0+IFpvZEJpZ0ludC5jcmVhdGUoeyAuLi5hcmcsIGNvZXJjZTogdHJ1ZSB9KSksXG4gICAgZGF0ZTogKChhcmcpID0+IFpvZERhdGUuY3JlYXRlKHsgLi4uYXJnLCBjb2VyY2U6IHRydWUgfSkpLFxufTtcbmV4cG9ydHMuTkVWRVIgPSBwYXJzZVV0aWxfMS5JTlZBTElEO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/node_modules/zod/lib/types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/types.js":
/*!***************************************!*\
  !*** ./node_modules/inngest/types.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Internal types and schemas used throughout the Inngest SDK.\n *\n * Note that types intended to be imported and utilized in userland code will be\n * exported from the main entrypoint of the SDK, `inngest`; importing types\n * directly from this file may result in breaking changes in non-major bumps as\n * only those exported from `inngest` are considered stable.\n *\n * @module\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.inBandSyncRequestBodySchema = exports.err = exports.ok = exports.functionConfigSchema = exports.logLevels = exports.sendEventResponseSchema = exports.incomingOpSchema = exports.StepOpCode = exports.jsonErrorSchema = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/inngest/node_modules/zod/lib/index.js\");\nconst baseJsonErrorSchema = zod_1.z.object({\n    name: zod_1.z.string().trim().optional(),\n    error: zod_1.z.string().trim().optional(),\n    message: zod_1.z.string().trim().optional(),\n    stack: zod_1.z.string().trim().optional(),\n});\nconst maybeJsonErrorSchema = zod_1.z.lazy(() => zod_1.z.object({\n    name: zod_1.z.string().trim(),\n    message: zod_1.z.string().trim(),\n    stack: zod_1.z.string().trim().optional(),\n    cause: zod_1.z.union([maybeJsonErrorSchema, zod_1.z.unknown()]).optional(),\n}));\nexports.jsonErrorSchema = baseJsonErrorSchema\n    .extend({\n    cause: zod_1.z.union([maybeJsonErrorSchema, zod_1.z.unknown()]).optional(),\n})\n    .passthrough()\n    .catch({})\n    .transform((val) => {\n    return Object.assign(Object.assign({}, val), { name: val.name || \"Error\", message: val.message || val.error || \"Unknown error\", stack: val.stack });\n});\n/**\n * Unique codes for the different types of operation that can be sent to Inngest\n * from SDK step functions.\n */\nvar StepOpCode;\n(function (StepOpCode) {\n    StepOpCode[\"WaitForSignal\"] = \"WaitForSignal\";\n    StepOpCode[\"WaitForEvent\"] = \"WaitForEvent\";\n    /**\n     * Legacy equivalent to `\"StepRun\"`. Has mixed data wrapping (e.g. `data` or\n     * `data.data` depending on SDK version), so this is phased out in favour of\n     * `\"StepRun\"`, which never wraps.\n     *\n     * Note that it is still used for v0 executions for backwards compatibility.\n     *\n     * @deprecated Only used for v0 executions; use `\"StepRun\"` instead.\n     */\n    StepOpCode[\"Step\"] = \"Step\";\n    StepOpCode[\"StepRun\"] = \"StepRun\";\n    StepOpCode[\"StepError\"] = \"StepError\";\n    StepOpCode[\"StepPlanned\"] = \"StepPlanned\";\n    StepOpCode[\"Sleep\"] = \"Sleep\";\n    /**\n     * Used to signify that the executor has requested that a step run, but we\n     * could not find that step.\n     *\n     * This is likely indicative that a step was renamed or removed from the\n     * function.\n     */\n    StepOpCode[\"StepNotFound\"] = \"StepNotFound\";\n    StepOpCode[\"InvokeFunction\"] = \"InvokeFunction\";\n    StepOpCode[\"AiGateway\"] = \"AIGateway\";\n    StepOpCode[\"Gateway\"] = \"Gateway\";\n})(StepOpCode || (exports.StepOpCode = StepOpCode = {}));\nexports.incomingOpSchema = zod_1.z.object({\n    id: zod_1.z.string().min(1),\n    data: zod_1.z.any().optional(),\n    error: zod_1.z.any().optional(),\n    input: zod_1.z.any().optional(),\n});\nexports.sendEventResponseSchema = zod_1.z.object({\n    /**\n     * Event IDs\n     */\n    ids: zod_1.z.array(zod_1.z.string()).default([]),\n    /**\n     * HTTP Status Code. Will be undefined if no request was sent.\n     */\n    status: zod_1.z.number().default(0),\n    /**\n     * Error message. Will be undefined if no error occurred.\n     */\n    error: zod_1.z.string().optional(),\n});\n/**\n * A set of log levels that can be used to control the amount of logging output\n * from various parts of the Inngest library.\n *\n * @public\n */\nexports.logLevels = [\n    \"fatal\",\n    \"error\",\n    \"warn\",\n    \"info\",\n    \"debug\",\n    \"silent\",\n];\n/**\n * This schema is used internally to share the shape of a concurrency option\n * when validating config. We cannot add comments to Zod fields, so we just use\n * an extra type check to ensure it matches our exported expectations.\n */\nconst concurrencyOptionSchema = zod_1.z.strictObject({\n    limit: zod_1.z.number(),\n    key: zod_1.z.string().optional(),\n    scope: zod_1.z.enum([\"fn\", \"env\", \"account\"]).optional(),\n});\nconst _checkConcurrencySchemaAligns = true;\n/**\n * The schema used to represent an individual function being synced with\n * Inngest.\n *\n * Note that this should only be used to validate the shape of a config object\n * and not used for feature compatibility, such as feature X being exclusive\n * with feature Y; these should be handled on the Inngest side.\n */\nexports.functionConfigSchema = zod_1.z.strictObject({\n    name: zod_1.z.string().optional(),\n    id: zod_1.z.string(),\n    triggers: zod_1.z.array(zod_1.z.union([\n        zod_1.z.strictObject({\n            event: zod_1.z.string(),\n            expression: zod_1.z.string().optional(),\n        }),\n        zod_1.z.strictObject({\n            cron: zod_1.z.string(),\n        }),\n    ])),\n    steps: zod_1.z.record(zod_1.z.strictObject({\n        id: zod_1.z.string(),\n        name: zod_1.z.string(),\n        runtime: zod_1.z.strictObject({\n            type: zod_1.z.union([zod_1.z.literal(\"http\"), zod_1.z.literal(\"ws\")]),\n            url: zod_1.z.string(),\n        }),\n        retries: zod_1.z\n            .strictObject({\n            attempts: zod_1.z.number().optional(),\n        })\n            .optional(),\n    })),\n    idempotency: zod_1.z.string().optional(),\n    batchEvents: zod_1.z\n        .strictObject({\n        maxSize: zod_1.z.number(),\n        timeout: zod_1.z.string(),\n        key: zod_1.z.string().optional(),\n        if: zod_1.z.string().optional(),\n    })\n        .optional(),\n    rateLimit: zod_1.z\n        .strictObject({\n        key: zod_1.z.string().optional(),\n        limit: zod_1.z.number(),\n        period: zod_1.z.string().transform((x) => x),\n    })\n        .optional(),\n    throttle: zod_1.z\n        .strictObject({\n        key: zod_1.z.string().optional(),\n        limit: zod_1.z.number(),\n        period: zod_1.z.string().transform((x) => x),\n        burst: zod_1.z.number().optional(),\n    })\n        .optional(),\n    singleton: zod_1.z\n        .strictObject({\n        key: zod_1.z.string().optional(),\n        mode: zod_1.z.enum([\"skip\", \"cancel\"]),\n    })\n        .optional(),\n    cancel: zod_1.z\n        .array(zod_1.z.strictObject({\n        event: zod_1.z.string(),\n        if: zod_1.z.string().optional(),\n        timeout: zod_1.z.string().optional(),\n    }))\n        .optional(),\n    debounce: zod_1.z\n        .strictObject({\n        key: zod_1.z.string().optional(),\n        period: zod_1.z.string().transform((x) => x),\n        timeout: zod_1.z\n            .string()\n            .transform((x) => x)\n            .optional(),\n    })\n        .optional(),\n    timeouts: zod_1.z\n        .strictObject({\n        start: zod_1.z\n            .string()\n            .transform((x) => x)\n            .optional(),\n        finish: zod_1.z\n            .string()\n            .transform((x) => x)\n            .optional(),\n    })\n        .optional(),\n    priority: zod_1.z\n        .strictObject({\n        run: zod_1.z.string().optional(),\n    })\n        .optional(),\n    concurrency: zod_1.z\n        .union([\n        zod_1.z.number(),\n        concurrencyOptionSchema.transform((x) => x),\n        zod_1.z\n            .array(concurrencyOptionSchema.transform((x) => x))\n            .min(1)\n            .max(2),\n    ])\n        .optional(),\n});\nconst ok = (data) => {\n    return { ok: true, value: data };\n};\nexports.ok = ok;\nconst err = (error) => {\n    return { ok: false, error };\n};\nexports.err = err;\nexports.inBandSyncRequestBodySchema = zod_1.z.strictObject({\n    url: zod_1.z.string(),\n});\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC90eXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUNBQW1DLEdBQUcsV0FBVyxHQUFHLFVBQVUsR0FBRyw0QkFBNEIsR0FBRyxpQkFBaUIsR0FBRywrQkFBK0IsR0FBRyx3QkFBd0IsR0FBRyxrQkFBa0IsR0FBRyx1QkFBdUI7QUFDN04sY0FBYyxtQkFBTyxDQUFDLHVFQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLGFBQWE7QUFDYjtBQUNBLHlDQUF5QyxVQUFVLG1HQUFtRztBQUN0SixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGlCQUFpQixrQkFBa0Isa0JBQWtCO0FBQ3RELHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxhQUFhO0FBQ2I7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1gsbUNBQW1DO0FBQ25DO0FBQ0EsQ0FBQztBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdml2ZS12aWJlLWFpLW5leHQvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC90eXBlcy5qcz9lOTkzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBJbnRlcm5hbCB0eXBlcyBhbmQgc2NoZW1hcyB1c2VkIHRocm91Z2hvdXQgdGhlIElubmdlc3QgU0RLLlxuICpcbiAqIE5vdGUgdGhhdCB0eXBlcyBpbnRlbmRlZCB0byBiZSBpbXBvcnRlZCBhbmQgdXRpbGl6ZWQgaW4gdXNlcmxhbmQgY29kZSB3aWxsIGJlXG4gKiBleHBvcnRlZCBmcm9tIHRoZSBtYWluIGVudHJ5cG9pbnQgb2YgdGhlIFNESywgYGlubmdlc3RgOyBpbXBvcnRpbmcgdHlwZXNcbiAqIGRpcmVjdGx5IGZyb20gdGhpcyBmaWxlIG1heSByZXN1bHQgaW4gYnJlYWtpbmcgY2hhbmdlcyBpbiBub24tbWFqb3IgYnVtcHMgYXNcbiAqIG9ubHkgdGhvc2UgZXhwb3J0ZWQgZnJvbSBgaW5uZ2VzdGAgYXJlIGNvbnNpZGVyZWQgc3RhYmxlLlxuICpcbiAqIEBtb2R1bGVcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pbkJhbmRTeW5jUmVxdWVzdEJvZHlTY2hlbWEgPSBleHBvcnRzLmVyciA9IGV4cG9ydHMub2sgPSBleHBvcnRzLmZ1bmN0aW9uQ29uZmlnU2NoZW1hID0gZXhwb3J0cy5sb2dMZXZlbHMgPSBleHBvcnRzLnNlbmRFdmVudFJlc3BvbnNlU2NoZW1hID0gZXhwb3J0cy5pbmNvbWluZ09wU2NoZW1hID0gZXhwb3J0cy5TdGVwT3BDb2RlID0gZXhwb3J0cy5qc29uRXJyb3JTY2hlbWEgPSB2b2lkIDA7XG5jb25zdCB6b2RfMSA9IHJlcXVpcmUoXCJ6b2RcIik7XG5jb25zdCBiYXNlSnNvbkVycm9yU2NoZW1hID0gem9kXzEuei5vYmplY3Qoe1xuICAgIG5hbWU6IHpvZF8xLnouc3RyaW5nKCkudHJpbSgpLm9wdGlvbmFsKCksXG4gICAgZXJyb3I6IHpvZF8xLnouc3RyaW5nKCkudHJpbSgpLm9wdGlvbmFsKCksXG4gICAgbWVzc2FnZTogem9kXzEuei5zdHJpbmcoKS50cmltKCkub3B0aW9uYWwoKSxcbiAgICBzdGFjazogem9kXzEuei5zdHJpbmcoKS50cmltKCkub3B0aW9uYWwoKSxcbn0pO1xuY29uc3QgbWF5YmVKc29uRXJyb3JTY2hlbWEgPSB6b2RfMS56LmxhenkoKCkgPT4gem9kXzEuei5vYmplY3Qoe1xuICAgIG5hbWU6IHpvZF8xLnouc3RyaW5nKCkudHJpbSgpLFxuICAgIG1lc3NhZ2U6IHpvZF8xLnouc3RyaW5nKCkudHJpbSgpLFxuICAgIHN0YWNrOiB6b2RfMS56LnN0cmluZygpLnRyaW0oKS5vcHRpb25hbCgpLFxuICAgIGNhdXNlOiB6b2RfMS56LnVuaW9uKFttYXliZUpzb25FcnJvclNjaGVtYSwgem9kXzEuei51bmtub3duKCldKS5vcHRpb25hbCgpLFxufSkpO1xuZXhwb3J0cy5qc29uRXJyb3JTY2hlbWEgPSBiYXNlSnNvbkVycm9yU2NoZW1hXG4gICAgLmV4dGVuZCh7XG4gICAgY2F1c2U6IHpvZF8xLnoudW5pb24oW21heWJlSnNvbkVycm9yU2NoZW1hLCB6b2RfMS56LnVua25vd24oKV0pLm9wdGlvbmFsKCksXG59KVxuICAgIC5wYXNzdGhyb3VnaCgpXG4gICAgLmNhdGNoKHt9KVxuICAgIC50cmFuc2Zvcm0oKHZhbCkgPT4ge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHZhbCksIHsgbmFtZTogdmFsLm5hbWUgfHwgXCJFcnJvclwiLCBtZXNzYWdlOiB2YWwubWVzc2FnZSB8fCB2YWwuZXJyb3IgfHwgXCJVbmtub3duIGVycm9yXCIsIHN0YWNrOiB2YWwuc3RhY2sgfSk7XG59KTtcbi8qKlxuICogVW5pcXVlIGNvZGVzIGZvciB0aGUgZGlmZmVyZW50IHR5cGVzIG9mIG9wZXJhdGlvbiB0aGF0IGNhbiBiZSBzZW50IHRvIElubmdlc3RcbiAqIGZyb20gU0RLIHN0ZXAgZnVuY3Rpb25zLlxuICovXG52YXIgU3RlcE9wQ29kZTtcbihmdW5jdGlvbiAoU3RlcE9wQ29kZSkge1xuICAgIFN0ZXBPcENvZGVbXCJXYWl0Rm9yU2lnbmFsXCJdID0gXCJXYWl0Rm9yU2lnbmFsXCI7XG4gICAgU3RlcE9wQ29kZVtcIldhaXRGb3JFdmVudFwiXSA9IFwiV2FpdEZvckV2ZW50XCI7XG4gICAgLyoqXG4gICAgICogTGVnYWN5IGVxdWl2YWxlbnQgdG8gYFwiU3RlcFJ1blwiYC4gSGFzIG1peGVkIGRhdGEgd3JhcHBpbmcgKGUuZy4gYGRhdGFgIG9yXG4gICAgICogYGRhdGEuZGF0YWAgZGVwZW5kaW5nIG9uIFNESyB2ZXJzaW9uKSwgc28gdGhpcyBpcyBwaGFzZWQgb3V0IGluIGZhdm91ciBvZlxuICAgICAqIGBcIlN0ZXBSdW5cImAsIHdoaWNoIG5ldmVyIHdyYXBzLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IGl0IGlzIHN0aWxsIHVzZWQgZm9yIHYwIGV4ZWN1dGlvbnMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWQgT25seSB1c2VkIGZvciB2MCBleGVjdXRpb25zOyB1c2UgYFwiU3RlcFJ1blwiYCBpbnN0ZWFkLlxuICAgICAqL1xuICAgIFN0ZXBPcENvZGVbXCJTdGVwXCJdID0gXCJTdGVwXCI7XG4gICAgU3RlcE9wQ29kZVtcIlN0ZXBSdW5cIl0gPSBcIlN0ZXBSdW5cIjtcbiAgICBTdGVwT3BDb2RlW1wiU3RlcEVycm9yXCJdID0gXCJTdGVwRXJyb3JcIjtcbiAgICBTdGVwT3BDb2RlW1wiU3RlcFBsYW5uZWRcIl0gPSBcIlN0ZXBQbGFubmVkXCI7XG4gICAgU3RlcE9wQ29kZVtcIlNsZWVwXCJdID0gXCJTbGVlcFwiO1xuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gc2lnbmlmeSB0aGF0IHRoZSBleGVjdXRvciBoYXMgcmVxdWVzdGVkIHRoYXQgYSBzdGVwIHJ1biwgYnV0IHdlXG4gICAgICogY291bGQgbm90IGZpbmQgdGhhdCBzdGVwLlxuICAgICAqXG4gICAgICogVGhpcyBpcyBsaWtlbHkgaW5kaWNhdGl2ZSB0aGF0IGEgc3RlcCB3YXMgcmVuYW1lZCBvciByZW1vdmVkIGZyb20gdGhlXG4gICAgICogZnVuY3Rpb24uXG4gICAgICovXG4gICAgU3RlcE9wQ29kZVtcIlN0ZXBOb3RGb3VuZFwiXSA9IFwiU3RlcE5vdEZvdW5kXCI7XG4gICAgU3RlcE9wQ29kZVtcIkludm9rZUZ1bmN0aW9uXCJdID0gXCJJbnZva2VGdW5jdGlvblwiO1xuICAgIFN0ZXBPcENvZGVbXCJBaUdhdGV3YXlcIl0gPSBcIkFJR2F0ZXdheVwiO1xuICAgIFN0ZXBPcENvZGVbXCJHYXRld2F5XCJdID0gXCJHYXRld2F5XCI7XG59KShTdGVwT3BDb2RlIHx8IChleHBvcnRzLlN0ZXBPcENvZGUgPSBTdGVwT3BDb2RlID0ge30pKTtcbmV4cG9ydHMuaW5jb21pbmdPcFNjaGVtYSA9IHpvZF8xLnoub2JqZWN0KHtcbiAgICBpZDogem9kXzEuei5zdHJpbmcoKS5taW4oMSksXG4gICAgZGF0YTogem9kXzEuei5hbnkoKS5vcHRpb25hbCgpLFxuICAgIGVycm9yOiB6b2RfMS56LmFueSgpLm9wdGlvbmFsKCksXG4gICAgaW5wdXQ6IHpvZF8xLnouYW55KCkub3B0aW9uYWwoKSxcbn0pO1xuZXhwb3J0cy5zZW5kRXZlbnRSZXNwb25zZVNjaGVtYSA9IHpvZF8xLnoub2JqZWN0KHtcbiAgICAvKipcbiAgICAgKiBFdmVudCBJRHNcbiAgICAgKi9cbiAgICBpZHM6IHpvZF8xLnouYXJyYXkoem9kXzEuei5zdHJpbmcoKSkuZGVmYXVsdChbXSksXG4gICAgLyoqXG4gICAgICogSFRUUCBTdGF0dXMgQ29kZS4gV2lsbCBiZSB1bmRlZmluZWQgaWYgbm8gcmVxdWVzdCB3YXMgc2VudC5cbiAgICAgKi9cbiAgICBzdGF0dXM6IHpvZF8xLnoubnVtYmVyKCkuZGVmYXVsdCgwKSxcbiAgICAvKipcbiAgICAgKiBFcnJvciBtZXNzYWdlLiBXaWxsIGJlIHVuZGVmaW5lZCBpZiBubyBlcnJvciBvY2N1cnJlZC5cbiAgICAgKi9cbiAgICBlcnJvcjogem9kXzEuei5zdHJpbmcoKS5vcHRpb25hbCgpLFxufSk7XG4vKipcbiAqIEEgc2V0IG9mIGxvZyBsZXZlbHMgdGhhdCBjYW4gYmUgdXNlZCB0byBjb250cm9sIHRoZSBhbW91bnQgb2YgbG9nZ2luZyBvdXRwdXRcbiAqIGZyb20gdmFyaW91cyBwYXJ0cyBvZiB0aGUgSW5uZ2VzdCBsaWJyYXJ5LlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0cy5sb2dMZXZlbHMgPSBbXG4gICAgXCJmYXRhbFwiLFxuICAgIFwiZXJyb3JcIixcbiAgICBcIndhcm5cIixcbiAgICBcImluZm9cIixcbiAgICBcImRlYnVnXCIsXG4gICAgXCJzaWxlbnRcIixcbl07XG4vKipcbiAqIFRoaXMgc2NoZW1hIGlzIHVzZWQgaW50ZXJuYWxseSB0byBzaGFyZSB0aGUgc2hhcGUgb2YgYSBjb25jdXJyZW5jeSBvcHRpb25cbiAqIHdoZW4gdmFsaWRhdGluZyBjb25maWcuIFdlIGNhbm5vdCBhZGQgY29tbWVudHMgdG8gWm9kIGZpZWxkcywgc28gd2UganVzdCB1c2VcbiAqIGFuIGV4dHJhIHR5cGUgY2hlY2sgdG8gZW5zdXJlIGl0IG1hdGNoZXMgb3VyIGV4cG9ydGVkIGV4cGVjdGF0aW9ucy5cbiAqL1xuY29uc3QgY29uY3VycmVuY3lPcHRpb25TY2hlbWEgPSB6b2RfMS56LnN0cmljdE9iamVjdCh7XG4gICAgbGltaXQ6IHpvZF8xLnoubnVtYmVyKCksXG4gICAga2V5OiB6b2RfMS56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgc2NvcGU6IHpvZF8xLnouZW51bShbXCJmblwiLCBcImVudlwiLCBcImFjY291bnRcIl0pLm9wdGlvbmFsKCksXG59KTtcbmNvbnN0IF9jaGVja0NvbmN1cnJlbmN5U2NoZW1hQWxpZ25zID0gdHJ1ZTtcbi8qKlxuICogVGhlIHNjaGVtYSB1c2VkIHRvIHJlcHJlc2VudCBhbiBpbmRpdmlkdWFsIGZ1bmN0aW9uIGJlaW5nIHN5bmNlZCB3aXRoXG4gKiBJbm5nZXN0LlxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIHNob3VsZCBvbmx5IGJlIHVzZWQgdG8gdmFsaWRhdGUgdGhlIHNoYXBlIG9mIGEgY29uZmlnIG9iamVjdFxuICogYW5kIG5vdCB1c2VkIGZvciBmZWF0dXJlIGNvbXBhdGliaWxpdHksIHN1Y2ggYXMgZmVhdHVyZSBYIGJlaW5nIGV4Y2x1c2l2ZVxuICogd2l0aCBmZWF0dXJlIFk7IHRoZXNlIHNob3VsZCBiZSBoYW5kbGVkIG9uIHRoZSBJbm5nZXN0IHNpZGUuXG4gKi9cbmV4cG9ydHMuZnVuY3Rpb25Db25maWdTY2hlbWEgPSB6b2RfMS56LnN0cmljdE9iamVjdCh7XG4gICAgbmFtZTogem9kXzEuei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgIGlkOiB6b2RfMS56LnN0cmluZygpLFxuICAgIHRyaWdnZXJzOiB6b2RfMS56LmFycmF5KHpvZF8xLnoudW5pb24oW1xuICAgICAgICB6b2RfMS56LnN0cmljdE9iamVjdCh7XG4gICAgICAgICAgICBldmVudDogem9kXzEuei5zdHJpbmcoKSxcbiAgICAgICAgICAgIGV4cHJlc3Npb246IHpvZF8xLnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICAgICAgfSksXG4gICAgICAgIHpvZF8xLnouc3RyaWN0T2JqZWN0KHtcbiAgICAgICAgICAgIGNyb246IHpvZF8xLnouc3RyaW5nKCksXG4gICAgICAgIH0pLFxuICAgIF0pKSxcbiAgICBzdGVwczogem9kXzEuei5yZWNvcmQoem9kXzEuei5zdHJpY3RPYmplY3Qoe1xuICAgICAgICBpZDogem9kXzEuei5zdHJpbmcoKSxcbiAgICAgICAgbmFtZTogem9kXzEuei5zdHJpbmcoKSxcbiAgICAgICAgcnVudGltZTogem9kXzEuei5zdHJpY3RPYmplY3Qoe1xuICAgICAgICAgICAgdHlwZTogem9kXzEuei51bmlvbihbem9kXzEuei5saXRlcmFsKFwiaHR0cFwiKSwgem9kXzEuei5saXRlcmFsKFwid3NcIildKSxcbiAgICAgICAgICAgIHVybDogem9kXzEuei5zdHJpbmcoKSxcbiAgICAgICAgfSksXG4gICAgICAgIHJldHJpZXM6IHpvZF8xLnpcbiAgICAgICAgICAgIC5zdHJpY3RPYmplY3Qoe1xuICAgICAgICAgICAgYXR0ZW1wdHM6IHpvZF8xLnoubnVtYmVyKCkub3B0aW9uYWwoKSxcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5vcHRpb25hbCgpLFxuICAgIH0pKSxcbiAgICBpZGVtcG90ZW5jeTogem9kXzEuei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgIGJhdGNoRXZlbnRzOiB6b2RfMS56XG4gICAgICAgIC5zdHJpY3RPYmplY3Qoe1xuICAgICAgICBtYXhTaXplOiB6b2RfMS56Lm51bWJlcigpLFxuICAgICAgICB0aW1lb3V0OiB6b2RfMS56LnN0cmluZygpLFxuICAgICAgICBrZXk6IHpvZF8xLnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICAgICAgaWY6IHpvZF8xLnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICB9KVxuICAgICAgICAub3B0aW9uYWwoKSxcbiAgICByYXRlTGltaXQ6IHpvZF8xLnpcbiAgICAgICAgLnN0cmljdE9iamVjdCh7XG4gICAgICAgIGtleTogem9kXzEuei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgICAgICBsaW1pdDogem9kXzEuei5udW1iZXIoKSxcbiAgICAgICAgcGVyaW9kOiB6b2RfMS56LnN0cmluZygpLnRyYW5zZm9ybSgoeCkgPT4geCksXG4gICAgfSlcbiAgICAgICAgLm9wdGlvbmFsKCksXG4gICAgdGhyb3R0bGU6IHpvZF8xLnpcbiAgICAgICAgLnN0cmljdE9iamVjdCh7XG4gICAgICAgIGtleTogem9kXzEuei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgICAgICBsaW1pdDogem9kXzEuei5udW1iZXIoKSxcbiAgICAgICAgcGVyaW9kOiB6b2RfMS56LnN0cmluZygpLnRyYW5zZm9ybSgoeCkgPT4geCksXG4gICAgICAgIGJ1cnN0OiB6b2RfMS56Lm51bWJlcigpLm9wdGlvbmFsKCksXG4gICAgfSlcbiAgICAgICAgLm9wdGlvbmFsKCksXG4gICAgc2luZ2xldG9uOiB6b2RfMS56XG4gICAgICAgIC5zdHJpY3RPYmplY3Qoe1xuICAgICAgICBrZXk6IHpvZF8xLnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICAgICAgbW9kZTogem9kXzEuei5lbnVtKFtcInNraXBcIiwgXCJjYW5jZWxcIl0pLFxuICAgIH0pXG4gICAgICAgIC5vcHRpb25hbCgpLFxuICAgIGNhbmNlbDogem9kXzEuelxuICAgICAgICAuYXJyYXkoem9kXzEuei5zdHJpY3RPYmplY3Qoe1xuICAgICAgICBldmVudDogem9kXzEuei5zdHJpbmcoKSxcbiAgICAgICAgaWY6IHpvZF8xLnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICAgICAgdGltZW91dDogem9kXzEuei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgIH0pKVxuICAgICAgICAub3B0aW9uYWwoKSxcbiAgICBkZWJvdW5jZTogem9kXzEuelxuICAgICAgICAuc3RyaWN0T2JqZWN0KHtcbiAgICAgICAga2V5OiB6b2RfMS56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgICAgIHBlcmlvZDogem9kXzEuei5zdHJpbmcoKS50cmFuc2Zvcm0oKHgpID0+IHgpLFxuICAgICAgICB0aW1lb3V0OiB6b2RfMS56XG4gICAgICAgICAgICAuc3RyaW5nKClcbiAgICAgICAgICAgIC50cmFuc2Zvcm0oKHgpID0+IHgpXG4gICAgICAgICAgICAub3B0aW9uYWwoKSxcbiAgICB9KVxuICAgICAgICAub3B0aW9uYWwoKSxcbiAgICB0aW1lb3V0czogem9kXzEuelxuICAgICAgICAuc3RyaWN0T2JqZWN0KHtcbiAgICAgICAgc3RhcnQ6IHpvZF8xLnpcbiAgICAgICAgICAgIC5zdHJpbmcoKVxuICAgICAgICAgICAgLnRyYW5zZm9ybSgoeCkgPT4geClcbiAgICAgICAgICAgIC5vcHRpb25hbCgpLFxuICAgICAgICBmaW5pc2g6IHpvZF8xLnpcbiAgICAgICAgICAgIC5zdHJpbmcoKVxuICAgICAgICAgICAgLnRyYW5zZm9ybSgoeCkgPT4geClcbiAgICAgICAgICAgIC5vcHRpb25hbCgpLFxuICAgIH0pXG4gICAgICAgIC5vcHRpb25hbCgpLFxuICAgIHByaW9yaXR5OiB6b2RfMS56XG4gICAgICAgIC5zdHJpY3RPYmplY3Qoe1xuICAgICAgICBydW46IHpvZF8xLnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICB9KVxuICAgICAgICAub3B0aW9uYWwoKSxcbiAgICBjb25jdXJyZW5jeTogem9kXzEuelxuICAgICAgICAudW5pb24oW1xuICAgICAgICB6b2RfMS56Lm51bWJlcigpLFxuICAgICAgICBjb25jdXJyZW5jeU9wdGlvblNjaGVtYS50cmFuc2Zvcm0oKHgpID0+IHgpLFxuICAgICAgICB6b2RfMS56XG4gICAgICAgICAgICAuYXJyYXkoY29uY3VycmVuY3lPcHRpb25TY2hlbWEudHJhbnNmb3JtKCh4KSA9PiB4KSlcbiAgICAgICAgICAgIC5taW4oMSlcbiAgICAgICAgICAgIC5tYXgoMiksXG4gICAgXSlcbiAgICAgICAgLm9wdGlvbmFsKCksXG59KTtcbmNvbnN0IG9rID0gKGRhdGEpID0+IHtcbiAgICByZXR1cm4geyBvazogdHJ1ZSwgdmFsdWU6IGRhdGEgfTtcbn07XG5leHBvcnRzLm9rID0gb2s7XG5jb25zdCBlcnIgPSAoZXJyb3IpID0+IHtcbiAgICByZXR1cm4geyBvazogZmFsc2UsIGVycm9yIH07XG59O1xuZXhwb3J0cy5lcnIgPSBlcnI7XG5leHBvcnRzLmluQmFuZFN5bmNSZXF1ZXN0Qm9keVNjaGVtYSA9IHpvZF8xLnouc3RyaWN0T2JqZWN0KHtcbiAgICB1cmw6IHpvZF8xLnouc3RyaW5nKCksXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/version.js":
/*!*****************************************!*\
  !*** ./node_modules/inngest/version.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.version = void 0;\n// Generated by genversion.\nexports.version = \"3.40.2\";\n//# sourceMappingURL=version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC92ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpdmUtdmliZS1haS1uZXh0Ly4vbm9kZV9tb2R1bGVzL2lubmdlc3QvdmVyc2lvbi5qcz9mODZhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy52ZXJzaW9uID0gdm9pZCAwO1xuLy8gR2VuZXJhdGVkIGJ5IGdlbnZlcnNpb24uXG5leHBvcnRzLnZlcnNpb24gPSBcIjMuNDAuMlwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/version.js\n");

/***/ })

};
;